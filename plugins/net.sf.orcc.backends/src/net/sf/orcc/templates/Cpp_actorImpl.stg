///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

variableDeclaration(variable) ::= <<
$variable.type$ $variable$$listSize(variable.type.dimensions)$
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

BoolExpr(constant) ::= <<
$if (constant.value)$1$else$0$endif$
>>

IntExpr(number) ::= <<
$number$$if (number.long)$L$endif$
>>

// the values of a list: {val1, val2, ..., valn}
ListExpr(constant) ::= <<
{$constant.value: Constant(); wrap, separator=", "$}
>>

StringExpr(constant) ::= <<
"$constant$"
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

defineConstantVars(variables) ::= <<
namespace
{
	$variables:defineConstantVar()$}
>>

defineConstantVar(variable) ::= <<
$if(!variable.assignable)$
const $variableDeclaration(variable)$ = $Constant(variable.constantValue)$;$\n$$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
StateVar(variable) ::= <<
$if(variable.assignable)$
$if (variable.type.dimensions)$
$variable$(new $variable.type$$listSize(variable.type.dimensions)$),
$else$
$if (variable.initialized)$
$variable$($Constant(variable.constantValue)$),
$endif$
$endif$
$endif$

>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
ListStateVarInitialization(variable) ::= <<
$if(variable.assignable)$
$if (variable.type.dimensions)$
$if (variable.initialized)$
const $variable.type$ tmp_$variable$[$variable.type.dimensions$] = $Constant(variable.constantValue)$;
memcpy($variable$, tmp_$variable$, $variable.type.dimensions$ * sizeof($variable.type$));
$endif$
$endif$
$endif$

>>
///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

$assign.target$ = $assign.value$;
>>

PrintFormat(parameter) ::= <<
$if (parameter.stringExpr)
$$parameter$$
else
$ "%$PrintFormatType(parameter.type)$" $
endif$
>>

PrintParameter(parameter) ::= <<
$if (!parameter.stringExpr)$, $parameter$$endif$
>>

Call(call) ::= <<

$if(call.print)$printf($call.parameters: PrintFormat()$$call.parameters: PrintParameter()$);$
else
$$if(call.target)$$call.target$ = $endif$$call.procedure$($call.parameters; separator=", "$);$
endif$
>>

Decrement(decrement) ::= <<

$decrement.target$--;
>>

HasTokens(hasTokens) ::= <<

$hasTokens.target$ = m_poTabIn[$actor.name$_$hasTokens.port$]->hasTokens($hasTokens.numTokens$);
>>

Increment(increment) ::= <<

$increment.target$++;
>>

Load(load) ::= <<

$load.target$ = $load.source$$load.indexes : {[$it$]}$;
>>

Peek(peek) ::= <<

$if(peek.unit)$
m_poTabIn[$actor.name$_$peek.port$]->peek($peek.target$);$\n$
$else$
m_poTabIn[$actor.name$_$peek.port$]->peek($peek.target$, $peek.numTokens$);$\n$
$endif$
>>

Read(read) ::= <<

$if (read.target)$
$if(read.unit)$
m_poTabIn[$actor.name$_$read.port$]->get($read.target$);$\n$
$else$
m_poTabIn[$actor.name$_$read.port$]->get($read.target$, $read.numTokens$);$\n$
$endif$
$else$
m_poTabIn[$actor.name$_$read.port$]->skip($read.numTokens$);$\n$
$endif$
>>

ReadEnd(readEnd) ::= <<
>>

Return(return) ::= <<

$if(return.value)$
return $return.value$;
$endif$
>>

SelfAssignment(selfAssign) ::= <<

$selfAssign.target$ $selfAssign.op.text$= $selfAssign.value$;
>>

Store(store) ::= <<

$store.target$$store.indexes : {[$it$]}$ = $store.value$;
>>

Write(write) ::= <<

$if(write.unit)$
m_poTabOut[$actor.name$_$write.port$]->put($write.target$);$\n$
$else$
m_poTabOut[$actor.name$_$write.port$]->put($write.target$, $write.numTokens$);$\n$
$endif$

>>

WriteEnd(writeEnd) ::= <<

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<

$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<

if ($ifNode.value$) {
	$nodes(ifNode.thenNodes)$
}$if(ifNode.elseNodes)$ else {
	$nodes(ifNode.elseNodes)$
}$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<

while ($whileNode.value$) {
	$nodes(whileNode.nodes)$
}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

$procedure.returnType$ actor_$actor.name$::$procedure$($procedure.parameters.list: {$variableDeclaration(it)$}; wrap, anchor, separator=", "$)
{
$if(procedure.locals.list)$
	$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$

$endif$
	$procedure.nodes: {$(it.class.simpleName)(it)$}$}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|m_poTabOut[$actor.name$_$port$]->hasRooms($pattern.(port)$)}; separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
$action.body$();
res = true;
i++;
>>

actionTest(action) ::= <<
if(isSchedulable_$action$())
{
	$if(action.outputPattern)$
	if($outputPattern(pattern=action.outputPattern)$)
	{
		$actionCall(action)$
	}
	$else$
	$actionCall(action)$
	$endif$
}>>

schedulingTest(actions) ::= <<
$actions: actionTest(); separator="\nelse "$
>>

scheduler(actions) ::= <<
int actor_$actor.name$::schedule()
{
	bool res = true;
	int i = 0;
  
	while (res) 
	{
		res = false;
		$if(actions)$
		$schedulingTest(actions)$
		$endif$
	}
	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
$nextState.action.body$();
_FSM_state = state_$nextState.targetState$;
res = true;
>>

actionTestState(nextState) ::= <<
if(isSchedulable_$nextState.action$())
{
	$if(nextState.action.outputPattern)$
	if($outputPattern(nextState.action.outputPattern)$)
	{
		$actionCallState(nextState)$
	}
	$else$
	$actionCallState(nextState)$
	$endif$
}>>

schedulingTestState(nextStates) ::= <<
$nextStates: actionTestState(); separator=" else "$
>>

stateScheduler(transition) ::= <<
bool actor_$actor.name$::$transition.sourceState$_state_scheduler()
{
	bool res = false;
	$schedulingTestState(nextStates=transition.nextStateInfo)$
	return res;
}

>>

switch(transitions) ::= <<
switch (_FSM_state)
{
$transitions: {case state_$it.sourceState$:
	res = $it.sourceState$_state_scheduler();
	break;
}$
default:
	std::cout << "unknown state: " << _FSM_state << std::endl;
	break;
}
>>

schedulerFSM(actions, fsm) ::= <<
$if(actions)$
bool actor_$actor.name$::outside_FSM_scheduler()
{
	bool res = false;
	int i = 0;
	$schedulingTest(actions)$
	return res;
}


$endif$
$fsm.transitions: stateScheduler(); separator="\n"$
int actor_$actor.name$::schedule()
{
	bool res = true;
	int i = 0;
	
	while (res)
	{
		res = false;
		$if(actions)$
		if(outside_FSM_scheduler())
		{
			res = true;
			i++;
		}
		else
		{
			$switch(fsm.transitions)$
		}
		$else$
		$switch(fsm.transitions)$
		$endif$
	}
	return i;
}

>>

constructor(parameters, stateVars) ::= <<
actor_$actor.name$::actor_$actor.name$($parameters: {int $it$}; separator=", "$)
:
$parameters: {$it$($it$),}; wrap, separator="\n"$
$if(actor.actionScheduler.fsm)$
_FSM_state(state_$actor.actionScheduler.fsm.initialState$),
$endif$
$stateVars : StateVar()$
ActorAKA($length(actor.inputs.list)$, $length(actor.outputs.list)$)
{
$stateVars : ListStateVarInitialization()$
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<

#include "$actor.name$.h"

$defineConstantVars(actor.stateVars.list)$

$constructor(parameters=actor.parameters.list, stateVars=actor.stateVars.list)$

void actor_$actor.name$::initializeActor()
{
#ifdef __TRACE_TOKENS__
	std::string strTrace("");
	strTrace = __FILE__;
	unsigned uDesc = g_oTracer.createFileDescriptor(strTrace);
	for(unsigned uIdx = 0; uIdx < $length(actor.inputs.list)$; uIdx++)
	{
	  strTrace = "m_poTabIn[" + toString(uIdx) + "] = " + toString((unsigned)m_poTabIn[uIdx]);
	  g_oTracer.addPort(uDesc, strTrace);
	}
#endif
}


////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
$actor.procs.list: procedure()$
////////////////////////////////////////////////////////////////////////////////
// Actions
$actor.actions: action()$
$if(actor.initializes)$
////////////////////////////////////////////////////////////////////////////////
// Initializes
$actor.initializes: action()$
void actor_$actor.name$::initialize()
{
	bool res = true;
	int i = 0;

	$if(actor.initializes)$
	$schedulingTest(actor.initializes)$
	$endif$
}

$endif$
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$

>>
