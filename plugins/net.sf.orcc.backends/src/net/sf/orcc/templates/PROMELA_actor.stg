///////////////////////////////////////////////////////////////////////////////
// Composite types
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Channel declaration
///////////////////////////////////////////////////////////////////////////////

channels(port) ::= <<
chan chan_$port.name$ = [1] of {$port.type$}
>>


///////////////////////////////////////////////////////////////////////////////
// parameters
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

variableDeclaration(variable) ::= <<
$
if(variable.port)
$$variable.type$ *$variable$$
else
$$variable.type$ $variable$$listSize(variable.type.dimensions)$$
endif
$
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
$(constant.class.simpleName)(constant)$
>>

BoolExpr(constant) ::= <<
$if (constant.value)$1$else$0$endif$
>>

IntExpr(number) ::= <<
$number$$if (number.long)$L$endif$
>>

// the values of a list: {val1, val2, ..., valn}
ListExpr(constant) ::= <<
{$constant.value: Constant(); wrap, separator=", "$}
>>

StringExpr(constant) ::= <<
"$constant$"
>>



///////////////////////////////////////////////////////////////////////////////
// State variable declaration
///////////////////////////////////////////////////////////////////////////////

stateVar(var) ::= <<
$if (var.assignable)$
$if (var.initialized)$
$variableDeclaration(var)$ = $Constant(var.constantValue)$;
$else$
$variableDeclaration(var)$;
$endif$
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with fsm
///////////////////////////////////////////////////////////////////////////////

newState() ::= << 
:: state == $fsm_trans.SourceState$
$if (rest(fsm_trans.NextStateInfo))$
	$options.peeks.(first(fsm_trans.NextStateInfo).action): { p | chan_$p.port$?<$p.port$>;}$
	if
	$fsm_trans.NextStateInfo: {
			fsm_nsi|
:: $fsm_nsi.action: schedulerFSM(); separator="\n"$ }$
	fi
$else$
$fsm_trans.NextStateInfo: {
		fsm_nsi| $fsm_nsi.action: schedulerFSM(); separator="\n"$ }$
$endif$
>>

schedulerFSM(action) ::= <<
	/* $action.name$ */ atomic { 
	$guardFSM()$ $inputChannelCheck(action.inputPattern)$ $outputChannelCheck(action.outputPattern)$
	-> 
	$inputPattern(action.inputPattern)$
	$action.body.CFG$
	$outputPattern(action.outputPattern)$
	state = $fsm_nsi.targetState$;
}
>>

guardFSM() ::= <<
$if (options.guards.(action))$
 $options.guards.(action): {act | && $act$} $
$else$
skip
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler without fsm
///////////////////////////////////////////////////////////////////////////////

scheduler(action) ::= <<
:: /* $action.name$ */ atomic { 
	$guard()$ $inputChannelCheck(action.inputPattern)$ $outputChannelCheck(action.outputPattern)$
	-> 
	$inputPattern(action.inputPattern)$
	$outputPattern(action.outputPattern)$
}	
>>

guard() ::= <<
$options.guards.(action); separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Action Templates
///////////////////////////////////////////////////////////////////////////////

priorities() ::= << 
$if (rest(options.guards.(action)))$
 /*priority*/ && !( $rest(options.guards.(action)); separator=" && "$ )
$endif$
>> 

inputPatternPort(port) ::= <<
chan_$port.name$?trash;
>>

inputPattern(pattern) ::= <<
$pattern.keys: inputPatternPort(); separator="\n"$
>>

outputPatternPort(port) ::= <<
chan_$port$!trash;
>>

outputPattern(pattern) ::= <<
$pattern.keys: outputPatternPort(); separator="\n"$
>>

inputChannelCheck(pattern) ::= <<
$pattern.keys: {key | && nempty($key$)} $
>>

outputChannelCheck(pattern) ::= <<
$pattern.keys: {key | && nfull($key$)} $
>>


///////////////////////////////////////////////////////////////////////////////
// Process declaration
///////////////////////////////////////////////////////////////////////////////

proctype() ::= <<
active proctype $actor.name$($actor.parameters.list: variableDeclaration(); wrap, separator=", "$) {

	/* State variables */
	$actor.stateVars.list : stateVar(); separator="\n"$

	$if (actor.actionScheduler.fsm)$
	mtype state = $actor.actionScheduler.fsm.initialState$;
	
	do
	$actor.actionScheduler.fsm.transitions: { fsm_trans| $newState()$ }$
	od
	$else$
	do
	$actor.actionScheduler.actions: scheduler(); separator="\n"$
	od
	$endif$
}
>>


actor(actor, options) ::= <<
/* Composite type */

/* Channels */
$ [actor.inputs.list, actor.outputs.list] : channels(); separator="\n"$


/* Process */
$proctype()$

>>
