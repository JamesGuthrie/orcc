///////////////////////////////////////////////////////////////////////////////
// Composite types
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Channel declaration
///////////////////////////////////////////////////////////////////////////////

channels(port) ::= <<
chan chan_$port.name$ = [1] of {$port.type$}
>>


///////////////////////////////////////////////////////////////////////////////
// parameters
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

variableDeclaration(variable) ::= <<
$
if(variable.port)
$$variable.type$ *$variable$$
else
$$variable.type$ $variable$$listSize(variable.type.dimensions)$$
endif
$
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
$(constant.class.simpleName)(constant)$
>>

BoolExpr(constant) ::= <<
$if (constant.value)$1$else$0$endif$
>>

IntExpr(number) ::= <<
$number$$if (number.long)$L$endif$
>>

// the values of a list: {val1, val2, ..., valn}
ListExpr(constant) ::= <<
{$constant.value: Constant(); wrap, separator=", "$}
>>

StringExpr(constant) ::= <<
"$constant$"
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

$assign.target$ = $assign.value$;
>>

PrintFormatType(type) ::= <<
$if (type.bool)
$i$
elseif (type.float)
$f$
elseif (type.int)
$$if (type.long)$ll$endif$i$
elseif (type.list)
$p$
elseif (type.string)
$s$
elseif (type.uint)
$$if (type.long)$ll$endif$u$
elseif (type.void)
$p$
endif$
>>

PrintFormat(parameter) ::= <<
$if (parameter.stringExpr)
$"$parameter$"$
else
$ "%$PrintFormatType(parameter.type)$" $
endif$
>>

PrintParameter(parameter) ::= <<
$if (!parameter.stringExpr)$, $parameter$$endif$
>>

Call(call) ::= <<
ERROR this must be removed
>>

Decrement(decrement) ::= <<

$decrement.target$--;
>>

Increment(increment) ::= <<

$increment.target$++;
>>

Load(load) ::= <<

$load.target$ = $load.source$$load.indexes : {[$it$]}$;
>>

Peek(peek) ::= <<
$peek.port$?<$peek.target$>;
>>

Read(read) ::= <<

$if (read.target)$
$read.port$?$read.target$;
$endif$
>>


Return(return) ::= <<
$if(return.value)$
return $return.value$;$
endif$
>>

SelfAssignment(selfAssign) ::= <<

$selfAssign.target$ $selfAssign.op.text$= $selfAssign.value$;
>>

Store(store) ::= <<

$store.target$$store.indexes : {[$it$]}$ = $store.value$;
>>

Write(write) ::= <<

chan_$write.port$!$write.target$;
>>



///////////////////////////////////////////////////////////////////////////////
// Nodes 
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<

if 
:: ($ifNode.value$) ->
	$nodes(ifNode.thenNodes)$
}$if(ifNode.elseNodes)$ else ->
	$nodes(ifNode.elseNodes)$
}$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<

do 
:: $whileNode.value$ ->
	$nodes(whileNode.nodes)$
:: else -> break;
od
}
$BlockNode(whileNode.joinNode)$
>>


///////////////////////////////////////////////////////////////////////////////
// State variable declaration
///////////////////////////////////////////////////////////////////////////////

stateVar(var) ::= <<
$if (var.assignable)$
$if (var.initialized)$
$variableDeclaration(var)$ = $Constant(var.constantValue)$;
$else$
$variableDeclaration(var)$;
$endif$
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with fsm
///////////////////////////////////////////////////////////////////////////////

newState() ::= << 
:: state == $fsm_trans.SourceState$
$if (rest(fsm_trans.NextStateInfo))$
	$options.peeks.(first(fsm_trans.NextStateInfo).action): { p | chan_$p.port$?<$p.port$>;}$
	if
	$fsm_trans.NextStateInfo: {
			fsm_nsi|
:: $fsm_nsi.action: schedulerFSM(); separator="\n"$ }$
	fi
$else$
$fsm_trans.NextStateInfo: {
		fsm_nsi| $fsm_nsi.action: schedulerFSM(); separator="\n"$ }$
$endif$
>>

schedulerFSM(action) ::= <<
	/* $action.name$ */ atomic { 
	$guardFSM()$ $inputChannelCheck(action.inputPattern)$ $outputChannelCheck(action.outputPattern)$
	-> 
	$inputPattern(action.inputPattern)$
	$action.body.nodes: {$(it.class.simpleName)(it)$}$
	$outputPattern(action.outputPattern)$
	state = $fsm_nsi.targetState$;
}
>>

guardFSM() ::= <<
$if (options.guards.(action))$
 $options.guards.(action): {act | && $act$} $
$else$
skip
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler without fsm
///////////////////////////////////////////////////////////////////////////////

scheduler(action) ::= <<
:: /* $action.name$ */ atomic { 
	$guard()$ $inputChannelCheck(action.inputPattern)$ $outputChannelCheck(action.outputPattern)$
	-> 
	$inputPattern(action.inputPattern)$
	$action.body.nodes: {$(it.class.simpleName)(it)$}$
	$outputPattern(action.outputPattern)$
}	
>>

guard() ::= <<
$options.guards.(action); separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Action Templates
///////////////////////////////////////////////////////////////////////////////

priorities() ::= << 
$if (rest(options.guards.(action)))$
 /*priority*/ && !( $rest(options.guards.(action)); separator=" && "$ )
$endif$
>> 

inputPatternPort(port) ::= <<
chan_$port.name$?trash;
>>

inputPattern(pattern) ::= <<
$pattern.keys: inputPatternPort(); separator="\n"$
>>

outputPatternPort(port) ::= <<
chan_$port$!trash;
>>

outputPattern(pattern) ::= <<
$pattern.keys: outputPatternPort(); separator="\n"$
>>

inputChannelCheck(pattern) ::= <<
$pattern.keys: {key | && nempty($key$)} $
>>

outputChannelCheck(pattern) ::= <<
$pattern.keys: {key | && nfull($key$)} $
>>


///////////////////////////////////////////////////////////////////////////////
// Process declaration
///////////////////////////////////////////////////////////////////////////////

proctype() ::= <<
active proctype $actor.name$($actor.parameters.list: variableDeclaration(); wrap, separator=", "$) {

	/* State variables */
	$actor.stateVars.list : stateVar(); separator="\n"$

	$if (actor.actionScheduler.fsm)$
	mtype state = $actor.actionScheduler.fsm.initialState$;
	
	do
	$actor.actionScheduler.fsm.transitions: { fsm_trans| $newState()$ }$
	od
	$else$
	do
	$actor.actionScheduler.actions: scheduler(); separator="\n"$
	od
	$endif$
}
>>


actor(actor, options) ::= <<
/* Composite type */

/* Channels */
$ [actor.inputs.list, actor.outputs.list] : channels(); separator="\n"$


/* Process */
$proctype()$

>>
