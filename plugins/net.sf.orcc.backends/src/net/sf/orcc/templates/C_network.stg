GetInstanceId(instance) ::= <<
$if (instance.broadcast)$bcast_$endif$$instance.id$
>>

BroadcastWrite(n) ::= <<
tok_output_$n$ = fifo_$instance.broadcast.type$_write($GetInstanceId(instance)$_output_$n$, output_$n$_buf, 1);
*tok_output_$n$ = *tok_input;
>>

BroadcastWriteEnd(n) ::= <<
fifo_$instance.broadcast.type$_write_end($GetInstanceId(instance)$_output_$n$, output_$n$_buf, 1);
>>

outputPatternPort(num) ::= <<
if (!fifo_$instance.broadcast.type$_has_room($GetInstanceId(instance)$_output_$num$, 1)) {
	ports |= (1 << $num$);
}
>>

outputPattern(outputs) ::= <<
int ports = 0;
$outputs: outputPatternPort(); separator="\n"$
if (ports != 0) {
>>

declareBroadcast(instance) ::= <<
$if (instance.broadcast)
$
void $GetInstanceId(instance)$_scheduler(struct schedinfo_s *si) {
	int i = 0;
	$instance.broadcast.type$ *tok_input, input_buf[1],
	$instance.broadcast.outputList: { n | output_$n$_buf[1], *tok_output_$n$}; separator=",\n"$;

	while (fifo_$instance.broadcast.type$_has_tokens($GetInstanceId(instance)$_input, 1)) {
		$outputPattern(instance.broadcast.outputList)$
			si->num_firings = i;
			si->reason = full;
			si->ports = ports;
			return;
		}

		tok_input = fifo_$instance.broadcast.type$_read($GetInstanceId(instance)$_input, input_buf, 1);
		$instance.broadcast.outputList: BroadcastWrite(); separator="\n"$
		fifo_$instance.broadcast.type$_read_end($GetInstanceId(instance)$_input, 1);
		$instance.broadcast.outputList: BroadcastWriteEnd(); separator="\n"$
		i++;
	}

	si->reason = starved;
	si->num_firings = i;
	si->ports = 0x01;
}$
endif$

>>

declareBroadcasts(instances) ::= <<
$instances: declareBroadcast()$
>>

///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count) ::= <<
DECLARE_FIFO($type$, $size$, $count$)
>>

doAllocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
$if (source.broadcast)$
$allocateFifoType(
  type=targetPort.type, size=edge.size, count=network.connectionMap.(edge))$$else$
$allocateFifoType(
  type=sourcePort.type, size=edge.size, count=network.connectionMap.(edge))$$endif$
>>

tryAllocateFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAllocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)$$endif$
>>

allocateFifo(edge) ::= <<
$tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

allocateFifos(edges) ::= <<
$edges: allocateFifo()$
>>


///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
struct fifo_$sourcePort.type$_s *$GetInstanceId(source)$_$sourcePort.name$ = &fifo_$count$;
struct fifo_$sourcePort.type$_s *$GetInstanceId(target)$_$targetPort.name$ = &fifo_$count$;
>>

tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$$endif$
>>

assignFifo(edge) ::= <<
$tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

assignFifos(edges) ::= <<
$edges: assignFifo()$
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler functions

initialize(instance) ::= <<
$if (instance.actor && !instance.actor.initializes.empty)$
extern void $instance.id$_initialize();
$endif$
>>

declareInitializes(instances) ::= <<
$instances: initialize()$
>>

declareSchedulers(instances) ::= <<
$instances: {extern void $it.id$_scheduler(struct schedinfo_s *si);}; separator="\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
$if (instance.actor && !instance.actor.initializes.empty)
$$instance.id$_initialize();
$endif$
>>

printInitializes(instances) ::= <<
$instances: printInitialize()$
>>

printSchedulerInstance(instance) ::= <<
si.num_firings = 0;
$GetInstanceId(instance)$_scheduler(&si);
#ifdef PRINT_FIRINGS
printf("$GetInstanceId(instance)$_scheduler: %i\n", si.num_firings);
#endif
>>

printSchedulers(instances) ::= <<
$instances: printSchedulerInstance(); separator="\n"$

#ifdef PRINT_FIRINGS
printf("\n");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// threads

printThread(thread) ::= <<
void *$thread$(void *user_data) {
	struct schedinfo_s si;

	printf("Started thread \"$thread$\"\n");

	while (1) {
		$printSchedulers(threads.(thread))$
	}
	return NULL;
}
>>

printThreads(threads) ::= <<
$threads.keys: printThread(); separator="\n\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network, options) ::= <<
// Generated from "$network.name$"

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef __APPLE__
#include "SDL.h"
#endif

$if (options.needPthreads)$
#ifndef _WIN32
#define __USE_GNU
#endif
#include <pthread.h>
$endif$

#include "orcc.h"
#include "orcc_fifo.h"
#include "orcc_util.h"

#define SIZE $fifoSize$
// #define PRINT_FIRINGS

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
$allocateFifos(network.connections)$
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
$assignFifos(network.connections)$

////////////////////////////////////////////////////////////////////////////////
$declareBroadcasts(network.instances)$

////////////////////////////////////////////////////////////////////////////////
// Action schedulers
$declareInitializes(network.instances)$
$declareSchedulers(network.instances)$

$if (options.needPthreads)
$////////////////////////////////////////////////////////////////////////////////
// Threads

$printThreads(options.threads)$

#ifdef _WIN32
typedef long cpu_set_t;
#endif

void clear_cpu_set(cpu_set_t *cpuset) {
#ifdef _WIN32
	*cpuset = 0;
#else
	CPU_ZERO(cpuset);
#endif
}

void orcc_set_affinity(cpu_set_t *cpuset, int proc_num, pthread_t tid) {
#ifdef _WIN32
	*cpuset = 1 << proc_num;
	// need to get the handle
	// SetThreadAffinityMask(tid, cpuset);
#else
	CPU_SET(proc_num, cpuset);
	if (pthread_setaffinity_np(tid, sizeof(cpu_set_t), cpuset) < 0) {
		perror("pthread_setaffinity_np");
	}
#endif
}

static void scheduler() {
	pthread_t $options.threads.keys: {thread_$it$}; separator=", "$;
	cpu_set_t cpuset;

	$printInitializes(network.instances)$
	$options.threads.keys: {pthread_create(&thread_$it$, NULL, $it$, NULL);}; separator="\n"$

	clear_cpu_set(&cpuset);
	$options.threads.keys: {orcc_set_affinity(&cpuset, $i0$, thread_$it$);}; separator="\n"$

	$options.threads.keys: {pthread_join(thread_$it$, NULL);}; separator="\n"$
}

$else$
////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

static void scheduler() {
	struct schedinfo_s si;

	$printInitializes(network.instances)$
	while (1) {
		$printSchedulers(network.instances)$
	}
}
$endif$

////////////////////////////////////////////////////////////////////////////////
int main(int argc, char *argv[]) {
	init_orcc(argc, argv);
	
	scheduler();

	printf("End of simulation! Press a key to continue\n");
	wait_for_key();

	return 0;
}

>>

