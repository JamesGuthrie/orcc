BroadcastWrite(n) ::= <<
tok_output_$n$ = fifo_$instance.broadcast.type$_write($instance.id$_output_$n$, 1);
*tok_output_$n$ = *tok_input;
>>

BroadcastWriteEnd(n) ::= <<
fifo_$instance.broadcast.type$_write_end($instance.id$_output_$n$, 1);
>>

outputPatternPort(num) ::= <<
if (!fifo_$instance.broadcast.type$_has_room($instance.id$_output_$num$, 1)) {
	ports |= (1 << $num$);
}
>>

outputPattern(outputs) ::= <<
int ports = 0;
$outputs: outputPatternPort(); separator="\n"$
if (ports != 0) {
>>

declareBroadcast(instance) ::= <<
$if (instance.broadcast)
$
void $instance.id$_scheduler(struct schedinfo_s *si) {
	int i = 0;
	$instance.broadcast.type$ *tok_input;
	$instance.broadcast.outputList: { n | $instance.broadcast.type$ *tok_output_$n$;
}$
	while (fifo_$instance.broadcast.type$_has_tokens($instance.id$_input, 1)) {
		$outputPattern(instance.broadcast.outputList)$
			si->num_firings = i;
			si->reason = full;
			si->ports = ports;
			return;
		}

		tok_input = fifo_$instance.broadcast.type$_read($instance.id$_input, 1);
		$instance.broadcast.outputList: BroadcastWrite(); separator="\n"$
		fifo_$instance.broadcast.type$_read_end($instance.id$_input, 1);
		$instance.broadcast.outputList: BroadcastWriteEnd(); separator="\n"$
		i++;
	}

	si->reason = starved;
	si->num_firings = i;
	si->ports = 0x01;
}$
endif$

>>

declareBroadcasts(instances) ::= <<
$instances: declareBroadcast()$
>>

///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count) ::= <<
DECLARE_FIFO($type$, $size$, $count$)
>>

doAllocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
$if (source.broadcast)$
$allocateFifoType(
  type=targetPort.type, size=edge.size, count=network.connectionMap.(edge))$$else$
$allocateFifoType(
  type=sourcePort.type, size=edge.size, count=network.connectionMap.(edge))$$endif$
>>

tryAllocateFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAllocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)$$endif$
>>

allocateFifo(edge) ::= <<
$tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

allocateFifos(edges) ::= <<
$edges: allocateFifo()$
>>


///////////////////////////////////////////////////////////////////////////////
// assigns Traces
doDeclareTrace(source, sourcePort) ::= <<
DECLARE_TRACE($source.id$_$sourcePort.name$)
>>


tryDeclareTrace(edge, src, tgt) ::= <<
$if (src.instance)$
$doDeclareTrace(
  source=src.instance, sourcePort=edge.source
  )$$endif$
>>

declareTrace(edge) ::= <<
$tryDeclareTrace(edge=edge, src=network.sourceMap.(edge))$
>>

doAssignTrace(source, sourcePort) ::= <<
trace_$source.id$_$sourcePort.name$= fopen("$source.id$_$sourcePort.name$_trace.txt", "w");
>>

tryAssignTrace(edge, src, tgt) ::= <<
$if (src.instance)$
$doAssignTrace(
  source=src.instance, sourcePort=edge.source
  )$$endif$
>>

assignTrace(edge) ::= <<
$tryAssignTrace(edge=edge, src=network.sourceMap.(edge))$
>>

declareTraces(edges) ::= <<
$edges: declareTrace()$

void assignTrace(){
	$edges: assignTrace()$
}
>>


///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
struct fifo_$sourcePort.type$_s *$source.id$_$sourcePort.name$ = &fifo_$count$;
struct fifo_$sourcePort.type$_s *$target.id$_$targetPort.name$ = &fifo_$count$;
>>

tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$$endif$
>>

assignFifo(edge) ::= <<
$tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

assignFifos(edges) ::= <<
$edges: assignFifo()$
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler functions

initialize(instance) ::= <<
$if (instance.actor && !instance.actor.initializes.empty)$
extern void $instance.id$_initialize();
$endif$
>>

declareInitializes(instances) ::= <<
$instances: initialize()$
>>

declareSchedulers(instances) ::= <<
$instances: {extern void $it.id$_scheduler(struct schedinfo_s *si);}; separator="\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
$if (instance.actor && !instance.actor.initializes.empty)$
$instance.id$_initialize();
$endif$
>>

printInitializes(instances) ::= <<
$instances: printInitialize()$
>>

printSchedulerInstance(instance) ::= <<
si.num_firings = 0;
$instance.id$_scheduler(&si);
#ifdef PRINT_FIRINGS
printf("$instance.id$_scheduler: %i\n", si.num_firings);
#endif
>>

openTrace(edge, srcPort) ::= <<
$edge.instance.id$_$srcPort$->pFile = fopen ("$edge.instance.id$_$srcPort$_trace.txt","w");
>>

setTraceFile(connection) ::= <<
$openTrace(edge=network.sourceMap.(connection), srcPort=connection.source)$

>>


printSchedulers(instances) ::= <<
$instances: printSchedulerInstance(); separator="\n"$

#ifdef PRINT_FIRINGS
printf("\n");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network, options) ::= <<
// Generated from "$network.name$"

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef __APPLE__
#include "SDL.h"
#endif

#include <orcc/fifo.h>
#include <orcc/orcc_util.h>

$if(options.("net.sf.orcc.backends.enableTrace"))$
#include <orcc/trace.h>
$endif$

#define SIZE $fifoSize$
// #define PRINT_FIRINGS

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
$allocateFifos(network.connections)$
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
$assignFifos(network.connections)$

////////////////////////////////////////////////////////////////////////////////
$declareBroadcasts(network.instances)$

$if(options.("net.sf.orcc.backends.enableTrace"))$
////////////////////////////////////////////////////////////////////////////////
// Trace allocation
$declareTraces(network.connections)$
$endif$

////////////////////////////////////////////////////////////////////////////////
// Action schedulers
$declareInitializes(network.instances)$
$declareSchedulers(network.instances)$

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

static void scheduler() {
	struct schedinfo_s si;

	$printInitializes(network.instances)$
	while (1) {
		$printSchedulers(network.instances)$
	}
}

////////////////////////////////////////////////////////////////////////////////
int main(int argc, char *argv[]) {
	init_orcc(argc, argv);
	
	$if(options.("net.sf.orcc.backends.enableTrace"))$
	assignTrace();
	$endif$
	
	scheduler();

	printf("End of simulation! Press a key to continue\n");
	wait_for_key();

	return 0;
}

>>

