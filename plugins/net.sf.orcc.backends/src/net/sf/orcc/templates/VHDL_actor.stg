///////////////////////////////////////////////////////////////////////////////
// FIFOs
///////////////////////////////////////////////////////////////////////////////
fifo_in(port) ::= <<
$if(port.type.bool)
$$port.name$_data  : in  std_logic;$
else
$$port.name$_data  : in  std_logic_vector($port.type.size$ -1 downto 0);$
endif$

$port.name$_rdy   : out std_logic;
$port.name$_send  : in  std_logic;
$port.name$_ack   : out  std_logic;

>>

fifo_out(port) ::= <<
$if(port.type.bool)
$$port.name$_data  : out std_logic;$
else
$$port.name$_data  : out std_logic_vector($port.type.size$ -1 downto 0);$
endif$

$port.name$_rdy   : in  std_logic;
$port.name$_send  : out std_logic;
$if(last(port.name))
$$port.name$_ack   : in  std_logic$
else
$$port.name$_ack   : in  std_logic;$
endif$
>>

fifo_out_init(port) ::=<<

$port.name$_send <= '0';
$if(port.type.bool)
$$port.name$_data  <= '0';$
else
$$port.name$_data  <= (others => '0');$
endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {$it$}; separator=" * "$
>>

signalDeclaration(variable) ::= <<
$if(variable.port)$
signal $variable$ : $variable.type$;$
else$
  $if(!variable.type.list)$
    $if(!variable.assignable)$
constant $variable$ : $variable.type$ := $Constant(variable.initialValue)$;$
    else
$signal $variable$ : $variable.type$;$
    endif$$
  else$
    $if(!variable.assignable)
      $$if(variable.initialized)
$type memory_type_$variable$ is array (0 to $listSize(variable.type.dimensions)$ -1) of $variable.type$;
constant $variable$ : memory_type_$variable$ := $Constant(variable.initialValue)$;$
      endif$$
    else
$type memory_type_$variable$ is array (0 to $listSize(variable.type.dimensions)$ -1) of $variable.type$;
signal $variable$ : memory_type_$variable$;$
    endif$$
  endif$$
endif$
>>


variableDeclaration(variable) ::= <<
$if(variable.type.list)
$-- error !!!!! variable $variable$ : $variable.type$ (0 to $listSize(variable.type.dimensions)$ -1)$
else
$variable $variable$ : $variable.type$$
endif
$
>>

///////////////////////////////////////////////////////////////////////////////
// Init at reset
///////////////////////////////////////////////////////////////////////////////

stateConst(variable) ::= <<
$
if(variable.initialized)
  $$
  if(variable.assignable)
$$variable$ <= $Constant(variable.initialValue)$;$
  endif
  $$
endif
$
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
$constant$
>>

actorParameters(parameters) ::= <<
$parameters.keys: { k | #define $k$ $Constant(parameters.(k))$
}$
>>
///////////////////////////////////////////////////////////////////////////////
// Cast
///////////////////////////////////////////////////////////////////////////////

CastStore(target, value, cast)::= <<
$
if(cast.extended)
$$target$ := $value$$
else
$$
  if(target.type.uint)
$
$target$ := ucast($value$, $value.type.size$, $target.type.size$)$  
  else
$
$target$ := cast($value$, $value.type.size$, $target.type.size$)$  
  endif
$$
endif
$

>>

CastLoad(target, source, cast)::= <<
$
if(cast.extended)
$$target$ := $source$$
else
$$
  if(target.type.uint)
$
$target$ := ucast($source$, $source.type.size$, $target.variable.type.size$)$
  else
$
$target$ := cast($source$, $source.type.size$, $target.variable.type.size$)$
  endif
$$
endif
$

>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

$if (assign.cast)
$$CastStore(target=assign.target, value=assign.value, cast=assign.cast)$;$
else
$$assign.target$ := $assign.value$;$
endif
$
>>

AssignIndex(AssignIndex) ::= <<

$AssignIndex.target$ := to_integer(unsigned($AssignIndex.indexes: {std_logic_vector(to_unsigned($it$, $it.type.size$))}; separator=" & "$));
>>



Call(call) ::= <<

$
if(call.target)
$
$call.target$ := $call.procedure$($call.procedure.loadedVariables: {$it$, }$$call.parameters: {$it$, }$'1');$
elseif(call.parameters)
$
$call.procedure$($call.parameters; separator=", "$, '1');$
else
$
$call.procedure$('1');$
endif
$
>>

Load(load) ::= <<

$if(load.indexes)
$$
  if(load.source.variable.port)
  $$
    if(load.cast)
$$CastLoad(target=load.target, source=load.source, cast=load.cast)$;$
    else
$$load.target$ := $load.source$;$
    endif
  $$
  else
$$load.target$ := $load.source$($load.indexes : {$it$}; separator=", "$);$
  endif
$$
else
$$load.target$ := $load.source$;$
endif$
>>

Peek(peek) ::= <<

$if(peek.unit)
  $$
  if(peek.target.type.bool)
$$peek.target$ := $peek.port$_data;    -- peek$
  else
  $$
    if(peek.target.type.int)
$$peek.target$ := to_integer(signed($peek.port$_data));    -- peek$
    else
$$peek.target$ := to_integer(unsigned($peek.port$_data));    -- peek$
    endif
  $$
  endif
$$
else
$-- peek multiple token not coded yet$
endif
$

>>

Read(read) ::= <<

$
if(read.unit)
$$
  if(read.target.type.bool)
  $
$read.target$ := $read.port$_data;$
  elseif(read.target.type.int)
  $
$read.target$ := to_integer(signed($read.port$_data));$
  elseif (read.target)
  $
$read.target$ := to_integer(unsigned($read.port$_data));$
  endif
  $$
else
$-- read multiple token not coded yet$
endif$
>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
Return(return) ::= <<

$
if(return.value)
$$
  if(transformReturn)
$
$procedure$_go := $return.value$;$
  else
$
return $return.value$;$
  endif
$$
endif$
>>

Store(store) ::= <<

$if(store.indexes)
$$
  if(store.target.port)
  $$
    if(store.cast)
$$CastStore(value=store.value, target=store.target, cast=store.cast)$;$
    else
$$store.target$ := $store.value$;$
    endif
  $$
  else
$
$store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
  endif
$$
else
$
$store.target$ <= $store.value$;$
endif$
>>

PrintIndexes(indexes) ::= <<
$if(indexes.type.int)
$-- nop $store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
else
$$store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
endif$
>>

Write(write) ::= <<

$if(write.target.type.bool)
$$write.port$_data <= $write.target$;$
elseif(write.target.type.int)
$$write.port$_data <= std_logic_vector(to_signed($write.target$, $write.port.type.size$));$
else
$$write.port$_data <= std_logic_vector(to_unsigned($write.target$, $write.port.type.size$));$
endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<

if ($ifNode.value$) then
  $nodes(ifNode.thenNodes)$$if(ifNode.elseNodes)$
else
  $nodes(ifNode.elseNodes)$
end if;$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<

while ($whileNode.value$) loop
  $nodes(whileNode.nodes)$$BlockNode(whileNode.joinNode)$
end loop;
>>

///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////

function(procedure, transformReturn) ::= <<
$if (!procedure.external)
  $$if (procedure.returnType.void)
$procedure $procedure$($parameters(procedure.parameters.list)$dummy : std_logic) is$
  else
$function $procedure$($VarUsed(procedure)$$parameters(procedure)$dummy : std_logic) $returnFunction(procedure.returnType) $ is$
  endif$
  $if(procedure.locals.list)
$$procedure.locals.list: {$VarInFctDeclaration(it)$;$\n$}$$
  endif$
begin
  $procedure.nodes: {$(it.class.simpleName)(it)$}$
end $procedure$;$
endif$

>>

VarUsed(procedure) ::= <<
$procedure.loadedVariables: functionParameter(); wrap$
>>

parameters(procedure) ::= <<
$procedure.parameters.list: functionParameter()$
>>

functionParameter(variable) ::= <<
$if(!variable.type.list)
$$variable$ : $typeFunction(variable.type)$; $
else
$-- error !!!!! type memory type$
endif
$
>>

VarInFctDeclaration(variable) ::= <<
$if(variable.port)
$  variable $variable$ : $typeFunction(variable.type)$$
elseif(!variable.type.list)
$  variable $variable$ : $typeFunction(variable.type)$$
else
$  -- error !!!!! type memory_type$
endif$
>>


returnFunction(type) ::= <<
$if(type.bool)
$return std_logic$
elseif(type.int)
$return integer$
endif$
>>

typeFunction(type) ::= <<
$if(type.bool)
$std_logic$
elseif(type.int)
$integer$
else
$integer$
endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

procedure(procedure, transformReturn) ::= <<
$procedure.nodes: {$(it.class.simpleName)(it)$}$
>>

printLocals(procedure) ::= <<
$if(procedure.locals.list)
$$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$$
endif$
>>

printActionLocalSchedul(action) ::= <<
$printLocals(action.scheduler)
$variable $action.scheduler$_go : std_logic;

>>

printActionLocalBody(action) ::= <<
$printLocals(action.body)$
>>

// prints the body of the given action "inline" (ie not within a function)
printActionBodyInline(action) ::= <<
$procedure(procedure=action.body)$
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Scheduler process
///////////////////////////////////////////////////////////////////////////////

Actor_Scheduler(actor) ::= <<
$actor$_sceduler : process($sensitivity(actor)$)
  $actor.actions : printActionLocalSchedul()$--
begin
  $actor.actions: printTemplateDataScheduler(); separator="\n\n"$

  --
  -- Test the action's inputs to fire (or not) an action  
$if(actor.actionScheduler.fsm)    
$  $printActionFireFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$$
else  
$  if $actor.actions: printActionFire(); separator="\n  elsif"$
  else
    $actor.actions : {actions|$actions$_go  <= '0';}; separator="\n"$
    $actor.inputs.list :{port|$port.name$_ack <= '0';}; separator="\n"$  
  end if;$
endif$

end process;

>>

// print the sensitivity list of the actor
sensitivity(actor) ::= <<
$actor.inputs.list: {port|$port.name$_send}; separator=", "$$
if(actor.inputs.list)
$$if(actor.outputs.list || actor.templateData)
$, $
endif$$
endif
$$actor.outputs.list: {port|$port.name$_rdy}; separator=", "$$
if(actor.outputs.list)
$$if(actor.actionScheduler.fsm || actor.templateData)
$, $
endif$$
endif
$$actor.templateData: {$it$}; separator=", "$$
if(actor.templateData && actor.actionScheduler.fsm)    
$, FSM$
elseif(actor.actionScheduler.fsm)
$FSM$
endif$
>>

// prints the scheduler of the given action according to the actor's template data
printTemplateDataScheduler(action) ::= <<
-- test if "$action$" action is schedulable
$procedure(procedure=action.scheduler, transformReturn="true")$
>>  
  

printActionFire(action) ::= <<
((isSchedulable_$action$_go $action.inputPattern.keys : {port| and $port.name$_send }$) = '1') then
    $action$_go  <= isSchedulable_$action$_go $action.outputPattern.keys : {port| and $port.name$_rdy }$;
    $action.inputPattern.keys : {
      port|$port.name$_ack <= isSchedulable_$action$_go $action.outputPattern.keys : {port| and $port.name$_rdy }$;} ; separator="\n"$
>>

printActionFireFSM(actions, fsm) ::= <<
$if(actions)
$if$printActionFire(actions)$
else
  $actor.actions : {actions|$actions$_go  <= '0';}; separator="\n  "$
  $actor.inputs.list :{port|$port.name$_ack <= '0';}; separator="\n"$  
  $actor.actions : {actions|$actions$_ack <= '0';}; separator="\n  "$
  case FSM is
  $TransitionAck()$
      end case;
end if;$
else
$$actor.actions : {actions|$actions$_go  <= '0';}; separator="\n  "$
  $actor.inputs.list :{port|$port.name$_ack <= '0';}; separator="\n"$  
  case FSM is
$fsm.transitions: TransitionFire(); separator="\n\n"$
end case;$
endif$
>>

TransitionFire(transition) ::= <<
    when s_$transition.sourceState$ =>
      if $transition.nextStateInfo: actionFire(); separator="\n      elsif"$
      end if;
>>

actionFire(nextstate) ::= <<
    $printActionFire(nextstate.action)$
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Execute process
///////////////////////////////////////////////////////////////////////////////

Actor_Exec(actor) ::= <<
$actor.name$_execute : process (reset_n, clock) is
  $actor.actions: printActionLocalBody()$  --
begin
  if reset_n = '0' then 
    $actor.stateVars.list: stateConst(); separator="\n"$     
    --
    $actor.outputs.list: fifo_out_init()$
    $actor.inputs.list :{port|$port.name$_rdy <= '0';}; separator="\n"$    
$if(actor.actionScheduler.fsm)    
$    FSM    <= s_$actor.actionScheduler.fsm.initialState$;
$
endif$  --
  elsif rising_edge(clock) then
    $actor.outputs.list :{port|$port.name$_send <= '0';}; separator="\n"$
    $actor.inputs.list :{port|$port.name$_rdy <= '1';}; separator="\n"$  
    --  
$if(actor.actionScheduler.fsm)    
$    $executeCoreFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$$
else
$    $executeCore(actor.actions)$$
endif$

  end if;
end process $actor.name$_execute;

>>

actionTestSceduler(action) ::= <<
($action$_go = '1') then
  -- body of "$action$" action
  $printActionBodyInline(action)$  --$actor.outputs.list: writeManagement()$$actor.inputs.list: rdyManagement()$
>>

writeManagement(port) ::= <<
$if(action.outputPattern.(port))
$
  $port.name$_send <= '1';$
endif$
>>

rdyManagement(port) ::= <<
$if(!action.inputPattern.(port))
$
  $port.name$_rdy <= '0';$
endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - NO FSM

executeCore(actions) ::= <<
    if $executeIndent(actions)$
>>


// just to have a correct indentation
executeIndent(actions) ::= <<
    $actions: actionTestSceduler(); separator="\nelsif "$
    end if;
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - WITH FSM

DefineFSM(actions, fsm) ::= <<
$if(fsm)
$---------------------------------------------------------------------------
-- FSM
---------------------------------------------------------------------------
type FSM_type is ($fsm.states: {s_$it$}; separator=", "$);
signal FSM : FSM_type;$
endif$

>>

executeCoreFSM(actions, fsm) ::= <<
$if(actions)
$$executeCore(actions)$
else
  case FSM is
  $switchTransition()$
      end case;
end if;$
else
$    case FSM is
  $fsm.transitions: switchTransition(); separator="\n\n"$
    end case;$
endif$
>>


switchTransition(transition) ::= <<
    when s_$transition.sourceState$ =>
      if $transition.nextStateInfo: actionTestState(); separator="\n      elsif"$
      end if;
>>


actionTestState(nextState) ::= <<
      $actionTestSceduler(nextState.action)$
        FSM <= s_$nextState.targetState$;
>>



///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
------------------------------------------------------------------------------
-- Generated from $actor.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;

------------------------------------------------------------------------------

entity $actor.name$ is
  port (
  -- Inputs
  clock    : in  std_logic;
  reset_n  : in  std_logic;
  $actor.inputs.list: fifo_in()$  -- Outputs
  $actor.outputs.list: fifo_out(); separator=";\n"$);  
end $actor.name$;

------------------------------------------------------------------------------

architecture rtl_$actor.name$ of $actor.name$ is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  $actorParameters(actor.parameters)$
  $actor.actions: {action| signal $action$_go : std_logic;}; separator="\n"$
  --
  $actor.stateVars.list: signalDeclaration()$

$if (actor.procs.list)
$  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  $actor.procs.list: {$function(procedure=it)$}; separator="\n"$$
endif$

  $DefineFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$

begin
  $Actor_Scheduler(actor)$
  
  $Actor_Exec(actor)$

end architecture rtl_$actor.name$;

>>