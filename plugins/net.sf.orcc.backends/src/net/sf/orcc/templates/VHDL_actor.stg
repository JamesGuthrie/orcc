///////////////////////////////////////////////////////////////////////////////
// FIFOs
///////////////////////////////////////////////////////////////////////////////
fifo_in(port) ::= <<
$
if(port.type.bool)
$$port.name$_data  : in std_logic;$
else
$$port.name$_data  : in std_logic_vector($port.type.size$ -1 downto 0);$
endif
$

$port.name$_send : in std_logic;
$port.name$_ack  : out std_logic;

>>

fifo_out(port) ::= <<
$port.name$_full  : in std_logic;
$
if(last(port.name))
  $$
  if(port.type.bool)
$$port.name$_data  : out std_logic;$
  else
$$port.name$_data  : out std_logic_vector($port.type.size$ -1 downto 0);$
  endif
  $

$port.name$_write : out std_logic$
else
$$port.name$_data  : out $port.type$;
$port.name$_write : out std_logic;$
endif
$
>>

fifo_out_init(port) ::=<<
$port.name$_write <= '0';
>>



///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Scheduler process
///////////////////////////////////////////////////////////////////////////////

Actor_out(port) ::= <<
$
if(port.type.bool)
$$port.name$_data  <= '0';$\n$$
else
$$port.name$_data  <= (others => '0');$\n$$
endif
$

>>

SensitivFIFOin(port) ::= <<
$port.name$_send
>>

SensitivFIFOout(port) ::= <<
$port.name$_full
>>

Actor_Schedul(actor) ::= <<
  $actor.name$_scheduler : process (reset_n$actor.templateData: {, $it$}$,
  $actor.inputs.list: SensitivFIFOin(); separator=", "$,
  $actor.outputs.list: SensitivFIFOout(); separator=", "$) is
    $actor.actions: printActionLocalSchedul()$  --
  begin
    if reset_n = '0' then 
      $actor.actions:printActionNoACK(); separator="\n"$
      $actor.inputs.list: NoACK(); separator="\n"$      
    else
      $actor.actions: printActionSchedulerInline(); separator="\n"$
    
      -- ACK
      $actor.actions:printActionNoACK(); separator="\n"$
      $actor.inputs.list: NoACK(); separator="\n"$
      if $actor.actions:printActionACK(); separator="      elsif "$      end if;
    end if;
  end process $actor.name$_scheduler;

>>

printActionNoACK(action) ::= <<
$action$_go <= '0';
>>

NoACK(port) ::= <<
$port.name$_ack <= '0';
>>

printActionACK(action) ::= <<
$
if(action.outputPattern)
$($outputPattern(pattern=action.outputPattern)$ and isSchedulable_$action$_go = '1') then$
else
$(isSchedulable_$action$_go = '1') then$
endif
$        -- Action : $action$
        $action$_go <= '1';
        $action.inputPattern.keys : ValidAck(); separator="\n"$

>>

ValidAck(port) ::= <<
$port$_ack <= '1';
>>




Actor_Schedul_FSM(actor) ::= <<
  $actor.name$_scheduler : process (reset_n, FSM$actor.templateData: {, $it$}$,
  $actor.inputs.list: SensitivFIFOin(); separator=", "$,
  $actor.outputs.list: SensitivFIFOout(); separator=", "$) is
    $actor.actions: printActionLocalSchedul()$  --
  begin
    if reset_n = '0' then 
      $actor.actions:printActionNoACK(); separator="\n"$
      $actor.inputs.list: NoACK(); separator="\n"$      
    else
      $actor.actions: printActionSchedulerInline(); separator="\n"$
    
      -- ACK
      $actor.actions:printActionNoACK(); separator="\n"$
      $actor.inputs.list: NoACK(); separator="\n"$          
      $schedulerAckFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
    --
    end if;
  end process $actor.name$_scheduler;

>>




///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Execute process
///////////////////////////////////////////////////////////////////////////////


Actor_Exec(actor) ::= <<
  $actor.name$_execute : process (reset_n, clock) is
    $actor.actions: printActionLocalBody()$  --
  begin
    if reset_n = '0' then 
      $actor.stateVars.list: stateConst()$      --
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      $actor.outputs.list: Actor_out()$    --
    elsif rising_edge(clock) then
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      --  
      $schedulingTest(actor.actions)$
      end if;
    end if;
  end process $actor.name$_execute;

>>


Actor_Exec_FSM(actor) ::= <<
  $actor.name$_execute : process (reset_n, clock) is
    $actor.actions: printActionLocalBody()$  --
  begin
    if reset_n = '0' then 
      $actor.stateVars.list: stateConst()$      $InitFSM(actor.actionScheduler.fsm)$      --
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      $actor.outputs.list: Actor_out()$    --
    elsif rising_edge(clock) then
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      --     
      $schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$   
    end if;
  end process $actor.name$_execute;

>>


///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {0 to $it$ -1}; separator=", "$
>>

signalDeclaration(variable) ::= <<
$
if(variable.port)
$signal $variable$ : $variable.type$;
$
else
$$
  if(!variable.type.list)
  $$
    if(!variable.assignable)
    $
constant $variable$ : $variable.type$ := $Constant(variable.constantValue)$;$
    else
    $
signal $variable$ : $variable.type$;$
    endif
  $$
  else
  $$
    if(!variable.assignable)
    $$
      if(variable.initialized)
      $
type memory_type_$variable$ is array ($listSize(variable.type.dimensions)$) of $variable.type$;
constant $variable$ : memory_type_$variable$ := $Constant(variable.constantValue)$;$ 
      endif
    $$
    else
    $
type memory_type_$variable$ is array ($listSize(variable.type.dimensions)$) of $variable.type$;
signal $variable$ : memory_type_$variable$;$
    endif
  $$
  endif
$$
endif
$
>>


variableDeclaration(variable) ::= <<
$
if(variable.port)
$variable $variable$ : $variable.type$$
elseif(!variable.type.list)
$variable $variable$ : $variable.type$ $listSize(variable.type.dimensions)$$
else
$-- error !!!!! type memory_type
-- variable $variable$ : $variable.type$ $listSize(variable.type.dimensions)$$
endif
$
>>

///////////////////////////////////////////////////////////////////////////////
// Constant Signal
///////////////////////////////////////////////////////////////////////////////

stateConst(variable) ::= <<
$
if(variable.constantValue)
  $$
  if(variable.assignable)
$$declareConst(variable)$$
  endif
  $$
endif
$

>>

declareConst(variable) ::= <<
$variable$ <= $Constant(variable.constantValue)$;

>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
$(constant.class.simpleName)(constant)$
>>

Boolean(constant) ::= <<
$if (constant)$'1'$else$'0'$endif$
>>

IntegerNumber(constant) ::= <<
$constant$
>>

// the values of a list: {val1, val2, ..., valn}
List(constant) ::= <<
($constant: Constant(); wrap, separator=", "$)
>>

ArrayList(constant) ::= <<$List(constant)$>>

String(constant) ::= <<
"$constant$"
>>



///////////////////////////////////////////////////////////////////////////////
// Cast
///////////////////////////////////////////////////////////////////////////////

CastStore(target, value, cast)::= <<
$
if(cast.extended)
  $$target$ := $value$$
else
$
$target$ := cast($value$, $value.type.size$, $target.type.size$)$
endif
$

>>

CastLoad(target, source, cast)::= <<
$
if(cast.extended)
  $$target$ := $source$$
else
$
-- cast not extended
$target$ := cast($source$, $source.type.size$, $target.variable.type.size$)$
endif
$

>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

$if (assign.cast)
$$CastStore(target=assign.target, value=assign.value, cast=assign.cast)$;$
else
$$assign.target$ := $assign.value$;$
endif
$
>>

AssignIndex(AssignIndex) ::= <<

$AssignIndex.target$ = to_integer(unsigned($AssignIndex.indexes: { std_logic_vector(to_signed($it$, $it$'length))}; separator=" & "$);
>>

Call(call) ::= <<

$
if(call.target)
$
$call.target$ := $call.procedure$($call.procedure.loadedVariables: {$it$, }$$call.parameters: {$it$, }$'1');$
elseif(call.parameters)
$
$call.procedure$($call.parameters; separator=", "$, '1');$
else
$
$call.procedure$('1');$
endif
$
>>

HasTokens(hasTokens) ::= <<

$hasTokens.target$ := $hasTokens.port$_send;
>>

Load(load) ::= <<

$if(load.indexes)
$$
  if(load.source.variable.port)
  $$
    if(load.cast)
$$CastLoad(target=load.target, source=load.source, cast=load.cast)$;
-- $load.target$ := $load.source$;$
    else
$$load.target$ := $load.source$;$
    endif
  $$
  else
$$load.target$ := $load.source$($load.indexes : {$it$}; separator=", "$);$
  endif
$$
else
$$load.target$ := $load.source$;$
endif$
>>

Peek(peek) ::= <<

$if(peek.unit)
  $$
  if(peek.target.type.bool)
$$peek.target$ := $peek.port$_data;$\n$$
  else
  $$
    if(peek.target.type.int)
$$peek.target$ := to_integer(signed($peek.port$_data));$
    else
$$peek.target$ := to_integer(unsigned($peek.port$_data));$
    endif
  $$
  endif
$$
else
$-- peek multiple token not coded yet$
endif
$

>>

Read(read) ::= <<

$
if(read.unit)
$$
  if(read.target.type.bool)
  $
$read.target$ := $read.port$_data;$
  elseif(read.target.type.int)
  $
$read.target$ := to_integer(signed($read.port$_data));$
  elseif (read.target)
  $
$read.target$ := to_integer(unsigned($read.port$_data));$
  endif
  $$
else
$-- read multiple token not coded yet$
endif
$
>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
Return(return) ::= <<

$
if(return.value)
$$
  if(transformReturn)
$
$procedure$_go := $return.value$;$
  else
$
return $return.value$;$
  endif
$$
endif
$
>>

Store(store) ::= <<

$if(store.indexes)
$$
  if(store.target.port)
  $$
    if(store.cast)
$$CastStore(value=store.value, target=store.target, cast=store.cast)$;
-- $store.target$ := $store.value$;$
    else
$$store.target$ := $store.value$;$
    endif
  $$
  else
$
$store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
  endif
$$
else
$
$store.target$ <= $store.value$;$
endif
$
>>

PrintIndexes(indexes) ::= <<
$
if(indexes.type.int)
$
-- nop $store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
else
$$store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
endif
$
>>

Write(write) ::= <<

$
if(write.target.type.bool)
$$write.port$_data <= $write.target$;$
elseif(write.target.type.int)
$
$write.port$_data <= std_logic_vector(to_signed($write.target$, $write.port.type.size$));$
else
$
$write.port$_data <= std_logic_vector(to_unsigned($write.target$, $write.port.type.size$));$
endif
$

$write.port$_write <= '1';
>>


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<

if ($ifNode.value$) then
  $nodes(ifNode.thenNodes)$$if(ifNode.elseNodes)$
else
  $nodes(ifNode.elseNodes)$
end if;$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<

while ($whileNode.value$) loop
  $nodes(whileNode.nodes)$$BlockNode(whileNode.joinNode)$
end loop;
>>

///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////

function(procedure, transformReturn) ::= <<
$
if (!procedure.external)
  $$
  if (procedure.returnType.void)
$procedure $procedure$($parameters(procedure.parameters.list)$dummy : std_logic) is
  $
  else
$function $procedure$($VarUsed(procedure)$$parameters(procedure)$dummy : std_logic) $returnFunction(procedure.returnType) $ is
  $
  endif
$$
  if(procedure.locals.list)
$$procedure.locals.list: {$VarInFctDeclaration(it)$;$\n$}$$
  endif
$begin
  $procedure.nodes: {$(it.class.simpleName)(it)$}$
end $procedure$;$
endif
$

>>

VarUsed(procedure) ::= <<
$procedure.loadedVariables: functionParameter(); wrap$
>>

parameters(procedure) ::= <<
$procedure.parameters.list: functionParameter()$
>>

functionParameter(variable) ::= <<
$if(!variable.type.list)
$$variable$ : $typeFunction(variable.type)$; $
else
$-- error !!!!! type memory type$
endif
$
>>

VarInFctDeclaration(variable) ::= <<
$
if(variable.port)
$  variable $variable$ : $typeFunction(variable.type)$$
elseif(!variable.type.list)
$  variable $variable$ : $typeFunction(variable.type)$$
else
$  -- error !!!!! type memory_type$
endif
$
>>


returnFunction(type) ::= <<
$
if(type.bool)
$return std_logic$
elseif(type.int)
$return integer$
endif
$
>>

typeFunction(type) ::= <<
$
if(type.bool)
$std_logic$
elseif(type.int)
$integer$
else
$integer$
endif
$
>>



///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

procedure(procedure, transformReturn) ::= <<
$procedure.nodes: {$(it.class.simpleName)(it)$}$
>>

// prints the scheduler of the given action "inline" (ie not within a function)
printActionSchedulerInline(action) ::= <<

-- test if "$action$" action is schedulable
$procedure(procedure=action.scheduler, transformReturn="true")$
>>

printLocals(procedure) ::= <<
$
if(procedure.locals.list)
$$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$$
endif
$

>>

// this template prints the locals of the body and the scheduler function
// of the given action
printActionLocals(action) ::= <<
$printLocals(action.body)$$printLocals(action.scheduler)$
>>

printActionLocalSchedul(action) ::= <<
$printLocals(action.scheduler)$variable $action.scheduler$_go : std_logic;

>>

printActionLocalBody(action) ::= <<
$printLocals(action.body)$
>>

// prints the body of the given action "inline" (ie not within a function)
printActionBodyInline(action) ::= <<

-- body of "$action$" action
$procedure(procedure=action.body)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|$port$_full = '0'}; separator=" and "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

schedulingTest(actions) ::= <<
if $actions: actionTest(); separator="\nelsif "$
>>

actionTest(action) ::= <<
($action$_go = '1') then
  $printActionBodyInline(action)$

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM (execute)

DefineFSM(actions, fsm) ::= <<
$
if(fsm)
$type FSM_type is ($fsm.states: {s_$it$}; separator=", "$);
signal FSM : FSM_type;$
endif
$

>>

InitFSM(fsm) ::= <<
FSM <= s_$fsm.initialState$;

>>

schedulerFSM(actions, fsm) ::= <<

$
if(actions)
$
$schedulingTest(actions)$
else
  case FSM is
  $switch(fsm.transitions)$
end case;
end if;$
else
$

case FSM is
  $switch(fsm.transitions)$
end case;$
endif
$
>>


switch(transitions) ::= <<
$transitions: switchTransition()$
>>

switchTransition(transition) ::= <<


when s_$transition.sourceState$ =>
  $stateScheduler(transition)$
>>

stateScheduler(transition) ::= <<
  -- $transition.sourceState$_state_scheduler
  $schedulingTestState(nextStates=transition.nextStateInfo)$
>>

schedulingTestState(nextStates) ::= <<

if $nextStates: actionTestState(); separator="--\nelsif"$end if;
>>

actionTestState(nextState) ::= <<
($nextState.action$_go = '1') then
  $actionCallState(nextState)$
>>

// prints the action referenced by the "nextState" parameter
// and updates the FSM state
actionCallState(nextState) ::= <<
$printActionBodyInline(nextState.action)$FSM <= s_$nextState.targetState$;

>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM (schedule)


schedulerAckFSM(actions, fsm) ::= <<

$
if(actions)
$
$schedulingTest(actions)$
else
  case FSM is
  $switchAck(fsm.transitions)$
end case;
end if;$
else
$

case FSM is
  $switchAck(fsm.transitions)$
  
  when others =>
    null;
end case;$
endif
$
>>


switchAck(transitions) ::= <<
$transitions: switchTransitionAck()$
>>

switchTransitionAck(transition) ::= <<


when s_$transition.sourceState$ =>
$stateSchedulerAck(transition)$
>>


stateSchedulerAck(transition) ::= <<
  $schedulingTestStateAck(nextStates=transition.nextStateInfo)$
>>

schedulingTestStateAck(nextStates) ::= <<

if $nextStates: actionTestStateAck(); separator="--\nelsif"$end if;
>>

actionTestStateAck(nextState) ::= <<
(isSchedulable_$nextState.action$_go = '1'$
if(nextState.action.outputPattern)
$ and $outputPattern(nextState.action.outputPattern)$) then
  $nextState.action.inputPattern.keys : ValidAck(); separator="\n"$
  $nextState.action$_go <= '1';
    -- Action : $nextState.action$
$
else
$) then
  $nextState.action.inputPattern.keys : ValidAck(); separator="\n"$
  $nextState.action$_go <= '1';
  -- Action : $nextState.action$
$
endif
$

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
------------------------------------------------------------------------------
-- Generated from $actor.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;

------------------------------------------------------------------------------

entity $actor.name$ is
  port (
  -- Inputs
  clock   : in std_logic;
  reset_n : in std_logic;
  $actor.inputs.list: fifo_in()$  -- Outputs
  $actor.outputs.list: fifo_out(); separator=";\n"$);  
end $actor.name$;

------------------------------------------------------------------------------

architecture rtl_$actor.name$ of $actor.name$ is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  $actor.actions: {action| signal $action$_go : std_logic;}; separator="\n"$  
  $actor.stateVars.list: signalDeclaration()$

  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  $actor.procs.list: {$function(procedure=it)$}; separator="\n"$

  ---------------------------------------------------------------------------
  -- FSM
  ---------------------------------------------------------------------------
  $DefineFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$

begin

$
if(actor.actionScheduler.fsm)
$
  $Actor_Schedul_FSM(actor)$
  $Actor_Exec_FSM(actor)$$
else
$
  $Actor_Schedul(actor)$
  $Actor_Exec(actor)$$
endif
$

end architecture rtl_$actor.name$;

>>