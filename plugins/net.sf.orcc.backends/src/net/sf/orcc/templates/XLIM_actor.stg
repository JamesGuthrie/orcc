BinOp ::= [
	"PLUS":"$add",
	"BITAND":"bitand",
	"BITOR":"bitor",
	"BITXOR":"bitxor",
	"DIV":"$div",
	"DIV_INT":"$div",
	"EQ":"$eq",
	"EXP":"exp",
	"GE":"$ge",
	"GT":"$gt",
	"LE":"$le",
	"LOGIC_AND":"$and",
	"LOGIC_OR":"$or",
	"LT":"$lt",
	"MINUS":"$sub",
	"MOD":"$mod",
	"NE":"$ne",
	"PLUS":"$add",
	"SHIFT_LEFT":"lshift",
	"SHIFT_RIGHT":"rshift",
	"TIMES":"$mul"
]

UnaryOp ::= [
	"BITNOT":"bitnot",
	"LOGIC_NOT":"$not",
	"MINUS":"$negate",
	"NUM_ELTS":"$size",
	"LIT_INT":"$literal_Integer"
]


///////////////////////////////////////////////////////////////////////////////
// Ports
///////////////////////////////////////////////////////////////////////////////

actorPort(port, dir) ::= <<
$if (port.type.bool)
$<actor-port dir="$dir$" name="$port.name$" size="1" typeName="$port.type$"/>$
else
$<actor-port dir="$dir$" name="$port.name$" size="$port.type.size$" typeName="$port.type$"/>$
endif$
>>

actorPorts() ::= <<
<!-- Ports -->
$instance.actor.inputs.list: {port|$actorPort(port=port, dir="in")$}; separator="\n"$
$instance.actor.outputs.list: {port|$actorPort(port=port, dir="out")$}; separator="\n"$
>>

internalPorts() ::= <<
>>

///////////////////////////////////////////////////////////////////////////////
// State Variables
///////////////////////////////////////////////////////////////////////////////

initValue(type, value) ::= <<
<initValue size="$if (type.bool)$1$else$$type.size$$endif$" typeName="$type$" value="$if (value)$$value$$else$0$endif$"/>
>>

stateVar(var) ::= <<
<stateVar name="$var.name$" sourceName="$var.name$">
$if (var.type.list)$
	<initValue typeName="List">
		$var.constantValue: {value | $initValue(type=var.type.elementType, value=value)$}; separator="\n"$
	</initValue>
$else$
	$initValue(type=var.type, value=var.constantValue)$
$endif$
</stateVar>
>>

stateVars() ::= <<
<!-- State variables -->
$instance.actor.stateVars.list: stateVar(); separator="\n"$
>>



///////////////////////////////////////////////////////////////////////////////
// Operation
///////////////////////////////////////////////////////////////////////////////


Call(call) ::= <<
<!-- TODO call-->
>>

Decrement(decrement) ::= <<
<!-- TODO decrement -->
>>

HasTokens(hasTokens) ::= <<
<operation kind="pinStatus" portName="$hasTokens.port$" removable="no">
	$port(dir="out", type=hasTokens.target.type, source=hasTokens.target)$
</operation>
>>

Increment(increment) ::= <<
<!-- TODO increment -->
>>

Peek(peek) ::= <<
<!-- TODO peek -->
>>

port(dir, type, source) ::= <<
$if (!type)
$<port dir="$dir$" source="$source$"/>$
else
$<port dir="$dir$" size="$if (type.bool)$1$else$$type.size$$endif$" source="$source$" typeName="$type$"/>$
endif$
>>

operation(op) ::= <<
	$(op.class.simpleName)(op)$
>>

Read(op) ::= <<
<operation kind="pinRead" portName="$op.port.name$" removable="no">
	$port(dir="out", type=op.port.type, source=op.target)$
</operation>
>>

Write(op) ::= <<
<operation kind="pinWrite" portName="$op.port.name$" removable="no">
	$port(dir="in", type=op.port.type, source=op.target)$
</operation>
>>

Load(op) ::= <<
$if (op.target.variable.type.list)$
$! TODO !$
$else$
<operation kind="noop">
	$port(dir="in", source=op.source)$
	$port(dir="out", type=op.target.type, source=op.target)$
</operation>
$endif$
>>

Store(op) ::= <<
$if (op.target.global)$
$! TODO !$
$else$
<operation kind="noop">
	$port(dir="in", source=op.value.var)$
	$port(dir="out", type=op.target.type, source=op.target)$
</operation>
$endif$
>>

Assign(op) ::= <<
$if (op.value.binaryExpr)$
<operation kind="$BinOp.(op.value.op)$">
	$port(dir="in", source=op.value.e1)$
	$port(dir="in", source=op.value.e2)$
	$port(dir="out", type=op.target.type, source=op.target)$
</operation>$else$<operation kind="$UnaryOp.(op.value.op)$">
	$port(dir="in", source=op.value.expr)$
	$port(dir="out", type=op.target.type, source=op.target)$
</operation>
$endif$
>>


PhiAssignment(phi) ::= <<
<PHI>
	<port dir="in" qualifier="then" source="$first(phi.vars)$"/>
	<port dir="in" qualifier="else" source="$rest(phi.vars)$"/>
	<port dir="out" size="$phi.target.type.size$" source="$phi.target$" typeName="$phi.target.type$"/>
</PHI>
>>

Return(return) ::= <<
<!-- TODO return -->
>>

SelfAssignment(selfAssign) ::= <<
<!-- TODO selfAssign -->
>>

WriteEnd(writeEnd) ::= <<
<!-- TODO writeEnd -->
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
IfNode(ifNode) ::= <<

<module kind="if">
	<module decision="" kind="test">
		$ifNode.value$
	</module>
	<module kind="then">
		$nodes(ifNode.thenNodes)$
	</module>
$if(ifNode.elseNodes)$
	<module kind="else">
		$nodes(ifNode.elseNodes)$
	</module>
$endif$
	<!-- joinnode -->
	$nodes(first(ifNode.joinNode.instructions))$
</module>
$nodes(rest(ifNode.joinNode.instructions))$
<!-- end joinnode -->
>>

// while node
WhileNode(whileNode) ::= <<

while ($whileNode.value$) {
	$nodes(whileNode.nodes)$
}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
$procedure.nodes: {$(it.class.simpleName)(it)$}$
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
<module autostart="false" kind="action" name="$action.name$">
	$action.body.nodes: nodes(); separator="\n"$
</module> 
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPatternPort(port, index, index0) ::= <<
<!--  OutputPattern -->
<operation kind="pinStatus" portName="$port$" removable="no">
	<port dir="out" size="1" source="outputPattern_$instance.id$_$port$" typeName="bool"/>
</operation>
<operation kind="$BinOp.LOGIC_AND$">
	<port dir="in" source="outputPattern_$instance.id$_$port$"/>
	<port dir="in" source="outputPattern_$instance.id$_res_$index0$"/>
	<port dir="out" size="1" source="outputPattern_$instance.id$_res_$index$" typeName="bool"/>
</operation>
>>

outputPatternPortDecision(index)::=<<
<module kind="if">
	<module decision="outputPattern_$instance.id$_decision_$index$" kind="test">
		<operation kind="noop">
			<port dir="in" source="outputPattern_$instance.id$_res_$index$"/>
			<port dir="out" size="1" source="outputPattern_$instance.id$_decision_$index$" typeName="bool"/>
		</operation>
	</module>
>>

outputPattern(pattern) ::= <<
$pattern.keys: {port | $outputPatternPort(port=port, index=i, index0=i0)$}; separator="\n"$
<!-- Last outputPattern -->
$outputPatternPortDecision(length(pattern.keys)); separator="\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<operation kind="taskCall" target="$action.body$"/>
>>

actionTest(action) ::= <<
$procedure(action.scheduler)$
<module kind="if">
	<module decision="isSchedulable_$action$" kind="test">
		<operation kind="noop">
			<port dir="in" source="isSchedulable_$action$_go"/>
			<port dir="out" size="1" source="isSchedulable_$action$" typeName="bool"/>
		</operation>
	</module>
	<module kind="then">
		$if(action.outputPattern)$
		$outputPattern(pattern=action.outputPattern)$
			<module kind="then">
				$actionCall(action)$
			</module>
		</module>
		$else$
		$actionCall(action)$
		$endif$
	</module>
	<module kind="else"/>
</module>
>>

schedulingTest(actions) ::= <<
$actions: actionTest(); separator=" else "$
>>

scheduler(actions) ::= <<
<module autostart="true" kind="action-scheduler" name="$instance.id$_scheduler" sourcename="$instance.id$_scheduler">
	<operation kind="$UnaryOp.LIT_INT$" value="1">
		<port dir="out" size="1" source="var_$instance.id$_sched" typeName="bool"/>
	</operation>
	<module kind="loop">
		<module decision="var_$instance.id$_sched" kind="test">
			<operation kind="noop">
				<port dir="in" source="var_$instance.id$_sched"/>
				<port dir="out" size="1" source="var_$instance.id$_loop" typeName="bool"/>
			</operation>
		</module>
		<module kind="body">
			$if(actions)$$schedulingTest(actions)$$endif$
		</module>
	</module>
</module>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
$nextState.action.body$();
i++;
goto l_$nextState.targetState$;
>>

actionTestState(nextState) ::= <<
if (isSchedulable_$nextState.action$()) {
	$if(nextState.action.outputPattern)$
	$outputPattern(nextState.action.outputPattern)$
		_FSM_state = s_$transition.sourceState$;
		si->num_firings = i;
		si->reason = full;
		si->ports = ports;
		return;
	}
	$endif$
	$actionCallState(nextState)$
}>>

schedulingTestState(nextStates) ::= <<
$nextStates: actionTestState(); separator=" else "$
>>

Transition(transition) ::= <<


l_$transition.sourceState$:
	$if (actions)$
	while (outside_FSM_scheduler()) {
		i++;
	}
	$endif$
	$if (transition.nextStateInfo.empty)$
	printf("stuck in state \"$transition.sourceState$\"\n");
	wait_for_key();
	exit(1);
	$else$
	$schedulingTestState(nextStates=transition.nextStateInfo)$ else {
		_FSM_state = s_$transition.sourceState$;
		si->num_firings = i;
		si->reason = starved;
		si->ports = 0x0$instance.actor.maskInputsTransition.(transition)$;
		return;
	}
	$endif$
>>

Transitions(actions, transitions) ::= <<
$transitions: Transition()$
>>

switchTransition(transition) ::= <<

case s_$transition.sourceState$:
	goto l_$transition.sourceState$;
>>

switch(transitions) ::= <<
switch (_FSM_state) {
$transitions: switchTransition()$
default:
	printf("unknown state: %s\n", stateNames[_FSM_state]);
	wait_for_key();
	exit(1);
}
>>

schedulerFSM(actions, fsm) ::= <<
enum states {
	s_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {s_$it$}; separator=",\n"$
};

static char *stateNames[] = {
	$fsm.states : {"s_$it$"}; separator=",\n"$
};

static enum states _FSM_state = s_$fsm.initialState$;

$if(actions)$
static int outside_FSM_scheduler() {
	int i = 0;
	$schedulingTest(actions)$ else {
		return 0;
	}
	return 1;
}
$endif$

void $instance.id$_scheduler(struct schedinfo_s *si) {
	int i = 0;

	// jump to FSM state 
	$switch(fsm.transitions)$

	// FSM transitions
$Transitions(actions=actions, transitions=fsm.transitions)$
}

>>

parameters(parameters) ::= <<
$parameters.keys: { k | #define $k$ $parameters.(k)$
}$
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

PrintHierarchicalPath(path) ::= <<
$path; separator="/"$
>>


design() ::= <<
<!-- /$first(instance.hierarchicalClass)$/$PrintHierarchicalPath(instance.hierarchicalId)$ -->
<!-- Source file is "$instance.actor.file$" -->
<design name="$instance.id$">
	$actorPorts()$
	$parameters(instance.parameters)$
	$instance.actor.stateVars.list: stateVar()$
	$instance.actor.procs.list: procedure()$
	$instance.actor.actions: action()$
	$if(instance.actor.initializes)$
	$instance.actor.initializes: action()$
	void $instance.id$_initialize() {
		int res = 1;
		int i = 0;

		$if(instance.actor.initializes)$
		$schedulingTest(instance.actor.initializes)$
		$endif$
	}

	$endif$
	$if(instance.actor.actionScheduler.fsm)$
	$schedulerFSM(actions=instance.actor.actionScheduler.actions, fsm=instance.actor.actionScheduler.fsm)$
	$else$
	$scheduler(actions=instance.actor.actionScheduler.actions)$
	$endif$
</design>
>>

instance(instance) ::= <<
<?xml version="1.0" encoding="UTF-8"?>
$design()$
>>

