///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifoName(port) ::= <<
$if(port.type.uint)
$ %struct.fifo_$fifoType(port)$_s* $
else
$ %struct.fifo_$fifoType(port)$_s* $
endif$
>>

fifoType(port) ::= <<
$if(port.type.uint)
$u$port.type.size$$
else
$i$port.type.size$$
endif$
>>

fifo(port) ::= <<
@$port.name$ = global $fifoName(port)$ null

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////
Var(var) ::= <<
$if(var.global)$@$else$%$endif$$var$
>>

Expr(expr) ::= <<
$if(expr.varExpr)$$Var(expr.var.variable)$$else$$expr$$endif$
>>

ExprType(expr) ::= <<
$expr.type$
>>

VarType(var) ::= <<
$var.type$
>>

ListType(list) ::= <<
$list.type.elementType$
>>

variableDeclaration(variable) ::= <<
$if(!variable.port)
$$if(variable.type.list)
$$AllocaOp(result={%$variable$}, type=variable.type)$$
endif$$
endif$
>>

indexes(indexes) ::= <<
$indexes: { index | $if(index.type)$$index.type$$else$i32$endif$ $Expr(index)$ }; separator=", "$
>>

indexesName(indexes) ::= <<
$indexes: {index |$index$}; separator="_"$
>>

parametersDeclaration(arguments, parameters, casts, location) ::= <<
$arguments, parameters, casts: { arg, param, cast | $parameters(type = arg.type, variable= param, cast =cast, location=location)$}; separator=", "$
>>

parameters(type, variable, cast, location) ::= <<
$if(variable.intExpr)$$type$ $elseif(type.list)$$type$* $elseif(variable.booleanExpr)$i1 $else$$variable.type$ $endif$$if(cast)$%$variable$$location$_cast$else$$Expr(variable)$$endif$
>>

argumentDeclaration(variable) ::= <<
$if(variable.type.list)
$$variable.type$* %$variable$$
else
$$variable.type$ %$variable$$
endif$
>>

argumentTypeDeclaration(variable) ::= <<
$if(variable.type.list)
$$variable.type$*$
else
$$variable.type$$
endif$
>>

Location(location) ::= <<
$location.startLine$$location.startColumn$$location.endColumn$
>>

ConstantValue(type, const) ::= <<
$if(type.list)$ $Constant(constant = const, type = type, iterator = type.sizeIterator)$ $else$ $Constant(constant = const)$ $endif$
>>


///////////////////////////////////////////////////////////////////////////////
// List
///////////////////////////////////////////////////////////////////////////////

Constant(constant, type, iterator) ::= <<
$(constant.class.simpleName)(constant = constant, type = type, iterator = iterator)$
>>

Boolean(constant, type, iterator) ::= <<
$if (constant)$1$else$0$endif$
>>

IntegerNumber(constant, type, iterator) ::= <<
$constant$
>>

// the values of a list: {val1, val2, ..., valn}
List(constant, type, iterator) ::= <<
[$iterator, constant: {iterator, value | $type.type$ $if(value)$ $Constant(constant = value, type=type.type, iterator = type.type.sizeIterator)$ $else$ zeroinitializer $endif$ }; wrap, separator=", "$]
>>

String(constant, type, iterator) ::= <<
c"$constant$"
>>

ArrayList(constant, type, iterator) ::= <<$List(constant = constant, type = type, iterator=iterator)$>>

// phi definition
phiPair(value, label) ::= <<
[$value$, %$label$]
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
@$variable$ = $if(variable.assignable)$ global $
else$ constant $endif$ $variable.type$ $
if(variable.constantValue)$ $ConstantValue(type=variable.type, const=variable.constantValue)$
$else$ zeroinitializer, align 32 
$endif$

>>


///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
LoadOp(ty, pointer, alignment) ::= <<
load $ty$* $pointer$ $if(alignment)$ [, align <alignment>] $endif$
>>

AndOp(result, ty, op1, op2) ::= <<
$result$ = and $ty$ $op1$, $op2$
>>

IcmpOp(result, cond, ty, op1, op2) ::= <<
$result$ = icmp $cond$ $ty$ $op1$, $op2$
>>
 
GetElementPtrOp(pty, ptrval, idx0, idx) ::= <<
getelementptr $pty$* $ptrval$$if(idx0)$, i32 $idx0$$endif$ $if(idx)$, $indexes(idx)$$endif$
>>

BitcastOp(result, ty, value, ty2) ::= <<
$result$ = bitcast $ty$ $value$ to $ty2$
>>

AllocaOp(result, type, NumElements, alignment) ::= <<
$result$ = alloca $type$ $if(NumElements)
$[, i32 <NumElements>]$
endif$$
if(alignment)$
[, align <alignment>]$
endif$
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
$if(cond)
$br i1 $cond$, label $iftrue$, label $iffalse$$
else
$br label $dest$$
endif$
>>

RetOp(type, value) ::= <<
$if(value)
$ret $type$ $value$$
else
$ret void$
endif$
>>

CallOp(tail, cconv, ret_attrs, ty, fnty, fnptrval, function_args, fn_attrs) ::= <<
$if(tail)$ [tail] $endif$call$
if(cconv)$ [cconv] $endif
$$if(ret_attrs)$ [ret_attrs] $
endif$ $ty$$
if(fnty)$ [<fnty>*] $endif
$ @$fnptrval$ ($if(function_args)$$function_args$$endif$) $
if(fn_attrs)$ [fn_attrs] $endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

StoreInstr(ty, value, pty, ptr, cast) ::= <<
$if(value.intExpr || value.booleanExpr)
$store $pty$ $value$$cast$, $pty$* $ptr$$
else
$store $ty$ $Expr(value)$$cast$, $pty$* $ptr$$
endif$
>>

PrintInstr(parameters) ::= <<
call i32 (i8*, ...)* @printf($parameters: PrintParameter(); separator=", "$)

>>

PrintParameter(parameter) ::= <<
$if (parameter.type.string)
$ i8* noalias getelementptr inbounds ($parameter.type$* @$parameter$, i64 0, i64 0) $
else
$$parameter.type$ %$parameter$$
endif$

>>

///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

CastAssign(target, value, cast)::= <<
$if(cast.extended)$
%$target$_ext = $value$
$if(cast.signed)
$%$target$ = sext $value.type$ %$target$_ext to $target.type$$
else
$%$target$ = zext $value.type$ %$target$_ext to $target.type$$
endif$
$else$
%$target$_trunc = $value$
%$target$ = trunc $value.type$ %$target$_trunc to $target.type$
$endif$

>>

CastParameter(casts, args, params, location )::= <<
$casts, args, params: { cast, arg, param | $if(cast)$ 
$BitcastOp(result={%$param$$location$_cast}, ty={$param.type$*}, value=Expr(param), ty2={$arg.type$*})$
$endif$}$
>>

CastCall(result, ty, fnptrval, function_args, cast)::= <<
$if(cast.extended)$
%$result$_ext = $CallOp(ty=ty, fnptrval=fnptrval, function_args=function_args)$
$if(cast.signed)
$%$result$ = sext $ty$ %$result$_ext to $result.type$$
else
$%$result$ = zext $ty$ %$result$_ext to $result.type$$
endif$
$else$
%$result$_trunc = $CallOp(ty=ty, fnptrval=fnptrval, function_args=function_args)$
%$result$ = trunc $ty$ %$result$_trunc to $result.type$
$endif$

>>


CastStore(ty, value, pty, ptr, cast, location)::= <<
$if(cast.extended)$
$if(cast.signed)
$%$value$_$location$_ext = sext $ty$ $Expr(value)$ to $pty$$
else
$%$value$_$location$_ext = zext $ty$ $Expr(value)$ to $pty$$
endif$
$StoreInstr(ty=pty, value=value, pty=pty, ptr=ptr, cast={_$location$_ext})$
$else$
%$value$_$location$_trunc = trunc $ty$ $Expr(value)$ to $pty$
$StoreInstr(ty=pty, value=value, pty=pty, ptr=ptr, cast={_$location$_trunc})$$
endif$

>>

StoreWithIndex(ty, value, pty, pointer, cast, indexes, location) ::= <<
%$pointer$_$location$_L$indexesName(indexes)$ptr = $GetElementPtrOp(idx0="0", pty=pty, ptrval=Var(pointer), idx=indexes)$ 
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty.elementType, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr}, cast=cast, location=location)$ 
$else$
$StoreInstr(ty=ty, value=value, pty=pty.elementType, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr})$
$endif$
>>

StoreWithoutIndex(ty, value, pty, pointer, cast, location) ::= <<
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty, ptr=Var(pointer), cast=cast, location=location)$ 
$else$
$StoreInstr(ty=ty, value=value, pty=pty, ptr=Var(pointer))$
$endif$
>>

StorePortWithIndex(ty, value, pty, pointer, cast, indexes, location) ::= <<
%$pointer$_$location$_L$indexesName(indexes)$ptr = $GetElementPtrOp(pty=pty, ptrval=Var(pointer), idx=indexes)$
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr}, cast=cast, location=location)$
$else$
$StoreInstr(ty=ty, value=value, pty=pty, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr})$
$endif$
>>

CastLoad(result, ty, ptr, cast)::= <<
$if(cast.extended)$
%$result$_ext = load $ty$* $ptr$
$if(cast.signed)
$%$result$ = sext $ty$ %$result$_ext to $result.type$$
else
$%$result$ = zext $ty$ %$result$_ext to $result.type$$
endif
$$else
$%$result$_trunc = load $ty$* %$ptr$
%$result$ = trunc $ty$ %$result$_trunc to $result.type$ $
endif$
>>

LoadPortWithIndex(result, pty, pointer, indexes, cast) ::= <<
%$result$_$pointer$$indexesName(indexes)$_ptr = $GetElementPtrOp(pty=pty, ptrval=Var(pointer), idx=indexes)$
$if(cast)$
$CastLoad(result=result, ty=pty, ptr={$result$_$pointer$$indexesName(indexes)$_ptr}, cast = cast)$
$else$
%$result$ = load $pty$* %$result$_$pointer$$indexesName(indexes)$_ptr
$endif$
>>

LoadWithIndex(result, ty, pointer, indexes, cast) ::= <<
%$result$_$pointer$L$indexesName(indexes)$_ptr = $GetElementPtrOp(idx0="0",  pty=ty, ptrval=Var(pointer), idx=indexes)$
$if(cast)$
$CastLoad(result=result, ty=ty.elementType, ptr={$result$_$pointer$L$indexesName(indexes)$_ptr}, cast=cast)$
$else$
%$result$ = load $ty.elementType$* %$result$_$pointer$L$indexesName(indexes)$_ptr
$endif$
>>

LoadWithoutIndex(result, ty, pointer, cast) ::= <<
$if(cast)$
$CastLoad(result=result, ty=ty, ptr=Var(pointer), cast=cast)$ 
$else$
$result$ = $LoadOp(ty=ty, pointer=Var(pointer))$
$endif$
>>

IfWithThenElseNodes(ifNode) ::= <<
	$BrOp(cond=Expr(ifNode.value), iftrue={%b$label(ifNode.thenNodes)$}, iffalse={%b$label(ifNode.elseNodes)$})$

b$label(ifNode.thenNodes)$: 
$Nodes_cond(first(ifNode.thenNodes))$ $Nodes(rest(ifNode.thenNodes))$
	br label %b$label(ifNode.joinNode)$

b$label(ifNode.elseNodes)$:
$Nodes_cond(first(ifNode.elseNodes))$ $Nodes(rest(ifNode.elseNodes))$
	br label %b$label(ifNode.joinNode)$

b$label(ifNode.joinNode)$:

>>

IfWithThenNode(ifNode) ::= <<
	$BrOp(cond=Expr(ifNode.value), iftrue={%b$label(ifNode.thenNodes)$}, iffalse={%b$label(ifNode.joinNode)$})$

b$label(ifNode.thenNodes)$: 
$Nodes_cond(first(ifNode.thenNodes))$ $Nodes(rest(ifNode.thenNodes))$
	br label %b$label(ifNode.joinNode)$

b$label(ifNode.joinNode)$:

>>

LoadLocalPort(instr) ::= <<
%local_$instr.port$$instr.block.label$ = $LoadOp(ty=fifoName(instr.port), pointer={@$instr.port$})$
>>

label(nodes) ::= "b$first(nodes):{ x | $x.label$}$"

phiPairs(phi) ::= <<
$phiVars(vars=first(phi.vars), node = first(phi.block.predecessors))$, $phiVars(vars=first(rest(phi.vars)), node = rest(phi.block.predecessors))$
>>

phiVars(vars, node) ::= <<
[$if(vars.variable.indexed)$ %$vars$ $else$ 0 $endif$, %b$label(node)$ ]
>>


///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////


Call(call) ::= <<
$if(call.print)$ 
$PrintInstr(call.parameters)$ 
$else$
$CastParameter(casts=call.paramCast, args=call.procedure.parameters.list, params=call.parameters, location=Location(call.location))$
$if(call.target)$$
if(call.cast)
$$CastCall(result=call.target,
ty=call.procedure.returnType,
fnptrval=call.procedure,
function_args=parametersDeclaration(arguments=call.procedure.parameters.list, parameters=call.parameters, casts=call.paramCast, location=Location(call.location)),
cast=call.cast)$$
else
$%$call.target$ = $CallOp(ty=call.procedure.returnType,
fnptrval=call.procedure,
function_args=parametersDeclaration(arguments=call.procedure.parameters.list, parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))$$
endif
$$else
$$CallOp(ty=call.procedure.returnType, fnptrval=call.procedure, function_args=parametersDeclaration(arguments=call.procedure.parameters.list ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))$$
endif$$endif$
>>

Assign(assign) ::= <<

$if(assign.cast)
$$CastAssign(target = assign.target, value = assign.value, cast = assign.cast)$$
else
$%$assign.target$ = $assign.value$$
endif$
>>

PhiAssignment(phi) ::= <<

%$phi.target$ = phi $phi.target.type$ $phiPairs(phi)$
>>

Read(read) ::= <<

$LoadLocalPort(read)$
%$read.port$ = $CallOp(ty ={$read.port.type$*}, fnptrval={fifo_$fifoType(read.port)$_read}, function_args={$fifoName(read.port)$ %local_$read.target$$read.block.label$, i32 $read.numTokens$})$
>>


Peek(peek) ::= <<

$LoadLocalPort(peek)$
%$peek.port$ = $CallOp(ty ={$peek.port.type$*}, fnptrval={fifo_$fifoType(peek.port)$_peek}, function_args={$fifoName(peek.port)$ %local_$peek.target$$peek.block.label$, i32 $peek.numTokens$})$
>>

Write(write) ::= <<

$LoadLocalPort(write)$
%$write.port$ = $CallOp(ty ={$write.port.type$*}, fnptrval={fifo_$fifoType(write.port)$_write}, function_args={$fifoName(write.port)$ %local_$write.target$$write.block.label$, i32 $write.numTokens$})$
>>

HasRoom(result, action, port, numToken) ::= <<

%$port$_$action$ = $LoadOp(ty=fifoName(port), pointer={@$port$})$
%$result$32 = $CallOp(ty="i32", fnptrval={fifo_$fifoType(port)$_has_room}, function_args={$fifoName(port)$ %$port$_$action$, i32 $numToken$})$
%$result$ = trunc i32 %$result$32 to i1
>>

HasTokens(hasTokens) ::= <<

$LoadLocalPort(hasTokens)$
%$hasTokens.target$32 = $CallOp(ty="i32", fnptrval={fifo_$fifoType(hasTokens.port)$_has_tokens}, function_args={$fifoName(hasTokens.port)$ %local_$hasTokens.port$$hasTokens.block.label$, i32 $hasTokens.numTokens$})$
%$hasTokens.target$ = trunc i32 %$hasTokens.target$32 to i1
>>

WriteEnd(writeEnd) ::= <<

%end_$writeEnd.port$ = $LoadOp(ty=fifoName(writeEnd.port), pointer={@$writeEnd.port$})$
$CallOp(ty ="void", fnptrval={fifo_$fifoType(writeEnd.port)$_write_end}, function_args={$fifoName(writeEnd.port)$ %end_$writeEnd.port$, i32 $writeEnd.numTokens$})$
>>


ReadEnd(readEnd) ::= <<

%end_$readEnd.port$ = $LoadOp(ty=fifoName(readEnd.port), pointer={@$readEnd.port$})$
$CallOp(ty ="void", fnptrval={fifo_$fifoType(readEnd.port)$_read_end}, function_args={$fifoName(readEnd.port)$ %end_$readEnd.port$, i32 $readEnd.numTokens$})$
>>

Return(return) ::= <<

$if(return.value)$$
RetOp(type=return.value.type, value=Expr(return.value))$$
else
$$RetOp()$$
endif$
>>

Store(store) ::= <<

$if(store.target.port)$
$if(!store.indexes.empty)
$$StorePortWithIndex(ty=store.value.type, value=store.value, pty=store.target.type.elementType, pointer=store.target, cast=store.cast, indexes=store.indexes, location=Location(store.location))$$
endif$$
else
$$if(store.indexes.empty)
$$StoreWithoutIndex(ty=store.value.type, value=store.value, pty=VarType(store.target), pointer=store.target, cast=store.cast, location=Location(store.location))$$
else
$$StoreWithIndex(ty=store.value.type, value=store.value, pty=store.target.type, pointer=store.target, cast=store.cast, indexes=store.indexes, location=Location(store.location))$$
endif$$
endif$
>>

Load(load) ::= <<
$if (load.source.variable.port)$$
if (!load.indexes.empty)$
$LoadPortWithIndex(result=load.target, pty=load.source.variable.type.elementType, indexes=load.indexes, pointer=load.source.variable, cast= load.cast)$
$endif$$
else$$
if(load.indexes.empty)
$$LoadWithoutIndex(result={%$load.target$}, ty=VarType(load.source.variable), pointer=load.source.variable, cast= load.cast)$$
else
$$LoadWithIndex(result=load.target, ty=load.source.variable.type, pointer=load.source.variable, indexes=load.indexes, cast= load.cast)$$
endif$$
endif$
>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

// if node
IfNode(ifNode) ::= <<
$if(ifNode.thenNodes)$
$if(ifNode.elseNodes)$
$IfWithThenElseNodes(ifNode)$
$else$
$IfWithThenNode(ifNode)$	
	$endif$
$else$
	$if(ifNode.elseNodes)$
3
$endif$
$endif$
$Nodes_cond(first(ifNode.joinNode))$
$Nodes(rest(ifNode.joinNode))$

>>

// while node
WhileNode(whileNode) ::= <<
$BlockNode(whileNode.joinNode)$
	$BrOp(cond=Expr(whileNode.value), iftrue={%b$label(whileNode.Nodes)$}, iffalse={%b$label(whileNode.joinNode.successors)$})$

b$label(whileNode.nodes)$:
$Nodes_cond(first(whileNode.nodes))$
$Nodes(rest(whileNode.nodes))$
	br label %b$label(whileNode.joinNode)$

b$label(whileNode.joinNode.successors)$:

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

Instruction(instruction) ::= <<
$(instruction.class.simpleName)(instruction)$
>>

Instructions(instructions) ::= <<
$instructions: Instruction()$
>>

Node(node) ::= <<
$(node.class.simpleName)(node)$
>>

Nodes(nodes) ::= <<
$nodes: Node()$
>>

Node_cond(node) ::= <<
$({$node.class.simpleName$_cond})(node)$
>>

Nodes_cond(nodes) ::= <<
$nodes: Node_cond()$
>>

WhileNode_cond(nodes) ::= <<
$WhileNode(nodes)$
>>

IfNode_cond(nodes) ::= <<
$IfNode(nodes)$
>>

BlockNode_cond(blockNode) ::= <<
	$Instructions(blockNode.instructions)$
>>

// if node
BlockNode(blockNode) ::= <<
	br label %b$label(blockNode)$

b$label(blockNode)$:
	$Instructions(blockNode.instructions)$
>>
