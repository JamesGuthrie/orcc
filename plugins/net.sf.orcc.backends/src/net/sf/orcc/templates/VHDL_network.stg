//////////////////////////////////////////////////////////////////////////////
// print signals()

printSignals(instance) ::= <<
$if(instance.actor)
$                                            -- Actor : $instance.id$
$instance.actor.inputs.list: printSigInput()$
$instance.actor.outputs.list: printSigOutput()$$
elseif(instance.network)
$                                            -- Network : $instance.id$
$instance.network.inputs.list: printSigInput()$
$instance.network.outputs.list: printSigOutput()$$
else
$                                            -- Broadcast : $instance.id$
$instance.broadcast.outputList: printBroadOutput(); separator="\n"$$
endif$
>>


printBroadOutput(num) ::= <<

$if(instance.broadcast.type.bool)
$signal $instance.id$_output_$num$_data_out   : std_logic;$
else
$signal $instance.id$_output_$num$_data_out   : std_logic_vector($instance.broadcast.type.size$ - 1 downto 0);$
endif$

signal $instance.id$_output_$num$_send       : std_logic;
signal $instance.id$_output_$num$_ack        : std_logic;
>> 


printSigInput(port) ::= <<

$if(port.type.bool)
$signal $instance.id$_$port.name$_data_in   : std_logic;$
else
$signal $instance.id$_$port.name$_data_in   : std_logic_vector($port.type.size$ - 1 downto 0);$
endif$

signal $instance.id$_$port.name$_send      : std_logic;
signal $instance.id$_$port.name$_ack       : std_logic;
>>

printSigOutput(port) ::= <<

--
$if(port.type.bool)
$signal $instance.id$_$port.name$_data_out   : std_logic;$
else
$signal $instance.id$_$port.name$_data_out   : std_logic_vector($port.type.size$ - 1 downto 0);$
endif$

signal $instance.id$_$port.name$_send       : std_logic;
signal $instance.id$_$port.name$_ack        : std_logic;
>> 

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

assignFifos(outgoingMap) ::= <<
$outgoingMap.keys: {instance | $assignFifo(instance=instance, map=network.predecessorsMap.(instance))$}; separator="\n\n"$
>>

assignFifo(instance, map) ::= <<
$instance.id$ : entity work.$instance.id$
  port map (
    $printInputs(map=map, ports=instance.actor.inputs.list)$
    $outgoingMap.(instance) : AssignInOuts(); separator="\n"$
    clock     => clock, 
    reset_n   => reset_n);
>>

AssignInOuts(connections) ::= <<
$AssignInOut(connections=connections, map=network.successorsMap.(instance))$  
>>

AssignInOut(connections, map) ::= <<
$connections.source$_data   => $map.(connections.source).id$_$connections.target$_data,
$connections.source$_send   => $map.(connections.source).id$_$connections.target$_send,
$connections.source$_ack    => $map.(connections.source).id$_$connections.target$_ack,
>>


tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance)
  $$if (tgt.instance)
$

$doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$$
  else
  $

$assignIn(source=src.instance, sourcePort=edge.source)$$
  endif$$
elseif (tgt.instance)
  $

$assignOut(target=tgt.instance, targetPort=edge.target)$$
endif$
>>






doAssignFifoOld(source, sourcePort, target, targetPort, count) ::= <<

fifo_$count$ : entity work.fifo_top 
generic map (
depth => $if(edge.size)$$edge.size$$else$1$endif$,
$if(targetPort.type.bool)
$width => 1)$
else
$width => $targetPort.type.size$)$
endif$

port map (
  wr_data    => $source.id$_$sourcePort.name$_send, 
$if(targetPort.type.bool)
$  data_in(0) => $source.id$_$sourcePort.name$_data_out,$\n$$
else
$  data_in    => $source.id$_$sourcePort.name$_data_out,$\n$$
endif$
  wr_clk     => clock, 
  wr_ack      => $source.id$_$sourcePort.name$_ack, 
$if(targetPort.type.bool)
$  data_out(0)=> $target.id$_$targetPort.name$_data_in,$\n$$
else
$  data_out   => $target.id$_$targetPort.name$_data_in,$\n$$
endif
$  rd_clk     => clock, 
  send        => $target.id$_$targetPort.name$_send, 
  rd_ack      => $target.id$_$targetPort.name$_ack,  
  reset_n    => reset_n); 
>>

assignIn(source, sourcePort) ::= <<

$tgt.port$_data    <= $source.id$_$sourcePort.name$_data_out;
$tgt.port$_send    <= $source.id$_$sourcePort.name$_send;
$source.id$_$sourcePort.name$_ack   <= $tgt.port$_ack;
>>

assignOut(target, targetPort) ::= <<

$target.id$_$targetPort.name$_data_in <= $src.port$_data;
$target.id$_$targetPort.name$_send    <= $src.port$_send;
$src.port$_ack <= $target.id$_$targetPort.name$_ack;
>>


///////////////////////////////////////////////////////////////////////////////
// print IOs of the TOP Network

printNetworkPorts(network) ::= <<
$network.inputs.list: printNetPortsInput(); separator="\n"$
$network.outputs.list: printNetPortsOutput(); separator="\n"$
>>

printNetPortsInput(port) ::= <<
$if(port.type.bool)
$$port.name$_data  : in  std_logic;$\n$$
else
$$port.name$_data  : in  std_logic_vector($port.type.size$ - 1 downto 0);$\n$$
endif$
$port.name$_send  : in  std_logic;
$port.name$_ack   : out std_logic;
>>

printNetPortsOutput(port) ::= <<
$if(port.type.bool)
$$port.name$_data   : out std_logic;$\n$$
else
$$port.name$_data   : out std_logic_vector($port.type.size$ - 1 downto 0);$\n$$
endif$
$port.name$_send   : out std_logic;
$port.name$_ack    : in  std_logic;
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of actors, networks and broadcasts

printActorPorts(instance) ::= <<
$instance.actor.inputs.list: printPortsInput(); separator="\n"$
$instance.actor.outputs.list: printPortsOutput(); separator="\n"$
>>

printNetworksPorts(instance) ::= <<
$instance.network.inputs.list: printPortsInput(); separator="\n"$
$instance.network.outputs.list: printPortsOutput(); separator="\n"$
>>

printPortsInput(port) ::= <<
$port.name$_data   => $instance.id$_$port.name$_data_in,
$port.name$_send   => $instance.id$_$port.name$_send,
$port.name$_ack    => $instance.id$_$port.name$_ack,
>>

printPortsOutput(port) ::= <<
$port.name$_data   => $instance.id$_$port.name$_data_out,
$port.name$_send   => $instance.id$_$port.name$_send,
$port.name$_ack    => $instance.id$_$port.name$_ack,
>> 

printBroadcastPorts(instance) ::= <<
-- Print Broadcast: $instance.id$
$instance.broadcast.outputList: printBroadcastOutput(); separator="\n"$
>>

printBroadcastOutput(num) ::= <<
$instance.id$_output_$num$_data_out <= $instance.id$_data_out;
$instance.id$_output_$num$_send     <= $instance.id$_send;
$instance.id$_output_$num$_ack      <= $instance.id$_ack;
>> 

///////////////////////////////////////////////////////////////////////////////
// print actors and networks

printActor(instance) ::= <<

$if (instance.actor)
  $$if (!instance.actor.system)
  $$instance.id$ : entity work.$instance.actor.simpleName$
  port map (
    $printActorPorts(instance)$
    clock     => clock, 
    reset_n   => reset_n);$
  endif$$
endif$
>>

printNetwork(instance) ::= <<

$if (!instance.actor)
  $$if (!instance.broadcast)
  $$instance.id$ : entity work.$instance.network$
  generic map (
    SIZE             => SIZE) 
  port map (
    $printNetworksPorts(instance)$
    clock     => clock, 
    reset_n   => reset_n);$
  else
  $$printBroadcastPorts(instance)$$
  endif$$
endif$
>>

printNetworkAndActors(instances) ::= <<
$instances:
  {$checkNetworkOrActors(instance=it,
    incoming=network.incomingMap.(it),
    outgoing=network.outgoingMap.(it))$}; separator="\n\n"$
>>



checkNetworkOrActors(instance, incoming, outgoing) ::= <<
$if (instance.actor)
$$printInstances(inputs=instance.actor.inputs.list,
                    outputs=instance.actor.outputs.list)$$
elseif (instance.broadcast)
$$printInstances(inputs=instance.broadcast.inputs.list,
                   outputs=instance.broadcast.outputs.list)$$
endif$
>>


printInstances(inputs, outputs) ::= <<
$instance.id$ : entity work.$instance.id$
  port map (
$if(!inputs.empty)
$$printInputs(map=network.predecessorsMap.(instance), ports=inputs)$$
endif$$
if(!outputs.empty)
$    --
    $printOutputs(map=network.successorsMap.(instance), ports=outputs)$
    clock     => clock, 
    reset_n   => reset_n);$
endif$
>>

printInputs(map, ports) ::= <<
$ports: printPortsInputs(); separator="\n"$
>>

printPortsInputs(port) ::= <<
$port.name$_data   => $instance.id$_$port.name$_data,
$port.name$_send   => $instance.id$_$port.name$_send,
$port.name$_ack    => $instance.id$_$port.name$_ack,
>>

printOutputs(map, ports) ::= <<
$ports: printPortsOutputs(); separator="\n"$
>>

printPortsOutputs(port) ::= <<
$port.name$_data   => $map.(port).id$_data,
$port.name$_send   => $map.(port).id$_send,
$port.name$_ack    => $map.(port).id$_ack,
>>


///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network, options) ::= <<
------------------------------------------------------------------------------
-- Generated from $network.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity $network.name$ is
  generic (
  SIZE : integer := $fifoSize$);
  port (
    $printNetworkPorts(network)$
    clock    : in  std_logic;
    reset_n  : in  std_logic);  
end $network.name$;


architecture rtl_$network.name$ of $network.name$ is

  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  $network.instances : printSignals(); separator="\n"$
  ---------------------------------------------------------------------------

begin

  ---------------------------------------------------------------------------
  -- Actors and Networks instantiation 
  ---------------------------------------------------------------------------

  ---------------------------------------------------------------------------
  -- FIFOs instantiation 
  --------------------------------------------------------------------------- 
  $assignFifos(network.outgoingMap)$
  ---------------------------------------------------------------------------

end architecture rtl_$network.name$;

>>
