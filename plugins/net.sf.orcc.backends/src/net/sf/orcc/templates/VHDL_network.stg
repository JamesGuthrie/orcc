///////////////////////////////////////////////////////////////////////////////
// print signals()

printSignals(instances) ::= <<
$instances: printSig()$
>>

printSig(instance) ::= <<
$
if(instance.actor)
$$instance.actor.inputs.list: printSigInput()$
$instance.actor.outputs.list: printSigOutput()$$
endif
$
>>

printSigInput(port) ::= <<
--
$
if(port.type.bool)
$signal $instance.id$_$port.name$_data_in   : std_logic;$\n$$
else
$signal $instance.id$_$port.name$_data_in   : std_logic_vector($port.type.size$ - 1 downto 0);$\n$$
endif
$
signal $instance.id$_$port.name$_ack       : std_logic;
signal $instance.id$_$port.name$_send      : std_logic;
>>

printSigOutput(port) ::= <<
--
$
if(port.type.bool)
$signal $instance.id$_$port.name$_data_out   : std_logic;$\n$$
else
$signal $instance.id$_$port.name$_data_out   : std_logic_vector($port.type.size$ - 1 downto 0);$\n$$
endif
$
signal $instance.id$_$port.name$_full       : std_logic;
signal $instance.id$_$port.name$_write      : std_logic;
>> 

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

assignFifos(edges) ::= <<
$edges: assignFifo()$
>>

assignFifo(edge) ::= <<
$tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

tryAssignFifo(edge, src, tgt) ::= <<
$
if (src.instance)
$$
  if (tgt.instance)
$

$doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$$
  else
  $

$assignIn(source=src.instance, sourcePort=edge.source)$$
  endif
$$
else
$$
  if (tgt.instance)
  $

$assignOut(target=tgt.instance, targetPort=edge.target)$$
  endif
  $$
endif
$
>>

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<

fifo_$count$ : entity work.fifo_top 
generic map (
depth => $edge.size$,
$
if(targetPort.type.bool)
$width => 0)
$
else
$width => $targetPort.type.size$)
$
endif
$
port map (
  wr_data    => $source.id$_$sourcePort.name$_write, 
$
if(targetPort.type.bool)
$  data_in(0) => $source.id$_$sourcePort.name$_data_out,$\n$$
else
$  data_in    => $source.id$_$sourcePort.name$_data_out,$\n$$
endif
$  full       => $source.id$_$sourcePort.name$_full, 
  rd_ack      => $target.id$_$targetPort.name$_ack, 
$
if(targetPort.type.bool)
$   data_out(0)=> $target.id$_$targetPort.name$_data_in,$\n$$
else
$  data_out   => $target.id$_$targetPort.name$_data_in,$\n$$
endif
$  send       => $target.id$_$targetPort.name$_send, 
  empty      => open,
  wr_clk     => clock, 
  rd_clk     => clock, 
  reset_n    => reset_n); 
>>

assignIn(source, sourcePort) ::= <<

$tgt.port$_data    <= $source.id$_$sourcePort.name$_data_out;
$tgt.port$_write   <= $source.id$_$sourcePort.name$_write;
$source.id$_$sourcePort.name$_full   <= $tgt.port$_full;
>>

assignOut(target, targetPort) ::= <<

$target.id$_$targetPort.name$_data_in <= $src.port$_data;
$target.id$_$targetPort.name$_send    <= $src.port$_send;
$src.port$_ack <= $target.id$_$targetPort.name$_ack;
>>


///////////////////////////////////////////////////////////////////////////////
// print IOs of the TOP Network

printNetworkPorts(network) ::= <<
$network.inputs.list: printNetPortsInput(); separator="\n"$
$network.outputs.list: printNetPortsOutput(); separator="\n"$
>>

printNetPortsInput(port) ::= <<
$
if(port.type.bool)
$$port.name$_data    : in  std_logic;$\n$$
else
$$port.name$_data    : in  std_logic_vector($port.type.size$ - 1 downto 0);$\n$$
endif
$
$port.name$_send     : in  std_logic;
$port.name$_ack      : out std_logic;
>>

printNetPortsOutput(port) ::= <<
$
if(port.type.bool)
$$port.name$_data   : out std_logic;$\n$$
else
$$port.name$_data   : out std_logic_vector($port.type.size$ - 1 downto 0);$\n$$
endif
$
$port.name$_write      : out std_logic;
$port.name$_full       : in  std_logic;
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of actors and networks

printActorPorts(instance) ::= <<
$instance.actor.inputs.list: printPortsInput(); separator="\n"$
$instance.actor.outputs.list: printPortsOutput(); separator="\n"$
>>

printNetworksPorts(instance) ::= <<
$instance.network.inputs.list: printPortsInput(); separator="\n"$
$instance.network.outputs.list: printPortsOutput(); separator="\n"$
>>

printPortsInput(port) ::= <<
$port.name$_data   => $instance.id$_$port.name$_data_in,
$port.name$_ack    => $instance.id$_$port.name$_ack,
$port.name$_send   => $instance.id$_$port.name$_send,
>>

printPortsOutput(port) ::= <<
$port.name$_data   => $instance.id$_$port.name$_data_out,
$port.name$_full   => $instance.id$_$port.name$_full,
$port.name$_write  => $instance.id$_$port.name$_write,
>> 

///////////////////////////////////////////////////////////////////////////////
// print actors and networks

printActor(instance) ::= <<
$
if (instance.actor)
$$
  if (!instance.actor.system)
  $
$instance.id$ : entity work.$instance.actor$
  port map (
    $printActorPorts(instance)$
    clock            => clock, 
    reset_n          => reset_n);
  $
  endif
  $$
endif
$
>>

printNetwork(instance) ::= <<
$
if (!instance.actor)
$
$instance.id$ : entity work.$instance.network$
  generic map (
    SIZE             => SIZE) 
  port map (
    $printNetworksPorts(instance)$
    clock            => clock, 
    reset_n          => reset_n);
$
endif
$
>>

printNetAct(instances) ::= <<
$instances: printActor(); separator="\n"$
$instances: printNetwork(); separator="\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network) ::= <<
------------------------------------------------------------------------------
-- Generated from $network.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity $network.name$ is
  generic (
  SIZE : integer := $fifoSize$);
  port (
    $printNetworkPorts(network)$
    clock   : in std_logic;
    reset_n : in std_logic);  
end $network.name$;


architecture rtl_$network.name$ of $network.name$ is

  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  $printSignals(network.instances); separator="\n"$
  ---------------------------------------------------------------------------

begin

  ---------------------------------------------------------------------------
  -- Actors and Networks instantiation 
  ---------------------------------------------------------------------------
  $printNetAct(network.instances); separator="\n"$

  ---------------------------------------------------------------------------
  -- FIFOs instantiation 
  ---------------------------------------------------------------------------  
  $assignFifos(network.connections)$ 
  ---------------------------------------------------------------------------

end architecture rtl_$network.name$;
>>

