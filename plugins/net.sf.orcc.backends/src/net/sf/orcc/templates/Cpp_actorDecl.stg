///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

variableDeclaration(variable) ::= <<
$if (variable.type.dimensions)
$$variable.type$ (*$variable$)$listSize(rest(variable.type.dimensions))$$
else
$$variable.type$ $variable$$
endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Non-const state variables
///////////////////////////////////////////////////////////////////////////////
nonConstStateVar(variable) ::= <<
$if(variable.assignable)$
$variableDeclaration(variable)$;$\n$
$endif$
>>




///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

$procedure.returnType$ $procedure$($procedure.parameters.list: {$variableDeclaration(it)$}; wrap, anchor, separator=", "$);

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|hasRoom($actor.name$_$port$, $pattern.(port)$)}; separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

scheduler(actions) ::= <<
int schedule();
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

stateScheduler(transition) ::= <<
bool $transition.sourceState$_state_scheduler();

>>

schedulerFSM(actions, fsm) ::= <<
enum states 
{
	state_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {state_$it$}; separator=",\n"$
};

int _FSM_state;


$if(actions)$
bool outside_FSM_scheduler();

$endif$
$fsm.transitions: stateScheduler(); separator="\n"$
int schedule();

>>

constructor(parameters) ::= <<
$if (actor.parameters.list)$
actor_$actor.name$(char*, $parameters: {$it.type$}; separator=", "$, AKA_PROFILING_MODE );
$else$
actor_$actor.name$(char*, AKA_PROFILING_MODE);
$endif$
>>

parameters(parameters) ::= <<
$parameters: { $it.type$ $it$;}; separator="\n"$

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<

#ifndef __ACTOR_$actor.name$_H__
#define __ACTOR_$actor.name$_H__

#include <fstream>
#include "actoraka.h"

////////////////////////////////////////////////////////////////////////////////
// Input FIFOs
enum
{
	$actor.inputs.list: {$actor.name$_$it.name$,}; separator="\n"$
	$actor.name$_nbInputs
};
////////////////////////////////////////////////////////////////////////////////
// Output FIFOs
enum
{
	$actor.outputs.list: {$actor.name$_$it.name$,}; separator="\n"$
	$actor.name$_nbOutputs
};


class actor_$actor.name$ : public ActorAKA 
{

public:
	$constructor(actor.parameters.list)$
	
	~actor_$actor.name$();
	
	void initializeActor();
////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
	$actor.procs.list: procedure()$
////////////////////////////////////////////////////////////////////////////////
// Actions
	$actor.actions: action()$

public:
$if(actor.initializes)$
////////////////////////////////////////////////////////////////////////////////
// Initializes
	$actor.initializes: action()$
	void initialize();
	
$endif$
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$

private:
$if(actor.inputs.list)$
const bool hasTokens(int port, int iSize) const {return  (m_arrAvailStatus[port] >= iSize);};
$endif$
$if(actor.outputs.list)$
const bool hasRooms(int port, int iSize) const {return  (m_arrRoomStatus[port] >= iSize);};
$endif$

void getFifoStatus();

private:
#ifdef __TRACE_CAPTURE__
	TraceCapture m_actionTracer;
#endif
static char* className;

////////////////////////////////////////////////////////////////////////////////
// Parameters
$parameters(actor.parameters.list)$
////////////////////////////////////////////////////////////////////////////////
// Non-const state variables of the actor
$actor.stateVars.list: nonConstStateVar()$
////////////////////////////////////////////////////////////////////////////////
// Fifo Status members
$if(actor.inputs.list)$
int m_arrAvailStatus[$actor.name$_nbInputs];
$endif$
$if(actor.outputs.list)$
int m_arrRoomStatus[$actor.name$_nbOutputs];
$endif$
};

#endif

>>
