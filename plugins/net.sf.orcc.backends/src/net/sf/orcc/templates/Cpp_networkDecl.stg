///////////////////////////////////////////////////////////////////////////////
// include Actors
includeActor(actor) ::= <<
#include "$actor.name$.h"
>>

includeActors(actors) ::= <<
$actors: includeActor(); separator="\n"$
>>



///////////////////////////////////////////////////////////////////////////////
// initialize Instances
argumentList(parameter) ::= <<
$instance.parameters.(parameter)$
>>

initializeInstance(instance) ::= <<
$instance.id$($instance.actor.parameters.list: argumentList(); separator=", "$)
>>

initializeInstances(instances) ::= <<
$instances: initializeInstance(); separator=", "$
>>


///////////////////////////////////////////////////////////////////////////////
// declare FIFOs

printFifo(src, srcport, dst, dstport) ::= <<
FifoAPI * $src$_$srcport$_$dst$_$dstport$ = FifoFactory<$edge.source.type$>::allocateFifo($edge.size$, 0);
>>

doDeclareFifo(edge, src, tgt) ::= <<
$if(src.instance && tgt.instance)$
$printFifo(src=src.instance.id, srcport=edge.source, dst=tgt.instance.id, dstport=edge.target)$
$endif$
>>

declareFifo(edge) ::= <<
$doDeclareFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

declareFifos(network) ::= <<
$network.connections: declareFifo()$

$if (network.networks)$
$network.networks: declareFifos()$
$endif$

>>

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
$source.id$.connect(ACTOR_PORT_OUT, $source.actor.name$_$sourcePort.name$, $network.name$_fifo_$count$);
$target.id$.connect(ACTOR_PORT_IN, $target.actor.name$_$targetPort.name$, $network.name$_fifo_$count$);
>>

tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$
$endif$
>>

assignFifo(edge) ::= <<
$tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

assignFifos(edges) ::= <<
$edges: assignFifo()$
>>

///////////////////////////////////////////////////////////////////////////////
// declare Instances

declareInstance(instance) ::= <<
$if (instance.network)$
$declareInstances(instance.network.instances)$
$else$
actor_$instance.actor.name$ $instance.id$;
$endif$
>>

declareInstances(instances) ::= <<
$instances: declareInstance(); separator="\n"$
>>



///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()
printInitialize(instance) ::= <<
$if (instance.actor)$
$if (!instance.actor.initializes.empty)$
$instance.id$.initialize();

$endif$
$endif$
>>

printInitializes(instances) ::= <<
$instances: printInitialize()$
>>

printScheduler(instance) ::= <<
res += $instance.id$.scheduler();
>>

printSchedulers(instances) ::= <<
$instances: printScheduler(); separator="\n"$
>>



declareNetwork(network) ::= <<
class network_$network.name$ : public Threadaka
{
public:
	network_$network.name$():
	$initializeInstances(network.instances)$
	{
		$assignFifos(network.connections)$
	}
	
	~network_$network.name$(){}

	void start()
	{
		$network.instances: {$it.id$.startActorExecution();};separator="\n"$
		Threadaka::init();
		Threadaka::start();
	}
	void stop()
	{
		Threadaka::stop();
	}
	
	void process(void * args)
	{
		$printInitializes(network.instances)$
		while (1) 
		{
			int res = 0;
			$printSchedulers(network.instances)$
			if(res == 0)
				Sleep(0);
		}
	}
	
private:	
	$declareInstances(network.instances)$
};

>>

declareNetworks(networks) ::= <<
$networks : declareNetwork()$
>>

network(debugFifos, fifoSize, network) ::= <<
// Generated from "$network.name$"

#include "FifoFactory.h"
#include "Threadaka.h"

$includeActors(network.actors)$

$declareFifos(network)$

$if (network.networks)$
$declareNetworks(network.networks)$
$else$
$declareNetwork(network)$
$endif$
>>

