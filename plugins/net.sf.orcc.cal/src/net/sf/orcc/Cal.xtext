grammar net.sf.orcc.Cal with org.eclipse.xtext.common.Terminals

generate cal "http://www.sf.net/orcc/Cal"

Actor:
	imports=Import*
	'actor' name=ID ('[' ']')?
		'(' (parameters += Parameter (',' parameters += Parameter)*)? ')'
		(inputs += Port (',' inputs += Port)*)? '==>'
		(outputs += Port (',' outputs += Port)*)? ':'
	
	(actions+=Action | stateVariables+=StateVariable)*
	
	'end';

///////////////////////////////////////////////////////////////////////////////
// actions
///////////////////////////////////////////////////////////////////////////////

Action:
	(tag=Tag ':')?
	'action'
	(inputs += InputPattern (',' inputs += InputPattern)*)?
	'==>'
	(outputs += OutputPattern (',' outputs += OutputPattern)*)?
	('guard' guards += Expression (',' guards += Expression)*)?
	('var'
		variables += ValuedVariableDeclaration
		(',' variables += ValuedVariableDeclaration)*)?
	('do' (statements+=Statement)*)?
	'end';

InputPattern: (port=[Port] ':')? '[' tokens+=Token (',' tokens+=Token)* ']'
	('repeat' repeat=Expression)?;

Token returns Variable: name=ID;

OutputPattern: (port=[Port] ':')? '[' values+=Expression (',' values+=Expression)* ']'
	('repeat' repeat=Expression)?;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

Expression:
	AndExpression ({BinOpSeq.left=current} operator=('||' | 'or') right=AndExpression)*;
AndExpression returns Expression:
	BitorExpression ({BinOpSeq.left=current} operator=('&&' | 'and') right=BitorExpression)*;
BitorExpression returns Expression:
	BitandExpression ({BinOpSeq.left=current} operator='|' right=BitandExpression)*;
BitandExpression returns Expression:
	EqExpression ({BinOpSeq.left=current} operator='&' right=EqExpression)*;
EqExpression returns Expression:
	RelationalExpression ({BinOpSeq.left=current} operator=('=' | '!=') right=RelationalExpression)*;
RelationalExpression returns Expression:
	ShiftExpression ({BinOpSeq.left=current} operator=('<' | '<=' | '>' | '>=') right=ShiftExpression)*;
ShiftExpression returns Expression:
	AdditiveExpression ({BinOpSeq.left=current} operator=('<<' | '>>') right=AdditiveExpression)*;
AdditiveExpression returns Expression:
	MultiplicativeExpression ({BinOpSeq.left=current} operator=('+' | '-') right=MultiplicativeExpression)*;
MultiplicativeExpression returns Expression:
	ExpExpression ({BinOpSeq.left=current} operator=('*' | '/' | 'div' | 'mod') right=ExpExpression)*;
ExpExpression returns Expression:
	UnaryExpression ({BinOpSeq.left=current} operator='^' right=UnaryExpression)*;
/*UnaryExpression returns Expression:
	operator=('-' | 'not' | '#') right=PostfixExpression;*/

UnaryExpression returns Expression:
	ListExpression
    | LiteralExpression
    | VariableReference
    | '(' Expression ')';

ListExpression:
	'[' expressions+=Expression (',' expressions+=Expression)*
	(':' generators+=Generator (',' generators+=Generator)*)? ']';

Generator:
	'for' variable=VariableDeclaration 'in'
	'Integers' '(' lower=Expression ',' higher=Expression ')';

VariableReference: value=[Variable];

///////////////////////////////////////////////////////////////////////////////
// literal expressions
///////////////////////////////////////////////////////////////////////////////

LiteralExpression:
	BooleanExpression
	| IntegerExpression
	| StringExpression;

BooleanExpression: value=('true' | 'false');

IntegerExpression: value=INT;

StringExpression: value=STRING;

///////////////////////////////////////////////////////////////////////////////
// statements
///////////////////////////////////////////////////////////////////////////////

Assign: target=[Variable] ':=' value=Expression ';';

If: 'if' condition=Expression 'then' statements+=Statement 'end';

Port: type=Type name=ID;

Import:
	'import' ('all' Tag ';' | Tag ';');

Parameter returns Variable: VariableDeclaration ('=' value=Expression)?;

Statement: Assign | If;

StateVariable returns Variable: ValuedVariableDeclaration ';';

Tag: (identifiers += ID) ('.' identifiers += ID)*;

Type: name=ID ('(' attributes += TypeAttribute (',' attributes += TypeAttribute)* ')')?;

TypeAttribute: name=ID (':' type=Type | '=' value=Expression);

VariableDeclaration returns Variable: type=Type name=ID;

ValuedVariableDeclaration returns Variable:
  VariableDeclaration (('=' | ':=') value=Expression)?;
