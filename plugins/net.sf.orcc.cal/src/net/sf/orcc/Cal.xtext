grammar net.sf.orcc.Cal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cal "http://www.sf.net/orcc/Cal"

///////////////////////////////////////////////////////////////////////////////
// actor
///////////////////////////////////////////////////////////////////////////////

Actor:
	(imports+=Import)*
	'actor' name=ID ('[' ']')?
		'(' (parameters += Parameter (',' parameters += Parameter)*)? ')'
		(inputs += Port (',' inputs += Port)*)? '==>'
		(outputs += Port (',' outputs += Port)*)? ':'

	(functions += Function
	| procedures += Procedure
	| actions += Action
	| initializes += Initialize
	| stateVariables += StateVariable)*

	(schedule = Schedule)?

	(priorities += Priority)*

	'end';

Port: type=Type name=ID;

Import:
	'import' ('all' Tag | Tag) ';';

Function:
	'function' name=ID
	'('
		(parameters += VariableDeclaration (',' parameters += VariableDeclaration)*)?
	')' '-->' type=Type
	('var'
		variables += ValuedVariableDeclaration
		(',' variables += ValuedVariableDeclaration)*)? ':'
	expression=Expression
	'end';

Procedure:
	'procedure' name=ID
	'('
		(parameters += VariableDeclaration (',' parameters += VariableDeclaration)*)?
	')'
	('var'
		variables += ValuedVariableDeclaration
		(',' variables += ValuedVariableDeclaration)*)?
	'begin'
		(statements += Statement)*
	'end';

Parameter returns Variable: VariableDeclaration ('=' value=Expression)?;

StateVariable returns Variable: ValuedVariableDeclaration ';';

Tag: (identifiers += ID) ('.' identifiers += ID)*;

///////////////////////////////////////////////////////////////////////////////
// priorities
///////////////////////////////////////////////////////////////////////////////

Inequality:
	tags += Tag ('>' tags += Tag)+ ';';
	
Priority:
	'priority'
		(inequalities += Inequality)*
	'end';

///////////////////////////////////////////////////////////////////////////////
// schedule
///////////////////////////////////////////////////////////////////////////////

Schedule:
	'schedule' 'fsm' initialState=[State] ':'
		(transitions += Transition)*
	'end';

Transition:
	source=State '(' tag=Tag ')' '-->' target=[State] ';';

State: name=ID;

///////////////////////////////////////////////////////////////////////////////
// actions
///////////////////////////////////////////////////////////////////////////////

Action:
	(tag=Tag ':')?
	'action'
	(inputs += InputPattern (',' inputs += InputPattern)*)?
	'==>'
	(outputs += OutputPattern (',' outputs += OutputPattern)*)?

	('guard' guards += Expression (',' guards += Expression)*)?
	('var'
		variables += ValuedVariableDeclaration
		(',' variables += ValuedVariableDeclaration)*)?
	('do' (statements+=Statement)*)?
	'end';

Initialize returns Action:
	(tag=Tag ':')?
	'initialize'
	'==>'
	(outputs += OutputPattern (',' outputs += OutputPattern)*)?
	('guard' guards += Expression (',' guards += Expression)*)?
	('var'
		variables += ValuedVariableDeclaration
		(',' variables += ValuedVariableDeclaration)*)?
	('do' (statements+=Statement)*)?
	'end';

InputPattern: (port=[Port] ':')? '[' tokens+=Token (',' tokens+=Token)* ']'
	('repeat' repeat=Expression)?;

Token returns Variable: name=ID;

OutputPattern: (port=[Port] ':')? '[' values+=Expression (',' values+=Expression)* ']'
	('repeat' repeat=Expression)?;

///////////////////////////////////////////////////////////////////////////////
// statements
///////////////////////////////////////////////////////////////////////////////

Assign:
	target=VariableReference
	('[' (indexes += Expression (',' indexes += Expression)*)? ']')*
	':=' value=Expression ';';

CallStatement:
	procedure=[Procedure]
	'(' (parameters += Expression (',' parameters += Expression)*)? ')' ';';

ForeachStatement:
	'foreach' variable=VariableDeclaration 'in'
		'Integers' '(' lower=Expression ',' higher=Expression ')'
	 'do'
		(statements += Statement)*
	'end';

IfStatement:
	'if' condition=Expression 'then'
		(then += Statement)*
	('else'
		(else += Statement)*)?
	'end';

WhileStatement:
	'while' condition=Expression 'do'
		(statements += Statement)*
	'end';

Statement: Assign | CallStatement | ForeachStatement | IfStatement | WhileStatement;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

Expression:
	AndExpression ({BinOpSeq.left=current} operator=('||' | 'or') right=AndExpression)*;
AndExpression returns Expression:
	BitorExpression ({BinOpSeq.left=current} operator=('&&' | 'and') right=BitorExpression)*;
BitorExpression returns Expression:
	BitandExpression ({BinOpSeq.left=current} operator='|' right=BitandExpression)*;
BitandExpression returns Expression:
	EqExpression ({BinOpSeq.left=current} operator='&' right=EqExpression)*;
EqExpression returns Expression:
	RelationalExpression ({BinOpSeq.left=current} operator=('=' | '!=') right=RelationalExpression)*;
RelationalExpression returns Expression:
	ShiftExpression ({BinOpSeq.left=current} operator=('<' | '<=' | '>' | '>=') right=ShiftExpression)*;
ShiftExpression returns Expression:
	AdditiveExpression ({BinOpSeq.left=current} operator=('<<' | '>>') right=AdditiveExpression)*;
AdditiveExpression returns Expression:
	MultiplicativeExpression ({BinOpSeq.left=current} operator=('+' | '-') right=MultiplicativeExpression)*;
MultiplicativeExpression returns Expression:
	ExpExpression ({BinOpSeq.left=current} operator=('*' | '/' | 'div' | 'mod') right=ExpExpression)*;
ExpExpression returns Expression:
	UnaryExpression ({BinOpSeq.left=current} operator='^' right=UnaryExpression)*;

UnaryExpression returns Expression:
	{UnaryExpression} unaryOperator=('-' | 'not' | '#') expression=PostfixExpression
	| PostfixExpression;

PostfixExpression returns Expression:
	ListExpression
	| CallExpression
	| IndexExpression
	| IfExpression
    | LiteralExpression
    | VariableExpression
    | '(' Expression ')';

CallExpression:
	function=[Function] '(' (parameters += Expression (',' parameters += Expression)*)? ')';

IndexExpression:
	source=VariableReference
	('[' (indexes += Expression (',' indexes += Expression)*)? ']')+;

IfExpression:
	'if' condition=Expression
	'then' then=Expression
	'else' else=Expression
	'end';

ListExpression:
	'[' expressions+=Expression (',' expressions+=Expression)*
	(':' generators+=Generator (',' generators+=Generator)*)? ']';

Generator:
	'for' variable=VariableDeclaration 'in'
	'Integers' '(' lower=Expression ',' higher=Expression ')';

VariableExpression: value=VariableReference;

///////////////////////////////////////////////////////////////////////////////
// literal expressions
///////////////////////////////////////////////////////////////////////////////

LiteralExpression:
	BooleanExpression
	| IntegerExpression
	| StringExpression;

BooleanExpression: value=('true' | 'false');

IntegerExpression: value=(INT | HEX);

terminal HEX returns ecore::EInt: '0' ('x'|'X') ('0'..'9'|'a'..'f'|'A'..'F')+ ;

StringExpression: value=STRING;

///////////////////////////////////////////////////////////////////////////////
// common stuff
///////////////////////////////////////////////////////////////////////////////

Type: BoolType | FloatType | IntType | ListType | StringType | UintType;

BoolType: name='bool';

FloatType: name='float';

IntType: name='int' ('(' 'size' '=' size = Expression ')')?;

ListType: name='List' '(' 'type' ':' type = Type ',' 'size' '=' size = Expression ')';

StringType: name='String';

UintType: name='uint' ('(' 'size' '=' size = Expression ')')?;

VariableDeclaration returns Variable: type=Type name=ID;

ValuedVariableDeclaration returns Variable:
	VariableDeclaration (('=' | ':=') value=Expression)?;

VariableReference: variable=[Variable];
