grammar net.sf.orcc.cal.Cal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/net.sf.orcc.core/model/ir.ecore" as ir

generate cal "http://orcc.sf.net/cal/Cal"

///////////////////////////////////////////////////////////////////////////////
// actor
///////////////////////////////////////////////////////////////////////////////

AstActor:
	(imports+=AstImport)*
	'actor' name=ID
		'(' (parameters += AstParameter (',' parameters += AstParameter)*)? ')'
		(inputs += AstPort (',' inputs += AstPort)*)? '==>'
		(outputs += AstPort (',' outputs += AstPort)*)? ':'

	(functions += AstFunction
	| procedures += AstProcedure
	| actions += AstAction
	| initializes += AstInitialize
	| stateVariables += AstStateVariable)*

	(schedule = AstSchedule)?

	(priorities += AstPriority)*

	'end';

AstPort: (irType = [ir::Type]) type=AstType name=ID;

AstImport:
	'import' ('all' tag=AstTag | tag=AstTag ('=' id = ID)?) ';';

AstFunction:
	(irType = [ir::Type])
	'function' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')' '-->' type=AstType
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)? ':'
	expression=AstExpression
	'end';

AstProcedure:
	'procedure' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')'
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	'begin'
		(statements += AstStatement)*
	'end';

AstParameter returns AstVariable: AstVariableDeclaration ('=' value=AstExpression)?;

AstStateVariable returns AstVariable: AstValuedVariableDeclaration ';';

AstTag: (identifiers += ID) ('.' identifiers += ID)*;

///////////////////////////////////////////////////////////////////////////////
// priorities
///////////////////////////////////////////////////////////////////////////////

AstInequality:
	tags += AstTag ('>' tags += AstTag)+ ';';
	
AstPriority:
	{AstPriority}

	'priority'
		(inequalities += AstInequality)*
	'end';

///////////////////////////////////////////////////////////////////////////////
// schedule
///////////////////////////////////////////////////////////////////////////////

AstSchedule:
	'schedule' 'fsm' initialState=[AstState] ':'
		(transitions += AstTransition)*
	'end';

AstTransition:
	source=[AstState] '(' tag=AstTag ')' '-->' target=[AstState] ';';

AstState: name=ID;

///////////////////////////////////////////////////////////////////////////////
// actions
///////////////////////////////////////////////////////////////////////////////

AstAction:
	{AstAction}

	(tag=AstTag ':')?
	'action'
	(inputs += AstInputPattern (',' inputs += AstInputPattern)*)?
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?

	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do' (statements+=AstStatement)*)?
	'end';

AstInitialize returns AstAction:
	{AstInitialize}

	(tag=AstTag ':')?
	'initialize'
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?
	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do' (statements+=AstStatement)*)?
	'end';

AstInputPattern: port=[AstPort] ':' '[' tokens+=AstToken (',' tokens+=AstToken)* ']'
	('repeat' repeat=AstExpression)?;

AstToken returns AstVariable: (irType = [ir::Type]) name=ID;

AstOutputPattern: port=[AstPort] ':' '[' values+=AstExpression (',' values+=AstExpression)* ']'
	('repeat' repeat=AstExpression)?;

///////////////////////////////////////////////////////////////////////////////
// statements
///////////////////////////////////////////////////////////////////////////////

AstStatementAssign:
	target=AstVariableReference
	('[' (indexes += AstExpression (',' indexes += AstExpression)*)? ']')*
	':=' value=AstExpression ';';

AstStatementCall:
	procedure=[AstProcedure]
	'(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')' ';';

AstStatementForeach:
	'foreach' variable=AstVariableDeclaration 'in'
		'Integers' '(' lower=AstExpression ',' higher=AstExpression ')'
	 'do'
		(statements += AstStatement)*
	'end';

AstStatementIf:
	'if' condition=AstExpression 'then'
		(then += AstStatement)*
	('else'
		(else += AstStatement)*)?
	'end';

AstStatementWhile:
	'while' condition=AstExpression 'do'
		(statements += AstStatement)*
	'end';

AstStatement:
	AstStatementAssign
	| AstStatementCall
	| AstStatementForeach
	| AstStatementIf
	| AstStatementWhile;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

AstExpression:
	AstExpressionAnd ((irType = [ir::Type]) {AstExpressionBinary.left=current} operator=('||' | 'or') right=AstExpressionAnd)*;
AstExpressionAnd returns AstExpression:
	AstExpressionBitor ({AstExpressionBinary.left=current} operator=('&&' | 'and') right=AstExpressionBitor)*;
AstExpressionBitor returns AstExpression:
	AstExpressionBitand ({AstExpressionBinary.left=current} operator='|' right=AstExpressionBitand)*;
AstExpressionBitand returns AstExpression:
	AstExpressionEq ({AstExpressionBinary.left=current} operator='&' right=AstExpressionEq)*;
AstExpressionEq returns AstExpression:
	AstExpressionRelational ({AstExpressionBinary.left=current} operator=('=' | '!=') right=AstExpressionRelational)*;
AstExpressionRelational returns AstExpression:
	AstExpressionShift ({AstExpressionBinary.left=current} operator=('<' | '<=' | '>' | '>=') right=AstExpressionShift)*;
AstExpressionShift returns AstExpression:
	AstExpressionAdditive ({AstExpressionBinary.left=current} operator=('<<' | '>>') right=AstExpressionAdditive)*;
AstExpressionAdditive returns AstExpression:
	AstExpressionMultiplicative ({AstExpressionBinary.left=current} operator=('+' | '-') right=AstExpressionMultiplicative)*;
AstExpressionMultiplicative returns AstExpression:
	AstExpressionExp ({AstExpressionBinary.left=current} operator=('*' | '/' | 'div' | 'mod') right=AstExpressionExp)*;
AstExpressionExp returns AstExpression:
	AstExpressionUnary ({AstExpressionBinary.left=current} operator='^' right=AstExpressionUnary)*;

AstExpressionUnary returns AstExpression:
	{AstExpressionUnary} unaryOperator=('-' | 'not' | '#') expression=AstExpressionPostfix
	| AstExpressionPostfix;

AstExpressionPostfix returns AstExpression:
	AstExpressionList
	| AstExpressionCall
	| AstExpressionIndex
	| AstExpressionIf
    | AstExpressionLiteral
    | AstExpressionVariable
    | '(' AstExpression ')';

AstExpressionCall:
	function=[AstFunction] '(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')';

AstExpressionIndex:
	source=AstVariableReference
	('[' (indexes += AstExpression (',' indexes += AstExpression)*)? ']')+;

AstExpressionIf:
	'if' condition=AstExpression
	'then' then=AstExpression
	'else' else=AstExpression
	'end';

AstExpressionList:
	'[' expressions+=AstExpression (',' expressions+=AstExpression)*
	(':' generators+=AstGenerator (',' generators+=AstGenerator)*)? ']';

AstGenerator:
	'for' variable=AstVariableDeclaration 'in'
	'Integers' '(' lower=AstExpression ',' higher=AstExpression ')';

AstExpressionVariable: value=AstVariableReference;

///////////////////////////////////////////////////////////////////////////////
// literal expressions
///////////////////////////////////////////////////////////////////////////////

AstExpressionLiteral:
	AstExpressionBoolean
	| AstExpressionInteger
	| AstExpressionString;

AstExpressionBoolean: value=BOOL;

terminal BOOL returns ecore::EBoolean: 'true' | 'false';

AstExpressionInteger: value=(INT | HEX);

terminal HEX returns ecore::EInt: '0' ('x'|'X') ('0'..'9'|'a'..'f'|'A'..'F')+ ;

AstExpressionString: value=STRING;

///////////////////////////////////////////////////////////////////////////////
// common stuff
///////////////////////////////////////////////////////////////////////////////

AstType: AstTypeBool | AstTypeFloat | AstTypeInt | AstTypeList | AstTypeString | AstTypeUint;

AstTypeBool: name='bool';

AstTypeFloat: name='float';

AstTypeInt: name='int' ('(' 'size' '=' size = AstExpression ')')?;

AstTypeList: name='List' '(' 'type' ':' type = AstType ',' 'size' '=' size = AstExpression ')';

AstTypeString: name='String';

AstTypeUint: name='uint' ('(' 'size' '=' size = AstExpression ')')?;

AstVariableDeclaration returns AstVariable: (irType = [ir::Type]) type=AstType name=ID;

AstValuedVariableDeclaration returns AstVariable:
	AstVariableDeclaration ((constant?='=' | ':=') value=AstExpression)?;

AstVariableReference: variable=[AstVariable];
