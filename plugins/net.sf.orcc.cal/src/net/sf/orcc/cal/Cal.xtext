grammar net.sf.orcc.cal.Cal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cal "http://orcc.sf.net/cal/Cal"

///////////////////////////////////////////////////////////////////////////////
// actor
///////////////////////////////////////////////////////////////////////////////

AstActor:
	(imports+=AstImport)*
	'actor' name=ID
		'(' (parameters += AstParameter (',' parameters += AstParameter)*)? ')'
		(inputs += AstPort (',' inputs += AstPort)*)? '==>'
		(outputs += AstPort (',' outputs += AstPort)*)? ':'

	(functions += AstFunction
	| procedures += AstProcedure
	| actions += AstAction
	| initializes += AstInitialize
	| stateVariables += AstStateVariable)*

	(schedule = AstSchedule)?

	(priorities += AstPriority)*

	'end';

AstPort: type=AstType name=ID;

AstImport:
	'import' ('all' tag=AstTag | tag=AstTag ('=' id = ID)?) ';';

AstFunction:
	'function' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')' '-->' type=AstType
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)? ':'
	expression=AstExpression
	'end';

AstProcedure:
	'procedure' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')'
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	'begin'
		(statements += AstStatement)*
	'end';

AstParameter returns AstVariable: AstVariableDeclaration ('=' value=AstExpression)?;

AstStateVariable returns AstVariable: AstValuedVariableDeclaration ';';

AstTag: (identifiers += ID) ('.' identifiers += ID)*;

///////////////////////////////////////////////////////////////////////////////
// priorities
///////////////////////////////////////////////////////////////////////////////

AstInequality:
	tags += AstTag ('>' tags += AstTag)+ ';';
	
AstPriority:
	{AstPriority}

	'priority'
		(inequalities += AstInequality)*
	'end';

///////////////////////////////////////////////////////////////////////////////
// schedule
///////////////////////////////////////////////////////////////////////////////

AstSchedule:
	'schedule' 'fsm' initialState=[AstState] ':'
		(transitions += AstTransition)*
	'end';

AstTransition:
	source=[AstState] '(' tag=AstTag ')' '-->' target=[AstState] ';';

AstState: name=ID;

///////////////////////////////////////////////////////////////////////////////
// actions
///////////////////////////////////////////////////////////////////////////////

AstAction:
	{AstAction}

	(tag=AstTag ':')?
	'action'
	(inputs += AstInputPattern (',' inputs += AstInputPattern)*)?
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?

	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do' (statements+=AstStatement)*)?
	'end';

AstInitialize returns AstAction:
	{AstInitialize}

	(tag=AstTag ':')?
	'initialize'
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?
	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do' (statements+=AstStatement)*)?
	'end';

AstInputPattern: (port=[AstPort] ':')? '[' tokens+=AstToken (',' tokens+=AstToken)* ']'
	('repeat' repeat=AstExpression)?;

AstToken returns AstVariable: name=ID;

AstOutputPattern: (port=[AstPort] ':')? '[' values+=AstExpression (',' values+=AstExpression)* ']'
	('repeat' repeat=AstExpression)?;

///////////////////////////////////////////////////////////////////////////////
// statements
///////////////////////////////////////////////////////////////////////////////

AstAssign:
	target=AstVariableReference
	('[' (indexes += AstExpression (',' indexes += AstExpression)*)? ']')*
	':=' value=AstExpression ';';

AstCallStatement:
	procedure=[AstProcedure]
	'(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')' ';';

AstForeachStatement:
	'foreach' variable=AstVariableDeclaration 'in'
		'Integers' '(' lower=AstExpression ',' higher=AstExpression ')'
	 'do'
		(statements += AstStatement)*
	'end';

AstIfStatement:
	'if' condition=AstExpression 'then'
		(then += AstStatement)*
	('else'
		(else += AstStatement)*)?
	'end';

AstWhileStatement:
	'while' condition=AstExpression 'do'
		(statements += AstStatement)*
	'end';

AstStatement:
	AstAssign | AstCallStatement | AstForeachStatement | AstIfStatement | AstWhileStatement;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

AstExpression:
	AstAndExpression ({AstBinOpSeq.left=current} operator=('||' | 'or') right=AstAndExpression)*;
AstAndExpression returns AstExpression:
	AstBitorExpression ({AstBinOpSeq.left=current} operator=('&&' | 'and') right=AstBitorExpression)*;
AstBitorExpression returns AstExpression:
	AstBitandExpression ({AstBinOpSeq.left=current} operator='|' right=AstBitandExpression)*;
AstBitandExpression returns AstExpression:
	AstEqExpression ({AstBinOpSeq.left=current} operator='&' right=AstEqExpression)*;
AstEqExpression returns AstExpression:
	AstRelationalExpression ({AstBinOpSeq.left=current} operator=('=' | '!=') right=AstRelationalExpression)*;
AstRelationalExpression returns AstExpression:
	AstShiftExpression ({AstBinOpSeq.left=current} operator=('<' | '<=' | '>' | '>=') right=AstShiftExpression)*;
AstShiftExpression returns AstExpression:
	AstAdditiveExpression ({AstBinOpSeq.left=current} operator=('<<' | '>>') right=AstAdditiveExpression)*;
AstAdditiveExpression returns AstExpression:
	AstMultiplicativeExpression ({AstBinOpSeq.left=current} operator=('+' | '-') right=AstMultiplicativeExpression)*;
AstMultiplicativeExpression returns AstExpression:
	AstExpExpression ({AstBinOpSeq.left=current} operator=('*' | '/' | 'div' | 'mod') right=AstExpExpression)*;
AstExpExpression returns AstExpression:
	AstUnaryExpression ({AstBinOpSeq.left=current} operator='^' right=AstUnaryExpression)*;

AstUnaryExpression returns AstExpression:
	{AstUnaryExpression} unaryOperator=('-' | 'not' | '#') expression=AstPostfixExpression
	| AstPostfixExpression;

AstPostfixExpression returns AstExpression:
	AstListExpression
	| AstCallExpression
	| AstIndexExpression
	| AstIfExpression
    | AstLiteralExpression
    | AstVariableExpression
    | '(' AstExpression ')';

AstCallExpression:
	function=[AstFunction] '(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')';

AstIndexExpression:
	source=AstVariableReference
	('[' (indexes += AstExpression (',' indexes += AstExpression)*)? ']')+;

AstIfExpression:
	'if' condition=AstExpression
	'then' then=AstExpression
	'else' else=AstExpression
	'end';

AstListExpression:
	'[' expressions+=AstExpression (',' expressions+=AstExpression)*
	(':' generators+=AstGenerator (',' generators+=AstGenerator)*)? ']';

AstGenerator:
	'for' variable=AstVariableDeclaration 'in'
	'Integers' '(' lower=AstExpression ',' higher=AstExpression ')';

AstVariableExpression: value=AstVariableReference;

///////////////////////////////////////////////////////////////////////////////
// literal expressions
///////////////////////////////////////////////////////////////////////////////

AstLiteralExpression:
	AstBooleanExpression
	| AstIntegerExpression
	| AstStringExpression;

AstBooleanExpression: value=('true' | 'false');

AstIntegerExpression: value=(INT | HEX);

terminal HEX returns ecore::EInt: '0' ('x'|'X') ('0'..'9'|'a'..'f'|'A'..'F')+ ;

AstStringExpression: value=STRING;

///////////////////////////////////////////////////////////////////////////////
// common stuff
///////////////////////////////////////////////////////////////////////////////

AstType: AstBoolType | AstFloatType | AstIntType | AstListType | AstStringType | AstUintType;

AstBoolType: name='bool';

AstFloatType: name='float';

AstIntType: name='int' ('(' 'size' '=' size = AstExpression ')')?;

AstListType: name='List' '(' 'type' ':' type = AstType ',' 'size' '=' size = AstExpression ')';

AstStringType: name='String';

AstUintType: name='uint' ('(' 'size' '=' size = AstExpression ')')?;

AstVariableDeclaration returns AstVariable: type=AstType name=ID;

AstValuedVariableDeclaration returns AstVariable:
	AstVariableDeclaration (('=' | ':=') value=AstExpression)?;

AstVariableReference: variable=[AstVariable];
