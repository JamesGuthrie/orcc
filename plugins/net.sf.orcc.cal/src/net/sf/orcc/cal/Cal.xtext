grammar net.sf.orcc.cal.Cal with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cal "http://orcc.sf.net/cal/Cal"

///////////////////////////////////////////////////////////////////////////////
// top-level entity
///////////////////////////////////////////////////////////////////////////////

AstEntity: actor=AstActor | unit=AstUnit;

///////////////////////////////////////////////////////////////////////////////
// unit
///////////////////////////////////////////////////////////////////////////////

AstUnit: 'unit' name=QualifiedName ':'

	(functions += AstFunction
	| variables += AstConstantVariable)*

	'end';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildCard:
	QualifiedName '.*'?;

AstConstantVariable returns AstVariable:
	AstVariableDeclaration (constant ?= '=') value=AstExpression ';';

///////////////////////////////////////////////////////////////////////////////
// actor
///////////////////////////////////////////////////////////////////////////////

Import: 'import' importedNamespace=QualifiedNameWithWildCard ';';

AstActor:
	(imports += Import)*

	'actor' name=QualifiedName
		'(' (parameters += AstParameter (',' parameters += AstParameter)*)? ')'
		(inputs += AstPort (',' inputs += AstPort)*)? '==>'
		(outputs += AstPort (',' outputs += AstPort)*)? ':'

	(functions += AstFunction
	| procedures += AstProcedure
	| actions += AstAction
	| initializes += AstInitialize
	| stateVariables += AstStateVariable)*

	(schedule = AstSchedule)?
	
	(scheduleRegExp = AstScheduleRegExp)?

	(priorities += AstPriority)*

	'end';

AstPort: type=AstType name=ID;

AstFunction:
	'function' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')' '-->' type=AstType
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)? ':'
	expression=AstExpression
	'end';

AstProcedure:
	'procedure' name=ID
	'('
		(parameters += AstVariableDeclaration (',' parameters += AstVariableDeclaration)*)?
	')'
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	'begin'
		(statements += AstStatement)*
	'end';

AstParameter returns AstVariable: AstVariableDeclaration ('=' value=AstExpression)?;

AstStateVariable returns AstVariable: AstValuedVariableDeclaration ';';

AstTag: (identifiers += ID) ('.' identifiers += ID)*;

///////////////////////////////////////////////////////////////////////////////
// priorities
///////////////////////////////////////////////////////////////////////////////

AstInequality:
	tags += AstTag ('>' tags += AstTag)+ ';';
	
AstPriority:
	{AstPriority}

	'priority'
		(inequalities += AstInequality)*
	'end';

///////////////////////////////////////////////////////////////////////////////
// schedule
///////////////////////////////////////////////////////////////////////////////

AstSchedule:
	'schedule' 'fsm' initialState=[AstState] ':'
		(transitions += AstTransition)*
	'end';

AstTransition:
	source=[AstState] '(' tag=AstTag ')' '-->' target=[AstState] ';';

AstState: name=ID;

AstScheduleRegExp:
	'schedule' 'regexp' AstRegExp
	'end';
	
AstRegExp:
	AstRegExpConcatenation({AstRegExpBinary.left=current} operator=('|') right=AstRegExpConcatenation)*;
AstRegExpConcatenation returns AstRegExp:
	AstRegExpPostfix({AstRegExpBinary.left=current} right=AstRegExpPostfix)*;
AstRegExpPostfix returns AstRegExp:
	AstRegExpGrouping({AstRegExpUnary.child=current} unaryOperator=('*'|'?'))*;
AstRegExpGrouping returns AstRegExp:
	  AstRegExpTerminal
	| '(' AstRegExp ')';

AstRegExpTerminal returns AstRegExp:
	{AstRegExpTag} tag=AstTag;

///////////////////////////////////////////////////////////////////////////////
// actions
///////////////////////////////////////////////////////////////////////////////

AstAction:
	{AstAction}

	(tag=AstTag ':')?
	'action'
	(inputs += AstInputPattern (',' inputs += AstInputPattern)*)?
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?

	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do' (statements+=AstStatement)*)?
	'end';

AstInitialize returns AstAction:
	{AstInitialize}

	(tag=AstTag ':')?
	'initialize'
	'==>'
	(outputs += AstOutputPattern (',' outputs += AstOutputPattern)*)?
	('guard' guards += AstExpression (',' guards += AstExpression)*)?
	('var'
		variables += AstValuedVariableDeclaration
		(',' variables += AstValuedVariableDeclaration)*)?
	('do' (statements+=AstStatement)*)?
	'end';

AstInputPattern: port=[AstPort] ':' '[' tokens+=AstToken (',' tokens+=AstToken)* ']'
	('repeat' repeat=AstExpression)?;

AstToken returns AstVariable: name=ID;

AstOutputPattern: port=[AstPort] ':' '[' values+=AstExpression (',' values+=AstExpression)* ']'
	('repeat' repeat=AstExpression)?;

///////////////////////////////////////////////////////////////////////////////
// statements
///////////////////////////////////////////////////////////////////////////////

AstStatementAssign:
	target=AstVariableReference
		('[' indexes += AstExpression ']')* ':=' value=AstExpression ';';

AstStatementCall:
	procedure=[AstProcedure]
	'(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')' ';';

AstStatementForeach:
	'foreach' variable=AstVariableDeclaration 'in' lower=AstExpression '..' higher=AstExpression
	'do'
		(statements += AstStatement)*
	'end';

AstStatementIf:
	'if' condition=AstExpression 'then'
		(then += AstStatement)*
	('else'
		(else += AstStatement)*)?
	'end';

AstStatementWhile:
	'while' condition=AstExpression 'do'
		(statements += AstStatement)*
	'end';

AstStatement:
	AstStatementAssign
	| AstStatementCall
	| AstStatementForeach
	| AstStatementIf
	| AstStatementWhile;

///////////////////////////////////////////////////////////////////////////////
// expressions
///////////////////////////////////////////////////////////////////////////////

AstExpression:
	AstExpressionAnd ({AstExpressionBinary.left=current} operator=('||' | 'or') right=AstExpressionAnd)*;
AstExpressionAnd returns AstExpression:
	AstExpressionBitor ({AstExpressionBinary.left=current} operator=('&&' | 'and') right=AstExpressionBitor)*;
AstExpressionBitor returns AstExpression:
	AstExpressionBitxor ({AstExpressionBinary.left=current} operator='|' right=AstExpressionBitxor)*;
AstExpressionBitxor returns AstExpression:
	AstExpressionBitand ({AstExpressionBinary.left=current} operator='^' right=AstExpressionBitand)*;
AstExpressionBitand returns AstExpression:
	AstExpressionEq ({AstExpressionBinary.left=current} operator='&' right=AstExpressionEq)*;
AstExpressionEq returns AstExpression:
	AstExpressionRelational ({AstExpressionBinary.left=current} operator=('=' | '!=') right=AstExpressionRelational)*;
AstExpressionRelational returns AstExpression:
	AstExpressionShift ({AstExpressionBinary.left=current} operator=('<' | '<=' | '>' | '>=') right=AstExpressionShift)*;
AstExpressionShift returns AstExpression:
	AstExpressionAdditive ({AstExpressionBinary.left=current} operator=('<<' | '>>') right=AstExpressionAdditive)*;
AstExpressionAdditive returns AstExpression:
	AstExpressionMultiplicative ({AstExpressionBinary.left=current} operator=('+' | '-') right=AstExpressionMultiplicative)*;
AstExpressionMultiplicative returns AstExpression:
	AstExpressionExp ({AstExpressionBinary.left=current} operator=('*' | '/' | 'div' | 'mod') right=AstExpressionExp)*;
AstExpressionExp returns AstExpression:
	AstExpressionUnary ({AstExpressionBinary.left=current} operator='**' right=AstExpressionUnary)*;

AstExpressionUnary returns AstExpression:
	{AstExpressionUnary} unaryOperator=('~' | '-' | 'not' | '#') expression=AstExpressionPostfix
	| AstExpressionPostfix;

AstExpressionPostfix returns AstExpression:
	AstExpressionList
	| AstExpressionCall
	| AstExpressionIndex
	| AstExpressionIf
    | AstExpressionLiteral
    | AstExpressionVariable
    | '(' AstExpression ')';

AstExpressionCall:
	function=[AstFunction] '(' (parameters += AstExpression (',' parameters += AstExpression)*)? ')';

AstExpressionIndex:
	source=AstVariableReference ('[' indexes += AstExpression ']')+;

AstExpressionIf:
	'if' condition=AstExpression
	'then' then=AstExpression
	'else' else=AstExpression
	'end';

AstExpressionList:
	'[' expressions+=AstExpression (',' expressions+=AstExpression)*
	(':' generators+=AstGenerator (',' generators+=AstGenerator)*)? ']';

AstGenerator:
	'for' variable=AstVariableDeclaration 'in' lower=AstExpression '..' higher=AstExpression;

AstExpressionVariable: value=AstVariableReference;

///////////////////////////////////////////////////////////////////////////////
// literal expressions
///////////////////////////////////////////////////////////////////////////////

AstExpressionLiteral:
	AstExpressionBoolean
	| AstExpressionFloat
	| AstExpressionInteger
	| AstExpressionString;

AstExpressionBoolean: value=BOOL;

terminal BOOL returns ecore::EBoolean: 'true' | 'false';

AstExpressionFloat: value=REAL;

terminal REAL returns ecore::EFloat :
	('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	'.' ('0'..'9')+ (('e'|'E') ('+' | '-')? ('0'..'9')+)?
|	('0'..'9')+ ('e'|'E') ('+' | '-')? ('0'..'9')+;

AstExpressionInteger: value=(DECIMAL | OCTAL | HEX);

terminal DECIMAL returns ecore::ELong : ('1'..'9') ('0'..'9')*;

terminal OCTAL returns ecore::ELong : '0' ('0'..'7')*;

terminal HEX returns ecore::ELong : '0' ('x'|'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+ ;

AstExpressionString: value=STRING;

///////////////////////////////////////////////////////////////////////////////
// common stuff
///////////////////////////////////////////////////////////////////////////////

AstType: AstTypeBool | AstTypeFloat | AstTypeInt | AstTypeList | AstTypeString | AstTypeUint;

AstTypeBool: name='bool';

AstTypeFloat: name='float';

AstTypeInt: name='int' ('(' 'size' '=' size = AstExpression ')')?;

AstTypeList: name='List' '(' 'type' ':' type = AstType ',' 'size' '=' size = AstExpression ')';

AstTypeString: name='String';

AstTypeUint: name='uint' ('(' 'size' '=' size = AstExpression ')')?;

AstVariableDeclaration returns AstVariable: type=AstType name=ID;

AstValuedVariableDeclaration returns AstVariable:
	AstVariableDeclaration ((constant ?= '=' | ':=') value=AstExpression)?;

AstVariableReference: variable=[AstVariable|QualifiedName];
