group Cpp_actorDecl;

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
declarePointer(value) ::= <<
$value : {*} $
>>

variableDeclaration(variable) ::= <<
$variable.type$$declarePointer(variable.type.dimensions)$ $variable$
>>

///////////////////////////////////////////////////////////////////////////////
// Non-const state variables
///////////////////////////////////////////////////////////////////////////////
nonConstStateVar(variable) ::= <<
$if(!variable.constantValue)$
$variableDeclaration(variable)$;$\n$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<
$assign.target$ = $assign.value$;

>>

Call(call) ::= <<
$if(call.target)$
$call.target$ = 
$endif$
$call.procedure$($call.parameters; separator=", "$);

>>

Decrement(decrement) ::= <<
$decrement.target$--;

>>

HasTokens(hasTokens) ::= <<
$hasTokens.target$ = hasTokens($instance.actor.name$_$hasTokens.port$, $hasTokens.numTokens$);

>>

Increment(increment) ::= <<
$increment.target$++;

>>

Load(load) ::= <<
$load.target$ = $load.source$$load.indexes : {[$it$]}$;

>>

Peek(peek) ::= <<
$peek.target$ = getPeekPtr($instance.actor.name$_$peek.port$, $peek.numTokens$);

>>

Read(read) ::= <<
$read.target$ = getReadPtr($instance.actor.name$_$read.port$, $read.numTokens$);

>>

ReadEnd(readEnd) ::= <<
setReadEnd($instance.actor.name$_$readEnd.port$);

>>

Return(return) ::= <<
$if(return.value)$
return $return.value$;

$endif$
>>

SelfAssignment(selfAssign) ::= <<
$selfAssign.target$ $selfAssign.op.text$= $selfAssign.value$;

>>

Store(store) ::= <<
$store.target$$store.indexes : {[$it$]}$ = $store.value$;

>>

Write(write) ::= <<
$write.target$ = getWritePtr($instance.actor.name$_$write.port$, $write.numTokens$);

>>

WriteEnd(writeEnd) ::= <<
setWriteEnd($instance.actor.name$_$writeEnd.port$);

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<
if ($ifNode.value$) {
	$nodes(ifNode.thenNodes)$}$if(ifNode.elseNodes)$ else {
	$nodes(ifNode.elseNodes)$}$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<
while ($whileNode.value$) {
	$nodes(whileNode.nodes)$}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

$procedure.returnType$ $procedure$($procedure.parameters.list: {$variableDeclaration(it)$}; wrap, anchor, separator=", "$);

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|hasRoom($instance.actor.name$_$port$, $pattern.(port)$)}; separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

scheduler(actions) ::= <<
int scheduler();
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

stateScheduler(transition) ::= <<
bool $transition.sourceState$_state_scheduler();

>>

schedulerFSM(actions, fsm) ::= <<
enum states 
{
	state_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {state_$it$}; separator=",\n"$
};

int _FSM_state;


$if(actions)$
bool outside_FSM_scheduler();

$endif$
$fsm.transitions: stateScheduler(transition=it); separator="\n"$
int scheduler();

>>


constructor(parameters) ::= <<
	actor_$instance.actor.name$($parameters: {int}; separator=", "$);
>>

parameters(parameters) ::= <<
$parameters.keys: { k | int $k$;}; separator="\n"$

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

instance(instance) ::= <<

#ifndef __ACTOR_$instance.actor.name$_H__
#define __ACTOR_$instance.actor.name$_H__

#include <iostream>

#include "actoraka.h"

////////////////////////////////////////////////////////////////////////////////
// Input FIFOs
enum
{
	$instance.actor.inputs.list: {$instance.actor.name$_$it.name$}; separator=",\n"$
};
////////////////////////////////////////////////////////////////////////////////
// Output FIFOs
enum
{
	$instance.actor.outputs.list: {$instance.actor.name$_$it.name$}; separator=",\n"$
};


class actor_$instance.actor.name$ : public ActorGen 
{

public:
$constructor(instance.parameters)$
	
	void initializeActor();

$! ////////////////////////////////////////////////////////////////////////////////
// State variables of the actor
	$instance.actor.stateVars.list: nonConstStateVar(it)$ !$

private:
////////////////////////////////////////////////////////////////////////////////
// Parameters
$parameters(instance.parameters)$
////////////////////////////////////////////////////////////////////////////////
// Non-const state variables of the actor
$instance.actor.stateVars.list: nonConstStateVar(it)$
////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
	$instance.actor.procs.list: procedure(it)$
////////////////////////////////////////////////////////////////////////////////
// Actions
	$instance.actor.actions: action(it)$

public:
	$if(instance.actor.initializes)$
////////////////////////////////////////////////////////////////////////////////
// Initializes
	$instance.actor.initializes: action(it)$
	void initialize();

$endif$
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
$if(instance.actor.actionScheduler.fsm)$
$schedulerFSM(actions=instance.actor.actionScheduler.actions, fsm=instance.actor.actionScheduler.fsm)$
$else$
$scheduler(actions=instance.actor.actionScheduler.actions)$
$endif$

};

#endif

>>
