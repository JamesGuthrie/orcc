group C_network;

declareBroadcast(bcast) ::= <<
int $bcast.id$_scheduler() {
	int i = 0;
	$bcast.type$ *tok_input;
	$bcast.outputList: { n | $bcast.type$ *tok_output_$n$;
}$
	while (hasTokens($bcast.id$_input, 1)
		$bcast.outputList:{ && hasRoom($bcast.id$_output_$i0$, 1)}$) {
		tok_input = getReadPtr($bcast.id$_input, 1);
		$bcast.outputList:
		  { n | tok_output_$n$ = getWritePtr($bcast.id$_output_$n$, 1);
*tok_output_$n$ = *tok_input;
}$	
		setReadEnd($bcast.id$_input);
		$bcast.outputList: { n | setWriteEnd($bcast.id$_output_$n$);}; separator="\n"$
		i++;
	}

	return i;
}

>>

declareBroadcasts(broadcasts) ::= <<
$broadcasts: declareBroadcast(it)$
>>

///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count) ::= <<
DECLARE_FIFO($type$, $size$, $count$)

>>

allocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
$if (source.broadcast)$
$allocateFifoType(
  type=targetPort.type, size=edge.size, count=network.connectionMap.(edge))$
$else$
$allocateFifoType(
  type=sourcePort.type, size=edge.size, count=network.connectionMap.(edge))$
$endif$
>>

tryAllocateFifo(edge, src, tgt) ::= <<
$if (src.instance)$
$if (tgt.instance)$
$allocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)$
$endif$
$endif$
>>

allocateFifos(edges) ::= <<
$edges: tryAllocateFifo(
  edge=it, src=network.sourceMap.(it), tgt=network.targetMap.(it))$
>>

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

assignFifo(source, sourcePort, target, targetPort, count) ::= <<
struct fifo_s *$source.id$_$sourcePort.name$ = &fifo_$count$;
struct fifo_s *$target.id$_$targetPort.name$ = &fifo_$count$;

>>

tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance)$
$if (tgt.instance)$
$assignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$
$endif$
$endif$
>>

assignFifos(edges) ::= <<
$edges: tryAssignFifo(
  edge=it, src=network.sourceMap.(it), tgt=network.targetMap.(it)) $
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler functions

initialize(instance) ::= <<
$if (instance.actor)$
$if (!instance.actor.initializes.empty)$
extern void $instance.id$_initialize();

$endif$
$endif$
>>

declareInitializes(instances) ::= <<
$instances: initialize()$
>>

declareSchedulers(instances) ::= <<
$instances: {extern int $it.id$_scheduler();}; separator="\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
$if (instance.actor)$
$if (!instance.actor.initializes.empty)$
$instance.id$_initialize();

$endif$
$endif$
>>

printInitializes(instances) ::= <<
$instances: printInitialize()$
>>

printSchedulers(instances) ::= <<
$instances: {i = $it.id$_scheduler();
#ifdef PRINT_FIRINGS
printf("$it.id$_scheduler: %i\n", i);
#endif}; separator="\n"$

#ifdef PRINT_FIRINGS
printf("\n");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network) ::= <<
// Generated from "$network.name$"

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>

#include "fifo.h"
#include "orcc_util.h"

#define SIZE $fifoSize$
// #define PRINT_FIRINGS

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
$allocateFifos(network.connections)$
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
$assignFifos(network.connections)$

////////////////////////////////////////////////////////////////////////////////
$declareBroadcasts(network.broadcasts)$

////////////////////////////////////////////////////////////////////////////////
// Action schedulers
$declareInitializes(network.instances)$
$declareSchedulers(network.instances)$

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

static void scheduler() {
	int i;

	$printInitializes(network.instances)$
	while (1) {
		$printSchedulers(network.instances)$
	}
}

////////////////////////////////////////////////////////////////////////////////
int main(int argc, char *argv[], char *env[]) {
	init_orcc(argc, argv, env);

	scheduler();

	printf("End of simulation! Press a key to continue\n");
	pause();

	return 0;
}

>>

