BroadcastWrite(n) ::= <<
tok_output_$n$ = getWritePtr($instance.id$_output_$n$, 1);
*tok_output_$n$ = *tok_input;
>>

BroadcastWriteEnd(n) ::= <<
setWriteEnd($instance.id$_output_$n$, 1);
>>

outputPatternPort(num) ::= <<
if (!hasRoom($instance.id$_output_$num$, 1)) {
	ports |= (1 << $num$);
}
>>

outputPattern(outputs) ::= <<
int ports = 0;
$outputs: outputPatternPort(); separator="\n"$
if (ports != 0) {
>>

declareBroadcast(instance) ::= <<
$if (instance.broadcast)
$
void $instance.id$_scheduler(struct schedinfo_s *si) {
	int i = 0;
	$instance.broadcast.type$ *tok_input;
	$instance.broadcast.outputList: { n | $instance.broadcast.type$ *tok_output_$n$;
}$
	while (hasTokens($instance.id$_input, 1)) {
		$outputPattern(instance.broadcast.outputList)$
			si->num_firings = i;
			si->reason = full;
			si->ports = ports;
			return;
		}

		tok_input = getReadPtr($instance.id$_input, 1);
		$instance.broadcast.outputList: BroadcastWrite(); separator="\n"$
		setReadEnd($instance.id$_input, 1);
		$instance.broadcast.outputList: BroadcastWriteEnd(); separator="\n"$
		i++;
	}

	si->reason = starved;
	si->num_firings = i;
	si->ports = 0x01;
}$
endif$

>>

declareBroadcasts(instances) ::= <<
$instances: declareBroadcast()$
>>

///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count) ::= <<
DECLARE_FIFO($type$, $size$, $count$)
>>

doAllocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
$if (source.broadcast)$
$allocateFifoType(
  type=targetPort.type, size=edge.size, count=network.connectionMap.(edge))$$else$
$allocateFifoType(
  type=sourcePort.type, size=edge.size, count=network.connectionMap.(edge))$$endif$
>>

tryAllocateFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAllocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)$$endif$
>>

allocateFifo(edge) ::= <<
$tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

allocateFifos(edges) ::= <<
$edges: allocateFifo()$
>>

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
struct fifo_s *$source.id$_$sourcePort.name$ = &fifo_$count$;
struct fifo_s *$target.id$_$targetPort.name$ = &fifo_$count$;
>>

tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance && tgt.instance)$
$doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$$endif$
>>

assignFifo(edge) ::= <<
$tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))$
>>

assignFifos(edges) ::= <<
$edges: assignFifo()$
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler functions

initialize(instance) ::= <<
$if (instance.actor && !instance.actor.initializes.empty)$
extern void $instance.id$_initialize();
$endif$
>>

declareInitializes(instances) ::= <<
$instances: initialize()$
>>

declareSchedulers(instances) ::= <<
$instances: {extern void $it.id$_scheduler(struct schedinfo_s *si);}; separator="\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
$if (instance.actor && !instance.actor.initializes.empty)$
$instance.id$_initialize();
$endif$
>>

printInitializes(instances) ::= <<
$instances: printInitialize()$
>>

printSchedulerInstance(instance) ::= <<
si.num_firings = 0;
$instance.id$_scheduler(&si);
#ifdef PRINT_FIRINGS
printf("$instance.id$_scheduler: %i\n", si.num_firings);
#endif
>>

printSchedulers(instances) ::= <<
$instances: printSchedulerInstance(); separator="\n"$

#ifdef PRINT_FIRINGS
printf("\n");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network) ::= <<
// Generated from "$network.name$"

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef __APPLE__
#include "SDL.h"
#endif

#include "fifo.h"
#include "orcc_util.h"

#define SIZE $fifoSize$
// #define PRINT_FIRINGS

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
$allocateFifos(network.connections)$
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
$assignFifos(network.connections)$

////////////////////////////////////////////////////////////////////////////////
$declareBroadcasts(network.instances)$

////////////////////////////////////////////////////////////////////////////////
// Action schedulers
$declareInitializes(network.instances)$
$declareSchedulers(network.instances)$

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

static void scheduler() {
	struct schedinfo_s si;

	$printInitializes(network.instances)$
	while (1) {
		$printSchedulers(network.instances)$
	}
}

////////////////////////////////////////////////////////////////////////////////
int main(int argc, char *argv[]) {
	init_orcc(argc, argv);

	scheduler();

	printf("End of simulation! Press a key to continue\n");
	wait_for_key();

	return 0;
}

>>

