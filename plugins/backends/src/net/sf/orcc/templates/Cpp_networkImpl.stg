group Cpp_networkImpl;

///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count, lock) ::= <<
FifoAPI * fifo_$count$ = FifoFactory<$type$>::allocateFifo($size$, $lock$);

>>

allocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
$if (source.wrapper)$
$allocateFifoType(type=targetPort.type, size=edge.size, count=network.connectionMap.(edge), lock=1)$
$else$
$if(target.wrapper)$
$allocateFifoType(type=targetPort.type, size=edge.size, count=network.connectionMap.(edge), lock=1)$
$else$
$allocateFifoType(type=sourcePort.type, size=edge.size, count=network.connectionMap.(edge), lock=0)$
$endif$
$endif$
>>

tryAllocateFifo(edge, src, tgt) ::= <<
$if (src.instance)$
$if (tgt.instance)$
$allocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)$
$endif$
$endif$
>>

allocateFifos(edges) ::= <<
$edges: tryAllocateFifo(
  edge=it, src=network.sourceMap.(it), tgt=network.targetMap.(it))$
>>

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs
assignLockedFifo(target, targetPort, count, dir) ::= <<
$target.id$.connect($dir$, $target.actor.name$_$targetPort.name$, lockedFifo_$count$);

>>

assignFifo(source, sourcePort, target, targetPort, count) ::= <<
$source.id$.connect(ACTOR_PORT_OUT, $source.actor.name$_$sourcePort.name$, fifo_$count$);
$target.id$.connect(ACTOR_PORT_IN, $target.actor.name$_$targetPort.name$, fifo_$count$);

>>

tryAssignFifo(edge, src, tgt) ::= <<
$if(!src.instance)$
$assignLockedFifo(
  target=tgt.instance, targetPort=edge.target,
  count=multicoreConnection.(edge), dir="ACTOR_PORT_IN")$
$else$
$if(!tgt.instance)$
$assignLockedFifo(
  target=src.instance, targetPort=edge.source,
  count=multicoreConnection.(edge), dir="ACTOR_PORT_OUT")$
$else$
$assignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$
$endif$
$endif$

>>

assignFifos(edges) ::= <<
$edges: tryAssignFifo(
  edge=it, src=network.sourceMap.(it), tgt=network.targetMap.(it))$
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()
printInitialize(instance) ::= <<
$if (instance.actor)$
$if (!instance.actor.initializes.empty)$
$instance.id$.initialize();

$endif$
$endif$
>>

printInitializes(instances) ::= <<
$instances: printInitialize()$
>>

printScheduler(instance) ::= <<
$if (!instance.wrapper)$
res += $instance.id$.scheduler();
$endif$
>>

printSchedulers(instances) ::= <<
$instances: printScheduler(it); separator="\n"$
>>


declareExternalFifos(multicoreConnection) ::= <<
$connectionMap: {extern FifoAPI * lockedFifo_$it$;}; separator="\n"$

>>

initializerList(id, instance) ::= <<
$id$($instance.actor.parameters.list:{$instance.parameters.(it)$}; separator=", "$)
>>


initializerLists(instances) ::= <<
$instances: initializerList(id=it.id, instance=it); separator=",\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network, connectionMap, multicoreConnection) ::= <<
/**
 * Generated from "$network.name$"
 */
 
#include "Network_$network.name$.h"

#define SIZE 10000

extern "C" {
#include "orcc_util.h"
}

$declareExternalFifos(connectionMap)$


////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
namespace
{
   $allocateFifos(network.connections)$
}



////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
network_$network.name$::network_$network.name$()
:
$initializerLists(network.instances)$
{
	$assignFifos(network.connections)$
}

network_$network.name$::~network_$network.name$(){}

void network_$network.name$::start()
{
	$network.instances: {$it.id$.initializeActor();}; separator="\n"$
	
	$network.instances: {$it.id$.startActorExecution();}; separator="\n"$
	
	Threadaka::init();
	Threadaka::start();
}

void network_$network.name$::stop()
{
	Threadaka::stop();
	
	$network.instances: {$it.id$.stop();}; separator="\n"$
}

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

void network_$network.name$::schedule() 
{
	$printInitializes(network.instances)$
	while (1) 
	{
		int res = 0;
		$printSchedulers(network.instances)$
		if(res == 0)
			Sleep(0);
	}
}

void network_$network.name$::process(void * args)
{
	schedule();
}

>>

