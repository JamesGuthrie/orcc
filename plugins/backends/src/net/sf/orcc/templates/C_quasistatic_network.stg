group C_quasistatic_network;

broadcast_scheduler(bcast) ::= <<
int $bcast.id$_scheduler() {
	$bcast.type$ *tok_input;
	$bcast.num: { n | $bcast.type$ *tok_output_$n$;
}$
	while (hasTokens($bcast.id$_input, 1)
		$bcast.num:{ && hasRoom($bcast.id$_output_$i0$, 1)}$) {
		tok_input = getReadPtr($bcast.id$_input, 1);
		$bcast.num: { n | tok_output_$n$ = getWritePtr($bcast.id$_output_$n$, 1);
}$
		$bcast.num: { n | *tok_output_$n$ = *tok_input;
}$	
	$if( !bcast.isAddActor )$
		return *tok_input;
	$endif$
	}
  
	return 0;
}

>>

broadcast(bcast) ::= <<
$if( bcast.isAddActor )$
void $bcast.id$() {
	$bcast.type$ *tok_input;
	$bcast.num: { n | $bcast.type$ *tok_output_$n$;
}$
	
	tok_input = getReadPtr($bcast.id$_input, 1);
	$bcast.num: { n | tok_output_$n$ = getWritePtr($bcast.id$_output_$n$, 1);
}$
	$bcast.num: { n | *tok_output_$n$ = *tok_input;
}$	
}
$endif$
>>

broadcast_do(bcast) ::= <<
$if( bcast.isAddActor )$
void $bcast.id$_do() {
	hasTokens($bcast.id$_input, 1);
	$bcast.num: { n | hasRoom($bcast.id$_output_$n$, 1);
}$
	$bcast.id$();
}
$endif$
>>

struct_fifo(fifo) ::= <<
static $fifo.type$ array_$fifo.count$[$fifo.size$ * sizeof($fifo.type$)];
static struct fifo_s fifo_$fifo.count$ = { sizeof($fifo.type$), $fifo.size$, (char *)array_$fifo.count$, 0, 0 };

>>

ptr_fifo(fifo) ::= <<
struct fifo_s *$fifo.source$_$fifo.src_port$ = &fifo_$fifo.count$;
struct fifo_s *$fifo.target$_$fifo.tgt_port$ = &fifo_$fifo.count$;

>>

pause() ::= <<
void pause() {
#ifndef _WIN32
  struct termios oldT, newT;
  char c;
#endif
  printf("Press a key to continue\n");

#ifdef _WIN32
  _getch();
#else
  ioctl(0, TCGETS, &oldT);
  newT.c_lflag &= ~ICANON; // one char @ a time
  ioctl(0, TCSETS, &newT); // set new terminal mode
  read(0, &c, 1); // read 1 char @ a time from stdin
  ioctl(0, TCSETS, &oldT); // restore previous terminal mode
#endif
}
>>

qs_scheduler(stmts) ::= <<

////////////////////////////////////////////////////////////////////////////////
// Actor quasi-static scheduler
static void qs_scheduler() {

$stmts: { stmt| 	$stmt$
}$

}
>>

network(debugFifos, name, size, broadcasts, initializes, instances, connections,qs_scheduler_stmts) ::= <<
// Generated from "$name$"

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef _WIN32
  #include <conio.h>
#else
  #include <termio.h>
#endif

#include "fifo.h"
#include "orcc_util.h"

#define SIZE $size$

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
$connections:struct_fifo()$
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
$connections:ptr_fifo()$

////////////////////////////////////////////////////////////////////////////////
$broadcasts:broadcast_scheduler()$
$broadcasts:broadcast()$
$broadcasts:broadcast_do()$
////////////////////////////////////////////////////////////////////////////////
// Action schedulers
$initializes: { init | extern void $init$_initialize(); 
}$
$instances: { inst | extern int $inst$_scheduler();
}$
////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

static void scheduler() {
	$initializes: { init | $init$_initialize();
}$	while (1) {
		$instances: { inst | $inst$_scheduler();
}$
		$broadcasts: { bcast | $bcast.id$_scheduler();
}$	}
}

$qs_scheduler(stmts=qs_scheduler_stmts)$

////////////////////////////////////////////////////////////////////////////////

$pause()$

extern void source_set_file_name(const char *file_name);

int main(int argc, char *argv[], char *env[]) {
	init_orcc(argc, argv, env);

	qs_scheduler();

	printf("End of simulation! Press a key to continue\n");
	pause();

	return 0;
}

>>

