///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
@$port.name$ = common global %struct.fifo_s* null

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////
Var(var) ::= <<
$if(var.variable.global)$@$else$%$endif$$var$
>>

Expr(expr) ::= <<
$if(expr.varExpr)$$Var(expr.var)$$else$$expr$$endif$
>>

ExprType(expr) ::= <<
$expr.type$
>>

VarType(var) ::= <<
$var.variable.type$
>>

ListType(list) ::= <<
$list.variable.type.elementType$
>>

variableDeclaration(variable) ::= <<
$if(variable.port)
$$AllocaOp(result={%$variable$}, type={$variable.type.elementType$*})$$
else
$$if(variable.list)
$$AllocaOp(result={%$variable$}, type=variable.type)$$
endif$$
endif$
>>

indexes(indexes) ::= <<
$indexes: { index | $if(index.type)$$index.type$$else$i32$endif$ $Expr(index)$ }; separator=", "$
>>

indexesName(indexes) ::= <<
$indexes: {index |$index$}; separator="_"$
>>

parametersDeclaration(arguments, parameters, casts, location) ::= <<
$arguments, parameters, casts: { arg, param, cast | $parameters(type = arg.type, variable= param, cast =cast, location=location)$}; separator=", "$
>>

parameters(type, variable, cast, location) ::= <<
$if(variable.intExpr)$$type$ $elseif(type.list)$$type$* $elseif(variable.booleanExpr)$i1 $else$$variable.type$ $endif$$if(cast)$%$variable$$location$_cast$else$$Expr(variable)$$endif$
>>

argumentDeclaration(variable) ::= <<
$if(variable.type.list)
$$variable.type$* %$variable$$
else
$$variable.type$ %$variable$$
endif$
>>

Location(location) ::= <<
$location.startLine$$location.startColumn$$location.endColumn$
>>

ConstantValue(type, const) ::= <<
$if(type.list)$$
listValue(type=type.type, values=const.value, iterator = type.sizeIterator)$
$else
$$const$
$endif$

>>


///////////////////////////////////////////////////////////////////////////////
// List
///////////////////////////////////////////////////////////////////////////////

// the values of a list: {val1, val2, ..., valn}
listValue(type, values, iterator) ::= <<
$if(first(values).listConst)$
[$iterator, values :{ iterator, value | $type$ $if(value)$ $listValue(type=type.type, values=value.value, iterator= type.sizeIterator)$ $else$ zeroinitializer $endif$}; separator=", "$]
$else$
[$values:{$type$ $it$}; separator=", "$]
$endif$

>>


// phi definition
phiPair(value, label) ::= <<
[$value$, %$label$]
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
$if(variable.constantValue)
$@$variable$ = internal global $variable.type$ $ConstantValue(type=variable.type, const=variable.constantValue)$$
else$
@$variable$ = internal global $variable.type$ zeroinitializer$
endif$
>>


///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
LoadOp(ty, pointer, alignment) ::= <<
load $ty$* $pointer$ $if(alignment)$ [, align <alignment>] $endif$
>>

AndOp(result, ty, op1, op2) ::= <<
$result$ = and $ty$ $op1$, $op2$
>>

IcmpOp(result, cond, ty, op1, op2) ::= <<
$result$ = icmp $cond$ $ty$ $op1$, $op2$
>>
 
GetElementPtrOp(pty, ptrval, idx0, idx) ::= <<
getelementptr $pty$* $ptrval$$if(idx0)$, i32 $idx0$$endif$ $if(idx)$, $indexes(idx)$$endif$
>>

BitcastOp(result, ty, value, ty2) ::= <<
$result$ = bitcast $ty$ $value$ to $ty2$
>>

AllocaOp(result, type, NumElements, alignment) ::= <<
$result$ = alloca $type$ $if(NumElements)
$[, i32 <NumElements>]$
endif$$
if(alignment)$
[, align <alignment>]$
endif$
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
$if(cond)
$br i1 $cond$, label $iftrue$, label $iffalse$$
else
$br label $dest$$
endif$
>>

RetOp(type, value) ::= <<
$if(value)
$ret $type$ $value$$
else
$ret void$
endif$
>>

CallOp(tail, cconv, ret_attrs, ty, fnty, fnptrval, function_args, fn_attrs) ::= <<
$if(tail)$ [tail] $endif$call$
if(cconv)$ [cconv] $endif
$$if(ret_attrs)$ [ret_attrs] $
endif$ $ty$$
if(fnty)$ [<fnty>*] $endif
$ @$fnptrval$ ($if(function_args)$$function_args$$endif$) $
if(fn_attrs)$ [fn_attrs] $endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

StoreInstr(ty, value, pty, ptr, cast) ::= <<
$if(value.intExpr || value.booleanExpr)
$store $pty$ $value$$cast$, $pty$* $ptr$$
else
$store $ty$ $Expr(value)$$cast$, $pty$* $ptr$$
endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

CastAssign(target, value, cast)::= <<
$if(cast.extended)$
%$target$_ext = $value$
$if(cast.signed)
$%$target$ = sext $value.type$ %$target$_ext to $target.type$$
else
$%$target$ = zext $value.type$ %$target$_ext to $target.type$$
endif$
$else$
%$target$_trunc = $value$
%$target$ = trunc $value.type$ %$target$_trunc to $target.type$
$endif$

>>

CastParameter(casts, args, params, location )::= <<
$casts, args, params: { cast, arg, param | $if(cast)$ 
$BitcastOp(result={%$param$$location$_cast}, ty={$param.type$*}, value=Expr(param), ty2={$arg.type$*})$
$endif$}$
>>

CastCall(result, ty, fnptrval, function_args, cast)::= <<
$if(cast.extended)$
%$result$_ext = $CallOp(ty=ty, fnptrval=fnptrval, function_args=function_args)$
$if(cast.signed)
$%$result$ = sext $ty$ %$result$_ext to $result.type$$
else
$%$result$ = zext $ty$ %$result$_ext to $result.type$$
endif$
$else$
%$result$_trunc = $CallOp(ty=ty, fnptrval=fnptrval, function_args=function_args)$
%$result$ = trunc $ty$ %$result$_trunc to $result.type$
$endif$

>>


CastStore(ty, value, pty, ptr, cast, location)::= <<
$if(cast.extended)$
$if(cast.signed)
$%$value$_$location$_ext = sext $ty$ $Expr(value)$ to $pty$$
else
$%$value$_$location$_ext = zext $ty$ $Expr(value)$ to $pty$$
endif$
$StoreInstr(ty=pty, value=value, pty=pty, ptr=ptr, cast={_$location$_ext})$
$else$
%$value$_$location$_trunc = trunc $ty$ $Expr(value)$ to $pty$
$StoreInstr(ty=pty, value=value, pty=pty, ptr=ptr, cast={_$location$_trunc})$$
endif$

>>

StoreWithIndex(ty, value, pty, pointer, cast, indexes, location) ::= <<
%$pointer$_$location$_L$indexesName(indexes)$ptr = $GetElementPtrOp(idx0="0", pty=pty, ptrval=Var(pointer), idx=indexes)$ 
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty.elementType, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr}, cast=cast, location=location)$ 
$else$
$StoreInstr(ty=ty, value=value, pty=pty.elementType, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr})$
$endif$
>>

StoreWithoutIndex(ty, value, pty, pointer, cast, location) ::= <<
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty, ptr=Var(pointer), cast=cast, location=location)$ 
$else$
$StoreInstr(ty=ty, value=value, pty=pty, ptr=Var(pointer))$
$endif$
>>

StorePortWithIndex(ty, value, pty, pointer, cast, indexes, location) ::= <<
%$pointer$_$location$_Loadport$indexesName(indexes)$ = $LoadOp(ty={$pty$*}, pointer=Var(pointer))$
%$pointer$_$location$_L$indexesName(indexes)$ptr = $GetElementPtrOp(pty=pty, ptrval={%$pointer$_$location$_Loadport$indexesName(indexes)$}, idx=indexes)$
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr}, cast=cast, location=location)$
$else$
$StoreInstr(ty=ty, value=value, pty=pty, ptr={%$pointer$_$location$_L$indexesName(indexes)$ptr})$
$endif$
>>

CastLoad(result, ty, ptr, cast)::= <<
$if(cast.extended)$
%$result$_ext = load $ty$* $ptr$
$if(cast.signed)
$%$result$ = sext $ty$ %$result$_ext to $result.type$$
else
$%$result$ = zext $ty$ %$result$_ext to $result.type$$
endif
$$else
$%$result$_trunc = load $ty$* $ptr$
%$result$ = trunc $ty$ %$result$_trunc to $result.type$$
endif$
>>

LoadPortWithIndex(result, pty, pointer, indexes, cast) ::= <<
%$result$_L = load $pty$** $Var(pointer)$
%$result$_$pointer$$indexesName(indexes)$_ptr = $GetElementPtrOp(pty=pty, ptrval={%$result$_L}, idx=indexes)$
$if(cast)$
$CastLoad(result=result, ty=pty, ptr={%$result$_$pointer$$indexesName(indexes)$_ptr}, cast = cast)$
$else$
%$result$ = load $pty$* %$result$_$pointer$$indexesName(indexes)$_ptr
$endif$
>>

LoadWithIndex(result, ty, pointer, indexes, cast) ::= <<
$result$_$pointer$L$indexesName(indexes)$_ptr = $GetElementPtrOp(idx0="0",  pty=ty, ptrval=Var(pointer), idx=indexes)$
$if(cast)$
$CastLoad(result=result, ty=ty.elementType, ptr={$result$_$pointer$L$indexesName(indexes)$_ptr}, cast=cast)$
$else$
$result$ = load $ty.elementType$* $result$_$pointer$L$indexesName(indexes)$_ptr
$endif$
>>

LoadWithoutIndex(result, ty, pointer, cast) ::= <<
$if(cast)$
$CastLoad(result=result, ty=ty, ptr=Var(pointer), cast=cast)$ 
$else$
$result$ = $LoadOp(ty=ty, pointer=Var(pointer))$
$endif$
>>

IfWithThenElseNodes(ifNode) ::= <<
	$BrOp(cond=Expr(ifNode.value), iftrue={%b$label(ifNode.thenNodes)$}, iffalse={%b$label(ifNode.elseNodes)$})$

b$label(ifNode.thenNodes)$: 
$Nodes_cond(first(ifNode.thenNodes))$ $Nodes(rest(ifNode.thenNodes))$
	br label %b$label(ifNode.joinNode)$

b$label(ifNode.elseNodes)$:
$Nodes_cond(first(ifNode.elseNodes))$ $Nodes(rest(ifNode.elseNodes))$
	br label %b$label(ifNode.joinNode)$

b$label(ifNode.joinNode)$:

>>

IfWithThenNode(ifNode) ::= <<
	$BrOp(cond=Expr(ifNode.value), iftrue={%b$label(ifNode.thenNodes)$}, iffalse={%b$label(ifNode.joinNode)$})$

b$label(ifNode.thenNodes)$: 
$Nodes_cond(first(ifNode.thenNodes))$ $Nodes(rest(ifNode.thenNodes))$
	br label %b$label(ifNode.joinNode)$

b$label(ifNode.joinNode)$:

>>

LoadLocalPort(instr) ::= <<
%local_$instr.port$$instr.block.label$ = $LoadOp(ty="%struct.fifo_s*", pointer={@$instr.port$})$
>>

HasRoom(result, action, port, numToken) ::= <<

%$port$_$action$ = $LoadOp(ty="%struct.fifo_s*", pointer={@$port$})$
%$result$32 = $CallOp(ty="i32", fnptrval="hasRoom", function_args={%struct.fifo_s* %$port$_$action$, i32 $numToken$})$
%$result$ = trunc i32 %$result$32 to i1
>>

label(nodes) ::= "b$first(nodes):{ x | $x.label$}$"

phiPairs(phi) ::= <<
$phiVars(vars=first(phi.vars), node = first(phi.block.predecessors))$, $phiVars(vars=first(rest(phi.vars)), node = rest(phi.block.predecessors))$
>>

phiVars(vars, node) ::= <<
[$if(vars.variable.assigned)$ %$vars$ $else$ 0 $endif$, %b$label(node)$ ]
>>


///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////


Call(call) ::= <<

$CastParameter(casts=call.paramCast, args=call.procedure.parameters.list, params=call.parameters, location=Location(call.location))$
$if(call.target)$$
if(call.cast)
$$CastCall(result=call.target,
ty=call.procedure.returnType,
fnptrval=call.procedure,
function_args=parametersDeclaration(arguments=call.procedure.parameters.list, parameters=call.parameters, casts=call.paramCast, location=Location(call.location)),
cast=call.cast)$$
else
$%$call.target$ = $CallOp(ty=call.procedure.returnType,
fnptrval=call.procedure,
function_args=parametersDeclaration(arguments=call.procedure.parameters.list, parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))$$
endif
$$else
$$CallOp(ty=call.procedure.returnType, fnptrval=call.procedure, function_args=parametersDeclaration(arguments=call.procedure.parameters.list ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))$$
endif$
>>

Assign(assign) ::= <<

$if(assign.cast)
$$CastAssign(target = assign.target, value = assign.value, cast = assign.cast)$$
else
$%$assign.target$ = $assign.value$$
endif$
>>

PhiAssignment(phi) ::= <<

%$phi.target$ = phi $phi.target.type$ $phiPairs(phi)$
>>

Read(read) ::= <<

$LoadLocalPort(read)$
%$read.target$_$read.block.label$ = $CallOp(ty ="i8*", fnptrval="getReadPtr", function_args={%struct.fifo_s* %local_$read.target$$read.block.label$, i32 $read.numTokens$})$
$BitcastOp(result={%$read.target$_$read.block.label$_cast}, ty="i8*", value={%$read.target$_$read.block.label$}, ty2={$ExprType(read.port)$*})$
store $ExprType(read.port)$* %$read.target$_$read.block.label$_cast, $ExprType(read.port)$** %$read.port$
>>

ReadEnd(readEnd) ::= <<

%end_$readEnd.port$ = $LoadOp(ty="%struct.fifo_s*", pointer={@$readEnd.port$})$
$CallOp(ty ="void", fnptrval="setReadEnd", function_args={%struct.fifo_s* %end_$readEnd.port$})$
>>

Peek(peek) ::= <<

$LoadLocalPort(peek)$
%$peek.target$_$peek.block.label$ = $CallOp(ty ="i8*", fnptrval="getPeekPtr", function_args={%struct.fifo_s* %local_$peek.target$$peek.block.label$, i32 $peek.numTokens$})$
$BitcastOp(result={%$peek.target$_$peek.block.label$_cast}, ty="i8*", value={%$peek.target$_$peek.block.label$}, ty2={$ExprType(peek.port)$*})$
store $ExprType(peek.port)$* %$peek.target$_$peek.block.label$_cast, $ExprType(peek.port)$** %$peek.port$
>>

Write(write) ::= <<

$LoadLocalPort(write)$
%$write.target$_$write.block.label$ = $CallOp(ty ="i8*", fnptrval="getWritePtr", function_args={%struct.fifo_s* %local_$write.target$$write.block.label$, i32 $write.numTokens$})$
$BitcastOp(result={%$write.target$_$write.block.label$_cast}, ty="i8*", value={%$write.target$_$write.block.label$}, ty2={$ExprType(write.port)$*})$
store $ExprType(write.port)$* %$write.target$_$write.block.label$_cast, $ExprType(write.port)$** %$write.port$
>>

WriteEnd(writeEnd) ::= <<

%end_$writeEnd.port$ = $LoadOp(ty="%struct.fifo_s*", pointer={@$writeEnd.port$})$
$CallOp(ty ="void", fnptrval="setWriteEnd", function_args={%struct.fifo_s* %end_$writeEnd.port$})$
>>

Return(return) ::= <<

$if(return.value)$$
RetOp(type=return.value.type, value=Expr(return.value))$$
else
$$RetOp()$$
endif$
>>

HasTokens(hasTokens) ::= <<

$LoadLocalPort(hasTokens)$
%$hasTokens.target$32 = $CallOp(ty="i32", fnptrval="hasTokens", function_args={%struct.fifo_s* %local_$hasTokens.port$$hasTokens.block.label$, i32 $hasTokens.numTokens$})$
%$hasTokens.target$ = trunc i32 %$hasTokens.target$32 to i1
>>

Store(store) ::= <<

$if(store.target.variable.port)$
$if(!store.indexes.empty)
$$StorePortWithIndex(ty=store.value.type, value=store.value, pty=store.target.variable.type.elementType, pointer=store.target, cast=store.cast, indexes=store.indexes, location=Location(store.location))$$
endif$$
else
$$if(store.indexes.empty)
$$StoreWithoutIndex(ty=store.value.type, value=store.value, pty=VarType(store.target), pointer=store.target, cast=store.cast, location=Location(store.location))$$
else
$$StoreWithIndex(ty=store.value.type, value=store.value, pty=store.target.variable.type, pointer=store.target, cast=store.cast, indexes=store.indexes, location=Location(store.location))$$
endif$$
endif$
>>

Load(load) ::= <<

$if (load.source.variable.port)$$
if (!load.indexes.empty)
$$LoadPortWithIndex(result=load.target, pty=load.source.variable.type.elementType, indexes=load.indexes, pointer=load.source, cast= load.cast)$$
endif$$
else$$
if(load.indexes.empty)
$$LoadWithoutIndex(result={%$load.target$}, ty=VarType(load.source), pointer=load.source, cast= load.cast)$$
else
$$LoadWithIndex(result={%$load.target$}, ty=load.source.variable.type, pointer=load.source, indexes=load.indexes, cast= load.cast)$$
endif$$
endif$
>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

// if node
IfNode(ifNode) ::= <<
$if(ifNode.thenNodes)$
$if(ifNode.elseNodes)$
$IfWithThenElseNodes(ifNode)$
$else$
$IfWithThenNode(ifNode)$	
	$endif$
$else$
	$if(ifNode.elseNodes)$
3
$endif$
$endif$
$Nodes_cond(first(ifNode.joinNode))$
$Nodes(rest(ifNode.joinNode))$

>>

// while node
WhileNode(whileNode) ::= <<
$BlockNode(whileNode.joinNode)$
	$BrOp(cond=Expr(whileNode.value), iftrue={%b$label(whileNode.Nodes)$}, iffalse={%b$label(whileNode.joinNode.successors)$})$

b$label(whileNode.nodes)$:
$Nodes_cond(first(whileNode.nodes))$
$Nodes(rest(whileNode.nodes))$
	br label %b$label(whileNode.joinNode)$

b$label(whileNode.joinNode.successors)$:

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

Instruction(instruction) ::= <<
$(instruction.class.simpleName)(instruction)$
>>

Instructions(instructions) ::= <<
$instructions: Instruction()$
>>

Node(node) ::= <<
$(node.class.simpleName)(node)$
>>

Nodes(nodes) ::= <<
$nodes: Node()$
>>

Node_cond(node) ::= <<
$({$node.class.simpleName$_cond})(node)$
>>

Nodes_cond(nodes) ::= <<
$nodes: Node_cond()$
>>

WhileNode_cond(nodes) ::= <<
$WhileNode(nodes)$
>>

IfNode_cond(nodes) ::= <<
$IfNode(nodes)$
>>

BlockNode_cond(blockNode) ::= <<
	$Instructions(blockNode.instructions)$
>>

// if node
BlockNode(blockNode) ::= <<
	br label %b$label(blockNode)$

b$label(blockNode)$:
	$Instructions(blockNode.instructions)$
>>
