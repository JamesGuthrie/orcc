group VHDL_testbench;

fifo_in(port) ::= <<
$if(port.type.bool)$
signal $actorName$_$port.name$_data  : std_logic;$\n$
$else$
signal $actorName$_$port.name$_data  : std_logic_vector($port.type.size$ -1 downto 0);$\n$
$endif$
signal $actorName$_$port.name$_empty : std_logic;
signal $actorName$_$port.name$_read  : std_logic;

>>


fifo_out(port) ::= <<
signal $actorName$_$port.name$_full  : std_logic;
$if(last(port.name))$
$if(port.type.bool)$
signal $actorName$_$port.name$_data  : std_logic;$\n$
$else$
signal $actorName$_$port.name$_data  : std_logic_vector($port.type.size$ -1 downto 0);$\n$
$endif$signal $actorName$_$port.name$_write : std_logic;
$else$
signal $actorName$_$port.name$_data  : $port.type$;
signal $actorName$_$port.name$_write : std_logic;
$endif$

>>


fifo_in_init(port) ::=<<
$actorName$_$port.name$_empty <= '1';$"\n"$
>>
fifo_out_init(port) ::=<<
$actorName$_$port.name$_full <= '0';$"\n"$
>>

fifo_map_in(port) ::= <<
$actorName$_$port.name$_data  => $actorName$_$port.name$_data,
$actorName$_$port.name$_empty => $actorName$_$port.name$_empty,
$actorName$_$port.name$_read  => $actorName$_$port.name$_read
>>

fifo_map_out(port) ::= <<
$actorName$_$port.name$_data  => $actorName$_$port.name$_data,
$actorName$_$port.name$_full  => $actorName$_$port.name$_full,
$actorName$_$port.name$_write => $actorName$_$port.name$_write
>>
///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

sig_const() ::= <<
constant clk_period      : time := 10 ns;
type severity_level is (note, warning, error, failure);
type tb_type is (after_reset, read_file, CheckRead);
$actor.inputs.list: signal_in(it)$--
$actor.outputs.list: signal_out(it)$--
$actor.inputs.list: fifo_in(it)$--
$actor.outputs.list: fifo_out(it)$
signal count             : integer range 255 downto 0;
signal clock             : std_logic := '0';
signal reset_n           : std_logic;

>>

signal_in(port) ::= <<
--
signal tb_FSM_$actorName$_$port.name$  : tb_type;
file sim_file_$actorName$_$port.name$  : text is "$actorName$_$port.name$_sim.txt";

>>

signal_out(port) ::= <<
--
file sim_file_$actorName$_$port.name$  : text is "$actorName$_$port.name$_sim.txt";

>>

///////////////////////////////////////////////////////////////////////////////
// Process
///////////////////////////////////////////////////////////////////////////////
init_process() ::= <<
  -- clock generation
  clock <= not clock after clk_period/2;

  -- reset generation
  process
  begin
    reset_n <= '0';
    wait for 10*clk_period;
    reset_n <= '1';
    wait;
  end process;

>>

tb_FSM_init(port) ::= <<
  tb_FSM_$actorName$_$port.name$ <= after_reset;

>>
    


waveform_process_in() ::= <<
-- Input(s) waveform Generation
WaveGen_Proc_In : process (reset_n, clock)
  variable Input_bit   : integer range 2147483647 downto - 2147483648;
  variable line_number : line;
begin
  if reset_n = '0' then
    $actor.inputs.list: fifo_in_init(it)$    --
    $actor.inputs.list: tb_FSM_init(it)$
    count <= 0;
    
  elsif falling_edge(clock) then
    --
    $actor.inputs.list:  {$case_define_in(it)$}; separator="\n"$$\n$
  end if;
end process WaveGen_Proc_In;

>>


case_define_in(port) ::= <<
case tb_FSM_$actorName$_$port.name$ is
  when after_reset =>
    count <= count + 1;
    if count = 15 then
      tb_FSM_$actorName$_$port.name$ <= read_file;
      count           <= 0;
    end if;

  when read_file =>
    if (not endfile (sim_file_$actorName$_$port.name$)) then
      readline(sim_file_$actorName$_$port.name$, line_number);
      --
      if line_number'length > 0 and line_number(1) /= '/' then
        read(line_number, input_bit);
$if(port.type.bool)$
        if (input_bit = 1) then
          $actorName$_$port.name$_data  <= '1';
        else
          $actorName$_$port.name$_data  <= '0';
        end if;
$else$
$if(port.type.int)$
        $actorName$_$port.name$_data  <= std_logic_vector(to_signed(input_bit, $port.type.size$));$\n$
$else$
        $actorName$_$port.name$_data  <= std_logic_vector(to_unsigned(input_bit, $port.type.size$));$\n$
$endif$
$endif$
        $actorName$_$port.name$_empty <= '0';    
        tb_FSM_$actorName$_$port.name$ <= CheckRead;
      end if;
    end if;

  when CheckRead =>
    if (not endfile (sim_file_$actorName$_$port.name$)) and $actorName$_$port.name$_read = '1' then
      readline(sim_file_$actorName$_$port.name$, line_number);
      --
      if line_number'length > 0 and line_number(1) /= '/' then
        read(line_number, input_bit);
$if(port.type.bool)$
        if (input_bit = 1) then
          $actorName$_$port.name$_data  <= '1';
        else
          $actorName$_$port.name$_data  <= '0';
        end if;
$else$
$if(port.type.int)$
        $actorName$_$port.name$_data  <= std_logic_vector(to_signed(input_bit, $port.type.size$));$\n$
$else$
        $actorName$_$port.name$_data  <= std_logic_vector(to_unsigned(input_bit, $port.type.size$));$\n$
$endif$
$endif$
        $actorName$_$port.name$_empty <= '0';     
      end if;
    end if;

  when others => null;
end case;


>>

waveform_process_out() ::= <<
-- Output(s) waveform Generation
WaveGen_Proc_Out : process (reset_n, clock)
  variable Input_bit   : integer range 2147483647 downto - 2147483648;
  variable line_number : line;
begin
  if reset_n = '0' then
    $actor.outputs.list: fifo_out_init(it)$    --
  elsif rising_edge(clock) then
    --
    $actor.outputs.list:  {$case_define_out(it)$}; separator="\n"$
  end if;
end process WaveGen_Proc_Out;

>>


case_define_out(port) ::= <<
    if (not endfile (sim_file_$actorName$_$port.name$) and $actorName$_$port.name$_write = '1') then
      readline(sim_file_$actorName$_$port.name$, line_number);
      --
      if line_number'length > 0 and line_number(1) /= '/' then
        read(line_number, input_bit);
$if(port.type.bool)$
        if Input_bit = 1 then
          assert ($actorName$_$port.name$_data = '1')
            report "incorrectly value computed : 0 instead of : 1"
            severity error;
        else
          assert ($actorName$_$port.name$_data = '0')
            report "incorrectly value computed : 1 instead of : 0"
            severity error;                
        end if;
$else$
$if(port.type.int)$
        assert ($actorName$_$port.name$_data  = std_logic_vector(to_signed(input_bit, $port.type.size$)))
          -- report "incorrectly value computed : " & to_string(to_integer(to_signed($actorName$_$port.name$_data))) & " instead of :" & to_string(input_bit)
          report "incorrectly value computed : " & str(to_integer(signed($actorName$_$port.name$_data))) & " instead of :" & str(input_bit)
          severity error;$\n$
$else$
        assert ($actorName$_$port.name$_data  = std_logic_vector(to_unsigned(input_bit, $port.type.size$)))
          report "Incorrectly value computed : " & to_string(to_integer(to_unsigned($actorName$_$port.name$_data))) & " instead of :" & to_string(input_bit)
          --report "Incorrectly value computed : " & str(to_integer(unsigned($actorName$_$port.name$_data))) & " instead of :" & str(input_bit)
          severity error;$\n$
$endif$
$endif$
        --
        $actorName$_$port.name$_full <= '0';    
      end if;
    end if;

>>

///////////////////////////////////////////////////////////////////////////////
// testbench
///////////////////////////////////////////////////////////////////////////////
testbench(actorName, actor) ::= <<
------------------------------------------------------------------------------
-- Generated from $actor.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use std.textio.all;
use ieee.numeric_std.all;

library work;
use work.sim_package.all;

entity $actor.name$_testbench is

end $actor.name$_testbench;


architecture rtl of $actor.name$_testbench is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  $sig_const()$
  ---------------------------------------------------------------------------

begin

  $actor.name$_orcc : entity work.$actor.name$
    port map (
      clock      => clock,
      reset_n    => reset_n,
      $actor.inputs.list: {$fifo_map_in(it)$}; separator=",\n"$,
      $actor.outputs.list: {$fifo_map_out(it)$}; separator=",\n"$);
      
  $init_process()$
  $waveform_process_in()$
  $waveform_process_out()$

end architecture rtl;
>>