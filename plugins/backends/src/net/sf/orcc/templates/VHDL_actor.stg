///////////////////////////////////////////////////////////////////////////////
// FIFOs
///////////////////////////////////////////////////////////////////////////////
fifo_in(port) ::= <<
$
if(port.type.bool)
$$actor.name$_$port.name$_data  : in std_logic;$
else
$$actor.name$_$port.name$_data  : in std_logic_vector($port.type.size$ -1 downto 0);$
endif
$

$actor.name$_$port.name$_empty : in std_logic;
$actor.name$_$port.name$_ack  : out std_logic;

>>

fifo_out(port) ::= <<
$actor.name$_$port.name$_full  : in std_logic;
$
if(last(port.name))
$$
if(port.type.bool)
$$actor.name$_$port.name$_data  : out std_logic;$
else
$$actor.name$_$port.name$_data  : out std_logic_vector($port.type.size$ -1 downto 0);$
endif
$

$actor.name$_$port.name$_write : out std_logic$
else
$$actor.name$_$port.name$_data  : out $port.type$;
$actor.name$_$port.name$_write : out std_logic;$
endif
$
>>

fifo_in_init(port) ::=<<
$actor.name$_$port.name$_ack <= '0';
>>
fifo_out_init(port) ::=<<
$actor.name$_$port.name$_write <= '0';
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture
///////////////////////////////////////////////////////////////////////////////

Actor_out(port) ::= <<
$
if(port.type.bool)
$$actor.name$_$port.name$_data  <= '0';$\n$$
else
$$actor.name$_$port.name$_data  <= (others => '0');$\n$$
endif
$

>>


Actor_Schedul(actor) ::= <<
  $actor.name$_proc : process (reset_n, clock) is
    $actor.actions: {action|variable $action.scheduler$_go : std_logic;}; separator="\n"$
    --
    $actor.actions: printActionLocals()$  --
  begin
    if reset_n = '0' then 
      $actor.stateVars.list: stateConst()$
      $InitFSM(actor.actionScheduler.fsm)$      --
      $actor.inputs.list: fifo_in_init(); separator="\n"$
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      $actor.outputs.list: Actor_out()$    --
    elsif rising_edge(clock) then
      $
      if(actor.initializes)
      $ -- $actor.initializes: action()$$
      endif
      $
      $actor.inputs.list: fifo_in_init(); separator="\n"$
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      --
      $actor.actions: printActionSchedulerInline(); separator="\n"$
      $schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$   
    end if;
  end process $actor.name$_proc;

>>


Actor_No_Schedul(actor) ::= <<
  $actor.name$_proc : process (reset_n, clock) is
    $actor.actions: {action| $action.scheduler$_go : std_logic;}; separator="\n"$
    --
    $actor.actions: printActionLocals()$  --
  begin
    if reset_n = '0' then 
      $actor.stateVars.list: stateConst()$      --
      $actor.inputs.list: fifo_in_init(); separator="\n"$
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      $actor.outputs.list: Actor_out()$    --
    elsif rising_edge(clock) then
      $
      if(actor.initializes)
      $$actor.initializes: action()$$
      endif
      $
      $actor.inputs.list: fifo_in_init(); separator="\n"$
      $actor.outputs.list: fifo_out_init(); separator="\n"$
      --
      $actor.actions: printActionSchedulerInline(); separator="\n"$
    
      $schedulingTest(actor.actions)$
      end if;
    end if;
  end process $actor.name$_proc;

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {0 to $it$ -1}; separator=", "$
>>


// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
($value; wrap, separator=", "$)
>>

signalDeclaration(variable) ::= <<
$
if(variable.port)
$signal $variable$ : $variable.type$;
$
else
$$
if(!variable.type.list)
$
signal $variable$ : $variable.type$;$
else
$
type memory_type_$variable$ is array ($listSize(variable.type.dimensions)$) of $variable.type$;
signal $variable$ : memory_type_$variable$;$
endif
$$
endif
$
>>

variableDeclaration(variable) ::= <<
$
if(variable.port)
$variable $variable$ : $variable.type$$
else
$$
if(!variable.type.list)
$variable $variable$ : $variable.type$ $listSize(variable.type.dimensions)$$
else
$-- error !!!!! type memory_type
-- variable $variable$ : $variable.type$ $listSize(variable.type.dimensions)$$
endif
$$
endif
$
>>

///////////////////////////////////////////////////////////////////////////////
// Constant Signal
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
$
if(variable.constantValue)
$$declareConst(variable=variable)$$
endif
$

>>


declareConst(variable) ::= <<
$variable$ <= $variable.constantValue$;

>>


///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

$assign.target$ := $assign.value$;
>>

Call(call) ::= <<

$
if(call.target)
$
$call.target$ := $call.procedure$($call.procedure.stateVarsUsed: {$it$, }$$call.parameters: {$it$, }$'1');$
else
$$
if(call.parameters)
$
$call.procedure$($call.parameters; separator=", "$, '1');$
else
$
$call.procedure$('1');$
endif
$$
endif
$
>>

HasTokens(hasTokens) ::= <<

$hasTokens.target$ := $actor.name$_$hasTokens.port$_send;
>>

Load(load) ::= <<

$if(load.indexes)
$$if(load.source.variable.port)
$$load.target$ := $load.source$;$
else
$$load.target$ := $load.source$($load.indexes : {$it$}; separator=", "$);$
endif
$$
else
$$load.target$ := $load.source$;$
endif$
>>

Peek(peek) ::= <<

$if(peek.unit)
$$
if(peek.target.type.bool)
$$peek.target$ := $actor.name$_$peek.port$_data;$\n$$
else
$$
if(peek.target.type.int)
$$peek.target$ := to_integer(signed($actor.name$_$peek.port$_data));$
else
$$peek.target$ := to_integer(unsigned($actor.name$_$peek.port$_data));$
endif
$$
endif
$$
else
$-- peek multiple token not coded yet$
endif
$

>>

Read(read) ::= <<
$
if(read.unit)
$$
if(read.target.type.bool)
$$read.target$ := $actor.name$_$read.port$_data;$\n$
$
else
$$
if(read.target.type.int)
$
$read.target$ := to_integer(signed($actor.name$_$read.port$_data));
$
else
$
$read.target$ := to_integer(unsigned($actor.name$_$read.port$_data));$
endif
$$
endif
$$actor.name$_$read.port$_ack <= '1';$
else
$-- read multiple token not coded yet
$
endif
$

>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
Return(return) ::= <<
$
if(return.value)
$$
  if(transformReturn)
$
$procedure$_go := $return.value$;$
  else
$
return $return.value$;$
  endif
$$
endif
$

>>

Store(store) ::= <<
$if(store.indexes)$$
if(store.target.variable.port)
$
$store.target$ := $store.value$;$
else
$
$store.target$($store.indexes : {$it$}; separator=", "$) <= $store.value$;$
endif
$$
else
$
$store.target$ <= $store.value$;$
endif
$

>>

Write(write) ::= <<

$
if(write.target.type.bool)
$$actor.name$_$write.port$_data <= $write.target$;$
else
$$
  if(write.target.type.int)
$
$actor.name$_$write.port$_data <= std_logic_vector(to_signed($write.target$, $write.port.type.size$));$
  else
$
$actor.name$_$write.port$_data <= std_logic_vector(to_unsigned($write.target$, $write.port.type.size$));$
  endif
$$
endif
$

$actor.name$_$write.port$_write <= '1';
>>


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<
if ($ifNode.value$) then
  $nodes(ifNode.thenNodes)$$if(ifNode.elseNodes)$else
  $nodes(ifNode.elseNodes)$end if;$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<
while ($whileNode.value$) loop
  $nodes(whileNode.nodes)$$BlockNode(whileNode.joinNode)$end loop;
>>

///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////

functionParameter(variable) ::= <<
$if(!(listSize(variable.type.dimensions)))$
$variable$ : $typeFunction(variable.type)$
$else$
-- error !!!!! type memory type
$endif$
>>

VarInFctDeclaration(variable) ::= <<
$variable.type.dimensions$
$if(variable.port)$
variable $variable$ : $typeFunction(variable.type)$
$else$
  $if(!(listSize(variable.type.dimensions)))$
variable $variable$ : $typeFunction(variable.type)$
  $else$
-- error !!!!! type memory_type
  $endif$
$endif$
>>

returnFunction(type) ::= <<
$if(type.bool)$
return std_logic 
$else$
$if(type.int)$
return integer 
$endif$
$endif$
>>

typeFunction(type) ::= <<
$if(type.bool)$
std_logic 
$else$
$if(type.int)$
integer
$else$
integer 
$endif$
$endif$
>>

parameters(params) ::= <<
$params: { $functionParameter()$; }; wrap$
>>

function(procedure, transformReturn) ::= <<
$if (procedure.returnType.void)$
procedure $procedure$($parameters(procedure.parameters.list)$dummy : std_logic) is
$else$
function $procedure$($parameters(procedure.stateVarsUsed)$$parameters(procedure.parameters.list)$dummy : std_logic) $returnFunction(procedure.returnType)$is
$endif$

  $if(procedure.locals.list)$
  $procedure.locals.list: {$VarInFctDeclaration()$;$\n$}$
  $endif$begin
  $procedure.nodes: {$(it.class.simpleName)(it)$}$end $procedure$;

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

procedure(procedure, transformReturn) ::= <<
$procedure.nodes: {$(it.class.simpleName)(it)$}$
>>

// prints the scheduler of the given action "inline" (ie not within a function)
printActionSchedulerInline(action) ::= <<
-- tests if "$action$" action is schedulable
$procedure(procedure=action.scheduler, transformReturn="true")$
>>

printLocals(procedure) ::= <<
$
if(procedure.locals.list)
$$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$$
endif
$
>>

// this template prints the locals of the body and the scheduler function
// of the given action
printActionLocals(action) ::= <<
$printLocals(action.body)$$printLocals(action.scheduler)$
>>

// prints the body of the given action "inline" (ie not within a function)
printActionBodyInline(action) ::= <<
-- body of "$action$" action
$procedure(procedure=action.body)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|$actor.name$_$port$_full = '0'}; separator=" and "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

schedulingTest(actions) ::= <<
-- Actions
if $actions: actionTest(); separator="\nelsif "$
>>

actionTest(action) ::= <<
(isSchedulable_$action$_go = '1') then$
if(action.outputPattern)
$
  if ($outputPattern(pattern=action.outputPattern)$) then
    $printActionBodyInline(action)$
  end if;$
else
$  $printActionBodyInline(action)$$
  endif
$

>>
///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

DefineFSM(actions, fsm) ::= <<
$
if(fsm)
$type FSM_type is ($fsm.states: {s_$it$}; separator=", "$);
signal FSM : FSM_type;$
endif
$

>>

InitFSM(fsm) ::= <<
FSM <= s_$fsm.initialState$;

>>

schedulerFSM(actions, fsm) ::= <<
$
if(actions)
$$schedulingTest(actions)$
else
  case FSM is
  $switch(fsm.transitions)$
end case;
end if;$
else
$case FSM is
  $switch(fsm.transitions)$
end case;$
endif
$

>>


switch(transitions) ::= <<
$transitions: {when s_$it.sourceState$ =>
$stateScheduler()$}$
>>

stateScheduler(transition) ::= <<
  -- $transition.sourceState$_state_scheduler
  $schedulingTestState(nextStates=transition.nextStateInfo)$

>>

schedulingTestState(nextStates) ::= <<
if $nextStates: actionTestState(); separator="elsif"$end if;

>>

// prints the action referenced by the "nextState" parameter
// and updates the FSM state
actionCallState(nextState) ::= <<
$printActionBodyInline(nextState.action)$FSM <= s_$nextState.targetState$;
>>

actionTestState(nextState) ::= <<
(isSchedulable_$nextState.action$_go = '1') then
  $if(nextState.action.outputPattern)$
  if ($outputPattern(nextState.action.outputPattern)$) then
    $actionCallState(nextState)$
  end if;
  $else$
  $actionCallState(nextState)$
  $endif$

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor) ::= <<
------------------------------------------------------------------------------
-- Generated from $actor.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;

------------------------------------------------------------------------------

entity $actor.name$ is
  port (
  -- Inputs
  clock   : in std_logic;
  reset_n : in std_logic;
  $actor.inputs.list: fifo_in()$  -- Outputs
  $actor.outputs.list: fifo_out(); separator=";\n"$);  
end $actor.name$;

------------------------------------------------------------------------------

architecture rtl_$actor.name$ of $actor.name$ is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  $actor.stateVars.list: signalDeclaration()$

  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  $actor.procs.list: {$function(procedure=it)$}; separator="\n"$

  ---------------------------------------------------------------------------
  -- FSM
  ---------------------------------------------------------------------------
  $DefineFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$

begin
$
if(actor.actionScheduler.fsm)
$  $Actor_Schedul(actor)$$
else
$  $Actor_No_Schedul(actor)$$
endif
$

end architecture rtl_$actor.name$;

>>


action(action) ::= <<

-- TODO
$procedure(procedure=action.body)$

>>