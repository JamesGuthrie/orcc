///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
extern struct fifo_s *$instance.id$_$port.name$;

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

variableDeclaration(variable) ::= <<
$
if(variable.port)
$$variable.type$ *$variable$$
else
$$variable.type$ $variable$$listSize(variable.type.dimensions)$$
endif
$
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
$if(variable.constantValue)$
$if(!variable.assignable)$
$if(!variable.type.list)$
#define $variable$ $variable.constantValue$
$else$
static $variableDeclaration(variable)$ = $variable.constantValue$;
$endif$
$else$
static $variableDeclaration(variable)$ = $variable.constantValue$;
$endif$
$else$
static $variableDeclaration(variable)$;
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<

$assign.target$ = $assign.value$;
>>

Call(call) ::= <<

$if(call.target)$$call.target$ = $endif$$call.procedure$($call.parameters; separator=", "$);
>>

Decrement(decrement) ::= <<

$decrement.target$--;
>>

HasTokens(hasTokens) ::= <<

$hasTokens.target$ = hasTokens($instance.id$_$hasTokens.port$, $hasTokens.numTokens$);
>>

Increment(increment) ::= <<

$increment.target$++;
>>

Load(load) ::= <<

$load.target$ = $load.source$$load.indexes : {[$it$]}$;
>>

Peek(peek) ::= <<

$peek.target$ = getPeekPtr($instance.id$_$peek.port$, $peek.numTokens$);
>>

Read(read) ::= <<

$read.target$ = getReadPtr($instance.id$_$read.port$, $read.numTokens$);
>>

ReadEnd(readEnd) ::= <<

setReadEnd($instance.id$_$readEnd.port$, $readEnd.numTokens$);
>>

Return(return) ::= <<
$if(return.value)$
return $return.value$;$
endif$
>>

SelfAssignment(selfAssign) ::= <<

$selfAssign.target$ $selfAssign.op.text$= $selfAssign.value$;
>>

Store(store) ::= <<

$store.target$$store.indexes : {[$it$]}$ = $store.value$;
>>

Write(write) ::= <<

$write.target$ = getWritePtr($instance.id$_$write.port$, $write.numTokens$);
>>

WriteEnd(writeEnd) ::= <<

setWriteEnd($instance.id$_$writeEnd.port$, $writeEnd.numTokens$);
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<

if ($ifNode.value$) {
	$nodes(ifNode.thenNodes)$
}$if(ifNode.elseNodes)$ else {
	$nodes(ifNode.elseNodes)$
}$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<

while ($whileNode.value$) {
	$nodes(whileNode.nodes)$
}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

static $procedure.returnType$ $procedure$($procedure.parameters.list: {$variableDeclaration(it)$}; wrap, anchor, separator=", "$) {
$if(procedure.locals.list)$
	$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$
$endif$
	$procedure.nodes: {$(it.class.simpleName)(it)$}$
}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPatternPort(port) ::= <<
if (!hasRoom($instance.id$_$port$, $pattern.(port)$)) {
	ports |= 0x0$instance.actor.maskOutput.(port)$;
}
>>

outputPattern(pattern) ::= <<
int ports = 0;
$pattern.keys: outputPatternPort(); separator="\n"$
if (ports != 0) {
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
$action.body$();
i++;
>>

actionTest(action) ::= <<
if (isSchedulable_$action$()) {
	$if(action.outputPattern)$
	$outputPattern(pattern=action.outputPattern)$
		si->num_firings = i;
		si->reason = full;
		si->ports = ports;
		break;
	}
	$endif$
	$actionCall(action)$
}>>

schedulingTest(actions) ::= <<
$actions: actionTest(); separator=" else "$
>>

scheduler(actions) ::= <<
void $instance.id$_scheduler(struct schedinfo_s *si) {
	int i = 0;
  
	while (1) {
		$if(actions)$$schedulingTest(actions)$$endif$ else {
			si->num_firings = i;
			si->reason = starved;
			si->ports = 0x0$instance.actor.maskInputs$;
			break;
		}
	}
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
$nextState.action.body$();
i++;
goto l_$nextState.targetState$;
>>

actionTestState(nextState) ::= <<
if (isSchedulable_$nextState.action$()) {
	$if(nextState.action.outputPattern)$
	$outputPattern(nextState.action.outputPattern)$
		_FSM_state = s_$transition.sourceState$;
		si->num_firings = i;
		si->reason = full;
		si->ports = ports;
		return;
	}
	$endif$
	$actionCallState(nextState)$
}>>

schedulingTestState(nextStates) ::= <<
$nextStates: actionTestState(); separator=" else "$
>>

Transition(transition) ::= <<


l_$transition.sourceState$:
	$if (actions)$
	while (outside_FSM_scheduler()) {
		i++;
	}
	$endif$
	$if (transition.nextStateInfo.empty)$
	printf("stuck in state \"$transition.sourceState$\"\n");
	wait_for_key();
	exit(1);
	$else$
	$schedulingTestState(nextStates=transition.nextStateInfo)$ else {
		_FSM_state = s_$transition.sourceState$;
		si->num_firings = i;
		si->reason = starved;
		si->ports = 0x0$instance.actor.maskInputsTransition.(transition)$;
		return;
	}
	$endif$
>>

Transitions(actions, transitions) ::= <<
$transitions: Transition()$
>>

switchTransition(transition) ::= <<

case s_$transition.sourceState$:
	goto l_$transition.sourceState$;
>>

switch(transitions) ::= <<
switch (_FSM_state) {
$transitions: switchTransition()$
default:
	printf("unknown state: %s\n", stateNames[_FSM_state]);
	wait_for_key();
	exit(1);
}
>>

schedulerFSM(actions, fsm) ::= <<
enum states {
	s_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {s_$it$}; separator=",\n"$
};

static char *stateNames[] = {
	$fsm.states : {"s_$it$"}; separator=",\n"$
};

static enum states _FSM_state = s_$fsm.initialState$;

$if(actions)$
static int outside_FSM_scheduler() {
	int i = 0;
	$schedulingTest(actions)$ else {
		return 0;
	}
	return 1;
}
$endif$

void $instance.id$_scheduler(struct schedinfo_s *si) {
	int i = 0;

	// jump to FSM state 
	$switch(fsm.transitions)$

	// FSM transitions
$Transitions(actions=actions, transitions=fsm.transitions)$
}

>>

parameters(parameters) ::= <<
$parameters.keys: { k | #define $k$ $parameters.(k)$
}$
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

instance(instance) ::= <<
// $instance.id$ generated from "$instance.actor.name$"

#include <stdio.h>
#include <stdlib.h>

#include "fifo.h"
#include "orcc_util.h"

////////////////////////////////////////////////////////////////////////////////
// Input FIFOs
$instance.actor.inputs.list: fifo()$
////////////////////////////////////////////////////////////////////////////////
// Output FIFOs
$instance.actor.outputs.list: fifo()$
////////////////////////////////////////////////////////////////////////////////
// Parameter values of the instance
$parameters(instance.parameters)$
////////////////////////////////////////////////////////////////////////////////
// State variables of the actor
$instance.actor.stateVars.list: stateVar()$
////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
$instance.actor.procs.list: procedure()$
////////////////////////////////////////////////////////////////////////////////
// Actions
$instance.actor.actions: action()$
$if(instance.actor.initializes)$
////////////////////////////////////////////////////////////////////////////////
// Initializes
$instance.actor.initializes: action()$
void $instance.id$_initialize() {
	int res = 1;
	int i = 0;

	$if(instance.actor.initializes)$
	$schedulingTest(instance.actor.initializes)$
	$endif$
}

$endif$
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
$if(instance.actor.actionScheduler.fsm)$
$schedulerFSM(actions=instance.actor.actionScheduler.actions, fsm=instance.actor.actionScheduler.fsm)$
$else$
$scheduler(actions=instance.actor.actionScheduler.actions)$
$endif$

>>
