///////////////////////////////////////////////////////////////////////////////
// Declare actors

declareActor(instance) ::= "$instance.id$"
declareActors(instances) ::= <<
struct actor_s $instances: declareActor(); wrap, separator=", "$;

>>

declareActorArray(instance) ::= "&$instance.id$"

declareActorsArray(instances) ::= <<
struct actor_s *actors[] = {$instances: declareActorArray(); wrap, separator=", "$};
>>

///////////////////////////////////////////////////////////////////////////////
// Declare predecessors and successors

Neighbor(port) ::= <<
&$map.(port).id$
>>

Neighbors(map, ports) ::= <<
$ports: Neighbor(); separator=", "$
>>

goDeclarePredSucc(inputs, outputs) ::= <<
$if(!inputs.empty)
$struct actor_s *$instance.id$_predecessors[] = {$Neighbors(map=network.predecessorsMap.(instance), ports=inputs)$};
$endif$$
if(!outputs.empty)
$struct actor_s *$instance.id$_successors[] = {$Neighbors(map=network.successorsMap.(instance), ports=outputs)$};
$endif$
>>

goDeclarePredsSuccs(instance, incoming, outgoing) ::= <<
$if (instance.actor)
$$goDeclarePredSucc(inputs=instance.actor.inputs.list,
                    outputs=instance.actor.outputs.list)$$
elseif (instance.broadcast)
$$goDeclarePredSucc(inputs=instance.broadcast.inputs.list,
                   outputs=instance.broadcast.outputs.list)$$
endif$
>>

declarePredsSuccs(instances) ::= <<
$instances:
  {$goDeclarePredsSuccs(instance=it,
    incoming=network.incomingMap.(it),
    outgoing=network.outgoingMap.(it))$}$
>>

///////////////////////////////////////////////////////////////////////////////
// Define actors

NumInputs(instance) ::= <<
$if (instance.actor)
$$instance.actor.inputs.length$$
elseif (instance.broadcast)$1$else$0$endif$
>>

NumOutputs(instance) ::= <<
$if (instance.actor)
$$instance.actor.outputs.length$$
elseif (instance.broadcast)$$instance.broadcast.numOutputs$$else$0$endif$
>>

fillActorStruct(instance) ::= <<

struct actor_s $instance.id$ = {"$instance.id$", $instance.id$_scheduler, $
NumInputs(instance)$, $NumOutputs(instance)$, $
if(instance.actor.inputs.list.empty)$NULL$else$$instance.id$_predecessors$endif$, $
if(instance.actor.outputs.list.empty)$NULL$else$$instance.id$_successors$endif$};
>>

fillActorsStructs(instances) ::= <<
$instances: fillActorStruct()$
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network) ::= <<
// Generated from "$network.name$"

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>

#include "fifo.h"
#include "scheduler.h"
#include "orcc_util.h"

#define SIZE $fifoSize$

////////////////////////////////////////////////////////////////////////////////
// FIFO allocation
$allocateFifos(network.connections)$
////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments
$assignFifos(network.connections)$
////////////////////////////////////////////////////////////////////////////////
$declareBroadcasts(network.instances)$
////////////////////////////////////////////////////////////////////////////////
// Action schedulers
$declareInitializes(network.instances)$
$declareSchedulers(network.instances)$

////////////////////////////////////////////////////////////////////////////////
// Declaration of a struct actor for each actor

$declareActors(network.instances)$
////////////////////////////////////////////////////////////////////////////////
// Declaration of the predecessors and successors of each actor

$declarePredsSuccs(network.instances)$
////////////////////////////////////////////////////////////////////////////////
// Declaration of the actors array

$fillActorsStructs(network.instances)$

$declareActorsArray(network.instances)$
////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

// Uncomment to print firings
// #define PRINT_FIRINGS

static void scheduler() {
	struct scheduler_s my_scheduler;
	struct actor_s *my_actor;
	struct schedinfo_s si;
	int iterations = 0;

	// initializes the actors that need it
	$printInitializes(network.instances)$
	// initialize scheduler
	sched_init(&my_scheduler, sizeof(actors) / sizeof(actors[0]), actors);

	sched_add_schedulable(&my_scheduler, &source);
	my_actor = sched_get_next_schedulable(&my_scheduler);
	while (my_actor != NULL) {
		iterations++;
		si.num_firings = 0;
		my_actor->sched_func(&si);
#ifdef PRINT_FIRINGS
		printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor->name);
#endif
		if (si.reason == full) {
			sched_add_successors(&my_scheduler, my_actor, si.ports);
		} else if (si.reason == starved) {
			sched_add_predecessors(&my_scheduler, my_actor, si.ports);
		}

		my_actor = sched_get_next_schedulable(&my_scheduler);

		if (iterations % 1000 == 0) {
			//printf("\n");
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
int main(int argc, char *argv[]) {
	init_orcc(argc, argv);

	scheduler();

	printf("End of simulation! Press a key to continue\n");
	wait_for_key();

	return 0;
}

>>

