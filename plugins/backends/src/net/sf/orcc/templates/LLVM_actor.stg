group LLVM_actor;


///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
@$actorName$_$port.name$ = common global %struct.fifo_s* null

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////
Var(var) ::= <<
$if(var.variable.global)$@$else$%$endif$$var$
>>

Expr(expr) ::= <<
$if(expr.varExpr)$$Var(expr.var)$$else$$expr$$endif$
>>

ExprType(expr) ::= <<
$expr.type$
>>

VarType(var) ::= <<
$var.variable.type$
>>

ListType(list) ::= <<
$list.variable.type.elementType$
>>

variableDeclaration(variable) ::= <<
$if(variable.port)$
$AllocaOp(result="%"+variable, type=variable.type.elementType+"*")$
$else$
$if(variable.list)$
$AllocaOp(result="%"+variable, type=variable.type)$
$endif$
$endif$


>>

indexes(indexes) ::= <<
$indexes: { index | $if(index.type)$$index.type$$else$i32$endif$ $Expr(index)$ }; separator=", "$
>>

indexesName(indexes) ::= <<
$indexes: {index |$index$}; separator="_"$
>>

parametersDeclaration(arguments, parameters, casts, location) ::= <<
$arguments, parameters, casts: { arg, param, cast | $parameters(type = arg.type, variable= param, cast =cast, location=location)$}; separator=", "$
>>

parameters(type, variable, cast, location) ::= <<
$if(variable.intExpr)$$type$ $elseif(type.list)$$type$* $elseif(variable.booleanExpr)$i1 $else$$variable.type$ $endif$$if(cast)$%$variable$$location$_cast$else$$Expr(variable)$$endif$
>>

argumentDeclaration(variable) ::= <<
$if(variable.type.list)$
$variable.type$* %$variable$
$else$
$variable.type$ %$variable$
$endif$
>>

Location(location) ::= <<
l$location.startLine$c$location.startColumn$
>>

ConstantValue(type, const) ::= <<
$if(const.listConst)$
$listValue(type=type.type, values=const.value, iterator = type.sizeIterator)$
$else$
$const$
$endif$

>>


///////////////////////////////////////////////////////////////////////////////
// List
///////////////////////////////////////////////////////////////////////////////

// the values of a list: {val1, val2, ..., valn}
listValue(type, values, iterator) ::= <<
$if(first(values).listConst)$
[$iterator, values :{ iterator, value | $type$ $if(value)$ $listValue(type=type.type, values=value.value, iterator= type.sizeIterator)$ $else$ zeroinitializer $endif$}; separator=", "$]
$else$
[$values:{$type$ $it$}; separator=", "$]
$endif$

>>


// phi definition
phiPair(value, label) ::= <<
[$value$, %$label$]
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
$if(variable.constantValue)$
@$variable$ = internal global $variable.type$ $ConstantValue(type=variable.type, const=variable.constantValue)$

$else$
@$variable$ = internal global $variable.type$ zeroinitializer

$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
StoreOp(ty, value, pty, pointer) ::= <<
store $ty$ $value$, $pty$* $pointer$
>>

LoadOp(result, ty, pointer,alignment) ::= <<
$result$ = load $ty$* $pointer$ $if(alignment)$ [, align <alignment>] $endif$
>>  

AddOp(result, ty, op1, op2) ::= <<
$result$ = add $ty$ $op1$, $op2$
>>  

AndOp(result, ty, op1, op2) ::= <<
$result$ = and $ty$ $op1$, $op2$
>>

IcmpOp(result, cond, ty, op1, op2) ::= <<
$result$ = icmp $cond$ $ty$ $op1$, $op2$
>>
 
GetElementPtrOp(result, pty, ptrval, idx0, idx) ::= <<
$result$ = getelementptr $pty$* $ptrval$$if(idx0)$
, i32 $idx0$
$endif$ $if(idx)$
, $indexes(idx)$
$endif$
>>

BitcastOp(result, ty, value, ty2) ::= <<
$result$ = bitcast $ty$ $value$ to $ty2$
>>

AllocaOp(result, type, NumElements, alignment) ::= <<
$result$ = alloca $type$ $if(NumElements)$
[, i32 <NumElements>]
$endif$
$if(alignment)$
[, align <alignment>]
$endif$
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
$if(cond)$br i1 $cond$, label $iftrue$, label $iffalse$
$else$
br label $dest$
$endif$
>>

RetOp(type, value) ::= <<
$if(value)$
ret $type$ $value$
$else$
ret void
$endif$


>>  

SwitchOp(intty, value, defaultdest, labelpairs) ::= <<
switch $intty$ $value$, label $defaultdest$ [ $labelpairs$ ]
>>

CallOp(result, tail, cconv, ret_attrs, ty, fnty, fnptrval, function_args, fn_attrs) ::= <<
$if(result)$$result$ = $endif$$if(tail)$ [tail] $endif$call$if(cconv)$ [cconv] $endif$$if(ret_attrs)$ [ret_attrs] $endif$ $ty$$if(fnty)$ [<fnty>*] $endif$ $fnptrval$ ($if(function_args)$$function_args$$endif$) $if(fn_attrs)$ [fn_attrs] $endif$
>>

PhiOp(result, ty, pairs) ::= << 
$result$ = phi $ty$ $pairs$ 

>>

ZextOp(result, ty, value, ty2) ::= << 
$result$ = zext $ty$ $value$ to $ty2$
>>

SextOp(result, ty, value, ty2) ::= << 
$result$ = sext $ty$ $value$ to $ty2$
>>

TruncOp(result, ty, value, ty2) ::= << 
$result$ = trunc $ty$ $value$ to $ty2$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

StoreInstr(ty, value, pty, pointer, cast) ::= <<
$if(value.intExpr)$
$StoreOp(ty=pty, value=Expr(value)+cast, pty=pty, pointer=pointer)$
$elseif(value.booleanExpr)$
$StoreOp(ty=pty, value=Expr(value)+cast, pty=pty, pointer=pointer)$
$else$
$StoreOp(ty=ty, value=Expr(value)+cast, pty=pty, pointer=pointer)$
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

states(transitions) ::= <<

$transitions:{$\t$i32 $it.sourceState.index$, label %s_$it.sourceState$$\n$}$
>>

switch(fsm, transitions) ::= <<
	$LoadOp(result="%"+fsm, ty="i32", pointer="@"+fsm)$
	$SwitchOp(intty="i32", value="%"+fsm, defaultdest="%default", labelpairs=states(transitions))$
$transitions: {
s_$it.sourceState$:
	$CallOp(result="%"+it.sourceState+"_res", ty="i1", fnptrval="@"+it.sourceState+"_state_scheduler")$
	$BrOp(cond="%"+it.sourceState+"_res", iftrue="%inc_i", iffalse="%return")$
}$
default:
	$BrOp(dest="%return")$

>>

CastAssign(target, value, cast)::= <<
$if(cast.extended)$
%$target$_ext = $value$
$if(cast.signed)$
$SextOp(result="%"+target, ty=value.type, value="%"+target+"_ext", ty2=target.type)$

$else$
$ZextOp(result="%"+target, ty=value.type, value="%"+target+"_ext", ty2=target.type)$

$endif$
$else$
%$target$_trunc = $value$
$TruncOp(result="%"+target, ty=value.type, value="%"+target+"_trunc", ty2=target.type)$
$endif$

>>

CastParameter(casts, args, params, location )::= <<
$casts, args, params: { cast, arg, param | $if(cast)$ 
$BitcastOp(result="%"+param+location+"_cast", ty=param.type+"*", value=Expr(param), ty2=arg.type+"*")$
$endif$}$
>>

CastCall(result, ty, fnptrval, function_args, cast)::= <<
$if(cast.extended)$
$CallOp(result="%"+result+"_ext", ty=ty, fnptrval=fnptrval, function_args=function_args)$
$if(cast.signed)$
$SextOp(result="%"+result, ty=ty, value="%"+result+"_ext", ty2=result.type)$

$else$
$ZextOp(result="%"+result, ty=ty, value="%"+result+"_ext", ty2=result.type)$

$endif$
$else$
$CallOp(result="%"+result+"_trunc", ty=ty, fnptrval=fnptrval, function_args=function_args)$
$TruncOp(result="%"+result, ty=ty, value="%"+result+"_trunc", ty2=result.type)$
$endif$

>>


CastStore(ty, value, pty, pointer, cast, location)::= <<
$if(cast.extended)$
$if(cast.signed)$
$SextOp(result="%"+value+"_"+location+"_ext", ty=ty, value=Expr(value), ty2=pty)$

$else$
$ZextOp(result="%"+value+"_"+location+"_ext", ty=ty, value=Expr(value), ty2=pty)$

$endif$
$StoreInstr(ty=pty, value=value, pty=pty, pointer=pointer, cast="_"+location+"_ext")$
$else$
$TruncOp(result="%"+value+"_"+location+"_trunc", ty=ty, value=Expr(value), ty2=pty)$

$StoreInstr(ty=pty, value=value, pty=pty, pointer=pointer, cast="_"+location+"_trunc")$
$endif$
$endif$
>>

StoreWithIndex(ty, value, pty, pointer, cast, indexes, location) ::= <<
$GetElementPtrOp(result="%"+pointer+"_"+location+"_L"+indexesName(indexes)+"ptr", idx0="0", pty=pty, ptrval=Var(pointer), idx=indexes)$
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty.elementType, pointer="%"+pointer+"_"+location+"_L"+indexesName(indexes)+"ptr", cast=cast, location=location)$
$else$
$StoreInstr(ty=ty, value=value, pty=pty.elementType, pointer="%"+pointer+"_"+location+"_L"+indexesName(indexes)+"ptr")$
$endif$
>>

StoreWithoutIndex(ty, value, pty, pointer, cast, location) ::= <<
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty, pointer=Var(pointer), cast=cast, location=location)$
$else$
$StoreInstr(ty=ty, value=value, pty=pty, pointer=Var(pointer))$
$endif$
>>

StorePortWithIndex(ty, value, pty, pointer, cast, indexes, location) ::= <<
$LoadOp(result="%"+pointer+"_"+location+"_Loadport"+indexesName(indexes), ty=pty+"*", pointer=Var(pointer))$
$GetElementPtrOp(result="%"+pointer+"_"+location+"_L"+indexesName(indexes)+"ptr", pty=pty, ptrval="%"+pointer+"_"+location+"_Loadport"+indexesName(indexes), idx=indexes)$
$if(cast)$
$CastStore(ty=ty, value=value, pty=pty, pointer="%"+pointer+"_"+location+"_L"+indexesName(indexes)+"ptr", cast=cast, location=location)$
$else$
$StoreInstr(ty=ty, value=value, pty=pty, pointer="%"+pointer+"_"+location+"_L"+indexesName(indexes)+"ptr")$
$endif$
>>

StorePortWithoutIndex(ty, value, pty, pointer, cast) ::= <<
StorePortWithoutIndex

>>


CastLoad(result, ty, pointer, cast)::= <<
$if(cast.extended)$
$LoadOp(result="%"+result+"_ext", ty=ty, pointer=pointer)$
$if(cast.signed)$
$SextOp(result="%"+result, ty=ty, value="%"+result+"_ext", ty2=result.type)$

$else$
$ZextOp(result="%"+result, ty=ty, value="%"+result+"_ext", ty2=result.type)$

$endif$
$else$
$LoadOp(result="%"+result+"_trunc", ty=ty, pointer=pointer)$
$TruncOp(result="%"+result, ty=ty, value="%"+result+"_trunc", ty2=result.type)$
$endif$
>>

LoadPortWithIndex(result, ty, pointer, indexes, cast) ::= <<
$LoadOp(result="%"+result+"_L", ty=ty+"*", pointer=Var(pointer))$
$GetElementPtrOp(result="%"+result+"_"+pointer+indexesName(indexes)+"_ptr", pty=ty, ptrval="%"+result+"_L", idx=indexes)$
$if(cast)$
$CastLoad(result=result, ty=ty, pointer="%"+result+"_"+pointer+indexesName(indexes)+"_ptr", cast = cast)$
$else$
$LoadOp(result="%"+result, ty=ty, pointer="%"+result+"_"+pointer+indexesName(indexes)+"_ptr")$
$endif$


>>

LoadPortWithoutIndex(result, ty, pointer, cast) ::= <<
LoadPortWithoutIndex


>>


LoadWithIndex(result, ty, pointer, indexes, cast) ::= <<
$GetElementPtrOp(result=result+"_"+pointer+"L"+indexesName(indexes)+"_ptr", idx0="0",  pty=ty, ptrval=Var(pointer), idx=indexes)$
$if(cast)$
$CastLoad(result=result, ty=ty.elementType, pointer=result+"_"+pointer+"L"+indexesName(indexes)+"_ptr", cast=cast)$
$else$
$LoadOp(result=result, ty=ty.elementType, pointer=result+"_"+pointer+"L"+indexesName(indexes)+"_ptr")$
$endif$


>>

LoadWithoutIndex(result, ty, pointer, cast) ::= <<
$if(cast)$
$CastLoad(result=result, ty=ty, pointer=Var(pointer), cast=cast)$
$else$
$LoadOp(result=result, ty=ty, pointer=Var(pointer))$
$endif$


>>

IfWithThenElseNodes(ifNode) ::= <<
	$BrOp(cond=Expr(ifNode.value), iftrue="%b"+label(ifNode.thenNodes), iffalse="%b"+label(ifNode.elseNodes))$

b$label(ifNode.thenNodes)$: 
$nodes_cond(first(ifNode.thenNodes))$ $nodes(rest(ifNode.thenNodes))$ $BrOp(dest ="%b"+label(ifNode.joinNode))$

b$label(ifNode.elseNodes)$:
$nodes_cond(first(ifNode.elseNodes))$ $nodes(rest(ifNode.elseNodes))$ $BrOp(dest ="%b"+label(ifNode.joinNode))$

b$label(ifNode.joinNode)$:

>>

IfWithThenNode(ifNode) ::= <<
	$BrOp(cond=Expr(ifNode.value), iftrue="%b"+label(ifNode.thenNodes), iffalse="%b"+label(ifNode.joinNode))$

b$label(ifNode.thenNodes)$: 
$nodes_cond(first(ifNode.thenNodes))$ $nodes(rest(ifNode.thenNodes))$ $BrOp(dest ="%b"+label(ifNode.joinNode))$

b$label(ifNode.joinNode)$:

>>



LoadLocalPort(instr) ::= <<
$LoadOp(result="%local_"+instr.port+instr.block.label, ty="%struct.fifo_s*", pointer="@"+actorName+"_"+instr.port)$
>>

HasRoom(result, action, actor, port, numToken) ::= <<
$LoadOp(result="%"+port+"_"+action, ty="%struct.fifo_s*", pointer="@"+actor+"_"+port)$
$CallOp(result="%"+result+"32", ty="i32", fnptrval="@hasRoom", function_args="%struct.fifo_s* %"+port+"_"+action+", i32 "+numToken)$
$TruncOp(result="%"+result, ty="i32", value="%"+result+"32", ty2="i1")$
>>

label(nodes) ::= "b$first(nodes):{ x | $x.label$}$"

phiPairs(phi) ::= <<
$phiVars(vars=first(phi.vars), node = first(phi.block.predecessors))$, $phiVars(vars=first(rest(phi.vars)), node = rest(phi.block.predecessors))$
>>

phiVars(vars, node) ::= <<
[$if(vars.variable.assigned)$ %$vars$ $else$ 0 $endif$, %b$label(node)$ ]
>>


///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////


Call(call) ::= <<
$CastParameter(casts=call.paramCast, args=call.procedure.parameters.list, params=call.parameters, location=Location(call.location))$
$if(call.target)$
$if(call.cast)$
$CastCall(result=call.target, ty=call.procedure.returnType, fnptrval=call.procedure, function_args=parametersDeclaration(arguments=call.procedure.parameters.list ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)), cast=call.cast)$
$else$
$CallOp(result="%"+call.target, ty=call.procedure.returnType, fnptrval=call.procedure, function_args=parametersDeclaration(arguments=call.procedure.parameters.list ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))$
$endif$
$else$
$CallOp(ty=call.procedure.returnType, fnptrval=call.procedure, function_args=parametersDeclaration(arguments=call.procedure.parameters.list ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))$
$endif$


>>

Assign(assign) ::= <<
$if(assign.cast)$
$CastAssign(target = assign.target, value = assign.value, cast = assign.cast)$
$else$
%$assign.target$ = $assign.value$
$endif$


>>

PhiAssignment(phi) ::= <<
$PhiOp(result="%"+phi.target, ty=phi.target.type, pairs=phiPairs(phi))$

>>

Read(read) ::= <<
$LoadLocalPort(read)$
$CallOp(result="%"+read.target+"_"+read.block.label, ty ="i8*", fnptrval="@getReadPtr", function_args="%struct.fifo_s* %local_"+read.target+read.block.label+", i32 "+read.numTokens)$
$BitcastOp(result="%"+read.target+"_"+read.block.label+"_cast", ty="i8*", value="%"+read.target+"_"+read.block.label, ty2=ExprType(read.port)+"*")$
$StoreOp(ty=ExprType(read.port)+"*", value="%"+read.target+"_"+read.block.label+"_cast", pty=ExprType(read.port)+"*", pointer="%"+read.port)$

>>

ReadEnd(readEnd) ::= <<
$LoadOp(result="%end_"+readEnd.port, ty="%struct.fifo_s*", pointer="@"+actorName+"_"+readEnd.port)$
$CallOp(ty ="void", fnptrval="@setReadEnd", function_args="%struct.fifo_s* %end_"+readEnd.port)$

>>

Peek(peek) ::= <<
$LoadLocalPort(peek)$
$CallOp(result="%"+peek.target+"_"+peek.block.label, ty ="i8*", fnptrval="@getPeekPtr", function_args="%struct.fifo_s* %local_"+peek.target+peek.block.label+", i32 "+peek.numTokens)$
$BitcastOp(result="%"+peek.target+"_"+peek.block.label+"_cast", ty="i8*", value="%"+peek.target+"_"+peek.block.label, ty2=ExprType(peek.port)+"*")$
$StoreOp(ty=ExprType(peek.port)+"*", value="%"+peek.target+"_"+peek.block.label+"_cast", pty=ExprType(peek.port)+"*", pointer="%"+peek.port)$

>>

Write(write) ::= <<
$LoadLocalPort(write)$
$CallOp(result="%"+write.target+"_"+write.block.label, ty ="i8*", fnptrval="@getWritePtr", function_args="%struct.fifo_s* %local_"+write.target+write.block.label+", i32 "+write.numTokens)$
$BitcastOp(result="%"+write.target+"_"+write.block.label+"_cast", ty="i8*", value="%"+write.target+"_"+write.block.label, ty2=ExprType(write.port)+"*")$
$StoreOp(ty=ExprType(write.port)+"*", value="%"+write.target+"_"+write.block.label+"_cast", pty=ExprType(write.port)+"*", pointer="%"+write.port)$

>>

WriteEnd(writeEnd) ::= <<
$LoadOp(result="%end_"+writeEnd.port, ty="%struct.fifo_s*", pointer="@"+actorName+"_"+writeEnd.port)$
$CallOp(ty ="void", fnptrval="@setWriteEnd", function_args="%struct.fifo_s* %end_"+writeEnd.port)$

>>

Return(return) ::= <<
$if(return.value)$
$RetOp(type=return.value.type, value=Expr(return.value))$
$else$
$RetOp()$

$endif$

>>

HasTokens(hasTokens) ::= <<
$LoadLocalPort(hasTokens)$
$CallOp(result="%"+hasTokens.target+"32", ty="i32", fnptrval="@hasTokens", function_args="%struct.fifo_s* %local_"+hasTokens.port+hasTokens.block.label+", i32 "+hasTokens.numTokens)$
$TruncOp(result="%"+hasTokens.target, ty="i32", value="%"+hasTokens.target+"32", ty2="i1")$

>>

Store(store) ::= <<
$if(store.target.variable.port)$
$if(store.indexes.empty)$
$StorePortWithoutIndex(ty=store.value.type, value=store.value, pty=store.target.variable.type.elementType, pointer=Var(store.target), cast=store.cast)$
$else$
$StorePortWithIndex(ty=store.value.type, value=store.value, pty=store.target.variable.type.elementType, pointer=store.target, cast=store.cast, indexes=store.indexes, location=Location(store.location))$
$endif$
$else$
$if(store.indexes.empty)$
$StoreWithoutIndex(ty=store.value.type, value=store.value, pty=VarType(store.target), pointer=store.target, cast=store.cast, location=Location(store.location))$
$else$
$StoreWithIndex(ty=store.value.type, value=store.value, pty=store.target.variable.type, pointer=store.target, cast=store.cast, indexes=store.indexes, location=Location(store.location))$
$endif$
$endif$



>>

Load(load) ::= <<
$if(load.source.variable.port)$
$if(load.indexes.empty)$
$LoadPortWithoutIndex(result=load.target, ty=load.source.variable.type.elementType, pointer=load.source, cast= load.cast)$
$else$
$LoadPortWithIndex(result=load.target, ty=load.source.variable.type.elementType, indexes=load.indexes, pointer=load.source, cast= load.cast)$
$endif$
$else$
$if(load.indexes.empty)$
$LoadWithoutIndex(result="%"+load.target, ty=VarType(load.source), pointer=load.source, cast= load.cast)$
$else$
$LoadWithIndex(result="%"+load.target, ty=load.source.variable.type, pointer=load.source, indexes=load.indexes, cast= load.cast)$
$endif$
$endif$

>>
///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

// if node
IfNode(ifNode) ::= <<
$if(ifNode.thenNodes)$
$if(ifNode.elseNodes)$
$IfWithThenElseNodes(ifNode)$
$else$
$IfWithThenNode(ifNode)$	
	$endif$
$else$
	$if(ifNode.elseNodes)$
3
$endif$
$endif$
$nodes_cond(first(ifNode.joinNode))$
$nodes(rest(ifNode.joinNode))$

>>

// while node
WhileNode(whileNode) ::= <<
$BlockNode(whileNode.joinNode)$
	$BrOp(cond=Expr(whileNode.value), iftrue="%b"+label(whileNode.Nodes), iffalse="%b"+label(whileNode.joinNode.successors))$

b$label(whileNode.nodes)$:
$nodes_cond(first(whileNode.nodes))$
$nodes(rest(whileNode.nodes))$
	$BrOp(dest="%b"+label(whileNode.joinNode))$

b$label(whileNode.joinNode.successors)$:

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
	$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

nodes_cond(nodes) ::= <<
$nodes: {$(it.class.simpleName+"_cond")(it)$}$
>>

WhileNode_cond(nodes) ::= <<
$WhileNode(nodes)$
>>

IfNode_cond(nodes) ::= <<
$IfNode(nodes)$
>>


BlockNode_cond(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
BlockNode(blockNode) ::= <<
	$BrOp(dest="%b"+label(blockNode))$

b$label(blockNode)$:
$instructions(blockNode.instructions)$
>>



///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern, action) ::= <<
$if(rest(pattern.keys))$
	$AllocaOp(result="%p"+action+"_roomTest", type="i1")$
	$StoreOp(ty="i1", value="1", pty="i1", pointer="%p"+action+"_roomTest")$
$pattern.keys:{port|
	$HasRoom(result=action+i+"_room", action=action,  actor=actorName, port=port, numToken=pattern.(port))$
	$LoadOp(result="%"+action+i+"_roomTest", ty="i1", pointer="%p"+action+"_roomTest")$
	$AndOp(result="%"+action+i, ty="i1", op1="%"+action+i+"_room", op2="%"+action+i+"_roomTest")$
	$StoreOp(ty="i1", value="%"+action+i, pty="i1", pointer="%p"+action+"_roomTest")$
}$
	$LoadOp(result="%"+action+"_room", ty="i1", pointer="%p"+action+"_roomTest")$
$else$
$pattern.keys:{port|
	$HasRoom(result=action+"_room", action=action,  actor=actorName, port=port, numToken=pattern.(port))$}$
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM
///////////////////////////////////////////////////////////////////////////////
schedulerFSM(actions, fsm) ::= <<
@_FSM_state = internal global i32 $fsm.initialState.index$

$fsm.transitions: stateScheduler(transition=it); separator="\n"$

$if(actions)$
define internal i32 @outside_FSM_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	$StoreOp(ty="i32", value="0", pty="i32", pointer="%i")$
	$BrOp(dest="%bb")$
	
bb:  
$schedulingTest(actions)$
	$BrOp(dest="%return")$

inc_i:
  $LoadOp(result="%i_load", ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  $StoreOp(ty="i32", value="%i_add", pty="i32", pointer="%i")$
  $BrOp(dest="%bb")$

return:
	$LoadOp(result="%i_ret", ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}
$endif$

define i32 @$actorName$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	$StoreOp(ty="i32", value="0", pty="i32", pointer="%i")$
	$BrOp(dest="%bb")$

bb:
$if(actions)$
	$CallOp(result="%outside_FSM_res", ty="i32", fnptrval="@outside_FSM_scheduler")$
	$IcmpOp(result="%outside_FSM", cond="sgt", ty="i32", op1="%outside_FSM_res", op2="0")$
	$BrOp(cond="%outside_FSM", iftrue="%inc_i", iffalse="%fsm_state")$

fsm_state:

$endif$
$switch(fsm="_FSM_state", transitions=fsm.transitions)$


inc_i:
  $LoadOp(result="%i_load", ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  $StoreOp(ty="i32", value="%i_add", pty="i32", pointer="%i")$
  $BrOp(dest="%bb")$

return:
	$LoadOp(result="%i_ret", ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

stateScheduler(transition) ::= <<
define internal i1 @$transition.sourceState$_state_scheduler() {
entry:
$schedulingTestState(nextStates=transition.nextStateInfo)$	$BrOp(dest="%sched_nok")$

sched_ok:
	$RetOp(type="i1", value="1")$

sched_nok:	
	$RetOp(type="i1", value="0")$
}

>>

schedulingTestState(nextStates) ::= <<
$nextStates: actionTestState(it)$
>>

actionTestState(nextState) ::= <<
	$CallOp(result="%isSchedulable_"+nextState.action, ty="i1", fnptrval="@isSchedulable_"+nextState.action)$
	$BrOp(cond="%isSchedulable_"+nextState.action, iftrue="%fire_"+nextState.action, iffalse="%skip_"+nextState.action)$

fire_$nextState.action$:
$if(nextState.action.outputPattern)$
$actionTestStateOutputs(nextState)$
$else$
$actionCallState(nextState)$

	
$endif$

skip_$nextState.action$:

>>

actionTestStateOutputs(nextState) ::= <<
$outputPattern(pattern=nextState.action.outputPattern, action=nextState.action)$
	$BrOp(cond="%"+nextState.action+"_room", iftrue="%hasroom_"+nextState.action, iffalse="%sched_nok")$

hasroom_$nextState.action$:
$actionCallState(nextState)$
	
>>

actionCallState(nextState) ::= <<
	$CallOp(ty="void", fnptrval=nextState.action.body)$
	$StoreOp(ty="i32", value=nextState.targetState.index, pty="i32", pointer="@_FSM_state")$
	$BrOp(dest="%sched_ok")$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM
///////////////////////////////////////////////////////////////////////////////

scheduler(actions, iterator) ::= <<
define i32 @$actorName$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	$StoreOp(ty="i32", value="0", pty="i32", pointer="%i")$
	$BrOp(dest="%bb")$
	
bb:  
$if(actions)$
$schedulingTest(actions=actions)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  $LoadOp(result="%i_load", ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  $StoreOp(ty="i32", value="%i_add", pty="i32", pointer="%i")$
  $BrOp(dest="%bb")$

return:
	$LoadOp(result="%i_ret", ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

schedulingTest(actions) ::= <<
$actions: actionTest(action=it)$
>>

actionTest(action) ::= <<
	$CallOp(result="%isSchedulable_"+action, ty="i1", fnptrval="@isSchedulable_"+action)$
	$BrOp(cond="%isSchedulable_"+action, iftrue="%fire_"+action, iffalse="%skip_"+action)$

fire_$action$:
$if(action.outputPattern)$
$actionTestOutputs(action)$
$else$
$actionCall(action)$
	$BrOp(dest="%inc_i")$
$endif$
	
skip_$action$:

>>

actionCall(action) ::= <<
	$CallOp(ty="void", fnptrval=action.body)$
>>

actionTestOutputs(action) ::= <<
$outputPattern(pattern=action.outputPattern, action=action)$
	$BrOp(cond="%"+action+"_room", iftrue="%hasroom_"+action, iffalse="%skip_"+action)$

hasroom_$action$:
$actionCall(action)$
	$BrOp(dest="%inc_i")$
	
>>


///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

define internal $procedure.returnType$ $procedure$($procedure.parameters.list: {$argumentDeclaration(it)$}; wrap, anchor, separator=", "$) {
entry:
$if(procedure.locals.list)$
	$procedure.locals.list: variableDeclaration(it)$
	
$endif$
$trunc(procedure.nodes): {$(it.class.simpleName)(it)$}$
	$last(procedure.nodes): {$instructions(it.instructions)$}$}

>>


///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actorName, actor) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "$actor.name$"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
$actor.inputs.list: fifo(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
$actor.outputs.list: fifo(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
$actor.stateVars.list: stateVar(it)$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
$actor.procs.list: procedure(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
$actor.actions: action(it)$

$if(actor.initializes)$
;////////////////////////////////////////////////////////////////////////////////
;// Initializes
$actor.initializes: action(it)$
define i32 @$actorName$_initialize() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	$StoreOp(ty="i32", value="0", pty="i32", pointer="%i")$
	$BrOp(dest="%bb")$
	
bb:
$if(actor.initializes)$
$schedulingTest(actor.initializes)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  $LoadOp(result="%i_load", ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  $StoreOp(ty="i32", value="%i_add", pty="i32", pointer="%i")$
  $BrOp(dest="%return")$

return:
	$LoadOp(result="%i_ret", ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

$endif$

;////////////////////////////////////////////////////////////////////////////////
;// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$ 

$header()$
>>



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Headers! to be remove
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
header() ::= <<

%struct.fifo_s = type { i32, i32, i8*, i32, i32 }

define internal i8* @getPeekPtr(%struct.fifo_s* %fifo, i32 %n) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=4]
  %n_addr = alloca i32                            ; <i32*> [#uses=1]
  %retval = alloca i8*                            ; <i8**> [#uses=2]
  %0 = alloca i8*                                 ; <i8**> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  store i32 %n, i32* %n_addr
  %1 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %2 = getelementptr inbounds %struct.fifo_s* %1, i32 0, i32 2 ; <i8**> [#uses=1]
  %3 = load i8** %2, align 4                      ; <i8*> [#uses=1]
  %4 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %5 = getelementptr inbounds %struct.fifo_s* %4, i32 0, i32 3 ; <i32*> [#uses=1]
  %6 = load i32* %5, align 4                      ; <i32> [#uses=1]
  %7 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %8 = getelementptr inbounds %struct.fifo_s* %7, i32 0, i32 0 ; <i32*> [#uses=1]
  %9 = load i32* %8, align 4                      ; <i32> [#uses=1]
  %10 = mul i32 %6, %9                            ; <i32> [#uses=1]
  %11 = getelementptr inbounds i8* %3, i32 %10    ; <i8*> [#uses=1]
  store i8* %11, i8** %0, align 4
  %12 = load i8** %0, align 4                     ; <i8*> [#uses=1]
  store i8* %12, i8** %retval, align 4
  br label %return

return:                                           ; preds = %entry
  %retval1 = load i8** %retval                    ; <i8*> [#uses=1]
  ret i8* %retval1
}

define internal i8* @getReadPtr(%struct.fifo_s* %fifo, i32 %n) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=6]
  %n_addr = alloca i32                            ; <i32*> [#uses=2]
  %retval = alloca i8*                            ; <i8**> [#uses=2]
  %ptr = alloca i32                               ; <i32*> [#uses=2]
  %0 = alloca i8*                                 ; <i8**> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  store i32 %n, i32* %n_addr
  %1 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %2 = getelementptr inbounds %struct.fifo_s* %1, i32 0, i32 3 ; <i32*> [#uses=1]
  %3 = load i32* %2, align 4                      ; <i32> [#uses=1]
  store i32 %3, i32* %ptr, align 4
  %4 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %5 = getelementptr inbounds %struct.fifo_s* %4, i32 0, i32 3 ; <i32*> [#uses=1]
  %6 = load i32* %5, align 4                      ; <i32> [#uses=1]
  %7 = load i32* %n_addr, align 4                 ; <i32> [#uses=1]
  %8 = add nsw i32 %6, %7                         ; <i32> [#uses=1]
  %9 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %10 = getelementptr inbounds %struct.fifo_s* %9, i32 0, i32 3 ; <i32*> [#uses=1]
  store i32 %8, i32* %10, align 4
  %11 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %12 = getelementptr inbounds %struct.fifo_s* %11, i32 0, i32 2 ; <i8**> [#uses=1]
  %13 = load i8** %12, align 4                    ; <i8*> [#uses=1]
  %14 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %15 = getelementptr inbounds %struct.fifo_s* %14, i32 0, i32 0 ; <i32*> [#uses=1]
  %16 = load i32* %15, align 4                    ; <i32> [#uses=1]
  %17 = load i32* %ptr, align 4                   ; <i32> [#uses=1]
  %18 = mul i32 %16, %17                          ; <i32> [#uses=1]
  %19 = getelementptr inbounds i8* %13, i32 %18   ; <i8*> [#uses=1]
  store i8* %19, i8** %0, align 4
  %20 = load i8** %0, align 4                     ; <i8*> [#uses=1]
  store i8* %20, i8** %retval, align 4
  br label %return

return:                                           ; preds = %entry
  %retval1 = load i8** %retval                    ; <i8*> [#uses=1]
  ret i8* %retval1
}

define internal i32 @hasRoom(%struct.fifo_s* %fifo, i32 %n) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=14]
  %n_addr = alloca i32                            ; <i32*> [#uses=4]
  %retval = alloca i32                            ; <i32*> [#uses=2]
  %num_tokens = alloca i32                        ; <i32*> [#uses=6]
  %res = alloca i32                               ; <i32*> [#uses=4]
  %num_free = alloca i32                          ; <i32*> [#uses=2]
  %0 = alloca i32                                 ; <i32*> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  store i32 %n, i32* %n_addr
  %1 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %2 = getelementptr inbounds %struct.fifo_s* %1, i32 0, i32 1 ; <i32*> [#uses=1]
  %3 = load i32* %2, align 4                      ; <i32> [#uses=1]
  %4 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %5 = getelementptr inbounds %struct.fifo_s* %4, i32 0, i32 4 ; <i32*> [#uses=1]
  %6 = load i32* %5, align 4                      ; <i32> [#uses=1]
  %7 = sub i32 %3, %6                             ; <i32> [#uses=1]
  store i32 %7, i32* %num_free, align 4
  %8 = load i32* %num_free, align 4               ; <i32> [#uses=1]
  %9 = load i32* %n_addr, align 4                 ; <i32> [#uses=1]
  %10 = icmp sge i32 %8, %9                       ; <i1> [#uses=1]
  %11 = zext i1 %10 to i32                        ; <i32> [#uses=1]
  store i32 %11, i32* %res, align 4
  %12 = load i32* %res, align 4                   ; <i32> [#uses=1]
  %13 = icmp eq i32 %12, 0                        ; <i1> [#uses=1]
  br i1 %13, label %bb, label %bb4

bb:                                               ; preds = %entry
  %14 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %15 = getelementptr inbounds %struct.fifo_s* %14, i32 0, i32 4 ; <i32*> [#uses=1]
  %16 = load i32* %15, align 4                    ; <i32> [#uses=1]
  %17 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %18 = getelementptr inbounds %struct.fifo_s* %17, i32 0, i32 3 ; <i32*> [#uses=1]
  %19 = load i32* %18, align 4                    ; <i32> [#uses=1]
  %20 = sub i32 %16, %19                          ; <i32> [#uses=1]
  store i32 %20, i32* %num_tokens, align 4
  %21 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %22 = getelementptr inbounds %struct.fifo_s* %21, i32 0, i32 3 ; <i32*> [#uses=1]
  %23 = load i32* %22, align 4                    ; <i32> [#uses=1]
  %24 = load i32* %num_tokens, align 4            ; <i32> [#uses=1]
  %25 = load i32* %n_addr, align 4                ; <i32> [#uses=1]
  %26 = add nsw i32 %24, %25                      ; <i32> [#uses=1]
  %27 = icmp sge i32 %23, %26                     ; <i1> [#uses=1]
  br i1 %27, label %bb1, label %bb4

bb1:                                              ; preds = %bb
  %28 = load i32* %num_tokens, align 4            ; <i32> [#uses=1]
  %29 = icmp sgt i32 %28, 0                       ; <i1> [#uses=1]
  br i1 %29, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %30 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %31 = getelementptr inbounds %struct.fifo_s* %30, i32 0, i32 0 ; <i32*> [#uses=1]
  %32 = load i32* %31, align 4                    ; <i32> [#uses=1]
  %33 = load i32* %num_tokens, align 4            ; <i32> [#uses=1]
  %34 = mul i32 %32, %33                          ; <i32> [#uses=1]
  %35 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %36 = getelementptr inbounds %struct.fifo_s* %35, i32 0, i32 2 ; <i8**> [#uses=1]
  %37 = load i8** %36, align 4                    ; <i8*> [#uses=1]
  %38 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %39 = getelementptr inbounds %struct.fifo_s* %38, i32 0, i32 3 ; <i32*> [#uses=1]
  %40 = load i32* %39, align 4                    ; <i32> [#uses=1]
  %41 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %42 = getelementptr inbounds %struct.fifo_s* %41, i32 0, i32 0 ; <i32*> [#uses=1]
  %43 = load i32* %42, align 4                    ; <i32> [#uses=1]
  %44 = mul i32 %40, %43                          ; <i32> [#uses=1]
  %45 = getelementptr inbounds i8* %37, i32 %44   ; <i8*> [#uses=1]
  %46 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %47 = getelementptr inbounds %struct.fifo_s* %46, i32 0, i32 2 ; <i8**> [#uses=1]
  %48 = load i8** %47, align 4                    ; <i8*> [#uses=1]
  call void @llvm.memcpy.i32(i8* %48, i8* %45, i32 %34, i32 1)
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1
  %49 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %50 = getelementptr inbounds %struct.fifo_s* %49, i32 0, i32 3 ; <i32*> [#uses=1]
  store i32 0, i32* %50, align 4
  %51 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %52 = getelementptr inbounds %struct.fifo_s* %51, i32 0, i32 4 ; <i32*> [#uses=1]
  %53 = load i32* %num_tokens, align 4            ; <i32> [#uses=1]
  store i32 %53, i32* %52, align 4
  %54 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %55 = getelementptr inbounds %struct.fifo_s* %54, i32 0, i32 1 ; <i32*> [#uses=1]
  %56 = load i32* %55, align 4                    ; <i32> [#uses=1]
  %57 = load i32* %num_tokens, align 4            ; <i32> [#uses=1]
  %58 = sub i32 %56, %57                          ; <i32> [#uses=1]
  %59 = load i32* %n_addr, align 4                ; <i32> [#uses=1]
  %60 = icmp sge i32 %58, %59                     ; <i1> [#uses=1]
  %61 = zext i1 %60 to i32                        ; <i32> [#uses=1]
  store i32 %61, i32* %res, align 4
  br label %bb4

bb4:                                              ; preds = %bb3, %bb, %entry
  %62 = load i32* %res, align 4                   ; <i32> [#uses=1]
  store i32 %62, i32* %0, align 4
  %63 = load i32* %0, align 4                     ; <i32> [#uses=1]
  store i32 %63, i32* %retval, align 4
  br label %return

return:                                           ; preds = %bb4
  %retval5 = load i32* %retval                    ; <i32> [#uses=1]
  ret i32 %retval5
}

declare void @llvm.memcpy.i32(i8* nocapture, i8* nocapture, i32, i32) nounwind

define internal i32 @hasTokens(%struct.fifo_s* %fifo, i32 %n) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=5]
  %n_addr = alloca i32                            ; <i32*> [#uses=2]
  %retval = alloca i32                            ; <i32*> [#uses=2]
  %res = alloca i32                               ; <i32*> [#uses=3]
  %num_tokens = alloca i32                        ; <i32*> [#uses=3]
  %0 = alloca i32                                 ; <i32*> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  store i32 %n, i32* %n_addr
  %1 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %2 = getelementptr inbounds %struct.fifo_s* %1, i32 0, i32 4 ; <i32*> [#uses=1]
  %3 = load i32* %2, align 4                      ; <i32> [#uses=1]
  %4 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %5 = getelementptr inbounds %struct.fifo_s* %4, i32 0, i32 3 ; <i32*> [#uses=1]
  %6 = load i32* %5, align 4                      ; <i32> [#uses=1]
  %7 = sub i32 %3, %6                             ; <i32> [#uses=1]
  store i32 %7, i32* %num_tokens, align 4
  %8 = load i32* %num_tokens, align 4             ; <i32> [#uses=1]
  %9 = load i32* %n_addr, align 4                 ; <i32> [#uses=1]
  %10 = icmp sge i32 %8, %9                       ; <i1> [#uses=1]
  %11 = zext i1 %10 to i32                        ; <i32> [#uses=1]
  store i32 %11, i32* %res, align 4
  %12 = load i32* %res, align 4                   ; <i32> [#uses=1]
  %13 = icmp eq i32 %12, 0                        ; <i1> [#uses=1]
  br i1 %13, label %bb, label %bb2

bb:                                               ; preds = %entry
  %14 = load i32* %num_tokens, align 4            ; <i32> [#uses=1]
  %15 = icmp eq i32 %14, 0                        ; <i1> [#uses=1]
  br i1 %15, label %bb1, label %bb2

bb1:                                              ; preds = %bb
  %16 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %17 = getelementptr inbounds %struct.fifo_s* %16, i32 0, i32 3 ; <i32*> [#uses=1]
  store i32 0, i32* %17, align 4
  %18 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %19 = getelementptr inbounds %struct.fifo_s* %18, i32 0, i32 4 ; <i32*> [#uses=1]
  store i32 0, i32* %19, align 4
  br label %bb2

bb2:                                              ; preds = %bb1, %bb, %entry
  %20 = load i32* %res, align 4                   ; <i32> [#uses=1]
  store i32 %20, i32* %0, align 4
  %21 = load i32* %0, align 4                     ; <i32> [#uses=1]
  store i32 %21, i32* %retval, align 4
  br label %return

return:                                           ; preds = %bb2
  %retval3 = load i32* %retval                    ; <i32> [#uses=1]
  ret i32 %retval3
}

define internal i8* @getWritePtr(%struct.fifo_s* %fifo, i32 %n) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=6]
  %n_addr = alloca i32                            ; <i32*> [#uses=2]
  %retval = alloca i8*                            ; <i8**> [#uses=2]
  %ptr = alloca i32                               ; <i32*> [#uses=2]
  %0 = alloca i8*                                 ; <i8**> [#uses=2]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  store i32 %n, i32* %n_addr
  %1 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %2 = getelementptr inbounds %struct.fifo_s* %1, i32 0, i32 4 ; <i32*> [#uses=1]
  %3 = load i32* %2, align 4                      ; <i32> [#uses=1]
  store i32 %3, i32* %ptr, align 4
  %4 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %5 = getelementptr inbounds %struct.fifo_s* %4, i32 0, i32 4 ; <i32*> [#uses=1]
  %6 = load i32* %5, align 4                      ; <i32> [#uses=1]
  %7 = load i32* %n_addr, align 4                 ; <i32> [#uses=1]
  %8 = add nsw i32 %6, %7                         ; <i32> [#uses=1]
  %9 = load %struct.fifo_s** %fifo_addr, align 4  ; <%struct.fifo_s*> [#uses=1]
  %10 = getelementptr inbounds %struct.fifo_s* %9, i32 0, i32 4 ; <i32*> [#uses=1]
  store i32 %8, i32* %10, align 4
  %11 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %12 = getelementptr inbounds %struct.fifo_s* %11, i32 0, i32 2 ; <i8**> [#uses=1]
  %13 = load i8** %12, align 4                    ; <i8*> [#uses=1]
  %14 = load %struct.fifo_s** %fifo_addr, align 4 ; <%struct.fifo_s*> [#uses=1]
  %15 = getelementptr inbounds %struct.fifo_s* %14, i32 0, i32 0 ; <i32*> [#uses=1]
  %16 = load i32* %15, align 4                    ; <i32> [#uses=1]
  %17 = load i32* %ptr, align 4                   ; <i32> [#uses=1]
  %18 = mul i32 %16, %17                          ; <i32> [#uses=1]
  %19 = getelementptr inbounds i8* %13, i32 %18   ; <i8*> [#uses=1]
  store i8* %19, i8** %0, align 4
  %20 = load i8** %0, align 4                     ; <i8*> [#uses=1]
  store i8* %20, i8** %retval, align 4
  br label %return

return:                                           ; preds = %entry
  %retval1 = load i8** %retval                    ; <i8*> [#uses=1]
  ret i8* %retval1
}

define internal void @setWriteEnd(%struct.fifo_s* %fifo) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=1]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  br label %return

return:                                           ; preds = %entry
  ret void
}

define internal void @setReadEnd(%struct.fifo_s* %fifo) nounwind {
entry:
  %fifo_addr = alloca %struct.fifo_s*             ; <%struct.fifo_s**> [#uses=1]
  %"alloca point" = bitcast i32 0 to i32          ; <i32> [#uses=0]
  store %struct.fifo_s* %fifo, %struct.fifo_s** %fifo_addr
  br label %return

return:                                           ; preds = %entry
  ret void
}
>>
