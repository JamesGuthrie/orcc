///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPatternRoom(port, portNumber) ::= <<
$HasRoom(result={$action$$portNumber$_room}, action=action, port=port, numToken=pattern.(port))$
%$action$$portNumber$_roomTest = $LoadOp(ty="i1", pointer={%p$action$_roomTest})$
$AndOp(result={%$action$$portNumber$}, ty="i1", op1={%$action$$portNumber$_room}, op2={%$action$$portNumber$_roomTest})$
store i1 %$action$$portNumber$, i1* %p$action$_roomTest
>>

outputPattern(pattern, action) ::= <<
$if(rest(pattern.keys))$
	$AllocaOp(result={%p$action$_roomTest}, type="i1")$
	store i1 1, i1* %p$action$_roomTest
	$pattern.keys: {$outputPatternRoom(port=it, portNumber=i)$}$
	%$action$_room = $LoadOp(ty="i1", pointer={%p$action$_roomTest})$
$else$
$pattern.keys:{port|
	$HasRoom(result={$action$_room}, action=action, port=port, numToken=pattern.(port))$}$
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM
///////////////////////////////////////////////////////////////////////////////

states(transitions) ::= <<

$transitions:{$\t$i32 $it.sourceState.index$, label %s_$it.sourceState$$\n$}$
>>

SwitchOp(intty, value, defaultdest, labelpairs) ::= <<
switch $intty$ $value$, label $defaultdest$ [ $labelpairs$ ]
>>

switch(fsm, transitions) ::= <<
	%$fsm$ = $LoadOp(ty="i32", pointer={@$fsm$})$
	$SwitchOp(intty="i32", value={%$fsm$}, defaultdest="%default", labelpairs=states(transitions))$
$transitions: switchTransition()$
default:
	$BrOp(dest="%return")$

>>

switchTransition(transition) ::= <<

s_$transition.sourceState$:
	%$transition.sourceState$_res = $CallOp(ty="i1", fnptrval={@$transition.sourceState$_state_scheduler})$
	$BrOp(cond={%$transition.sourceState$_res}, iftrue="%inc_i", iffalse="%return")$
>>

schedulerFSM(actions, fsm) ::= <<
@_FSM_state = internal global i32 $fsm.initialState.index$

$fsm.transitions: stateScheduler(); separator="\n"$

$if(actions)$
define internal i32 @outside_FSM_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$
	
bb:  
$schedulingTest(actions)$
	$BrOp(dest="%return")$

inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%bb")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}
$endif$

define i32 @$actor.name$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$

bb:
$if(actions)$
	%outside_FSM_res = $CallOp(ty="i32", fnptrval="@outside_FSM_scheduler")$
	$IcmpOp(result="%outside_FSM", cond="sgt", ty="i32", op1="%outside_FSM_res", op2="0")$
	$BrOp(cond="%outside_FSM", iftrue="%inc_i", iffalse="%fsm_state")$

fsm_state:

$endif$
$switch(fsm="_FSM_state", transitions=fsm.transitions)$


inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%bb")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

stateScheduler(transition) ::= <<
define internal i1 @$transition.sourceState$_state_scheduler() {
entry:
$schedulingTestState(nextStates=transition.nextStateInfo)$	$BrOp(dest="%sched_nok")$

sched_ok:
	$RetOp(type="i1", value="1")$

sched_nok:	
	$RetOp(type="i1", value="0")$
}

>>

schedulingTestState(nextStates) ::= <<
$nextStates: actionTestState()$
>>

actionTestState(nextState) ::= <<
	%isSchedulable_$nextState.action$ = $CallOp(ty="i1", fnptrval={@isSchedulable_$nextState.action$})$
	$BrOp(cond={%isSchedulable_$nextState.action$}, iftrue={%fire_$nextState.action$}, iffalse={%skip_$nextState.action$})$

fire_$nextState.action$:
$if(nextState.action.outputPattern)$
$actionTestStateOutputs(nextState)$
$else$
$actionCallState(nextState)$

	
$endif$

skip_$nextState.action$:

>>

actionTestStateOutputs(nextState) ::= <<
$outputPattern(pattern=nextState.action.outputPattern, action=nextState.action)$
	$BrOp(cond={%$nextState.action$_room}, iftrue={%hasroom_$nextState.action$}, iffalse="%sched_nok")$

hasroom_$nextState.action$:
$actionCallState(nextState)$
	
>>

actionCallState(nextState) ::= <<
	$CallOp(ty="void", fnptrval=nextState.action.body)$
	store i32 $nextState.targetState.index$, i32* @_FSM_state
	$BrOp(dest="%sched_ok")$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM
///////////////////////////////////////////////////////////////////////////////

scheduler(actions, iterator) ::= <<
define i32 @$actor.name$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$
	
bb:  
$if(actions)$
$schedulingTest(actions=actions)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%bb")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

schedulingTest(actions) ::= <<
$actions:{$actionTest(action=it)$}$
>>

actionTest(action) ::= <<
	%isSchedulable_$action$ = $CallOp(ty="i1", fnptrval={@isSchedulable_$action$})$
	$BrOp(cond={%isSchedulable_$action$}, iftrue={%fire_$action$}, iffalse={%skip_$action$})$

fire_$action$:
$if(action.outputPattern)$
$actionTestOutputs(action)$
$else$
$actionCall(action)$
	$BrOp(dest="%inc_i")$
$endif$
	
skip_$action$:

>>

actionCall(action) ::= <<
	$CallOp(ty="void", fnptrval=action.body)$
>>

actionTestOutputs(action) ::= <<
$outputPattern(pattern=action.outputPattern, action=action)$
	$BrOp(cond={%$action$_room}, iftrue={%hasroom_$action$}, iffalse={%skip_$action$})$

hasroom_$action$:
$actionCall(action)$
	$BrOp(dest="%inc_i")$
	
>>


///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

define internal $procedure.returnType$ $procedure$($procedure.parameters.list: argumentDeclaration(); wrap, anchor, separator=", "$) {
entry:
$if(procedure.locals.list)$
	$procedure.locals.list: variableDeclaration()$
$endif$
$Nodes(trunc(procedure.nodes))$
$Node(last(procedure.nodes))$
}

>>

///////////////////////////////////////////////////////////////////////////////
// Parameters
///////////////////////////////////////////////////////////////////////////////

actorParameter(parameter) ::= <<
@$parameter$ = constant $parameter.type$ undef

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "$actor.name$"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
$actor.inputs.list: fifo()$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
$actor.outputs.list: fifo()$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
$actor.parameters.list: actorParameter()$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
$actor.stateVars.list: stateVar()$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
$actor.procs.list: procedure()$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
$actor.actions: action()$

$if(actor.initializes)$
;////////////////////////////////////////////////////////////////////////////////
;// Initializes
$actor.initializes: action()$
define i32 @$actor.name$_initialize() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$
	
bb:
$if(actor.initializes)$
$schedulingTest(actor.initializes)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%return")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

$endif$

;////////////////////////////////////////////////////////////////////////////////
;// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$ 

$header()$
>>
