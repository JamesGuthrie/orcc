///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern, action) ::= <<
$if(rest(pattern.keys))$
	$AllocaOp(result={%p$action$_roomTest}, type="i1")$
	store i1 1, i1* %p$action$_roomTest
$pattern.keys:{port|
	$HasRoom(result={$action$$i$_room}, action=action,  actor=actorName, port=port, numToken=pattern.(port))$
	%$action$$i$_roomTest = $LoadOp(ty="i1", pointer={%p$action$_roomTest})$
	$AndOp(result={%$action$$i$}, ty="i1", op1={%$action$$i$_room}, op2={%$action$$i$_roomTest})$
	store i1 %$action$$i$, i1* %p$action$_roomTest
}$
	%$action$_room = $LoadOp(ty="i1", pointer={%p$action$_roomTest})$
$else$
$pattern.keys:{port|
	$HasRoom(result={$action$_room}, action=action,  actor=actorName, port=port, numToken=pattern.(port))$}$
$endif$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM
///////////////////////////////////////////////////////////////////////////////
schedulerFSM(actions, fsm) ::= <<
@_FSM_state = internal global i32 $fsm.initialState.index$

$fsm.transitions: {$stateScheduler(transition=it)$}; separator="\n"$

$if(actions)$
define internal i32 @outside_FSM_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$
	
bb:  
$schedulingTest(actions)$
	$BrOp(dest="%return")$

inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%bb")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}
$endif$

define i32 @$actorName$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$

bb:
$if(actions)$
	$CallOp(result="%outside_FSM_res", ty="i32", fnptrval="@outside_FSM_scheduler")$
	$IcmpOp(result="%outside_FSM", cond="sgt", ty="i32", op1="%outside_FSM_res", op2="0")$
	$BrOp(cond="%outside_FSM", iftrue="%inc_i", iffalse="%fsm_state")$

fsm_state:

$endif$
$switch(fsm="_FSM_state", transitions=fsm.transitions)$


inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%bb")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

stateScheduler(transition) ::= <<
define internal i1 @$transition.sourceState$_state_scheduler() {
entry:
$schedulingTestState(nextStates=transition.nextStateInfo)$	$BrOp(dest="%sched_nok")$

sched_ok:
	$RetOp(type="i1", value="1")$

sched_nok:	
	$RetOp(type="i1", value="0")$
}

>>

schedulingTestState(nextStates) ::= <<
$nextStates: {$actionTestState(it)$}$
>>

actionTestState(nextState) ::= <<
	$CallOp(result={%isSchedulable_$nextState.action$}, ty="i1", fnptrval={@isSchedulable_$nextState.action$})$
	$BrOp(cond={%isSchedulable_$nextState.action$}, iftrue={%fire_$nextState.action$}, iffalse={%skip_$nextState.action$})$

fire_$nextState.action$:
$if(nextState.action.outputPattern)$
$actionTestStateOutputs(nextState)$
$else$
$actionCallState(nextState)$

	
$endif$

skip_$nextState.action$:

>>

actionTestStateOutputs(nextState) ::= <<
$outputPattern(pattern=nextState.action.outputPattern, action=nextState.action)$
	$BrOp(cond={%$nextState.action$_room}, iftrue={%hasroom_$nextState.action$}, iffalse="%sched_nok")$

hasroom_$nextState.action$:
$actionCallState(nextState)$
	
>>

actionCallState(nextState) ::= <<
	$CallOp(ty="void", fnptrval=nextState.action.body)$
	store i32 $nextState.targetState.index$, i32* @_FSM_state
	$BrOp(dest="%sched_ok")$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM
///////////////////////////////////////////////////////////////////////////////

scheduler(actions, iterator) ::= <<
define i32 @$actorName$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$
	
bb:  
$if(actions)$
$schedulingTest(actions=actions)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%bb")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

schedulingTest(actions) ::= <<
$actions:{$actionTest(action=it)$}$
>>

actionTest(action) ::= <<
	$CallOp(result={%isSchedulable_$action$}, ty="i1", fnptrval={@isSchedulable_$action$})$
	$BrOp(cond={%isSchedulable_$action$}, iftrue={%fire_$action$}, iffalse={%skip_$action$})$

fire_$action$:
$if(action.outputPattern)$
$actionTestOutputs(action)$
$else$
$actionCall(action)$
	$BrOp(dest="%inc_i")$
$endif$
	
skip_$action$:

>>

actionCall(action) ::= <<
	$CallOp(ty="void", fnptrval=action.body)$
>>

actionTestOutputs(action) ::= <<
$outputPattern(pattern=action.outputPattern, action=action)$
	$BrOp(cond={%$action$_room}, iftrue={%hasroom_$action$}, iffalse={%skip_$action$})$

hasroom_$action$:
$actionCall(action)$
	$BrOp(dest="%inc_i")$
	
>>


///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

define internal $procedure.returnType$ $procedure$($procedure.parameters.list: {$argumentDeclaration(it)$}; wrap, anchor, separator=", "$) {
entry:
$if(procedure.locals.list)$
	$procedure.locals.list:{$variableDeclaration(it)$}$
	
$endif$
$trunc(procedure.nodes): {$(it.class.simpleName)(it)$}$
	$last(procedure.nodes): {$instructions(it.instructions)$}$}

>>


///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actorName, actor) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "$actor.name$"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
$actor.inputs.list:{$fifo(it)$}$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
$actor.outputs.list:{$fifo(it)$}$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
$actor.stateVars.list:{$stateVar(it)$}$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
$actor.procs.list:{$procedure(it)$}$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
$actor.actions:{$action(it)$}$

$if(actor.initializes)$
;////////////////////////////////////////////////////////////////////////////////
;// Initializes
$actor.initializes:{$action(it)$}$
define i32 @$actorName$_initialize() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	store i32 0, i32* %i
	$BrOp(dest="%bb")$
	
bb:
$if(actor.initializes)$
$schedulingTest(actor.initializes)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  %i_load = $LoadOp(ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  store i32 %i_add, i32* %i
  $BrOp(dest="%return")$

return:
	%i_ret = $LoadOp(ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

$endif$

;////////////////////////////////////////////////////////////////////////////////
;// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$ 

$header()$
>>
