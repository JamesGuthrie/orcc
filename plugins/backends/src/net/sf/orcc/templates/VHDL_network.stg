group VHDL_network;

///////////////////////////////////////////////////////////////////////////////
// print signals()

printSig(instance) ::= <<
$if (instance.actor)$
$instance.actor.inputs.list: printSigInput(it)$
$instance.actor.outputs.list: printSigOutput(it)$
$endif$
>>

printSigInput(it) ::= <<
$if(it.type.bool)$
signal $instance.actor$_$it$_data_in   : std_logic;$\n$
$else$
signal $instance.actor$_$it$_data_in   : std_logic_vector($it.type.size$ - 1 downto 0);$\n$
$endif$
signal $instance.actor$_$it$_read      : std_logic;
signal $instance.actor$_$it$_empty     : std_logic;

>>

printSigOutput(it) ::= <<
$if(it.type.bool)$
signal $instance.actor$_$it$_data_out   : std_logic;$\n$
$else$
signal $instance.actor$_$it$_data_out   : std_logic_vector($it.type.size$ - 1 downto 0);$\n$
$endif$
signal $instance.actor$_$it$_full       : std_logic;
signal $instance.actor$_$it$_write      : std_logic;

>> 

printSignals(instances) ::= <<
$instances: printSig()$

>>


///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

assignFifo(source, sourcePort, target, targetPort, count) ::= <<
fifo_$count$ : entity work.fifo_generic 
generic map (
depth => FIFO_DEPTH,
$if(targetPort.type.bool)$
width => 0)$\n$
$else$
width => $targetPort.type.size$)$\n$
$endif$
port map (
  write_data => $source.id$_$sourcePort.name$_write, 
$if(targetPort.type.bool)$ 
  data_in(0) => $source.id$_$sourcePort.name$_data_out,$\n$
$else$
  data_in    => $source.id$_$sourcePort.name$_data_out,$\n$
$endif$
  full       => $source.id$_$sourcePort.name$_full, 
  read_data  => $target.id$_$targetPort.name$_read, 
$if(targetPort.type.bool)$ 
  data_out(0)=> $target.id$_$targetPort.name$_data_in,$\n$
$else$
  data_out   => $target.id$_$targetPort.name$_data_in,$\n$
$endif$
  empty      => $target.id$_$targetPort.name$_empty, 
  clock_in   => clock, 
  clock_out  => clock, 
  reset_n    => reset_n); 


>>

assignIn(source, sourcePort) ::= <<
$network$_$tgt.port$_data   <= $source.id$_$sourcePort.name$_data_out;
$network$_$tgt.port$_write   <= $source.id$_$sourcePort.name$_write;
$source.id$_$sourcePort.name$_full   <= $network$_$tgt.port$_full;

>>

assignOut(target, targetPort) ::= <<
$target.id$_$targetPort.name$_data_in <= $network$_$src.port$_data;
$target.id$_$targetPort.name$_empty <= $network$_$src.port$_empty;
$network$_$src.port$_read <= $target.id$_$targetPort.name$_read;


>>

tryAssignFifo(edge, src, tgt) ::= <<
$if (src.instance)$
  $if (tgt.instance)$
$assignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))$
  $else$ 
$assignIn(source=src.instance, sourcePort=edge.source)$
  $endif$
$else$
  $if (tgt.instance)$
$assignOut(target=tgt.instance, targetPort=edge.target)$
  $endif$
$endif$
>>

assignFifos(edges) ::= <<
$edges: tryAssignFifo(
  edge=it, src=network.sourceMap.(it), tgt=network.targetMap.(it)) $
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of the TOP Network

printNetworkPorts(network) ::= <<
$network.inputs.list: printNetPortsInput(it); separator="\n"$
$network.outputs.list: printNetPortsOutput(it); separator="\n"$
>>

printNetPortsInput(it) ::= <<
$if(it.type.bool)$
$network$_$it$_data    : in  std_logic;$\n$
$else$
$network$_$it$_data    : in  std_logic_vector($it.type.size$ - 1 downto 0);$\n$
$endif$
$network$_$it$_empty   : in  std_logic;
$network$_$it$_read    : out std_logic;
>>

printNetPortsOutput(it) ::= <<
$if(it.type.bool)$
$network$_$it$_data   : out std_logic;$\n$
$else$
$network$_$it$_data   : out std_logic_vector($it.type.size$ - 1 downto 0);$\n$
$endif$
$network$_$it$_write      : out std_logic;
$network$_$it$_full       : in  std_logic;
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of the Networks

printNetworksPorts(network) ::= <<
$network.inputs.list: printNetsInput(it); separator="\n"$
$network.outputs.list: printNetsOutput(it); separator="\n"$
>>

printNetsInput(it) ::= <<
$network$_$it$_data   => $network$_$it$_data_in,
$network$_$it$_read   => $network$_$it$_read,
$network$_$it$_empty  => $network$_$it$_empty,
>>

printNetsOutput(it) ::= <<
$network$_$it$_data   => $network$_$it$_data_out,
$network$_$it$_full   => $network$_$it$_full,
$network$_$it$_write  => $network$_$it$_write,
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of the actors

printActorPorts(instance) ::= <<
$instance.actor.inputs.list: printPortsInput(it); separator="\n"$
$instance.actor.outputs.list: printPortsOutput(it); separator="\n"$
>>

printPortsInput(it) ::= <<
$instance.actor$_$it$_data   => $instance.actor$_$it$_data_in,
$instance.actor$_$it$_read   => $instance.actor$_$it$_read,
$instance.actor$_$it$_empty  => $instance.actor$_$it$_empty,
>>

printPortsOutput(it) ::= <<
$instance.actor$_$it$_data   => $instance.actor$_$it$_data_out,
$instance.actor$_$it$_full   => $instance.actor$_$it$_full,
$instance.actor$_$it$_write  => $instance.actor$_$it$_write,
>> 

///////////////////////////////////////////////////////////////////////////////
// print actors and networks

printActor(instance) ::= <<
$if (instance.actor)$
$if (!instance.actor.system)$

$it.id$ : entity work.$it.actor$
  port map (
    $printActorPorts(instance)$
    clock            => clock, 
    reset_n          => reset_n);

$endif$
$endif$
>>

printNetwork(instance) ::= <<
$if (!instance.actor)$

$it.id$ : entity work.$it.network$
  generic map (
    FIFO_DEPTH       => FIFO_DEPTH) 
  port map (
    $printNetworksPorts(it.network)$
    clock            => clock, 
    reset_n          => reset_n);

$endif$
>>

printNetAct(instances) ::= <<
$instances: printActor()$
$instances: printNetwork()$

>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network) ::= <<
------------------------------------------------------------------------------
-- Generated from $network.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity $network.name$ is
  generic (
  FIFO_DEPTH : integer := $fifoSize$;
  );
  port (
    $printNetworkPorts(network)$
    clock   : in std_logic;
    reset_n : in std_logic);  
end $network.name$;


architecture rtl_$network.name$ of $network.name$ is

  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  $printSignals(network.instances); separator="\n"$
  ---------------------------------------------------------------------------

begin

  ---------------------------------------------------------------------------
  -- Actors and Networks instantiation 
  ---------------------------------------------------------------------------
  $printNetAct(network.instances); separator="\n"$

  ---------------------------------------------------------------------------
  -- FIFOs instantiation 
  ---------------------------------------------------------------------------  
  $assignFifos(network.connections)$ 
  ---------------------------------------------------------------------------

end architecture rtl_$network.name$;
>>

