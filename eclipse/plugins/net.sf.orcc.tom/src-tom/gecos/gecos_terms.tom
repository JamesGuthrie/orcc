// Primitive terminals (enum and data types)

%typeterm Types {
	implement 		{Types}
	is_sort(t) 		{$t instanceof Types}
	equals(l1,l2) 	{$l1==$l2}
}

%typeterm Kinds {
	implement 		{Kinds}
	is_sort(t) 		{$t instanceof Kinds}
	equals(l1,l2) 	{$l1==$l2}
}

%typeterm OverflowMode {
	implement 		{OverflowMode}
	is_sort(t) 		{$t instanceof OverflowMode}
	equals(l1,l2) 	{$l1==$l2}
}

%typeterm QuantificationMode {
	implement 		{QuantificationMode}
	is_sort(t) 		{$t instanceof QuantificationMode}
	equals(l1,l2) 	{$l1==$l2}
}

%typeterm BranchType {
	implement 		{BranchType}
	is_sort(t) 		{$t instanceof BranchType}
	equals(l1,l2) 	{$l1==$l2}
}

    
// Terminals
%typeterm Inst {
	implement 		{Instruction}
	is_sort(t) 		{$t instanceof Instruction}
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}


%typeterm Blk {
	implement 		{Block}
	is_sort(t) 		{$t instanceof Block}
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}


%typeterm Sym {
	implement 		{Symbol}
	is_sort(t) 		{$t instanceof Symbol}
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}


%typeterm Type {
	implement 		{Type}
	is_sort(t) 		{$t instanceof Type}
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}


%typeterm Proc {
	implement 		{Procedure}
	is_sort(t) 		{$t instanceof Procedure}
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}



%typeterm SymL{
	 implement { EList<Symbol> }
     is_sort(t) 					{ $t instanceof EList<?> && 
                           (((EList<Symbol>)$t).size() == 0 
                         || (((EList<Symbol>)$t).size()>0 && ((EList<Symbol>)$t).get(0) instanceof Symbol))} 
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}

/*PROTECTED REGION ID(fcall_tom_operator_with_param) ENABLED START*/

%op Sym symbDef(name: String){
	is_fsym(t) {$t instanceof Symbol}
	get_slot(name,t) {(((Symbol)$t).getName())}
	make(_children) {fr.irisa.cairn.gecos.model.tom.gecos.internal.GecosTomFactory.createSym($_children)}
}

%op Sym funcSymbDef(name: String){
	is_fsym(t) {$t instanceof ProcedureSymbol}
	get_slot(name,t) {(((Symbol)$t).getName())}
	make(_children) {fr.irisa.cairn.gecos.model.tom.gecos.internal.GecosTomFactory.createProcedureSym($_children)}
}

/*PROTECTED REGION END*/

%oparray SymL SymL (Sym*) {
 	 is_fsym(t) 					{ $t instanceof EList<?> && 
                           (((EList<Symbol>)$t).size() == 0 
                         || (((EList<Symbol>)$t).size()>0 && ((EList<Symbol>)$t).get(0) instanceof Symbol))} 
     make_empty(n) { new BasicEList<Symbol>($n) }
     make_append(e,l) { append($e,$l) }
     get_element(l,n) { $l.get($n) }
     get_size(l)      { $l.size() }
}



%typeterm InstL{
	 implement { EList<Instruction> }
     is_sort(t) 					{ $t instanceof EList<?> && 
                           (((EList<Instruction>)$t).size() == 0 
                         || (((EList<Instruction>)$t).size()>0 && ((EList<Instruction>)$t).get(0) instanceof Instruction))} 
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}

%oparray InstL InstL (Inst*) {
 	 is_fsym(t) 					{ $t instanceof EList<?> && 
                           (((EList<Instruction>)$t).size() == 0 
                         || (((EList<Instruction>)$t).size()>0 && ((EList<Instruction>)$t).get(0) instanceof Instruction))} 
     make_empty(n) { new BasicEList<Instruction>($n) }
     make_append(e,l) { append($e,$l) }
     get_element(l,n) { $l.get($n) }
     get_size(l)      { $l.size() }
}



%typeterm TypeL{
	 implement { EList<Type> }
     is_sort(t) 					{ $t instanceof EList<?> && 
                           (((EList<Type>)$t).size() == 0 
                         || (((EList<Type>)$t).size()>0 && ((EList<Type>)$t).get(0) instanceof Type))} 
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}

%oparray TypeL TypeL (Type*) {
 	 is_fsym(t) 					{ $t instanceof EList<?> && 
                           (((EList<Type>)$t).size() == 0 
                         || (((EList<Type>)$t).size()>0 && ((EList<Type>)$t).get(0) instanceof Type))} 
     make_empty(n) { new BasicEList<Type>($n) }
     make_append(e,l) { append($e,$l) }
     get_element(l,n) { $l.get($n) }
     get_size(l)      { $l.size() }
}



%typeterm BlkL{
	 implement { EList<Block> }
     is_sort(t) 					{ $t instanceof EList<?> && 
                           (((EList<Block>)$t).size() == 0 
                         || (((EList<Block>)$t).size()>0 && ((EList<Block>)$t).get(0) instanceof Block))} 
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}

%oparray BlkL BlkL (Blk*) {
 	 is_fsym(t) 					{ $t instanceof EList<?> && 
                           (((EList<Block>)$t).size() == 0 
                         || (((EList<Block>)$t).size()>0 && ((EList<Block>)$t).get(0) instanceof Block))} 
     make_empty(n) { new BasicEList<Block>($n) }
     make_append(e,l) { append($e,$l) }
     get_element(l,n) { $l.get($n) }
     get_size(l)      { $l.size() }
}


// List Terminals


%typeterm ProcListList{
	 implement { EList<Procedure> }
     is_sort(t) 					{ $t instanceof EList<?> && 
                           (((EList<Procedure>)$t).size() == 0 
                         || (((EList<Procedure>)$t).size()>0 && ((EList<Procedure>)$t).get(0) instanceof Procedure))} 
	equals(l1,l2) 	{($l1!=null && $l1.equals($l2)) || $l1==$l2}
}

%oparray ProcListList ProcListList (Proc*) {
 	 is_fsym(t) 					{ $t instanceof EList<?> && 
                           (((EList<Procedure>)$t).size() == 0 
                         || (((EList<Procedure>)$t).size()>0 && ((EList<Procedure>)$t).get(0) instanceof Procedure))} 
     make_empty(n) { new BasicEList<Procedure>($n) }
     make_append(e,l) { append($e,$l) }
     get_element(l,n) { $l.get($n) }
     get_size(l)      { $l.size() }
}


