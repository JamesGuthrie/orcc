package net.sf.orcc.tom.transform;

import java.util.*;
import tom.library.sl.*;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.*;

import net.sf.orcc.df.*;
import net.sf.orcc.ir.*;
import net.sf.orcc.util.OrccLogger;

public class LiteralIntegersAdder {

	private static boolean tom_equal_term_Strategy(Object t1, Object t2) {return  (t1.equals(t2)) ;}private static boolean tom_is_sort_Strategy(Object t) {return  (t instanceof tom.library.sl.Strategy) ;} private static boolean tom_equal_term_Position(Object t1, Object t2) {return  (t1.equals(t2)) ;}private static boolean tom_is_sort_Position(Object t) {return  (t instanceof tom.library.sl.Position) ;} private static boolean tom_equal_term_int(int t1, int t2) {return  t1==t2 ;}private static boolean tom_is_sort_int(int t) {return  true ;} private static boolean tom_equal_term_char(char t1, char t2) {return  t1==t2 ;}private static boolean tom_is_sort_char(char t) {return  true ;} private static boolean tom_equal_term_String(String t1, String t2) {return  t1.equals(t2) ;}private static boolean tom_is_sort_String(String t) {return  t instanceof String ;} private static  tom.library.sl.Strategy  tom_make_mu( tom.library.sl.Strategy  var,  tom.library.sl.Strategy  v) { return ( new tom.library.sl.Mu(var,v) );}private static  tom.library.sl.Strategy  tom_make_MuVar( String  name) { return ( new tom.library.sl.MuVar(name) );}private static  tom.library.sl.Strategy  tom_make_Identity() { return ( new tom.library.sl.Identity() );}private static  tom.library.sl.Strategy  tom_make_All( tom.library.sl.Strategy  v) { return ( new tom.library.sl.All(v) );}private static  tom.library.sl.Strategy  tom_make_Fail() { return ( new tom.library.sl.Fail() );}private static boolean tom_is_fun_sym_Sequence( tom.library.sl.Strategy  t) {return ( (t instanceof tom.library.sl.Sequence) );}private static  tom.library.sl.Strategy  tom_empty_list_Sequence() { return ( null );}private static  tom.library.sl.Strategy  tom_cons_list_Sequence( tom.library.sl.Strategy  head,  tom.library.sl.Strategy  tail) { return ( (tail==null)?head:new tom.library.sl.Sequence(head,tail) );}private static  tom.library.sl.Strategy  tom_get_head_Sequence_Strategy( tom.library.sl.Strategy  t) {return ( (tom.library.sl.Strategy)t.getChildAt(tom.library.sl.Sequence.FIRST) );}private static  tom.library.sl.Strategy  tom_get_tail_Sequence_Strategy( tom.library.sl.Strategy  t) {return ( (tom.library.sl.Strategy)t.getChildAt(tom.library.sl.Sequence.THEN) );}private static boolean tom_is_empty_Sequence_Strategy( tom.library.sl.Strategy  t) {return ( t == null );}   private static   tom.library.sl.Strategy  tom_append_list_Sequence( tom.library.sl.Strategy  l1,  tom.library.sl.Strategy  l2) {     if(( l1 == null )) {       return l2;     } else if(( l2 == null )) {       return l1;     } else if(( (l1 instanceof tom.library.sl.Sequence) )) {       if(( ( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.THEN) ) == null )) {         return ( (l2==null)?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ):new tom.library.sl.Sequence(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ),l2) );       } else {         return ( (tom_append_list_Sequence(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.THEN) ),l2)==null)?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ):new tom.library.sl.Sequence(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.FIRST) ),tom_append_list_Sequence(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Sequence.THEN) ),l2)) );       }     } else {       return ( (l2==null)?l1:new tom.library.sl.Sequence(l1,l2) );     }   }   private static   tom.library.sl.Strategy  tom_get_slice_Sequence( tom.library.sl.Strategy  begin,  tom.library.sl.Strategy  end, tom.library.sl.Strategy  tail) {     if( (begin.equals(end)) ) {       return tail;     } else if( (end.equals(tail))  && (( end == null ) ||  (end.equals(tom_empty_list_Sequence())) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return ( (( tom.library.sl.Strategy )tom_get_slice_Sequence(((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.THEN) ):tom_empty_list_Sequence()),end,tail)==null)?((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.FIRST) ):begin):new tom.library.sl.Sequence(((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.FIRST) ):begin),( tom.library.sl.Strategy )tom_get_slice_Sequence(((( (begin instanceof tom.library.sl.Sequence) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Sequence.THEN) ):tom_empty_list_Sequence()),end,tail)) );   }   private static boolean tom_is_fun_sym_Choice( tom.library.sl.Strategy  t) {return ( (t instanceof tom.library.sl.Choice) );}private static  tom.library.sl.Strategy  tom_empty_list_Choice() { return ( null );}private static  tom.library.sl.Strategy  tom_cons_list_Choice( tom.library.sl.Strategy  head,  tom.library.sl.Strategy  tail) { return ( (tail==null)?head:new tom.library.sl.Choice(head,tail) );}private static  tom.library.sl.Strategy  tom_get_head_Choice_Strategy( tom.library.sl.Strategy  t) {return ( (tom.library.sl.Strategy)t.getChildAt(tom.library.sl.Choice.FIRST) );}private static  tom.library.sl.Strategy  tom_get_tail_Choice_Strategy( tom.library.sl.Strategy  t) {return ( (tom.library.sl.Strategy)t.getChildAt(tom.library.sl.Choice.THEN) );}private static boolean tom_is_empty_Choice_Strategy( tom.library.sl.Strategy  t) {return ( t ==null );}   private static   tom.library.sl.Strategy  tom_append_list_Choice( tom.library.sl.Strategy  l1,  tom.library.sl.Strategy  l2) {     if(( l1 ==null )) {       return l2;     } else if(( l2 ==null )) {       return l1;     } else if(( (l1 instanceof tom.library.sl.Choice) )) {       if(( ( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.THEN) ) ==null )) {         return ( (l2==null)?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ):new tom.library.sl.Choice(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ),l2) );       } else {         return ( (tom_append_list_Choice(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.THEN) ),l2)==null)?( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ):new tom.library.sl.Choice(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.FIRST) ),tom_append_list_Choice(( (tom.library.sl.Strategy)l1.getChildAt(tom.library.sl.Choice.THEN) ),l2)) );       }     } else {       return ( (l2==null)?l1:new tom.library.sl.Choice(l1,l2) );     }   }   private static   tom.library.sl.Strategy  tom_get_slice_Choice( tom.library.sl.Strategy  begin,  tom.library.sl.Strategy  end, tom.library.sl.Strategy  tail) {     if( (begin.equals(end)) ) {       return tail;     } else if( (end.equals(tail))  && (( end ==null ) ||  (end.equals(tom_empty_list_Choice())) )) {       /* code to avoid a call to make, and thus to avoid looping during list-matching */       return begin;     }     return ( (( tom.library.sl.Strategy )tom_get_slice_Choice(((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.THEN) ):tom_empty_list_Choice()),end,tail)==null)?((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.FIRST) ):begin):new tom.library.sl.Choice(((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.FIRST) ):begin),( tom.library.sl.Strategy )tom_get_slice_Choice(((( (begin instanceof tom.library.sl.Choice) ))?( (tom.library.sl.Strategy)begin.getChildAt(tom.library.sl.Choice.THEN) ):tom_empty_list_Choice()),end,tail)) );   }     private static  tom.library.sl.Strategy  tom_make_Try( tom.library.sl.Strategy  v) { return ( tom_cons_list_Choice(v,tom_cons_list_Choice(tom_make_Identity(),tom_empty_list_Choice())) );}private static  tom.library.sl.Strategy  tom_make_TopDown( tom.library.sl.Strategy  v) { return ( tom_make_mu(tom_make_MuVar("_x"),tom_cons_list_Sequence(v,tom_cons_list_Sequence(tom_make_All(tom_make_MuVar("_x")),tom_empty_list_Sequence()))) );}  private static boolean tom_equal_term_boolean(boolean t1, boolean t2) {return  t1==t2 ;}private static boolean tom_is_sort_boolean(boolean t) {return  true ;} private static boolean tom_equal_term_long(long t1, long t2) {return  t1==t2 ;}private static boolean tom_is_sort_long(long t) {return  true ;} private static boolean tom_equal_term_float(float t1, float t2) {return  t1==t2 ;}private static boolean tom_is_sort_float(float t) {return  true ;} private static boolean tom_equal_term_double(double t1, double t2) {return  t1==t2 ;}private static boolean tom_is_sort_double(double t) {return  true ;}   private static <O> EList<O> enforce(EList l) {   return l; }  private static <O> EList<O> append(O e, EList<O> l) {        l.add(e);        return l; } private static boolean tom_equal_term_Block(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Block(Object t) {return  t instanceof net.sf.orcc.ir.Block;}private static boolean tom_equal_term_BlockL(Object l1, Object l2) {return (l1!=null && l1.equals(l2)) || l1==l2 ;}private static boolean tom_is_sort_BlockL(Object t) {return  t instanceof EList<?> && (((EList<net.sf.orcc.ir.Block>)t).size() == 0 ||
              (((EList<net.sf.orcc.ir.Block>)t).size() > 0 && 
              ((EList<net.sf.orcc.ir.Block>)t).get(0) instanceof net.sf.orcc.ir.Block));}private static boolean tom_equal_term_BlockBasic(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_BlockBasic(Object t) {return  t instanceof net.sf.orcc.ir.BlockBasic ;}private static boolean tom_equal_term_BlockIf(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_BlockIf(Object t) {return  t instanceof net.sf.orcc.ir.BlockIf ;}private static boolean tom_equal_term_BlockWhile(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_BlockWhile(Object t) {return  t instanceof net.sf.orcc.ir.BlockWhile ;}private static boolean tom_equal_term_Instruction(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Instruction(Object t) {return  t instanceof net.sf.orcc.ir.Instruction ;}private static boolean tom_equal_term_InstructionL(Object l1, Object l2) {return (l1!=null && l1.equals(l2)) || l1==l2 ;}private static boolean tom_is_sort_InstructionL(Object t) {return  t instanceof EList<?> && (((EList<net.sf.orcc.ir.Instruction>)t).size() == 0 ||
              (((EList<net.sf.orcc.ir.Instruction>)t).size() > 0 && 
              ((EList<net.sf.orcc.ir.Instruction>)t).get(0) instanceof net.sf.orcc.ir.Instruction));}private static boolean tom_equal_term_InstCall(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstCall(Object t) {return  t instanceof net.sf.orcc.ir.InstCall ;}private static boolean tom_equal_term_InstLoad(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstLoad(Object t) {return  t instanceof net.sf.orcc.ir.InstLoad ;}private static boolean tom_equal_term_InstAssign(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstAssign(Object t) {return  t instanceof net.sf.orcc.ir.InstAssign ;}private static boolean tom_equal_term_InstPhi(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstPhi(Object t) {return  t instanceof net.sf.orcc.ir.Instruction ;}private static boolean tom_equal_term_InstReturn(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstReturn(Object t) {return  t instanceof net.sf.orcc.ir.InstReturn ;}private static boolean tom_equal_term_InstStore(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstStore(Object t) {return  t instanceof net.sf.orcc.ir.InstStore ;}private static boolean tom_equal_term_InstSpecific(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_InstSpecific(Object t) {return  t instanceof net.sf.orcc.ir.InstSpecific ;}private static boolean tom_equal_term_Expression(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Expression(Object t) {return  t instanceof net.sf.orcc.ir.Expression ;}private static boolean tom_equal_term_ExpressionL(Object l1, Object l2) {return (l1!=null && l1.equals(l2)) || l1==l2 ;}private static boolean tom_is_sort_ExpressionL(Object t) {return  t instanceof EList<?> && (((EList<net.sf.orcc.ir.Expression>)t).size() == 0 ||
                  (((EList<net.sf.orcc.ir.Expression>)t).size() > 0 && 
                    ((EList<net.sf.orcc.ir.Expression>)t).get(0) instanceof net.sf.orcc.ir.Expression));}private static boolean tom_equal_term_ExprBinary(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprBinary(Object t) {return  t instanceof net.sf.orcc.ir.ExprBinary ;}private static boolean tom_equal_term_ExprUnary(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprUnary(Object t) {return  t instanceof net.sf.orcc.ir.ExprUnary ;}private static boolean tom_equal_term_ExprBool(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprBool(Object t) {return  t instanceof net.sf.orcc.ir.ExprBool ;}private static boolean tom_equal_term_ExprFloat(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprFloat(Object t) {return  t instanceof net.sf.orcc.ir.ExprFloat ;}private static boolean tom_equal_term_ExprInt(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprInt(Object t) {return  t instanceof net.sf.orcc.ir.ExprInt ;}private static boolean tom_equal_term_ExprList(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprList(Object t) {return  t instanceof net.sf.orcc.ir.ExprList ;}private static boolean tom_equal_term_ExprString(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprString(Object t) {return  t instanceof net.sf.orcc.ir.ExprString ;}private static boolean tom_equal_term_ExprVar(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ExprVar(Object t) {return  t instanceof net.sf.orcc.ir.ExprVar ;}private static boolean tom_equal_term_Type(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Type(Object t) {return  t instanceof net.sf.orcc.ir.Type ;}private static boolean tom_equal_term_TypeVoid(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeVoid(Object t) {return  t instanceof net.sf.orcc.ir.TypeVoid ;}private static boolean tom_equal_term_TypeString(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeString(Object t) {return  t instanceof net.sf.orcc.ir.TypeString ;}private static boolean tom_equal_term_TypeInt(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeInt(Object t) {return  t instanceof net.sf.orcc.ir.TypeInt ;}private static boolean tom_equal_term_TypeUint(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeUint(Object t) {return  t instanceof net.sf.orcc.ir.TypeUint ;}private static boolean tom_equal_term_TypeBool(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeBool(Object t) {return  t instanceof net.sf.orcc.ir.TypeBool ;}private static boolean tom_equal_term_TypeList(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeList(Object t) {return  t instanceof net.sf.orcc.ir.TypeList ;}private static boolean tom_equal_term_TypeFloat(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_TypeFloat(Object t) {return  t instanceof net.sf.orcc.ir.TypeFloat ;}private static boolean tom_equal_term_Procedure(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Procedure(Object t) {return  t instanceof net.sf.orcc.ir.Procedure ;}private static boolean tom_equal_term_Param(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Param(Object t) {return  t instanceof net.sf.orcc.ir.Param ;}private static boolean tom_equal_term_ParamL(Object l1, Object l2) {return (l1!=null && l1.equals(l2)) || l1==l2 ;}private static boolean tom_is_sort_ParamL(Object t) {return  t instanceof EList<?> && (((EList<net.sf.orcc.ir.Param>)t).size() == 0 ||
                  (((EList<net.sf.orcc.ir.Param>)t).size() > 0 && 
                ((EList<net.sf.orcc.ir.Param>)t).get(0) instanceof net.sf.orcc.ir.Param)) ;}private static boolean tom_equal_term_Arg(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Arg(Object t) {return  t instanceof net.sf.orcc.ir.Arg ;}private static boolean tom_equal_term_ArgByRef(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ArgByRef(Object t) {return  t instanceof net.sf.orcc.ir.ArgByRef ;}private static boolean tom_equal_term_ArgByVal(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_ArgByVal(Object t) {return  t instanceof net.sf.orcc.ir.ArgByVal ;}private static boolean tom_equal_term_Var(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Var(Object t) {return  t instanceof net.sf.orcc.ir.Var ;}private static boolean tom_equal_term_Use(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Use(Object t) {return  t instanceof net.sf.orcc.ir.Use ;}private static boolean tom_equal_term_Def(Object l1, Object l2) {return  l1.equals(l2) || l1 == l2 ;}private static boolean tom_is_sort_Def(Object t) {return  t instanceof net.sf.orcc.ir.Def ;}     private static boolean tom_is_fun_sym_exprInt( net.sf.orcc.ir.Expression  t) {return  t instanceof ExprInt ;}private static  int  tom_get_slot_exprInt_value( net.sf.orcc.ir.Expression  t) {return ((net.sf.orcc.ir.ExprInt)t).getValue().intValue() ;}    public static class printLiteral extends tom.library.sl.AbstractStrategyBasic {public printLiteral() {super(tom_make_Fail());}public tom.library.sl.Visitable[] getChildren() {tom.library.sl.Visitable[] stratChilds = new tom.library.sl.Visitable[getChildCount()];stratChilds[0] = super.getChildAt(0);return stratChilds;}public tom.library.sl.Visitable setChildren(tom.library.sl.Visitable[] children) {super.setChildAt(0, children[0]);return this;}public int getChildCount() {return 1;}public tom.library.sl.Visitable getChildAt(int index) {switch (index) {case 0: return super.getChildAt(0);default: throw new IndexOutOfBoundsException();}}public tom.library.sl.Visitable setChildAt(int index, tom.library.sl.Visitable child) {switch (index) {case 0: return super.setChildAt(0, child);default: throw new IndexOutOfBoundsException();}}@SuppressWarnings("unchecked")public  net.sf.orcc.ir.Expression  visit_Expression( net.sf.orcc.ir.Expression  tom__arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {{{if (tom_is_sort_Expression(tom__arg)) {if (tom_is_fun_sym_exprInt((( net.sf.orcc.ir.Expression )tom__arg))) {








 OrccLogger.traceln("cst: " + tom_get_slot_exprInt_value((( net.sf.orcc.ir.Expression )tom__arg))); }}}}return _visit_Expression(tom__arg,introspector); }@SuppressWarnings("unchecked")public  net.sf.orcc.ir.Expression  _visit_Expression( net.sf.orcc.ir.Expression  arg, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (!((environment ==  null ))) {return (( net.sf.orcc.ir.Expression )any.visit(environment,introspector));} else {return any.visitLight(arg,introspector);} }@SuppressWarnings("unchecked")public <T> T visitLight(T v, tom.library.sl.Introspector introspector) throws tom.library.sl.VisitFailure {if (tom_is_sort_Expression(v)) {return ((T)visit_Expression((( net.sf.orcc.ir.Expression )v),introspector));}if (!((environment ==  null ))) {return ((T)any.visit(environment,introspector));} else {return any.visitLight(v,introspector);} }}private static  tom.library.sl.Strategy  tom_make_printLiteral() { return new printLiteral();}



	public void doSwitch(Instance instance) {
		if(instance.isActor()) {
			doSwitch(instance.getActor());
		}
	}

	public void doSwitch(Actor actor) {
		for(Action action : actor.getActions()) {
			Procedure actionBody = action.getBody();

			try {
				tom_make_TopDown(tom_make_Try(tom_make_printLiteral())).visit(actionBody);
			} catch (VisitFailure e) {
				System.out.println("strategy failed");
			}
		}
	}
}