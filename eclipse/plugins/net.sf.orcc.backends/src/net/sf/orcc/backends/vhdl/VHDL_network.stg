import "net/sf/orcc/backends/vhdl/VHDL_actor.stg"


///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
SignalType(instance, port, dataType) ::=<<
<if(port.type.bool)
>signal <instance.id>_<port.name>_<dataType>   : std_logic;<
else
>signal <instance.id>_<port.name>_<dataType>   : std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of the TOP Network
///////////////////////////////////////////////////////////////////////////////
printNetworkPorts(network) ::= <<
-- Inputs
<network.inputs: {port|<printPort(port, "in  ", "out ")>}; separator=";\n"><if(network.inputs && network.outputs)>;<endif>
-- Outputs
<network.outputs: {port|<printPort(port, "out ", "in  ")>}; separator=";\n">
>>


//////////////////////////////////////////////////////////////////////////////
// Print signals
//////////////////////////////////////////////////////////////////////////////
tryPrintSignals(network) ::= <<
<network.instances: checkInstanceType(); separator="\n\n"> 
>>

checkInstanceType(instance) ::= <<
<if (instance.actor)
>                                            -- Actor : <instance.id>
<printSignals(inputs=instance.actor.inputs,
              outputs=instance.actor.outputs)><
elseif (instance.broadcast)
>                                            -- Broadcast : <instance.id>
<printSignals(inputs=instance.broadcast.inputs.list,
              outputs=instance.broadcast.outputs.list)><
elseif (instance.network)
>                                            -- Network : <instance.id>
<printSignals(inputs=instance.network.inputs,
              outputs=instance.network.outputs)><
endif>
>>

printSignals(inputs, outputs) ::= <<
<if(!inputs.empty)
><instance.incomingPortMap.keys: { port | <inputPortSignals(port, instance.incomingPortMap.(port))> }; separator="\n"><
endif>
>>

inputPortSignals(port, connection) ::= <<
<if(connection.sourcePort)
><if(port.native)
><SignalType(instance=instance, port=port, dataType="")><
else
><SignalType(instance=instance, port=port, dataType="data")>
signal <instance.id>_<port.name>_send   : std_logic;
signal <instance.id>_<port.name>_ack    : std_logic;<
endif><
endif><
if (instance.broadcast)
><broadcastType(connection=connection, name=instance.id, direction="fromBroad")><
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print FIFOs instantiation
///////////////////////////////////////////////////////////////////////////////
assignFifos(edges) ::= <<
<edges: assignFifo()>
>> 

assignFifo(edge) ::= <<
<tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>> 

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)
><doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))><
endif>
>>

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
<if(edge.size)>
fifo_<count> : entity work.fifo_generic 
  generic map (
    depth =\> <edge.size>,
  <if(targetPort.type.bool)
>  width =\> 1)<
  else
>  width =\> <targetPort.type.size>)<
  endif>

  port map (
    wr_data    =\> <source.id>_<sourcePort.name>_send, 
  <if(targetPort.type.bool)
>  data_in(0) =\> <source.id>_<sourcePort.name>_data,<\n><
  else
>  data_in    =\> <source.id>_<sourcePort.name>_data,<\n><
  endif>
    wr_clk     =\> clock, 
    wr_ack     =\> <source.id>_<sourcePort.name>_ack, 
  <if(targetPort.type.bool)
>  data_out(0)=\> <target.id>_<targetPort.name>_data,<\n><
  else
>  data_out   =\> <target.id>_<targetPort.name>_data,<\n><
  endif
>    rd_clk     =\> clock, 
    send       =\> <target.id>_<targetPort.name>_send, 
    rd_ack     =\> <target.id>_<targetPort.name>_ack,  
    reset_n    =\> reset_n);<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// print actors and networks instantiation
///////////////////////////////////////////////////////////////////////////////
PrintNetworksAndActors(outgoingMap) ::= <<
<outgoingMap.keys: {instance | <checkNetworkOrActors(instance=instance)>}>
<network.instances: checkNetworkOrActors()>
>>

checkNetworkOrActors(instance) ::= <<
<if (instance.actor)
><printInstances(name=instance.actor.simpleName,
				 inputs=instance.actor.inputs,
                 outputs=instance.actor.outputs)>
                 
                 <
elseif (instance.network)
><printInstances(name=instance.network.simpleName,
				 inputs=instance.network.inputs,
                 outputs=instance.network.outputs)>
                 
                 <
endif>
>>


printInstances(name, inputs, outputs) ::= <<
<instance.id> : entity work.<name>
  port map (
<if(!inputs.empty)
>

    <instance.incomingPortMap.keys: { port | <printInstanceInputs(port, instance.incomingPortMap.(port))> }; separator="\n">

    
    <network.incomingMap.(instance): {connection | <printInputs(connection=connection, portPredMap=network.predecessorsMap.(instance), 
															srcVertex=network.sourceMap.(connection))>}; separator="\n">
<
endif><
if(!outputs.empty)
>
    <outgoingMap.(instance).values:
    	{connections| <connections:{connection | <printOutputs(connection=connection, portSuccMap=network.successorsMap.(instance), 
															tgtVertex=network.targetMap.(connection))>}; separator="\n">}; separator="\n">

    <instance.outgoingPortMap.keys: { port | <printInstanceOutputs(port, instance.outgoingPortMap.(port))> }; separator="\n">
<
endif>
    clock     =\> clock, 
    reset_n   =\> reset_n);
>>

/** Print input connection of an instance according to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instance)
 * portPredMap: a map that associates each port of an instance to the predecessor of this port
 * srcVertex: contain the source of the connection (e.g. a port of the network)
 * 
 */
 printInstanceInputs(port, connection) ::= <<
 <if(connection.sourcePort.name)
 ><port.name>_data =\> <instance.id>_<port.name>_data,
<port.name>_send =\> <instance.id>_<port.name>_send,
<port.name>_ack =\> <instance.id>_<port.name>_ack,<
else
>port <port.name> connected to network (TODO)<
endif>
>>
 
  
 printInstanceOutputs(port, connection) ::= <<
 <if(connection.sourcePort.name)
 ><port.name>_data =\> <instance.id>_<port.name>_data,
<port.name>_send =\> <instance.id>_<port.name>_send,
<port.name>_ack =\> <instance.id>_<port.name>_ack,<
else
>port <port.name>
<connection>
sourcePort <connection.sourcePort.name>
targetPort <connection.targetPort.name><
endif>

>>  


printInputs(connection, portPredMap, srcVertex) ::= <<
<connection>
<portPredMap>
<srcVertex>
<if(!connection.target.native)
><if(portPredMap.(connection.target))
><if(portPredMap.(connection.target).broadcast)
><connection.target.name>_data     =\> <portPredMap.(connection.target).id>_fromBroad_data,
<else
><if(instance.broadcast && connection.target.type.bool)
><connection.target.name>_data(0)  =\> <instance.id>_<connection.target.name>_data,
<else
><connection.target.name>_data     =\> <instance.id>_<connection.target.name>_data,
<endif>
<endif><
if(!connection.target.native)
><connection.target.name>_send     =\> <instance.id>_<connection.target.name>_send,
<connection.target.name>_ack      =\> <instance.id>_<connection.target.name>_ack,<
endif><
else
><if(instance.broadcast && connection.target.type.bool)
><connection.target.name>_data(0)  =\> <srcVertex.port.name>_data,
<else
><connection.target.name>_data     =\> <srcVertex.port.name>_data,
<endif>
<connection.target.name>_send     =\> <srcVertex.port.name>_send,
<connection.target.name>_ack      =\> <srcVertex.port.name>_ack,<
endif><
else
><connection.target.name>     =\> <srcVertex.port.name>,<
endif>
>>

/** Print output connections of an instance according to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instance)
 * portSuccMap: a map that associates each port of an instance to the successors of this port
 * tgtVertex: target of the connection (e.g. a port of the network)
 * 
 */ 
printOutputs(connection, portSuccMap, tgtVertex) ::= <<
<if(first(portSuccMap.(connection.source)))
><if(connection.attributes)
><connection.source.name>_data     =\> <instance.id>_<connection.source.name>_data,
<connection.source.name>_send     =\> <instance.id>_<connection.source.name>_send,
<connection.source.name>_ack      =\> <instance.id>_<connection.source.name>_ack,<
else
><connection.source.name>_data     =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_data,
<connection.source.name>_send     =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_send,
<connection.source.name>_ack      =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_ack,<
endif><
else
><if(connection.source.native)
><connection.source.name>         =\> <tgtVertex.port.name>,<
else
><connection.source.name>_data     =\> <tgtVertex.port.name>_data,
<connection.source.name>_send     =\> <tgtVertex.port.name>_send,
<connection.source.name>_ack      =\> <tgtVertex.port.name>_ack,<
endif><
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// print broadcasts instantiation
///////////////////////////////////////////////////////////////////////////////
printBroadcasts(outgoingMap) ::= <<
<outgoingMap.keys: {instance | <checkBroadcast(instance=instance)>}>
>>

checkBroadcast(instance) ::= <<
<if (instance.broadcast)
><printBroadcast(name=instance.id,
				 inputs=instance.broadcast.inputs.list,
                 outputs=instance.broadcast.outputs.list)><
endif>
>>

// Instanciate a broadcast if necessary
printBroadcast(name, inputs, outputs) ::= <<
broadcast_<name> : entity work.broadcast
  generic map (
    width =\> <if(instance.broadcast.type.bool)>1<else><instance.broadcast.type.size><endif>,
    size  =\> <instance.broadcast.numOutputs>)
  port map (
<if(!inputs.empty)>
    <network.incomingMap.(instance).values:{connection | <printInputs(connection=connection, portPredMap=network.predecessorsMap.(instance), 
															srcVertex=network.sourceMap.(connection))>}; separator="\n">
<endif>
<if(!outputs.empty)>
<if(last(outputs).type.bool)
>    output_data(0) =\> <name>_fromBroad_data,
<else
>    output_data    =\> <name>_fromBroad_data,
<endif>
    <outgoingMap.(instance).values: {connections | <printBroadcastOutputs(connections=connections, index=i0, network=network,
    								instance=instance, control="send")>}; separator="\n">	
    <outgoingMap.(instance).values: {connections | <printBroadcastOutputs(connections=connections, index=i0, network=network,
    								instance=instance, control="ack")>}; separator="\n">
<endif>
    clock         =\> clock,
    reset_n       =\> reset_n);
    --
    <outgoingMap.(instance).values: {connections|<connections:{connection | <printBroadToOut(tgtVertex=network.targetMap.(connection))>}>}>
>>

/** Print connection between broadcast and output
 * tgtVertex: target vertex of the connection (supposed to be a port)
 * 
 */
printBroadToOut(tgtVertex) ::= <<
<if(tgtVertex.port)
><tgtVertex.port.name>_data \<= <name>_fromBroad_data;<
endif>
>>

printBroadcastOutputs(connections, index, network , instance, control) ::= <<
<connections: { connection | <printBroadcastOutput( connection=connection, index=index, portSuccMap=network.successorsMap.(instance),
    			tgtVertex=network.targetMap.(connection), control=control)>}; separator="\n">		
>>

/** Print output connections of a broadcast to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instances)
 * index: index of the output (e.g. 1, 2, 3, ...)
 * portSuccMap: a map that associates each port of an instance to the successors of this port
 * tgtVertex: target of the connection (e.g. a port of the network)
 * control: "send" or "ack"
 * 
 */
printBroadcastOutput(connection, index, portSuccMap, tgtVertex, control) ::= <<
<if(first(portSuccMap.(connection.source)))
><if(connection.attributes)
>output_<control>(<index>) =\> <instance.id>_<connection.source.name>_<control>,<
else
>output_<control>(<index>) =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_<control>,<
endif><
else
>output_<control>(<index>) =\> <tgtVertex.port.name>_<control>,<
endif>
>>

broadcastType(connection, name, direction) ::= <<
<if(connection.target.type.bool)
>signal <name>_<direction>_data : std_logic;<
else
>signal <name>_<direction>_data : std_logic_vector(<connection.target.type.size> -1 downto 0);<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// print the network
///////////////////////////////////////////////////////////////////////////////
network(network, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Configuration: <network.simpleName>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <network.simpleName>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


------------------------------------------------------------------------------
entity <network.simpleName> is
  port (
    clock    : in  std_logic;
    reset_n  : in  std_logic;
    <printNetworkPorts(network)>);  
end <network.simpleName>;


------------------------------------------------------------------------------
architecture rtl_<network.simpleName> of <network.simpleName> is

  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  <tryPrintSignals(network); separator="\n">
  ---------------------------------------------------------------------------

begin

  ---------------------------------------------------------------------------
  -- Actors and Networks instantiation 
  ---------------------------------------------------------------------------
  <PrintNetworksAndActors(network.outgoingMap)>
  ---------------------------------------------------------------------------
  -- Broadcast and FIFO instantiation 
  --------------------------------------------------------------------------- 
  <printBroadcasts(network.outgoingMap)>
  <assignFifos(network.connections)>
  ---------------------------------------------------------------------------

end architecture rtl_<network.simpleName>;

>>
