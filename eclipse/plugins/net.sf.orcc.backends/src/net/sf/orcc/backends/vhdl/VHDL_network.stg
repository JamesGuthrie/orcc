import "net/sf/orcc/backends/vhdl/VHDL_actor.stg"


///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
SignalType(instance, port, dataType) ::=<<
<if(port.type.bool)
>signal <instance.id>_<port.name>_<dataType>   : std_logic;<
else
>signal <instance.id>_<port.name>_<dataType>   : std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// print IOs of the TOP Network
///////////////////////////////////////////////////////////////////////////////
printNetworkPorts(network) ::= <<
-- Inputs
<network.inputs: {port|<printPort(port, "in  ", "out ")>}; separator=";\n"><if(network.inputs && network.outputs)>;<endif>
-- Outputs
<network.outputs: {port|<printPort(port, "out ", "in  ")>}; separator=";\n">
>>


//////////////////////////////////////////////////////////////////////////////
// Print signals
//////////////////////////////////////////////////////////////////////////////
tryPrintSignals(network) ::= <<
<network.instances: checkInstanceType(); separator="\n\n"> 
>>

checkInstanceType(instance) ::= <<
<if (instance.actor)
>                                            -- Actor : <instance.id>
<printSignals(inputs=instance.actor.inputs,
              outputs=instance.actor.outputs)><
elseif (instance.broadcast)
>                                            -- Broadcast : <instance.id>
<printSignals(inputs=instance.broadcast.inputs.list,
              outputs=instance.broadcast.outputs.list)><
elseif (instance.network)
>                                            -- Network : <instance.id>
<printSignals(inputs=instance.network.inputs,
              outputs=instance.network.outputs)><
endif>
>>

printSignals(inputs, outputs) ::= <<
<if(!inputs.empty)
><instance.incomingPortMap.keys: { port | <inputPortSignals(port, instance.incomingPortMap.(port))> }; separator="\n"><
endif>
>>

inputPortSignals(port, connection) ::= <<
<if(connection.sourcePort)
><if(port.native)
><SignalType(instance=instance, port=port, dataType="")><
else
><SignalType(instance=instance, port=port, dataType="data")>
signal <instance.id>_<port.name>_send   : std_logic;
signal <instance.id>_<port.name>_ack    : std_logic;<
endif><
endif><
if (instance.broadcast)
><broadcastType(connection=connection, name=instance.id, direction="fromBroad")><
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print FIFOs instantiation
///////////////////////////////////////////////////////////////////////////////
assignFifos(edges) ::= <<
<edges: assignFifo()>
>> 

assignFifo(edge) ::= <<
<tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>> 

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)
><doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))><
endif>
>>

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
<if(edge.size)>
fifo_<count> : entity work.fifo_generic 
  generic map (
    depth =\> <edge.size>,
  <if(targetPort.type.bool)
>  width =\> 1)<
  else
>  width =\> <targetPort.type.size>)<
  endif>

  port map (
    wr_data    =\> <source.id>_<sourcePort.name>_send, 
  <if(targetPort.type.bool)
>  data_in(0) =\> <source.id>_<sourcePort.name>_data,<\n><
  else
>  data_in    =\> <source.id>_<sourcePort.name>_data,<\n><
  endif>
    wr_clk     =\> clock, 
    wr_ack     =\> <source.id>_<sourcePort.name>_ack, 
  <if(targetPort.type.bool)
>  data_out(0)=\> <target.id>_<targetPort.name>_data,<\n><
  else
>  data_out   =\> <target.id>_<targetPort.name>_data,<\n><
  endif
>    rd_clk     =\> clock, 
    send       =\> <target.id>_<targetPort.name>_send, 
    rd_ack     =\> <target.id>_<targetPort.name>_ack,  
    reset_n    =\> reset_n);<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// print actors and networks instantiation
///////////////////////////////////////////////////////////////////////////////
PrintNetworksAndActors(network) ::= <<
<network.instances: checkNetworkOrActors()>
>>

checkNetworkOrActors(instance) ::= <<
<if (instance.actor)
><printInstances(name=instance.actor.simpleName,
				 inputs=instance.actor.inputs,
                 outputs=instance.actor.outputs)>
                 
                 <
elseif (instance.network)
><printInstances(name=instance.network.simpleName,
				 inputs=instance.network.inputs,
                 outputs=instance.network.outputs)>
                 
                 <
endif>
>>


printInstances(name, inputs, outputs) ::= <<
<instance.id> : entity work.<name>
  port map (
<if(!inputs.empty)
><instance.incomingPortMap.keys: { port | <printInstanceInputs(port, instance.incomingPortMap.(port))> }; separator="\n"><
endif><
if(!outputs.empty)>
<instance.outgoingPortMap.keys: { port | <printInstanceOutputs(port, instance.outgoingPortMap.(port))> }; separator="\n">
<endif>
    clock     =\> clock, 
    reset_n   =\> reset_n);
>>

 printInstanceInputs(port, connection) ::= <<
 <if(connection.sourcePort)
 >   <port.name>_data   =\> <instance.id>_<port.name>_data,
   <port.name>_send   =\> <instance.id>_<port.name>_send,
   <port.name>_ack    =\> <instance.id>_<port.name>_ack,<
else
>   <port.name>_data   =\> <connection.source.name>_data,
   <port.name>_send   =\> <connection.source.name>_send,
   <port.name>_ack    =\> <connection.source.name>_ack,<
endif>
>>
  
 printInstanceOutputs(port, connection) ::= <<
<connection : printInstanceOutput()>
>>

 printInstanceOutput(connection) ::= <<
 <if(connection.target.actor)
 >   <port.name>_data   =\> <connection.target.id>_<connection.targetPort.name>_data,
   <port.name>_send   =\> <connection.target.id>_<connection.targetPort.name>_send,
   <port.name>_ack    =\> <connection.target.id>_<connection.targetPort.name>_ack,<
elseif(connection.target.broadcast)
>   <port.name>_data   =\> <connection.target.id>_<connection.targetPort.name>_data,
   <port.name>_send   =\> <connection.target.id>_<connection.targetPort.name>_send,
   <port.name>_ack    =\> <connection.target.id>_<connection.targetPort.name>_ack,<
elseif(connection.target.network)
>   <port.name>_data   =\> <connection.target.id>_<connection.targetPort.name>_data,
   <port.name>_send   =\> <connection.target.id>_<connection.targetPort.name>_send,
   <port.name>_ack    =\> <connection.target.id>_<connection.targetPort.name>_ack,<
else
>   <port.name>_data   =\> <connection.target.name>_data,
   <port.name>_send   =\> <connection.target.name>_send,
   <port.name>_ack    =\> <connection.target.name>_ack,<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// print broadcasts instantiation
///////////////////////////////////////////////////////////////////////////////
printBroadcasts(network) ::= <<
<network.instances: checkBroadcast(); separator="\n\n"> 
>>

checkBroadcast(instance) ::= <<
<if (instance.broadcast)
><printBroadcast(name=instance.id,
				 inputs=instance.broadcast.inputs.list,
                 outputs=instance.broadcast.outputs.list)><
endif>
>>

// Instanciate a broadcast if necessary
printBroadcast(name, inputs, outputs) ::= <<
broadcast_<name> : entity work.broadcast
  generic map (
    width =\> <if(instance.broadcast.type.bool)>1<else><instance.broadcast.type.size><endif>,
    size  =\> <instance.broadcast.numOutputs>)
  port map (
<if(!inputs.empty)
><instance.incomingPortMap.keys: { port | <printInstanceInputs(port, instance.incomingPortMap.(port))> }; separator="\n"><
endif><
if(!outputs.empty)>
<instance.outgoingPortMap.keys: { port | <printInstanceOutputs(port, instance.outgoingPortMap.(port))> }; separator="\n">
<endif>
    clock     =\> clock, 
    reset_n   =\> reset_n);
    --
    <network.outgoingMap.(instance).values: {connections|<connections:{connection | <printBroadToOut(tgtVertex=network.targetMap.(connection))>}>}>
>>

/** Print connection between broadcast and output
 * tgtVertex: target vertex of the connection (supposed to be a port)
 * 
 */
printBroadToOut(tgtVertex) ::= <<
<if(tgtVertex.port)
><tgtVertex.port.name>_data \<= <name>_fromBroad_data;<
endif>
>>

printBroadcastOutputs(connections, index, network , instance, control) ::= <<
<connections: { connection | <printBroadcastOutput( connection=connection, index=index, portSuccMap=network.successorsMap.(instance),
    			tgtVertex=network.targetMap.(connection), control=control)>}; separator="\n">		
>>

/** Print output connections of a broadcast to the maps:
 * 
 * connection: connection of the instance (e.g. a connection between two instances)
 * index: index of the output (e.g. 1, 2, 3, ...)
 * portSuccMap: a map that associates each port of an instance to the successors of this port
 * tgtVertex: target of the connection (e.g. a port of the network)
 * control: "send" or "ack"
 * 
 */
printBroadcastOutput(connection, index, portSuccMap, tgtVertex, control) ::= <<
<if(first(portSuccMap.(connection.source)))
><if(connection.attributes)
>output_<control>(<index>) =\> <instance.id>_<connection.source.name>_<control>,<
else
>output_<control>(<index>) =\> <first(portSuccMap.(connection.source)).id>_<connection.target.name>_<control>,<
endif><
else
>output_<control>(<index>) =\> <tgtVertex.port.name>_<control>,<
endif>
>>

broadcastType(connection, name, direction) ::= <<
<if(connection.target.type.bool)
>signal <name>_<direction>_data : std_logic;<
else
>signal <name>_<direction>_data : std_logic_vector(<connection.target.type.size> -1 downto 0);<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// print the network
///////////////////////////////////////////////////////////////////////////////
printNetwork(network, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : <network.simpleName>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <network.simpleName>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


------------------------------------------------------------------------------
entity <network.simpleName> is
  port (
    clock    : in  std_logic;
    reset_n  : in  std_logic;
    <printNetworkPorts(network)>);  
end <network.simpleName>;


------------------------------------------------------------------------------
architecture rtl_<network.simpleName> of <network.simpleName> is

  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  <tryPrintSignals(network); separator="\n">
  ---------------------------------------------------------------------------

begin

  ---------------------------------------------------------------------------
  -- Actors and Networks instantiation 
  ---------------------------------------------------------------------------
  <PrintNetworksAndActors(network)>
  ---------------------------------------------------------------------------
  -- Broadcast and FIFO instantiation 
  --------------------------------------------------------------------------- 
  <printBroadcasts(network)>
  <assignFifos(network.connections)>
  ---------------------------------------------------------------------------

end architecture rtl_<network.simpleName>;

>>
