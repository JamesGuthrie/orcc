printProcessor(processor, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : <processor.name>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <processor.name>.vhd
-- Author     : Orcc - TTA
-- Company    : 
-- Created    : 
-- Standard   : VHDL 93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------


------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;

library work;
use work.<processor.name>_tl_globals.all;
use work.<processor.name>_tl_imem_mau.all;
use work.<processor.name>_tl_params.all;
use work.<processor.name>_mem_constants.all;


------------------------------------------------------------------------------
entity <processor.name> is
  generic
    (
      device_family : string
      );
  port
    (
      clk                    : in  std_logic;
      <processor.incoming: { edge |<declarePort(edge, edge.targetPort)>}; separator="\n">
      <processor.outgoing: { edge |<declarePort(edge, edge.sourcePort)>}; separator="\n">
      rst_n                  : in  std_logic
      );
end <processor.name>;


------------------------------------------------------------------------------
architecture bdf_type of <processor.name> is

<if(options.fpga.xilinx)>
  ---------------------------------------------------------------------------
  -- Components declaration
  ---------------------------------------------------------------------------
  component dram_<processor.name>
    port (
      clka  : in  std_logic;
      wea   : in  std_logic_vector(3 downto 0);
      addra : in  std_logic_vector(fu_LSU_0_addrw-1 downto 0);
      dina  : in  std_logic_vector(fu_LSU_0_dataw-1 downto 0);
      douta : out std_logic_vector(fu_LSU_0_dataw-1 downto 0));
  end component;

  component irom_<processor.name>
    port (
      clka  : in  std_logic;
      addra : in  std_logic_vector(INSTRUCTIONADDRWIDTH-1 downto 0);
      douta : out std_logic_vector(INSTRUCTIONWIDTH-1 downto 0));
  end component;
  
<endif>
  ---------------------------------------------------------------------------
  -- Signals declaration
  ---------------------------------------------------------------------------
  signal dram_addr          : std_logic_vector(fu_LSU_0_addrw-2-1 downto 0);
  signal wren_wire          : std_logic;
  signal wren_x_wire        : std_logic;
  signal dram_data_in_wire  : std_logic_vector(fu_LSU_0_dataw-1 downto 0);
  signal dram_data_out_wire : std_logic_vector(fu_LSU_0_dataw-1 downto 0);
  signal bytemask_wire      : std_logic_vector(fu_LSU_0_dataw/8-1 downto 0);
<if(options.fpga.xilinx)>
  signal bytemask_i         : std_logic_vector(fu_LSU_0_dataw/8-1 downto 0);
  signal bytemask_i2        : std_logic_vector(fu_LSU_0_dataw/8-1 downto 0);
<endif>
  --
  signal imem_addr          : std_logic_vector(IMEMADDRWIDTH-1 downto 0);
  signal idata_wire         : std_logic_vector(INSTRUCTIONWIDTH-1 downto 0);
  --
  <processor.incoming: { edge |<declarePortSignal(edge, edge.targetPort)>}; separator="\n">
  <processor.outgoing: { edge |<declarePortSignal(edge, edge.sourcePort)>}; separator="\n">
  ---------------------------------------------------------------------------

begin

  wren_wire \<= not(wren_x_wire);
  <processor.incoming: { edge |<mapPortSignal(edge, edge.targetPort)>}; separator="\n">
  <processor.outgoing: { edge |<mapPortSignal(edge, edge.sourcePort)>}; separator="\n">

<if(options.fpga.altera)>

  inst_dram_<processor.name> : entity work.dram_1p
    generic map(depth         =\> DATADEPTH,
                byte_width    =\> fu_LSU_0_dataw/4,
                addr_width	  =\> fu_LSU_0_addrw-2,
                bytes         =\> 4,
                init_file     =\> "dram_<processor.name>.mif",
                device_family =\> device_family)
    port map(clk     =\> clk,
             wren    =\> wren_wire,
             address =\> dram_addr,
             byteen  =\> bytemask_wire,
             data    =\> dram_data_in_wire,
             queue   =\> dram_data_out_wire,
             rst_n   =\> rst_n);

  inst_irom_<processor.name> : entity work.irom
    generic map(depth         =\> INSTRUCTIONDEPTH,
                byte_width    =\> IMEMMAUWIDTH,
                addr_width	  =\> INSTRUCTIONADDRWIDTH,
                bytes         =\> IMEMWIDTHINMAUS,
                init_file     =\> "irom_<processor.name>.mif",
                device_family =\> device_family)
    port map(clk     =\> clk,
             address =\> imem_addr(INSTRUCTIONADDRWIDTH-1 downto 0),
             queue   =\> idata_wire,
             rst_n   =\> rst_n);
<else>
  bytemask_i2 \<= wren_wire & wren_wire & wren_wire & wren_wire;
  bytemask_i  \<= bytemask_i2 and bytemask_wire;

  inst_irom_<processor.name> : irom_<processor.name>
    port map (
      clka  =\> clk,
      addra =\> imem_addr(INSTRUCTIONADDRWIDTH-1 downto 0),
      douta =\> idata_wire);

  inst_dram_<processor.name> : dram_<processor.name>
    port map (
      clka  =\> clk,
      wea   =\> bytemask_i,
      addra =\> dram_addr,
      dina  =\> dram_data_in_wire,
      douta =\> dram_data_out_wire);
<endif>


  inst_<processor.name>_tl : entity work.<processor.name>_tl
    port map(clk                      =\> clk,
             busy                     =\> '0',
             imem_addr                =\> imem_addr,
             imem_data                =\> idata_wire,
             pc_init                  =\> (others => '0'),
             fu_LSU_0_dmem_data_in    =\> dram_data_out_wire,
             fu_LSU_0_dmem_data_out   =\> dram_data_in_wire,
             fu_LSU_0_dmem_addr       =\> dram_addr,
             fu_LSU_0_dmem_wr_en_x(0) =\> wren_x_wire,
             fu_LSU_0_dmem_bytemask   =\> bytemask_wire,
             <processor.incoming: { edge |<mapPort(edge, edge.targetPort)>}; separator="\n">
             <processor.outgoing: { edge |<mapPort(edge, edge.sourcePort)>}; separator="\n">
             rstx                     =\> rst_n);
             
end bdf_type;

>>

declarePort(edge, port) ::= <<
<if(edge.signal)
>fu_<port.name> : out std_logic_vector(<edge.size>-1 downto 0);<
else
>fu_<port.name>_dmem_data_in  : in std_logic_vector(fu_<port.name>_dataw-1 downto 0);
fu_<port.name>_dmem_data_out : out std_logic_vector(fu_<port.name>_dataw-1 downto 0);
fu_<port.name>_dmem_addr     : out std_logic_vector(fu_<port.name>_addrw-2-1 downto 0);
fu_<port.name>_dmem_wr_en    : out std_logic;
fu_<port.name>_dmem_bytemask : out std_logic_vector(fu_<port.name>_dataw/8-1 downto 0);<
endif>
>>

declarePortSignal(edge, port) ::= <<
<if(edge.signal)
>signal fu_<port.name>_i : std_logic_vector(7 downto 0);<
else
>signal fu_<port.name>_dmem_wr_en_x : std_logic;<
endif>
>>

mapPort(edge, port) ::= <<
<if(edge.signal)
>fu_<port.name>_STRATIXIII_LED =\> fu_<port.name>_i,<
else
>fu_<port.name>_dmem_data_in    =\> fu_<port.name>_dmem_data_in,
fu_<port.name>_dmem_data_out   =\> fu_<port.name>_dmem_data_out,
fu_<port.name>_dmem_addr       =\> fu_<port.name>_dmem_addr,
fu_<port.name>_dmem_wr_en_x(0) =\> fu_<port.name>_dmem_wr_en_x,
fu_<port.name>_dmem_bytemask   =\> fu_<port.name>_dmem_bytemask,<
endif>
>>

mapPortSignal(edge, port) ::= <<
<if(edge.signal)
>fu_<port.name> \<= fu_<port.name>_i(<edge.size>-1 downto 0);<
else
>fu_<port.name>_dmem_wr_en \<= not(fu_<port.name>_dmem_wr_en_x);<
endif>
>>

