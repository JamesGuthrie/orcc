import "net/sf/orcc/backends/llvm/aot/Actor.stg"

printExternalFifo(connection, port) ::= <<
<if(!port.native)
>@fifo_<connection.id>_content = external addrspace(<port.id>) global [<connection.size> x <if(connection.sourcePort)><connection.sourcePort.type><else><connection.targetPort.type><endif>]
@fifo_<connection.id>_rdIndex = external addrspace(<port.id>) global i32
@fifo_<connection.id>_wrIndex = external addrspace(<port.id>) global i32<
endif>
>>


printInput(port, connection) ::= <<
<if(!port.native)
>@SIZE_<port.name> = internal constant i32 <connection.size>
@index_<port.name> = internal global i32 0
@wrIndex_<port.name> = internal global i32 0
@numTokens_<port.name> = internal global i32 0

<printReadTokensFunction(port, connection)><
endif>
>>

printOutput(port, connection) ::= <<
<if(!port.native)
>@SIZE_<port.name> = internal constant i32 <connection.size>
@index_<port.name> = internal global i32 0
@rdIndex_<port.name> = internal global i32 0
@numFree_<port.name> = internal global i32 0

<printWriteTokensFunction(port, connection)><
endif>
>>

printReadTokensFunction(port, connection) ::= <<
define internal void @read_<port.name>() {
entry:
	br label %read

read:
	%rdIndex = load volatile i32 addrspace(<port.id>)* @fifo_<connection.id>_rdIndex
	store i32 %rdIndex, i32* @index_<port.name>
	%wrIndex = load volatile i32 addrspace(<port.id>)* @fifo_<connection.id>_wrIndex
	store i32 %wrIndex, i32* @wrIndex_<port.name>
	%getNumTokens = sub i32 %wrIndex, %rdIndex
	%numTokens = add i32 %rdIndex, %getNumTokens
	store i32 %numTokens, i32* @numTokens_<port.name>
	ret void
}

define internal void @read_end_<port.name>() {
entry:
	br label %read_end

read_end:
	%rdIndex = load i32* @index_<port.name>
	store volatile i32 %rdIndex, i32 addrspace(<port.id>)* @fifo_<connection.id>_rdIndex
	ret void
}
>>

printWriteTokensFunction(port, connection) ::= <<
define internal void @write_<port.name>() {
entry:
	br label %write

write:
	%wrIndex = load volatile i32 addrspace(<port.id>)* @fifo_<connection.id>_wrIndex
	store i32 %wrIndex, i32* @index_<port.name>
	%rdIndex = load volatile i32 addrspace(<port.id>)* @fifo_<connection.id>_rdIndex
	store i32 %rdIndex, i32* @rdIndex_<port.name>
	%size = load i32* @SIZE_<port.name>
	%numTokens = sub i32 %wrIndex, %rdIndex
	%getNumFree = sub i32 %size, %numTokens
	%numFree = add i32 %wrIndex, %getNumFree
	store i32 %numFree, i32* @numFree_<port.name>
	ret void
}

define internal void @write_end_<port.name>() {
entry:
	br label %write_end

write_end:
	%wrIndex = load i32* @index_<port.name>
	store volatile i32 %wrIndex, i32 addrspace(<port.id>)* @fifo_<connection.id>_wrIndex
	ret void
}
>>

printCallEndTokenFunctions() ::= <<
>>

printArchitecture() ::= <<
>>

printStore(store) ::= <<
<if(store.target.variable.type.list)>
<if(action.outputPattern.varToPortMap.(store.target.variable) && !action.outputPattern.varToPortMap.(store.target.variable).native)>
<printPortAccess(first(instance.outgoingPortMap.(action.outputPattern.varToPortMap.(store.target.variable))), action.outputPattern.varToPortMap.(store.target.variable), store.target.variable, store.indexes, store)>
store volatile <store.target.variable.type.innermostType> <Expr(store.value)>, <store.target.variable.type.innermostType> addrspace(<action.outputPattern.varToPortMap.(store.target.variable).id>)* <varName(store.target.variable, store)>
<else>
<varName(store.target.variable, store)> = getelementptr <store.target.variable.type>* <Var(store.target.variable)>, i32 0<if(store.indexes)>, <indexes(store.indexes)><endif>
store <store.target.variable.type.innermostType> <Expr(store.value)>, <store.target.variable.type.innermostType>* <varName(store.target.variable, store)>
<endif>
<else>
store <store.target.variable.type> <Expr(store.value)>, <store.target.variable.type>* <Var(store.target.variable)>
<endif>
>>

printLoad(load) ::= <<
<if(load.source.variable.type.list)>
<if(action.inputPattern.varToPortMap.(load.source.variable) && !action.inputPattern.varToPortMap.(load.source.variable).native)>
<printPortAccess(instance.incomingPortMap.(action.inputPattern.varToPortMap.(load.source.variable)), action.inputPattern.varToPortMap.(load.source.variable), load.source.variable, load.indexes, load)>
<Var(load.target.variable)> = load volatile <load.source.variable.type.innermostType> addrspace(<action.inputPattern.varToPortMap.(load.source.variable).id>)* <varName(load.source.variable, load)>
<elseif(action.peekPattern.varToPortMap.(load.source.variable))>
<printPortAccess(instance.incomingPortMap.(action.peekPattern.varToPortMap.(load.source.variable)), action.peekPattern.varToPortMap.(load.source.variable), load.source.variable, load.indexes, load)>
<Var(load.target.variable)> = load volatile <load.source.variable.type.innermostType> addrspace(<action.peekPattern.varToPortMap.(load.source.variable).id>)* <varName(load.source.variable, load)>
<else>
<varName(load.source.variable, load)> = getelementptr <load.source.variable.type>* <Var(load.source.variable)>, i32 0, <indexes(load.indexes)>
<Var(load.target.variable)> = load <load.source.variable.type.innermostType>* <varName(load.source.variable, load)>
<endif>
<else>
<Var(load.target.variable)> = load <load.source.variable.type>* <Var(load.source.variable)>
<endif>
>>

printPortAccess(fifo, port, var, indexes, instruction) ::= <<
<if(instance.actor.templateData.castedIndexes.(first(indexes)))>%cast_index_<var.name>_<procedure.accessMap.(instruction)> = zext <first(indexes).type> <Expr(first(indexes))> to i32<endif>
%tmp_index_<var.name>_<procedure.accessMap.(instruction)> = add i32 %local_index_<port.name>, <if(instance.actor.templateData.castedIndexes.(first(indexes)))>%cast_index_<var.name>_<procedure.accessMap.(instruction)><else><Expr(first(indexes))><endif>
%final_index_<var.name>_<procedure.accessMap.(instruction)> = urem i32 %tmp_index_<var.name>_<procedure.accessMap.(instruction)>, %local_size_<port.name>
<varName(var, instruction)> = getelementptr [<fifo.size> x <port.type>] addrspace(<port.id>)* @fifo_<fifo.id>_content, i32 0, i32 %final_index_<var.name>_<procedure.accessMap.(instruction)>
>>

printNativeRead(port, var) ::= <<
;; TODO
>>

printNativeWrite(port, var) ::= <<
%tmp_<var.name>_elt = getelementptr <var.type>* <Var(var)>, i32 0, i1 0 
%tmp_<var.name> = load <var.type.innermostType>* %tmp_<var.name>_elt
tail call void asm sideeffect "SIG_OUT_<port.name>.LEDS", "ir"(<var.type.innermostType> %tmp_<var.name>) nounwind
>>

checkOutputPorts(action, port, restPorts, portToIndexMap, state, lastPort=false) ::= <<
<if(!port.native)
>%size_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @SIZE_<port.name>
%index_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @index_<port.name>
%rdIndex_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @rdIndex_<port.name>
%tmp_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = sub i32 %size_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, %index_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>
%status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = add i32 %tmp_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, %rdIndex_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)><
endif>

<if(!lastPort)>
%has_valid_outputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = icmp uge i32 <if(!port.native)>%status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)><else><pattern.numTokensMap.(port)><endif>, <pattern.numTokensMap.(port)>
<else>
%available_output_<if(state)><state.name>_<endif><action.name>_<port.name> = icmp sge i32 <if(!port.native)>%status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)><else><pattern.numTokensMap.(port)><endif>, <pattern.numTokensMap.(port)>
%has_valid_outputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = and i1 %has_valid_outputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(lastPort)>, %available_output_<if(state)><state.name>_<endif><action.name>_<port.name><
endif><
if(restPorts)>
<checkOutputPorts(action, first(restPorts), rest(restPorts), portToIndexMap, state, port)><
endif>
>>

printStateVarNature(variable) ::= <<
addrspace(0) <if(variable.assignable)>global<else>constant<endif>
>>

printActionBody(procedure) ::= <<
define internal void @<procedure.name>() nounwind {
entry:
	<procedure.locals: variableDeclaration()>
	<action.outputPattern.ports: { port | <if(port.native)><variableDeclaration(action.outputPattern.portToVarMap.(port))><endif>}; separator="\n">
	<action.inputPattern.ports: { port | <if(!port.native)><fifoVar(port, action.inputPattern.portToVarMap.(port))><endif>}; separator="\n">
	<action.outputPattern.ports: { port | <if(!port.native)><fifoVar(port, action.outputPattern.portToVarMap.(port))><endif>}; separator="\n">
	<action.inputPattern.ports: { port | <if(port.native)><printNativeRead(port, action.inputPattern.portToVarMap.(port))><endif>}; separator="\n">
	br label %b<label(first(procedure.nodes))>

<printNodes(procedure.nodes, false)>
	<action.inputPattern.ports: { port | <if(!port.native)><printFifoEnd(port, action.inputPattern.numTokensMap.(port))><endif>}; separator="\n">
	<action.outputPattern.ports: { port | <if(!port.native)><printFifoEnd(port, action.outputPattern.numTokensMap.(port))><endif>}; separator="\n"> 
	<action.outputPattern.ports: { port | <if(port.native)><printNativeWrite(port, action.outputPattern.portToVarMap.(port))><endif>}; separator="\n">
	;; TOFIX: only when the connected actors is mapped to another processor
	<action.inputPattern.ports: {port|<if(!port.native)>call void @read_end_<port.name>()<endif>}; separator="\n">
	<action.outputPattern.ports: {port|<if(!port.native)>call void @write_end_<port.name>()<endif>}; separator="\n">
	ret void
}
>>

printBcastCopy() ::= <<
%size_<first(entity.inputs).name> = load i32* @SIZE_<first(entity.inputs).name>
%final_index_<first(entity.inputs).name>  = urem i32 %index_<first(entity.inputs).name> , %size_<first(entity.inputs).name>
%ptr_<first(entity.inputs).name> = getelementptr [<entity.incomingPortMap.(first(entity.inputs)).size> x <first(entity.inputs).type>] addrspace(<first(entity.inputs).id>)* @fifo_<entity.incomingPortMap.(first(entity.inputs)).id>_content, i32 0, i32 %final_index_<first(entity.inputs).name>
%value = load volatile <first(entity.inputs).type> addrspace(<first(entity.inputs).id>)* %ptr_<first(entity.inputs).name>
%new_index_<first(entity.inputs).name> = add i32 %index_<first(entity.inputs).name>, 1
store i32 %new_index_<first(entity.inputs).name>, i32* @index_<first(entity.inputs).name>
<entity.outputs: copyBcastOutputs(); separator="\n">
br label %bb_scheduler_start
>>

checkBcastOutputs(port, restPorts, lastPort) ::= <<
%size_<port.name> = load i32* @SIZE_<port.name>
%index_<port.name> = load i32* @index_<port.name>
%rdIndex_<port.name> = load i32* @rdIndex_<port.name>
%tmp_<port.name> = sub i32 %size_<port.name>, %index_<port.name>
%status_<port.name> = add i32 %tmp_<port.name>, %rdIndex_<port.name>
%ready_<port.name> = icmp sge i32 %status_<port.name>, 1
%fireable_<port.name> = and i1 %ready_<port.name>, %fireable_<lastPort.name>
<if(restPorts)><
checkBcastOutputs(first(restPorts), rest(restPorts), port)><
else
>br i1 %fireable_<port.name>, label %bb_copy, label %bb_finished<
endif>
>>

copyBcastOutputs(port) ::= <<
%final_index_<port.name>  = urem i32 %index_<port.name> , %size_<port.name>
%ptr_<port.name> = getelementptr [<first(entity.outgoingPortMap.(port)).size> x <port.type>] addrspace(<port.id>)* @fifo_<first(entity.outgoingPortMap.(port)).id>_content, i32 0, i32 %final_index_<port.name>
store volatile <port.type> %value, <port.type> addrspace(<port.id>)* %ptr_<port.name>
%new_index_<port.name> = add i32 %index_<port.name>, 1
store i32 %new_index_<port.name>, i32* @index_<port.name>
>>