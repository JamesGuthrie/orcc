
indexPort(port) ::= <<
<if(instance.actor)
><instance.actor.templateData.portToIndexMap.(port)><
elseif(instance.broadcast)
><instance.broadcast.portMap.(port)><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////

sendData(port) ::= <<
<if(port.type.int)
>s_<port.name>_q  \<= std_logic_vector(to_signed(input_value, 32));<
else
>s_<port.name>_q  \<= std_logic_vector(to_unsigned(input_value, 32));<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print signal and instanciation
///////////////////////////////////////////////////////////////////////////////

printSignalInput(port) ::= <<
<if(!port.native)
>signal s_<port.name>_q      : std_logic_vector(31 downto 0);
signal s_<port.name>_status : std_logic_vector(31 downto 0);
signal s_<port.name>_rdreq  : std_logic;<
else
>signal <port.name>_native : std_logic_vector(<port.type.size>-1 downto 0);<
endif>
>>

printSignalOutput(port) ::= <<
<if(!port.native)
>signal s_<port.name>_data   : std_logic_vector(31 downto 0);
signal s_<port.name>_status : std_logic_vector(31 downto 0);
signal s_<port.name>_wrreq  : std_logic;<
else
>signal <port.name>_native : std_logic_vector(<port.type.size>-1 downto 0);<
endif>
>>

mapSignalInput(port) ::= <<
<if(port.native)
><port.name> =\> s_<port.name>_native,<
else
>data_<indexPort(port)>_in    =\> s_<port.name>_q,
status_<indexPort(port)>_in  =\> s_<port.name>_status,
ack_<indexPort(port)>_in     =\> s_<port.name>_rdreq,<
endif>
>>

mapSignalOutput(port) ::= <<
<if(port.native)
><port.name>   =\> s_<port.name>_native,<
else
>data_<indexPort(port)>_out   =\> s_<port.name>_data,
status_<indexPort(port)>_out =\> s_<port.name>_status,
dv_<indexPort(port)>_out     =\> s_<port.name>_wrreq,<
endif>
>>

sig_const(input, output) ::= <<
constant PERIOD      : time := 10 ns;
--
type severity_level is (note, warning, error, failure);
--
-- Input and Output files
<input: printTraceIn(); separator="\n">
<output: printTraceOut(); separator="\n">
--
-- Input and Output signals
<input: printSignalInput(); separator="\n">
<output: printSignalOutput(); separator="\n">
--
-- Configuration
signal clk         : std_logic := '0';
signal rst_n       : std_logic := '0';

>>

printTraceIn(port) ::= <<
<if(!port.native)
>file trace_<port.name> : text is "../trace/<instance.id>_<port.name>.txt";<
endif>
>>

printTraceOut(port) ::= <<
<if(!port.native)
>file trace_<port.name> : text is "../trace/<instance.id>_<port.name>.txt";<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print processes
///////////////////////////////////////////////////////////////////////////////

init_process() ::= <<
-- clock generation
clk \<= not clk after PERIOD/2;

-- reset generation
reset_proc: process
begin
    rst_n \<= '0';
    wait for 100 ns;
    rst_n \<= '1';
    wait;
end process;
>>

printInputProcess(input) ::= <<
-- Input "<input.name>" Generation
Proc_in_<input.name> : process (rst_n, clk)
  variable input_value  : integer;
  variable current_line : line;
  variable current_status_<input.name> : integer;
  
begin

  if rst_n = '0' then
    file_close(trace_<input.name>);
    file_open(trace_<input.name>, "../trace/<instance.id>_<input.name>.txt", read_mode);
    
    -- Compute initial status
    current_status_<input.name> := 0;
    while not (endfile (trace_<input.name>)) loop
      readline (trace_<input.name>, current_line);
      current_status_<input.name> := current_status_<input.name> + 1;
    end loop;
    
    file_close(trace_<input.name>);
    file_open(trace_<input.name>, "../trace/<instance.id>_<input.name>.txt", read_mode);
    
    -- Initialize signals
    if not (endfile (trace_<input.name>)) then
      readline(trace_<input.name>, current_line);
      --
      if current_line'length \> 0 and current_line(1) /= '/' then
        read(current_line, input_value);
        <sendData(input)>
        current_status_<input.name> := current_status_<input.name> - 1;
      else
        s_<input.name>_q \<= (others =\> '0');
      end if;
    else
      s_<input.name>_q \<= (others =\> '0');
    end if;
    
    s_<input.name>_status \<= std_logic_vector(to_unsigned(current_status_<input.name>, 32));    
    
    
  elsif clk'event and clk = '1' then 
    if not (endfile (trace_<input.name>)) and s_<input.name>_rdreq = '1' then
      readline(trace_<input.name>, current_line);
      --
      if current_line'length \> 0 and current_line(1) /= '/' then
        read(current_line, input_value);
        <sendData(input)>
        current_status_<input.name> := current_status_<input.name> - 1;
      end if;
    end if;
    s_<input.name>_status  \<= std_logic_vector(to_unsigned(current_status_<input.name>, 32));
  end if;
  
end process Proc_in_<input.name>;
>>

printOutputProcess(output) ::= <<
-- Output "<output.name>" Generation
Proc_in_<output.name> : process (rst_n, clk)
  variable output_value : integer;
  variable current_line : line;

begin

  if (rst_n = '0') then
    s_<output.name>_status \<= (others => '0');
    
  elsif clk'event and clk = '1' then
    if (not (endfile (trace_<output.name>)) and s_<output.name>_wrreq = '1') then
      readline(trace_<output.name>, current_line);
      if (current_line'length \> 0 and current_line(1) /= '/') then
        read(current_line, output_value);
<if(output.type.int)>
        assert (s_<output.name>_data  = std_logic_vector(to_signed(output_value, 32)))
          report ("on port <output.name> incorrectly value computed : " & str(to_integer(signed(s_<output.name>_data))) & " instead of " & str(output_value) & ".")
          severity error;
<else>
        assert (s_<output.name>_data  = std_logic_vector(to_unsigned(output_value, 32)))
          report ("on port <output.name> incorrectly value computed : " & str(to_integer(unsigned(s_<output.name>_data))) & " instead of " & str(output_value) & ".")
          severity error;
<endif>
      end if;
    end if;
  end if;
  
end process Proc_in_<output.name>;
>>


///////////////////////////////////////////////////////////////////////////////
// Testbench
///////////////////////////////////////////////////////////////////////////////

instance(instance, options) ::= <<
------------------------------------------------------------------------------
-- Generated from <instance.id>
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;
use work.sim_package.all;

entity tb_<instance.id> is

end tb_<instance.id>;


architecture arch_tb_<instance.id> of tb_<instance.id> is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.actor.inputs,output=instance.actor.outputs)>
  ---------------------------------------------------------------------------

begin

  <instance.id>_orcc : entity work.processor_<instance.id>
    port map (
      clk          =\> clk,
      <if(instance.actor.inputs)><instance.actor.inputs: mapSignalInput(); separator="\n"><endif>
      <if(instance.actor.outputs)><instance.actor.outputs: mapSignalOutput(); separator="\n"><endif>
      rst_n        =\> rst_n);
            
  <init_process()>
    
  <if(instance.actor.inputs)
  ><instance.actor.inputs: printInputProcess(); separator="\n\n"><
  endif>
  
  <if(instance.actor.outputs)
  ><instance.actor.outputs: printOutputProcess(); separator="\n\n"><
  endif>

end architecture arch_tb_<instance.id>;
>>

network(network, options) ::= <<
------------------------------------------------------------------------------
-- Generated from top
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;

entity tb_top is

end tb_top;


architecture arch_tb_top of tb_top is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=network.inputs,output=network.outputs)>
  ---------------------------------------------------------------------------

begin

  top_orcc : entity work.top
    port map (
      clk     =\> clk,
      <if(network.inputs)><network.inputs: mapSignalInput(); separator="\n"><endif>
      <if(network.outputs)><network.outputs: mapSignalOutput(); separator="\n"><endif>
      rst_n   =\> rst_n);
      
    <init_process()>


end architecture arch_tb_top;
>>