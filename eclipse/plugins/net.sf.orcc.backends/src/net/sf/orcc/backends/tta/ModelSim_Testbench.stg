
indexPort(port) ::= <<
<if(instance.actor)
><instance.actor.templateData.portToIndexMap.(port)><
elseif(instance.broadcast)
><instance.broadcast.portMap.(port)><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////

sendData(port) ::= <<
<if(port.type.int)
>s_<port.name>_q  \<= std_logic_vector(to_signed(input_bit, 32));<
else
>s_<port.name>_q  \<= std_logic_vector(to_unsigned(input_bit, 32));<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print signal and instanciation
///////////////////////////////////////////////////////////////////////////////

printSignalInput(port) ::= <<
<if(!port.native)
>signal s_<port.name>_q			: std_logic_vector(31 downto 0);
signal s_<port.name>_status		: std_logic_vector(8 downto 0);
signal s_<port.name>_rdreq		: std_logic;<
else
>signal s_<port.name>_native	: std_logic_vector(<port.type.size>-1 downto 0);<
endif>
>>

printSignalOutput(port) ::= <<
<if(!port.native)
>signal s_<port.name>_data		: std_logic_vector(31 downto 0);
signal s_<port.name>_status		: std_logic_vector(8 downto 0);
signal s_<port.name>_wrreq		: std_logic;<
else
>signal s_<port.name>_native	: std_logic_vector(<port.type.size>-1 downto 0);<
endif>
>>

signalInitInput(port) ::=<<
<if(!port.native)
>s_<port.name>_q       \<= (others =\> '0');
s_<port.name>_status  \<= (others =\> '0');<
else
>s_<port.name>_native  \<= 'Z';<
endif>
>>

signalInitOutput(port) ::=<<
<if(!port.native)
>s_<port.name>_status   \<= (others =\> '0');<
else
>s_<port.name>_native   \<= 'Z';<
endif>
>>

mapSignalInput(port) ::= <<
<if(port.native)
><port.name> =\> s_<port.name>_native,<
else
>data_<indexPort(port)>_in    =\> s_<port.name>_q,
status_<indexPort(port)>_in  =\> s_<port.name>_status,
ack_<indexPort(port)>_in     =\> s_<port.name>_rdreq,<
endif>
>>

mapSignalOutput(port) ::= <<
<if(port.native)
><port.name>   =\> s_<port.name>_native,<
else
>data_<indexPort(port)>_out   =\> s_<port.name>_data,
status_<indexPort(port)>_out =\> s_<port.name>_status,
dv_<indexPort(port)>_out     =\> s_<port.name>_wrreq,<
endif>
>>

sig_const(input, output) ::= <<
constant PERIOD      : time := 10 ns;
--
type severity_level is (note, warning, error, failure);
--
-- Input and Output files
<input: printTraceIn(); separator="\n">
<output: printTraceOut(); separator="\n">
--
-- Input and Output signals
<input: printSignalInput(); separator="\n">
<output: printSignalOutput(); separator="\n">
--
-- Configuration
signal clk         : std_logic := '0';
signal rst_n       : std_logic := '0';

>>

printTraceIn(port) ::= <<
<if(!port.native)
>file trace_<instance.id>_<port.name> : text is "../trace/<instance.id>_<port.name>.txt";<
endif>
>>

printTraceOut(port) ::= <<
<if(!port.native)
>file trace_<instance.id>_<port.name> : text is "../trace/<instance.id>_<port.name>.txt";<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print processes
///////////////////////////////////////////////////////////////////////////////

init_process() ::= <<
-- clock generation
clk \<= not clk after PERIOD/2;

-- reset generation
reset_proc: process
begin
    rst_n \<= '0';
    wait for 100 ns;
    rst_n \<= '1';
    wait;
end process;
>>

process_in(inputs) ::= <<
--
-- Input(s) Waveform Generation
WaveGen_Proc_In : process (rst_n, clk)
  variable Input_bit   : integer;
  variable line_number : line;
begin
  if rst_n = '0' then
    <inputs: signalInitInput(); separator="\n">
  --  
  elsif clk = '1' then 
    <inputs: readAndSend(); separator="\n">
  end if;
end process WaveGen_Proc_In;
>>


readAndSend(port) ::= <<
<if (!port.native)
>-- Input port: <port.name> Waveform Generation
if (not endfile (trace_<instance.id>_<port.name>)) then
  readline(trace_<instance.id>_<port.name>, line_number);
  --
  if ((line_number'length \> 0 and line_number(1) /= '/') and s_<port.name>_rdreq = '1') then
    read(line_number, input_bit);
    <sendData(port)>
  end if;
end if;<
endif>
>>

process_out(outputs) ::= <<
-- Output(s) waveform Generation
<outputs: {port|<if(!port.native)>s_<port.name>_status \<= (others => '0');<\n><endif>}>    
--
WaveGen_Proc_Out : process (rst_n, clk)
  variable Input_bit   : integer;
  variable line_number : line;
begin
  if (rst_n = '0') then
    <outputs: signalInitOutput()>    --
  elsif (rising_edge(clk)) then
    <outputs: case_define_out(); separator="\n">
  end if;
end process WaveGen_Proc_Out;

>>


case_define_out(port) ::= <<
<if (!port.native)
>-- Output port: <port.name> Waveform Generation
if (not endfile (trace_<instance.id>_<port.name>) and s_<port.name>_wrreq = '1') then
  readline(trace_<instance.id>_<port.name>, line_number);
  --
  if (line_number'length \> 0 and line_number(1) /= '/') then
    read(line_number, input_bit);
<
if(port.type.bool)
>    if (input_bit = 1) then
      assert (s_<port.name>_data = '1')
        report "on port <port.name> incorrectly value computed : '0' instead of '1'"
        severity error;
    else
      assert (s_<port.name>_data = '0')
        report "on port <port.name> incorrectly value computed : '1' instead of '0'"
        severity error;
           
    end if;<
else
><if(port.type.int)
  >    assert (s_<port.name>_data  = std_logic_vector(to_signed(input_bit, 32)))
      report "on port <port.name> incorrectly value computed : " & str(to_integer(signed(s_<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;

  <else
  >    assert (s_<port.name>_data  = std_logic_vector(to_unsigned(input_bit, 32)))
      report "on port <port.name> incorrectly value computed : " & str(to_integer(unsigned(s_<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;
      
  <endif
  ><endif
>    --
  end if;
end if;
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Testbench
///////////////////////////////////////////////////////////////////////////////

instance(instance, options) ::= <<
------------------------------------------------------------------------------
-- Generated from <instance.id>
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;
use work.sim_package.all;

entity tb_<instance.id> is

end tb_<instance.id>;


architecture arch_tb_<instance.id> of tb_<instance.id> is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.actor.inputs,output=instance.actor.outputs)>
  ---------------------------------------------------------------------------

begin

  <instance.id>_orcc : entity work.processor_<instance.id>
    port map (
      clk          =\> clk,
      <if(instance.actor.inputs)><instance.actor.inputs: mapSignalInput(); separator="\n"><endif>
      <if(instance.actor.outputs)><instance.actor.outputs: mapSignalOutput(); separator="\n"><endif>
      rst_n        =\> rst_n);
            
    <init_process()>
    
    <if(instance.actor.inputs)
    ><process_in(instance.actor.inputs)><
    endif>

end architecture arch_tb_<instance.id>;
>>

network(network, options) ::= <<
------------------------------------------------------------------------------
-- Generated from top
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;

entity tb_top is

end tb_top;


architecture arch_tb_top of tb_top is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=network.inputs,output=network.outputs)>
  ---------------------------------------------------------------------------

begin

  top_orcc : entity work.top
    port map (
      clk     =\> clk,
      <if(network.inputs)><network.inputs: mapSignalInput(); separator="\n"><endif>
      <if(network.outputs)><network.outputs: mapSignalOutput(); separator="\n"><endif>
      rst_n   =\> rst_n);
      
    <init_process()>


end architecture arch_tb_top;
>>