import "net/sf/orcc/backends/c/CMakeLists.stg"

printNetwork(network, options) ::= <<
# Generated from <network.simpleName>

cmake_minimum_required (VERSION 2.6)

<useClang()>

project (<network.simpleName>)

<includeLibraries()>

<createExecutable(network)>

<link(network)>
>>

useClang() ::= <<
# LLVM compiler
set(CMAKE_C_COMPILER "clang")
>>

createExecutable(network) ::= <<
set(filenames
	${CMAKE_BINARY_DIR}/CMakeFiles/<network.simpleName>.ll.o
	<network.instances: sourceFile();separator="\n">
	<network.entities: sourceFile();separator="\n">
)

macro (compileAssemblyFile name) 
	add_custom_command(
		OUTPUT ${CMAKE_BINARY_DIR}/CMakeFiles/${name}.ll.o
		DEPENDS ${CMAKE_SOURCE_DIR}/${name}.ll
		COMMAND ${CMAKE_C_COMPILER} -c ${CMAKE_SOURCE_DIR}/${name}.ll -o ${CMAKE_BINARY_DIR}/CMakeFiles/${name}.ll.o
		COMMENT "Building LLVM object ${name}.ll.o" 
	)
endmacro(compileAssemblyFile)

compileAssemblyFile(<network.simpleName>)
<network.instances: compileAssemblyFile();separator="\n">
<network.entities: compileAssemblyFile();separator="\n">

add_executable(<network.simpleName> ${filenames})

set_target_properties(<network.simpleName> PROPERTIES LINKER_LANGUAGE C)
>>

sourceFile(instance) ::= <%
<if(!instance.actor.native)>
${CMAKE_BINARY_DIR}/CMakeFiles/<instance.name>.ll.o
<endif>
%>

compileAssemblyFile(vertex) ::= <<
<if(!vertex.actor.native)
>compileAssemblyFile(<vertex.name>)<
endif>
>>
