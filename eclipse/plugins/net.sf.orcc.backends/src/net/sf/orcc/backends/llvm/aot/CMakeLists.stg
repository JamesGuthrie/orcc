import "net/sf/orcc/backends/c/CMakeLists.stg"

printNetwork(network, options) ::= <<
# Generated from <network.simpleName>

cmake_minimum_required (VERSION 2.6)

<useClang()>

project (<network.simpleName>)

<includeLibraries()>

<createExecutable(network)>

<link(network)>
>>

useClang() ::= <<
# LLVM compiler
set(CMAKE_C_COMPILER "clang")
>>

createExecutable(network) ::= <<
set(filenames
	${CMAKE_BINARY_DIR}/<network.simpleName>.o
	<network.instances: sourceFile();separator="\n">
	<network.entities: sourceFile();separator="\n">
)

macro (compileAssemblyFile name) 
	add_custom_command(
		OUTPUT ${CMAKE_BINARY_DIR}/${name}.o
		DEPENDS ${CMAKE_SOURCE_DIR}/${name}.ll
		COMMAND ${CMAKE_C_COMPILER} -c ${CMAKE_SOURCE_DIR}/${name}.ll -o ${CMAKE_BINARY_DIR}/${name}.o
	)
endmacro(compileAssemblyFile)

compileAssemblyFile(<network.simpleName>)
<network.instances: compileAssemblyFile();separator="\n">
<network.entities: compileAssemblyFile();separator="\n">

add_executable(<network.simpleName> ${filenames})

set_target_properties(<network.simpleName> PROPERTIES LINKER_LANGUAGE C)
>>

sourceFile(instance) ::= <%
<if(!instance.actor.native)>
${CMAKE_BINARY_DIR}/<instance.name>.o
<endif>
%>

compileAssemblyFile(vertex) ::= <<
<if(!vertex.actor.native)
>compileAssemblyFile(<vertex.name>)<
endif>
>>
