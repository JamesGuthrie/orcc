printNetwork (network, options) ::= << 
target triple = "x86_64"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare and initialize FIFO variables 

declare void @init_orcc(i32 %argc, i8** %argv)

<network.connections: declareFifo(); separator="\n\n">


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare the scheduling function of each actor

<network.instances: declareScheduler(); separator="\n">
<network.entities: declareScheduler(); separator="\n">
<network.instances: declareInitialize(); separator="\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The main function - A simple round-robin scheduler

define void @main(i32 %argc, i8** %argv) noinline noreturn nounwind {
entry:
	call void @init_orcc(i32 %argc, i8** %argv);
	<network.instances: callInitialize(); separator="\n">
	br label %loop

loop:
	<network.instances: callScheduler(); separator="\n">
	<network.entities: callScheduler(); separator="\n">
	br label %loop
}

>>

callScheduler(vertex) ::= <<
call void @<vertex.name>_scheduler()
>>

callInitialize(instance) ::= <%
<if(instance.actor.initializes)>
call void @<instance.name>_initialize()
<endif>
%>

declareFifo(connection) ::= <<
@fifo_<connection.id>_content = global [<connection.size> x <connection.sourcePort.type>] zeroinitializer, align 32
@fifo_<connection.id>_rdIndex = global i32 zeroinitializer, align 32
@fifo_<connection.id>_wrIndex = global i32 zeroinitializer, align 32
>>

declareScheduler(vertex) ::= <<
declare void @<vertex.name>_scheduler()
>>

declareInitialize(instance) ::= <%
<if(instance.actor.initializes)>
declare void @<instance.name>_initialize()
<endif>
%>