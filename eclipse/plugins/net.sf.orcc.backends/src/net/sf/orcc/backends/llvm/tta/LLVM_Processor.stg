import "net/sf/orcc/backends/llvm/aot/Network.stg"


printProcessor(processor, options) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare and initialize FIFO variables 

<processor.incoming: { buffer |<declareBuffer(buffer, buffer.targetPort.addressSpace.id)>}; separator="\n\n">

<processor.outgoing: { buffer |<declareBuffer(buffer, buffer.sourcePort.addressSpace.id)>}; separator="\n\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare the scheduling function of each actor

<processor.mappedActors: declareScheduler(); separator="\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The main function - A simple round-robin scheduler

define void @main() noinline noreturn nounwind {
entry:
	br label %loop

loop:
	<processor.mappedActors: callScheduler(); separator="\n">
	br label %loop
}
>>

declareBuffer(buffer, id) ::= <<
<buffer.mappedConnections: declareFifo(id); separator="\n\n">
>>

declareFifo(connection, id) ::= <<
@fifo_<connection.id>_content = addrspace(<id>) global [<connection.size> x <connection.sourcePort.type>] zeroinitializer, align 32
@fifo_<connection.id>_rdIndex = addrspace(<id>) global i32 zeroinitializer, align 32
@fifo_<connection.id>_wrIndex = addrspace(<id>) global i32 zeroinitializer, align 32
>>

getAddressSpace(processor, buffer) ::= <<
<processor.templateData.bufferToIdMap.(buffer)>
>>
