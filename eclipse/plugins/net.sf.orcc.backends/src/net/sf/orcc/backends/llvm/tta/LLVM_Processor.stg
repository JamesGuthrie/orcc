import "net/sf/orcc/backends/llvm/aot/Network.stg"


printProcessor(processor, options) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare and initialize FIFO variables 

<processor.localRAMs: declareBuffer(); separator="\n\n">
<processor.sharedRAMs: declareBuffer(); separator="\n\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare the scheduling function of each actor

<processor.mappedActors: declareScheduler(); separator="\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The main function - A simple round-robin scheduler

define i32 @main() noreturn nounwind {
entry:
	br label %loop

loop:
	<processor.mappedActors: callScheduler(); separator="\n">
	br label %loop
}
>>

declareBuffer(buffer) ::= <<
<buffer.mappedConnections: declareFifo(processor.memToAddrSpaceIdMap.(buffer)); separator="\n\n">
>>

declareFifo(connection, id) ::= <<
@fifo_<connection.id>_content = addrspace(<id>) global [<connection.size> x <connection.sourcePort.type>] zeroinitializer, align 32
@fifo_<connection.id>_rdIndex = addrspace(<id>) global i32 zeroinitializer, align 32
@fifo_<connection.id>_wrIndex = addrspace(<id>) global i32 zeroinitializer, align 32
>>

getAddressSpace(processor, buffer) ::= <<
<processor.templateData.bufferToIdMap.(buffer)>
>>
