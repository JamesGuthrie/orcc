import "net/sf/orcc/backends/llvm/aot/Network.stg"


printProcessor(processor, options) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare and initialize FIFO variables 

<processor.incoming: declareBuffer(); separator="\n\n">
<processor.outgoing: declareBuffer(); separator="\n\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Declare the scheduling function of each actor

<processor.mappedActors: declareScheduler(); separator="\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; The main function - A simple round-robin scheduler

define void @main() noinline noreturn nounwind {
entry:
	br label %loop

loop:
	<processor.mappedActors: callScheduler(); separator="\n">
	br label %loop
}
>>

declareBuffer(buffer) ::= <<
<buffer.mappedConnections: declareFifo(); separator="\n\n">
>>

declareFifo(connection) ::= <<
@fifo_<connection.id>_content = addrspace(<getAddressSpace(processor, buffer)>) global [<connection.size> x <connection.sourcePort.type>] zeroinitializer, align 32
@fifo_<connection.id>_rdIndex = addrspace(<getAddressSpace(processor, buffer)>) global i32 zeroinitializer, align 32
@fifo_<connection.id>_wrIndex = addrspace(<getAddressSpace(processor, buffer)>) global i32 zeroinitializer, align 32
>>

getAddressSpace(processor, buffer) ::= <<
<processor.templateData.bufferToIdMap.(buffer)>
>>
