// printing actor interfaces in an IDL file


printParameter(parameter) ::= <<
	in parameter <parameter.name>
>>

printPort(port,direction) ::= <<
	<direction> <port.type> <port.name>
>>

printStateVar(stateVar) ::= <<
	in <stateVar.type> <stateVar.name>_i, out <stateVar.type> <stateVar.name>_o  
>>

printFunctionParameters(actor,action) ::= <%
<actor.parameters:printParameter(); separator=", ">
<if ( !actor.parameters.empty && !action.inputPattern.ports.empty)>, <endif>
<action.inputPattern.ports: {port | <printPort(port,"in")>}; separator=", ">
<if (!actor.parameters.empty || !action.inputPattern.ports.empty)><
	if(!action.outputPattern.ports.empty)>, <endif>
<endif>
<action.outputPattern.ports: {port | <printPort(port,"out")>}; separator=", "> 
<if (!actor.parameters.empty || !action.inputPattern.ports.empty || !action.outputPattern.ports.empty)><
	if(!actor.stateVars.empty)>, <endif>
<endif>
<actor.stateVars : {stateVar | <printStateVar(stateVar)>};separator=", ">
%>

printInterface(action, actor, interface) ::= <<
	interface <interface> {
		void <action.name> (<printFunctionParameters(actor,action)>);
	};
	
>>

printActor(actor, options) ::= <<
module <actor.simpleName> {

	typedef long parameter; <! It might be a good idea to write net.sf.orcc.ir.util.IDLTypePrinter !>
	typedef char i8;
	typedef short i16;
	typedef long i32;
	typedef long long i64;

	typedef char u8;
	typedef unsigned short u16;
	typedef unsigned long u32;
	typedef unsigned long long u64;
	
	
<if (!actor.initializes.empty)>
<printInterface(first(actor.initializes), actor, "init")>
<endif>
<if (!actor.actions.empty)>
<printInterface(first(actor.actions), actor, "loop")>
<endif><!
 There is no end() action in CAL !>};
>>