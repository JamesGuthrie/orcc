import "net/sf/orcc/backends/vhdl/VHDL_actor.stg"

///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
sendData(port) ::= <<
<if(port.type.bool)
>if (input_bit = 1) then
  <port.name>_data  \<= '1';
else
  <port.name>_data  \<= '0';
end if;<
else
><if(port.type.int)
  ><port.name>_data  \<= std_logic_vector(to_signed(input_bit, <port.type.size>));<
  else
  ><port.name>_data  \<= std_logic_vector(to_unsigned(input_bit, <port.type.size>));<
  endif><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print signal and instanciation
///////////////////////////////////////////////////////////////////////////////
printSignal(port, dirSend, dirAck) ::= <<
signal <portType(port=port, IOtype=dirSend, dataType="_data")>;<if (!port.native)>
signal <port.name>_send  : <dirSend>std_logic;
signal <port.name>_ack   : <dirAck>std_logic;<endif>
>>

signalInit(port) ::=<<
<if (port.native)><
if(port.type.bool)>
<port.name> \<= 'Z';
<else>
<port.name> \<= (others =\> 'Z');
<endif>
<else>
<port.name>_send \<= '0';
<if(port.type.bool)>
<port.name>_data \<= '0';
<else>
<port.name>_data \<= (others =\> '0');
<endif>
<endif>
>>

signalsInstanciation(port) ::= <<
<if (port.native)
><port.name>       =\> <port.name><
else
><port.name>_data  =\> <port.name>_data,
<port.name>_send  =\> <port.name>_send,
<port.name>_ack   =\> <port.name>_ack<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : {value | <value>}; separator=" * ">
>>

sig_const(input, output) ::= <<
constant PERIOD      : time := 10 ns;
--
type severity_level is (note, warning, error, failure);
type tb_type is (after_reset, read_file, CheckRead);
--
-- Input and Output files
<input: printFSMIn(); separator="\n">
<output: printFSMOut(); separator="\n">
--
-- Input and Output signals
<input: {port| <printSignal(port, "", "")>}; separator="\n">
<output: {port| <printSignal(port, "", "")>}; separator="\n">
--
-- Configuration
signal count       : integer range 255 downto 0;
signal clock       : std_logic := '0';
signal reset_n     : std_logic := '0';

>>

printFSMIn(port) ::= <<
<if(!port.native)
>signal tb_FSM_<port.name>  : tb_type;
file sim_file_<instance.id>_<port.name>  : text is "<instance.id>_<port.name>_sim.txt";<
endif>
>>

printFSMOut(port) ::= <<
<if(!port.native)
>file sim_file_<instance.id>_<port.name>  : text is "<instance.id>_<port.name>_sim.txt";<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print processes
///////////////////////////////////////////////////////////////////////////////
init_process() ::= <<
-- clock generation
clock \<= not clock after PERIOD/2;

-- reset generation
reset_n \<= '1' after 10*PERIOD;

>>

waveform_process_in(input) ::= <<
--
-- Input(s) Waveform Generation
WaveGen_Proc_In : process (reset_n, clock)
  variable Input_bit   : integer;
  variable line_number : line;
begin
  if reset_n = '0' then
    <input: signalInit()>    --
    <input: {port|<if (!port.native)> tb_FSM_<port.name> \<= after_reset; <endif>} ; separator="\n">    
    count \<= 0;
  --  
  elsif rising_edge(clock) then 
    <input: case_define_in(); separator="\n">
  end if;
end process WaveGen_Proc_In;

>>


case_define_in(port) ::= <<
<if (!port.native)
>--
-- Input port: <port.name> Waveform Generation
case tb_FSM_<port.name> is
  when after_reset =\>
    count \<= count + 1;
    if (count = 15) then
      tb_FSM_<port.name> \<= read_file;
      count           \<= 0;
    end if;

  when read_file =\>
    if (not endfile (sim_file_<instance.id>_<port.name>)) then
      readline(sim_file_<instance.id>_<port.name>, line_number);
      --
      if (line_number'length \> 0 and line_number(1) /= '/') then
        read(line_number, input_bit);
        <sendData(port)>
        <port.name>_send \<= '1';    
        tb_FSM_<port.name> \<= CheckRead;
      end if;
    end if;

  when CheckRead =\>
    if (not endfile (sim_file_<instance.id>_<port.name>)) and <port.name>_ack = '1' then
      readline(sim_file_<instance.id>_<port.name>, line_number);
      --
      if (line_number'length \> 0 and line_number(1) /= '/') then
        read(line_number, input_bit);
        <sendData(port)>
        <port.name>_send \<= '1';      
      end if;
    elsif (endfile (sim_file_<instance.id>_<port.name>)) then
      <port.name>_send \<= '0'; 
    end if;

  when others =\> null;
end case;
<endif>

>>

waveform_process_out(output) ::= <<
-- Output(s) waveform Generation
<output: {port| <if (!port.native)> <port.name>_ack \<= <port.name>_send;<\n><endif>}>    
--
WaveGen_Proc_Out : process (reset_n, clock)
  variable Input_bit   : integer;
  variable line_number : line;
begin
  if (reset_n = '0') then
    -- nothing here
  elsif (rising_edge(clock)) then
    <output: case_define_out(); separator="\n">
  end if;
end process WaveGen_Proc_Out;

>>


case_define_out(port) ::= <<
<if (!port.native)
>--
-- Output port: <port.name> Waveform Generation
if (not endfile (sim_file_<instance.id>_<port.name>) and <port.name>_send = '1') then
  readline(sim_file_<instance.id>_<port.name>, line_number);
  --
  if (line_number'length \> 0 and line_number(1) /= '/') then
    read(line_number, input_bit);
<
if(port.type.bool)
>    if (input_bit = 1) then
      assert (<port.name>_data = '1')
        report "on port <port.name> incorrectly value computed : '0' instead of : '1'"
        severity error;
    else
      assert (<port.name>_data = '0')
        report "on port <port.name> incorrectly value computed : '1' instead of : '0'"
        severity error;
           
    end if;<
else
><if(port.type.int)
  >    assert (<port.name>_data  = std_logic_vector(to_signed(input_bit, <port.type.size>)))
      -- report "on <port.name> incorrectly value computed : " & to_string(to_integer(to_signed(<port.name>_data))) & " instead of :" & to_string(input_bit)
      report "on port <port.name> incorrectly value computed : " & str(to_integer(signed(<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;

  <else
  >    assert (<port.name>_data  = std_logic_vector(to_unsigned(input_bit, <port.type.size>)))
      --report "on port <port.name> incorrectly value computed : " & to_string(to_integer(to_unsigned(<port.name>_data))) & " instead of :" & to_string(input_bit)
      report "on port <port.name> incorrectly value computed : " & str(to_integer(unsigned(<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;
      
  <endif
  ><endif
>    --
  end if;
end if;
<endif>
>>



///////////////////////////////////////////////////////////////////////////////
// testbench
///////////////////////////////////////////////////////////////////////////////
printInstance(instance, options) ::= <<
------------------------------------------------------------------------------
-- Generated from <instance.id>
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;
use work.sim_package.all;

entity tb_<instance.id> is

end tb_<instance.id>;


architecture arch_tb_<instance.id> of tb_<instance.id> is 

<if(instance.actor)>
  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.actor.inputs,output=instance.actor.outputs)>
  ---------------------------------------------------------------------------

begin

  <instance.actor.simpleName>_orcc : entity work.<instance.actor.simpleName>
    port map (
      clock      =\> clock,
      reset_n    =\> reset_n<if(instance.actor.inputs || instance.actor.outputs)>,<endif>
      <instance.actor.inputs: signalsInstanciation(); separator=",\n"><if(instance.actor.inputs && instance.actor.outputs)>,<endif>
      <instance.actor.outputs: signalsInstanciation(); separator=",\n"><if(!instance.actor.outputs)>    <endif>);
            
    <init_process()>
    <if(instance.actor.inputs)
    ><waveform_process_in(input=instance.actor.inputs)><
    endif>
    
    
    <if(instance.actor.outputs)
    ><waveform_process_out(output=instance.actor.outputs)><
    endif>
<else>
  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.network.inputs,output=instance.network.outputs)>
  ---------------------------------------------------------------------------

begin

  <instance.network.name>_orcc : entity work.<instance.network.name>
    port map (
      clock      =\> clock,
      reset_n    =\> reset_n<if(instance.network.inputs || instance.network.outputs)>,<endif>
      <instance.network.inputs: signalsInstanciation(); separator=",\n"><if(instance.network.inputs && instance.network.outputs)>,<endif>
      <instance.network.outputs: signalsInstanciation(); separator=",\n"><if(!instance.network.outputs)>    <endif>);
      
    <init_process()>
    <if(instance.network.inputs)
    ><waveform_process_in(input=instance.network.inputs)><
    endif>
    
    <if(instance.network.outputs)
    ><waveform_process_out(output=instance.network.outputs)><
    endif>
<endif>

end architecture arch_tb_<instance.id>;
>>