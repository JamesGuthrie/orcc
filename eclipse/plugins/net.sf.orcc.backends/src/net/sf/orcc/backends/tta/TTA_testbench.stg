
indexPort(port) ::= <<
<if(instance.actor)
><instance.actor.templateData.portToIndexMap.(port)><
elseif(instance.broadcast)
><instance.broadcast.portMap.(port)><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////

sendData(port) ::= <<
<if(port.type.bool)
>if (input_bit = 1) then
  s_<port.name>_q  \<= '1';
else
  s_<port.name>_q  \<= '0';
end if;<
elseif(port.type.int)
>s_<port.name>_q  \<= std_logic_vector(to_signed(input_bit, 32));<
else
>s_<port.name>_q  \<= std_logic_vector(to_unsigned(input_bit, 32));<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print signal and instanciation
///////////////////////////////////////////////////////////////////////////////

printSignalInput(port) ::= <<
<if(!port.native)
>signal s_<port.name>_q			: std_logic_vector(31 downto 0);
signal s_<port.name>_status		: std_logic_vector(8 downto 0);
signal s_<port.name>_rdreq		: std_logic;<
else
>signal s_<port.name>_native	: std_logic_vector(<port.type.size>-1 downto 0);<
endif>
>>

printSignalOutput(port) ::= <<
<if(!port.native)
>signal s_<port.name>_data		: std_logic_vector(31 downto 0);
signal s_<port.name>_status		: std_logic_vector(8 downto 0);
signal s_<port.name>_wrreq		: std_logic;<
else
>signal s_<port.name>_native	: std_logic_vector(<port.type.size>-1 downto 0);<
endif>
>>

signalInitInput(port) ::=<<
<if(!port.native)
>s_<port.name>_q       \<= (others =\> '0');
s_<port.name>_status  \<= (others =\> '0');<
else
>s_<port.name>_native  \<= 'Z';<
endif>
>>

signalInitOutput(port) ::=<<
<if(!port.native)
>s_<port.name>_status   \<= (others =\> '0');<
else
>s_<port.name>_native   \<= 'Z';<
endif>
>>

mapSignalInput(port) ::= <<
<if(port.native)
><port.name>_in   =\> s_<port.name>_native,<
else
>data_<indexPort(port)>_in     =\> s_<port.name>_q,
status_<indexPort(port)>_in   =\> s_<port.name>_status,
ack_<indexPort(port)>_in      =\> s_<port.name>_rdreq,<
endif>
>>

mapSignalOutput(port) ::= <<
<if(port.native)
><port.name>_out   =\> s_<port.name>_native,<
else
>data_<indexPort(port)>_out    =\> s_<port.name>_data,
status_<indexPort(port)>_out  =\> s_<port.name>_status,
dv_<indexPort(port)>_out      =\> s_<port.name>_wrreq,<
endif>
>>

sig_const(input, output) ::= <<
constant PERIOD      : time := 10 ns;
--
type severity_level is (note, warning, error, failure);
type tb_type is (after_reset, read_file, CheckRead);
--
-- Input and Output files
<input: printTraceIn(); separator="\n">
<output: printTraceOut(); separator="\n">
--
-- Input and Output signals
<input: printSignalInput(); separator="\n">
<output: printSignalOutput(); separator="\n">
--
-- Configuration
signal count       : integer range 255 downto 0;
signal clock       : std_logic := '0';
signal reset_n     : std_logic := '0';

>>

printTraceIn(port) ::= <<
<if(!port.native)
>signal tb_FSM_<port.name>  : tb_type;
file trace_<instance.id>_<port.name>  : text is "../../trace/<instance.id>_<port.name>.txt";<
endif>
>>

printTraceOut(port) ::= <<
<if(!port.native)
>file trace_<instance.id>_<port.name>  : text is "../../trace/<instance.id>_<port.name>.txt";<
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print processes
///////////////////////////////////////////////////////////////////////////////

init_process() ::= <<
-- clock generation
clock \<= not clock after PERIOD/2;

>>

waveform_process_in(inputs) ::= <<
--
-- Input(s) Waveform Generation
WaveGen_Proc_In : process (reset_n, clock)
  variable Input_bit   : integer;
  variable line_number : line;
begin
  if reset_n = '0' then
    <inputs: signalInitInput(); separator="\n">
    --
    <inputs: {port|<if(!port.native)>tb_FSM_<port.name> \<= after_reset;<endif>}; separator="\n">    
    count \<= 0;
  --  
  elsif rising_edge(clock) then 
    <inputs: case_define_in(); separator="\n">
  end if;
end process WaveGen_Proc_In;

>>


case_define_in(port) ::= <<
<if (!port.native)
>-- Input port: <port.name> Waveform Generation
case tb_FSM_<port.name> is
  when after_reset =\>
    count \<= count + 1;
    if (count = 15) then
      tb_FSM_<port.name> \<= read_file;
      count           \<= 0;
    end if;

  when read_file =\>
    if (not endfile (trace_<instance.id>_<port.name>)) then
      readline(trace_<instance.id>_<port.name>, line_number);
      --
      if ((line_number'length \> 0 and line_number(1) /= '/') and s_<port.name>_rdreq = '1') then
        read(line_number, input_bit);
        <sendData(port)>
        tb_FSM_<port.name> \<= CheckRead;
      end if;
    end if;

  when CheckRead =\>
    if (not endfile (trace_<instance.id>_<port.name>) and s_<port.name>_rdreq = '1') then
      readline(trace_<instance.id>_<port.name>, line_number);
      --
      if (line_number'length \> 0 and line_number(1) /= '/') then
        read(line_number, input_bit);
        <sendData(port)>  
      end if;
    elsif (endfile (trace_<instance.id>_<port.name>)) then
      s_<port.name>_status \<= (others => '0'); 
    end if;

  when others =\> null;
end case;
<endif>

>>

waveform_process_out(outputs) ::= <<
-- Output(s) waveform Generation
<outputs: {port|<if(!port.native)>s_<port.name>_status \<= (others => '0');<\n><endif>}>    
--
WaveGen_Proc_Out : process (reset_n, clock)
  variable Input_bit   : integer;
  variable line_number : line;
begin
  if (reset_n = '0') then
    <outputs: signalInitOutput()>    --
  elsif (rising_edge(clock)) then
    <outputs: case_define_out(); separator="\n">
  end if;
end process WaveGen_Proc_Out;

>>


case_define_out(port) ::= <<
<if (!port.native)
>-- Output port: <port.name> Waveform Generation
if (not endfile (trace_<instance.id>_<port.name>) and s_<port.name>_wrreq = '1') then
  readline(trace_<instance.id>_<port.name>, line_number);
  --
  if (line_number'length \> 0 and line_number(1) /= '/') then
    read(line_number, input_bit);
<
if(port.type.bool)
>    if (input_bit = 1) then
      assert (s_<port.name>_data = '1')
        report "on port <port.name> incorrectly value computed : '0' instead of '1'"
        severity error;
    else
      assert (s_<port.name>_data = '0')
        report "on port <port.name> incorrectly value computed : '1' instead of '0'"
        severity error;
           
    end if;<
else
><if(port.type.int)
  >    assert (s_<port.name>_data  = std_logic_vector(to_signed(input_bit, 32)))
      report "on port <port.name> incorrectly value computed : " & str(to_integer(signed(s_<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;

  <else
  >    assert (s_<port.name>_data  = std_logic_vector(to_unsigned(input_bit, 32)))
      report "on port <port.name> incorrectly value computed : " & str(to_integer(unsigned(s_<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;
      
  <endif
  ><endif
>    --
  end if;
end if;
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Testbench
///////////////////////////////////////////////////////////////////////////////

instance(instance, options) ::= <<
------------------------------------------------------------------------------
-- Generated from <instance.id>
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;
use work.sim_package.all;

entity tb_<instance.id> is

end tb_<instance.id>;


architecture arch_tb_<instance.id> of tb_<instance.id> is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.actor.inputs,output=instance.actor.outputs)>
  ---------------------------------------------------------------------------

begin

  <instance.id>_orcc : entity work.processor_<instance.id>
    port map (
      clk         =\> clock,
      <if(instance.actor.inputs)><instance.actor.inputs: mapSignalInput(); separator="\n"><endif>
      <if(instance.actor.outputs)><instance.actor.outputs: mapSignalOutput(); separator="\n"><endif>
      reset_n       =\> reset_n);
            
    <init_process()>
    <if(instance.actor.inputs)
    ><waveform_process_in(instance.actor.inputs)><
    endif>
    
    <if(instance.actor.outputs)
    ><waveform_process_out(instance.actor.outputs)><
    endif>

end architecture arch_tb_<instance.id>;
>>

network(network, options) ::= <<
------------------------------------------------------------------------------
-- Generated from top
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all; 
use std.textio.all;
use ieee.numeric_std.all;

library work;

entity tb_top is

end tb_top;


architecture arch_tb_top of tb_top is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=network.inputs,output=network.outputs)>
  ---------------------------------------------------------------------------

begin

  top_orcc : entity work.top
    port map (
      hw_clk      =\> clock,
      <if(network.inputs)><network.inputs: mapSignalInput(); separator="\n"><endif>
      <if(network.outputs)><network.outputs: mapSignalOutput(); separator="\n"><endif>
      reset_n    =\> reset_n);
      
    <init_process()>


end architecture arch_tb_top;
>>