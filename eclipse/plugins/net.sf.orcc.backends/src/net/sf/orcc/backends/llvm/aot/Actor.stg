printArchitecture() ::= <<
target triple = "x86_64"
>>

///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

variableDeclaration(variable) ::= <<
<if(variable.type.list && !instance.actor.templateData.castedListReferences.(variable))>
%<variable.indexedName> = alloca <variable.type>
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant, type) ::= <<
<if (constant.exprBool)><printBool(constant)><
elseif(constant.exprInt)><printInt(constant)><
elseif(constant.exprList)><printList(constant, type)><
elseif(constant.exprString)><printString(constant)><
endif>
>>

printBool(constant) ::= <<
<if(constant.value)>1<else>0<endif>
>>

printInt(constant) ::= <<
<constant>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant, type) ::= <<
[<constant.value: { elementValue |<type.type> <Constant(elementValue, type.type)>}; wrap, separator=", ">]
>>

printString(constant) ::= <<
c<constant>
>>


///////////////////////////////////////////////////////////////////////////////
// Argument type declaration
///////////////////////////////////////////////////////////////////////////////

argumentTypeDeclaration(param) ::= <<
<if(param.variable.type.string)
> i8* <
elseif(param.variable.type.list)
> <param.variable.type>* <
else
> <param.variable.type> <
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

Var(var) ::= <<
<if(var.global)>@<else>%<endif><var.indexedName>
>>

Expr(expr) ::= <<
<if(expr.exprVar)><Var(expr.use.variable)><else><Constant(expr, expr.type)><endif>
>>

indexes(indexes) ::= <<
<indexes: { index | <if(index.type)><index.type><else>i32<endif> <Expr(index)> }; separator=", ">
>>

printParameters(arguments, parameters) ::= <<
<arguments, parameters: { arg, param | <printParameter(arg.variable.type, param)>}; separator=", ">
>>

printParameter(type, param) ::= <<
<if (param.byRef)
>TODO <
elseif(type.string)
> i8* <if(param.value.use.variable.local)> <Expr(param.value)> <else> noalias getelementptr inbounds (<param.value.type>* <Expr(param.value)>, i64 0, i64 0) <endif><
else
> <type><if(type.list)>*<endif> <Expr(param.value)> <
endif>
>>

argumentDeclaration(param) ::= <<
<if(param.variable.type.string)
> i8* %<param.variable.name><
elseif(param.variable.type.list)
><param.variable.type>* %<param.variable.name><
else
><param.variable.type> %<param.variable.name><
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////

stateVar(variable) ::= <<
@<variable.name> = internal <printStateVarNature(variable)> <variable.type> <initializeStateVar(variable)>
>>

printStateVarNature(variable) ::= <<
<if(variable.assignable)>global<else>constant<endif>
>>

initializeStateVar(variable) ::= <<
<if(variable.initialValue)><Constant(variable.initialValue, variable.type)><else>zeroinitializer, align 32<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: printInstruction(); separator="\n">
>>

printInstruction(inst) ::= <<
<if(inst.assign)><printAssign(inst)><
elseif(inst.phi)><printPhiAssignment(inst)><
elseif(inst.call)><printCall(inst)><
elseif(inst.load)><printLoad(inst)><
elseif(inst.return)><printReturn(inst)><
elseif(inst.store)><printStore(inst)><
elseif(inst.instCast)><printCast(inst)><
endif>
>>

printCall(call) ::= <<
<if(call.print)
>call i32 (i8*, ...)* @printf(<call.parameters:{param | <printParameter(param.value.type, param)>}; separator=", ">)<
else
><if(call.target)
>%<call.target.variable.indexedName> = <
endif
>call <call.procedure.returnType> @<call.procedure.name> (<printParameters(call.procedure.parameters, call.parameters)>)<
endif>
>>

printCast(cast)::= <<
%<cast.target.variable.indexedName> = <printCastOp(cast)> <printCastType(cast.source.variable)> <Var(cast.source.variable)> to <printCastType(cast.target.variable)>
>>

printCastOp(cast) ::= <<
<if(cast.source.variable.type.list)>bitcast<else><if(cast.extended)><if(cast.signed)>sext<else>zext<endif><else>trunc<endif><endif>
>>

printCastType(var) ::= <<
<var.type><if(var.type.list)>*<endif>
>>

printAssign(assign) ::= <<
%<assign.target.variable.indexedName> = <assign.value>
>>

printPhiAssignment(phi) ::= <<
<Var(phi.target.variable)> = phi <phi.target.variable.type> <printPhiPairs(phi)>
>>

printPhiPairs(phi) ::= <<
<printPhiExpr(first(phi.values), phi.target.variable.type, first(phi.block.cfgNode.predecessors).node)>, <printPhiExpr(first(rest(phi.values)), phi.target.variable.type, first(rest(phi.block.cfgNode.predecessors)).node)>
>>

printPhiExpr(expr, type, node) ::= <<
[<Expr(expr)>, %b<label(node)>]
>>

printReturn(return) ::= <<
<if(removeReturn)
><if(return.value)
>ret <return.value.type> <Expr(return.value)><
else
>ret void<
endif><
endif>
>>

printStore(store) ::= <<
<if(store.target.variable.type.list)>
<if(action.outputPattern.varToPortMap.(store.target.variable) && !action.outputPattern.varToPortMap.(store.target.variable).native)>
<printPortAccess(first(instance.outgoingPortMap.(action.outputPattern.varToPortMap.(store.target.variable))), action.outputPattern.varToPortMap.(store.target.variable), store.target.variable, store.indexes, store)>
<else>
<varName(store.target.variable, store)> = getelementptr <store.target.variable.type>* <Var(store.target.variable)>, i32 0<if(store.indexes)>, <indexes(store.indexes)><endif>
<endif>
store <store.target.variable.type.innermostType> <Expr(store.value)>, <store.target.variable.type.innermostType>* <varName(store.target.variable, store)>
<else>
store <store.target.variable.type> <Expr(store.value)>, <store.target.variable.type>* <Var(store.target.variable)>
<endif>
>>

printLoad(load) ::= <<
<if(load.source.variable.type.list)>
<if(action.inputPattern.varToPortMap.(load.source.variable) && !action.inputPattern.varToPortMap.(load.source.variable).native)>
<printPortAccess(instance.incomingPortMap.(action.inputPattern.varToPortMap.(load.source.variable)), action.inputPattern.varToPortMap.(load.source.variable), load.source.variable, load.indexes, load)>
<elseif(action.peekPattern.varToPortMap.(load.source.variable))>
<printPortAccess(instance.incomingPortMap.(action.peekPattern.varToPortMap.(load.source.variable)), action.peekPattern.varToPortMap.(load.source.variable), load.source.variable, load.indexes, load)>
<else>
<varName(load.source.variable, load)> = getelementptr <load.source.variable.type>* <Var(load.source.variable)>, i32 0, <indexes(load.indexes)>
<endif>
<Var(load.target.variable)> = load <load.source.variable.type.innermostType>* <varName(load.source.variable, load)>
<else>
<Var(load.target.variable)> = load <load.source.variable.type>* <Var(load.source.variable)>
<endif>
>>

printPortAccess(fifo, port, var, indexes, instruction) ::= <<
<if(instance.actor.templateData.castedIndexes.(first(indexes)))>%cast_index_<var.name>_<procedure.accessMap.(instruction)> = zext <first(indexes).type> <Expr(first(indexes))> to i32<endif>
%tmp_index_<var.name>_<procedure.accessMap.(instruction)> = add i32 %local_index_<port.name>, <if(instance.actor.templateData.castedIndexes.(first(indexes)))>%cast_index_<var.name>_<procedure.accessMap.(instruction)><else><Expr(first(indexes))><endif>
%final_index_<var.name>_<procedure.accessMap.(instruction)> = urem i32 %tmp_index_<var.name>_<procedure.accessMap.(instruction)>, %local_size_<port.name>
<varName(var, instruction)> = getelementptr [<fifo.size> x <port.type>]* @fifo_<fifo.id>_content, i32 0, i32 %final_index_<var.name>_<procedure.accessMap.(instruction)>
>>

varName(var, instruction) ::= <<
%<var.name>_elt_<procedure.accessMap.(instruction)>
>>


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printNodes(nodes, removeReturn=true) ::= <<
<nodes:printNode(); separator="\n">
>>

printNode(node) ::= <<
<if(node.nodeBlock)><printBlockNode(node)><
elseif(node.nodeIf)><printIfNode(node)><
elseif(node.nodeWhile)><printWhileNode(node)><
endif>
>>

printBlockNode(blockNode) ::= <<
b<label(blockNode)>:
	<printInstructions(blockNode.instructions)>
	<if(blockNode.cfgNode.successors)>
	br label %b<printNextLabel(first(blockNode.cfgNode.successors).node)>
	<endif>
>>

printIfNode(ifNode) ::= <<
b<label(ifNode)>:
	br i1 <Expr(ifNode.condition)>, label %b<printNextLabel(first(ifNode.thenNodes))>, label %b<printNextLabel(first(ifNode.elseNodes))>

<printNodes(ifNode.thenNodes, removeReturn)>

<printNodes(ifNode.elseNodes, removeReturn)>

<printNodes(ifNode.joinNode, removeReturn)>
>>

printWhileNode(whileNode) ::= <<
b<label(whileNode.joinNode)>:
	<printInstructions(whileNode.joinNode.instructions)>
	br i1 <Expr(whileNode.condition)>, label %b<label(first(whileNode.Nodes))>, label %b<label(whileNode)>

<printNodes(whileNode.nodes, removeReturn)>

b<label(whileNode)>:
	br label %b<printNextLabel(first(whileNode.cfgNode.successors).node)>
>>

label(block) ::= "b<block.cfgNode.number>"

printNextLabel(node)::=<<
<if(node.nodeWhile)><label(node.joinNode)><else><label(node)><endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

printProcedure(procedure, action="") ::= <<
<if(procedure.native)>
declare <procedure.returnType> @<procedure.name>(<procedure.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind
<else>
define internal <procedure.returnType> @<procedure.name>(<procedure.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
<if(procedure.locals)>
	<procedure.locals: variableDeclaration()>
<endif>
	br label %b<label(first(procedure.nodes))>
	
<printNodes(procedure.nodes)>
}
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// FIFO managment
///////////////////////////////////////////////////////////////////////////////

printExternalFifo(connection, port) ::= <<
<if(!port.native)
>@fifo_<connection.id>_content = external global [<connection.size> x <port.type>]
@fifo_<connection.id>_rdIndex = external global i32
@fifo_<connection.id>_wrIndex = external global i32<
endif>
>>

printInput(port, connection) ::= <<
<if(!port.native)
>@SIZE_<port.name> = internal constant i32 <connection.size>
@index_<port.name> = internal global i32 0
@numTokens_<port.name> = internal global i32 0

<printReadTokensFunction(port, connection)><
endif>
>>

printOutput(port, connection) ::= <<
<if(!port.native)
>@SIZE_<port.name> = internal constant i32 <connection.size>
@index_<port.name> = internal global i32 0
@numFree_<port.name> = internal global i32 0

<printWriteTokensFunction(port, connection)><
endif>
>>

printReadTokensFunction(port, connection) ::= <<
define internal void @read_<port.name>() {
entry:
	br label %read

read:
	%rdIndex = load i32* @fifo_<connection.id>_rdIndex
	store i32 %rdIndex, i32* @index_<port.name>
	%wrIndex = load i32* @fifo_<connection.id>_wrIndex
	%getNumTokens = sub i32 %wrIndex, %rdIndex
	%numTokens = add i32 %rdIndex, %getNumTokens
	store i32 %numTokens, i32* @numTokens_<port.name>
	ret void
}

define internal void @read_end_<port.name>() {
entry:
	br label %read_end

read_end:
	%rdIndex = load i32* @index_<port.name>
	store i32 %rdIndex, i32* @fifo_<connection.id>_rdIndex
	ret void
}
>>

printWriteTokensFunction(port, connection) ::= <<
define internal void @write_<port.name>() {
entry:
	br label %write

write:
	%wrIndex = load i32* @fifo_<connection.id>_wrIndex
	store i32 %wrIndex, i32* @index_<port.name>
	%rdIndex = load i32* @fifo_<connection.id>_rdIndex
	%size = load i32* @SIZE_<port.name>
	%numTokens = sub i32 %wrIndex, %rdIndex
	%getNumFree = sub i32 %size, %numTokens
	%numFree = add i32 %wrIndex, %getNumFree
	store i32 %numFree, i32* @numFree_<port.name>
	ret void
}

define internal void @write_end_<port.name>() {
entry:
	br label %write_end

write_end:
	%wrIndex = load i32* @index_<port.name>
	store i32 %wrIndex, i32* @fifo_<connection.id>_wrIndex
	ret void
}
>>

printCallStartTokenFunctions() ::= <<
<instance.actor.inputs: {port|call void @read_<port.name>()}; separator="\n">
<instance.actor.outputs: {port|<if(!port.native)>call void @write_<port.name>()<endif>}; separator="\n">
>>

printCallEndTokenFunctions() ::= <<
<instance.actor.inputs: {port|call void @read_end_<port.name>()}; separator="\n">
<instance.actor.outputs: {port|<if(!port.native)>call void @write_end_<port.name>()<endif>}; separator="\n">
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler
///////////////////////////////////////////////////////////////////////////////

checkOutputPorts(action, port, restPorts, portToIndexMap, state, lastPort=false) ::= <<
%size_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @SIZE_<port.name>
%index_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @index_<port.name>
%rdIndex_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @fifo_<first(instance.outgoingPortMap.(port)).id>_rdIndex
%tmp_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = sub i32 %size_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, %index_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>
%status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = add i32 %tmp_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, %rdIndex_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>
<if(!lastPort)>
%has_valid_outputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = icmp uge i32 %status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, <pattern.numTokensMap.(port)>
<else>
%available_output_<if(state)><state.name>_<endif><action.name>_<port.name> = icmp sge i32 %status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, <pattern.numTokensMap.(port)>
%has_valid_outputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = and i1 %has_valid_outputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(lastPort)>, %available_output_<if(state)><state.name>_<endif><action.name>_<port.name><
endif><
if(restPorts)>
<checkOutputPorts(action, first(restPorts), rest(restPorts), portToIndexMap, state, port)><
endif>
>>

checkOutputPattern(action, pattern, state=false) ::= <<
<checkOutputPorts(action, first(pattern.ports), rest(pattern.ports), instance.actor.templateData.portToIndexByPatternMap.(pattern), state)>
>>

checkInputPorts(action, port, restPorts, portToIndexMap, state, lastPort=false) ::= <<
%numTokens_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @numTokens_<port.name>
%index_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = load i32* @index_<port.name>
%status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = sub i32 %numTokens_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, %index_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>
<if(!lastPort)>
%has_valid_inputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = icmp sge i32 %status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, <pattern.numTokensMap.(port)>
<else>
%available_input_<if(state)><state.name>_<endif><action.name>_<port.name> = icmp uge i32 %status_<port.name>_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)>, <pattern.numTokensMap.(port)>
%has_valid_inputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(port)> = and i1 %has_valid_inputs_<if(state)><state.name>_<endif><action.name>_<portToIndexMap.(lastPort)>, %available_input_<if(state)><state.name>_<endif><action.name>_<port.name><
endif><
if(restPorts)>
<checkInputPorts(action, first(restPorts), rest(restPorts), portToIndexMap, state, port)><
endif>
>>

checkInputPattern(action, pattern, state=false) ::= <<
<checkInputPorts(action, first(pattern.ports), rest(pattern.ports), instance.actor.templateData.portToIndexByPatternMap.(pattern), state)>
>>

actionTest(action, restActions,outsideFSM) ::= <<
	; ACTION <action.name>
<if(!action.inputPattern.empty)
>	;; Input pattern
	<checkInputPattern(action, action.inputPattern)>
	%is_schedulable_<action.name> = call i1 @<action.scheduler.name> ()
	%is_fireable_<action.name> = and i1 %is_schedulable_<action.name>, %has_valid_inputs_<action.name>_<length(action.inputPattern.ports)>
	
	br i1 %is_fireable_<action.name>, label %bb_<action.name>_check_outputs, label %bb_<action.name>_unschedulable<
else
>	;; Empty input pattern
	%is_fireable_<action.name> = call i1 @<action.scheduler.name> ()
	
	br i1 %is_fireable_<action.name>, label %bb_<action.name>_check_outputs, label %bb_<action.name>_unschedulable<
endif>


bb_<action.name>_check_outputs:
<if(!action.outputPattern.empty)
>	;; Output pattern
	<checkOutputPattern(action, action.outputPattern)>
	
	br i1 %has_valid_outputs_<action.name>_<length(action.outputPattern.ports)>, label %bb_<action.name>_fire, label %bb_finished<
else
>	;; Empty output pattern
	
	br label %bb_<action.name>_fire<
endif>


bb_<action.name>_fire:
	call void @<action.body.name> ()

<if(outsideFSM)>
	br label %bb_outside_scheduler_start
<else>
	br label %bb_scheduler_start
<endif>

bb_<action.name>_unschedulable:
<if(restActions)>
<actionTest(first(restActions), rest(restActions),outsideFSM)>
<else>
	<if(outsideFSM)>
		br label %bb_outside_finished
	<else>
		br label %bb_finished
	<endif>
<endif>
>>

printActionLoop(actions, outsideFSM) ::= <<
<actionTest(first(actions), rest(actions), outsideFSM)>
>>

actionTestState(sourceState, transition, restTransitionsList) ::= <<
	; ACTION <transition.action.name>
<if(!transition.action.inputPattern.empty)
>	;; Input pattern
	<checkInputPattern(transition.action, transition.action.inputPattern, sourceState)>
	%is_schedulable_<sourceState.name>_<transition.action.name> = call i1 @<transition.action.scheduler.name> ()
	%is_fireable_<sourceState.name>_<transition.action.name> = and i1 %is_schedulable_<sourceState.name>_<transition.action.name>, %has_valid_inputs_<sourceState.name>_<transition.action.name>_<length(transition.action.inputPattern.ports)>
	
	br i1 %is_fireable_<sourceState.name>_<transition.action.name>, label %bb_<sourceState.name>_<transition.action.name>_check_outputs, label %bb_<sourceState.name>_<transition.action.name>_unschedulable<
else
>	;; Empty input pattern
	%is_fireable_<sourceState.name>_<transition.action.name> = call i1 @<transition.action.scheduler.name> ()
	
	br i1 %is_fireable_<sourceState.name>_<transition.action.name>, label %bb_<sourceState.name>_<transition.action.name>_check_outputs, label %bb_<sourceState.name>_<transition.action.name>_unschedulable<
endif>


bb_<sourceState.name>_<transition.action.name>_check_outputs:
<if(!transition.action.outputPattern.empty)
>	;; Output pattern
	<checkOutputPattern(transition.action, transition.action.outputPattern, sourceState)>
	
	br i1 %has_valid_outputs_<sourceState.name>_<transition.action.name>_<length(transition.action.outputPattern.ports)>, label %bb_<sourceState.name>_<transition.action.name>_fire, label %bb_<sourceState.name>_finished<
else
>	;; Empty output pattern
	
	br label %bb_<sourceState.name>_<transition.action.name>_fire<
endif>


bb_<sourceState.name>_<transition.action.name>_fire:
	call void @<transition.action.body.name> ()
	
	br label %bb_s_<transition.target.name>

bb_<sourceState.name>_<transition.action.name>_unschedulable:

<if(restTransitionsList)>
<actionTestState(sourceState, first(restTransitionsList), rest(restTransitionsList))><
else
>	br label %bb_<sourceState.name>_finished

bb_<sourceState.name>_finished:
	store i32 <instance.actor.templateData.stateToLabelMap.(sourceState)>, i32* @_FSM_state
	br label %bb_finished
<endif>
>>

schedulingStates(sourceState, transitionsList) ::= <<
<actionTestState(sourceState, first(transitionsList), rest(transitionsList))>
>>

printTransition(state) ::= <<
; STATE <state.name>
bb_s_<state.name>:
	<if (actions)>
	call void @<instance.name>_outside_FSM_scheduler()
	<endif>
<schedulingStates(state, state.outgoing)>
>>

printFsmState(state) ::= <<
i32 <instance.actor.templateData.stateToLabelMap.(state)>, label %bb_s_<state.name>
>>

printFsmSwitch(fsm) ::= <<
%local_FSM_state = load i32* @_FSM_state
switch i32 %local_FSM_state, label %default [
					<fsm.states: printFsmState(); separator="\n"> ]
>>

schedulerWithFSM(actions, fsm) ::= <<
@_FSM_state = internal global i32 <instance.actor.templateData.stateToLabelMap.(fsm.initialState)>

<if(actions)>
define void @<instance.name>_outside_FSM_scheduler() nounwind {
entry:
	br label %bb_outside_scheduler_start
	
bb_outside_scheduler_start:
	;; no read/write here!
<printActionLoop(actions=actions, outsideFSM=true)>

bb_outside_finished:
	;; no read_end/write_end here!
	ret void
}
<endif>


define void @<instance.name>_scheduler() noreturn nounwind {
entry:
	br label %bb_scheduler_start

bb_scheduler_start:
	<printCallStartTokenFunctions()>
	<printFsmSwitch(fsm)>
	br label %bb_scheduler_start

default:
	; TODO: print error
	br label %bb_scheduler_start

<fsm.states: printTransition(); separator="\n">

bb_finished:
	<printCallEndTokenFunctions()>
	ret void
}
>>

schedulerWithoutFSM(actions) ::= <<
define void @<instance.name>_scheduler() nounwind {
entry:
	<printCallStartTokenFunctions()>
	br label %bb_scheduler_start
	
bb_scheduler_start:
<printActionLoop(actions=instance.actor.actionsOutsideFsm, outsideFSM=false)>
bb_finished:
	<printCallEndTokenFunctions()>
	ret void
}
>>


///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

fifoVar(port, var=false) ::= <<
%local_index_<port.name> = load i32* @index_<port.name>
%local_size_<port.name> = load i32* @SIZE_<port.name>
>>

printFifoEnd(port, numTokens) ::= <<
%new_index_<port.name> = add i32 %local_index_<port.name>, <numTokens>
store i32 %new_index_<port.name>, i32* @index_<port.name>
>>

printActionSchedulable(procedure) ::= <<
define internal i1 @<procedure.name>() nounwind {
entry:
	<procedure.locals: variableDeclaration()>
	<action.peekPattern.ports: { port | <if(!port.native)><fifoVar(port, action.inputPattern.portToVarMap.(port))><endif>}; separator="\n">
	br label %b<label(first(procedure.nodes))>
	
<printNodes(procedure.nodes)>
}
>>

printActionBody(procedure) ::= <<
define internal void @<procedure.name>() nounwind {
entry:
	<procedure.locals: variableDeclaration()>
	<action.inputPattern.ports: { port | <if(!port.native)><fifoVar(port, action.inputPattern.portToVarMap.(port))><endif>}; separator="\n">
	<action.outputPattern.ports: { port | <if(!port.native)><fifoVar(port, action.outputPattern.portToVarMap.(port))><endif>}; separator="\n">
	br label %b<label(first(procedure.nodes))>

<printNodes(procedure.nodes, false)>
	<action.inputPattern.ports: { port | <if(!port.native)><printFifoEnd(port, action.inputPattern.numTokensMap.(port))><endif>}; separator="\n">
	<action.outputPattern.ports: { port | <if(!port.native)><printFifoEnd(port, action.outputPattern.numTokensMap.(port))><endif>}; separator="\n"> 
	ret void
}
>>

printAction(action) ::= <<
<printActionSchedulable(action.scheduler)>

<printActionBody(action.body)>
>>

callInitialize(initialize) ::= <<
call <initialize.body.returnType> @<initialize.body.name> ()
>>

initializeFunction() ::= <<
define void @<instance.name>_initialize() noreturn nounwind {
entry:
	<printCallStartTokenFunctions()>
	<instance.actor.initializes: callInitialize(); separator="\n">
	<printCallEndTokenFunctions()>
	ret void
}
>>


///////////////////////////////////////////////////////////////////////////////
// Instance
///////////////////////////////////////////////////////////////////////////////

actorParameter(parameter) ::= <<
@<parameter.name> = global <parameter.type> undef
>>

printInstance(instance, options) ::= <<
<printArchitecture()>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "<instance.actor.name>"
declare i32 @printf(i8* noalias , ...) nounwind 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Connected FIFOs

<instance.incoming: { connection |<printExternalFifo(connection, connection.targetPort)>}; separator="\n\n">

<instance.outgoing: { connection |<printExternalFifo(connection, connection.sourcePort)>}; separator="\n\n">

<if(instance.actor.inputs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input ports

<instance.actor.inputs: { port |<printInput(port, instance.incomingPortMap.(port))>}; separator="\n\n">
<endif>

<if(instance.actor.outputs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output ports
<instance.actor.outputs: { port |<printOutput(port, first(instance.outgoingPortMap.(port)))>}; separator="\n\n">
<endif>

<if(instance.actor.parameters)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<instance.actor.parameters: actorParameter(); separator="\n">
<endif>

<if(instance.actor.stateVars)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<instance.actor.stateVars: stateVar(); separator="\n">
<endif>

<if(instance.actor.procs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<instance.actor.procs: printProcedure()>
<endif>

<if(instance.actor.initializes)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initializes
<instance.actor.initializes: printAction(); separator="\n\n">
<endif>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<instance.actor.actions: printAction(); separator="\n\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Action-scheduler

<if(instance.actor.initializes)>
<initializeFunction()>
<endif>

<if(instance.actor.fsm)>
<schedulerWithFSM(instance.actor.actionsOutsideFsm, instance.actor.fsm)>
<else>
<schedulerWithoutFSM(instance.actor.actionsOutsideFsm)>
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Broadcast
///////////////////////////////////////////////////////////////////////////////

printEntity(entity, options) ::= <<
<printArchitecture()>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Broadcast

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Connected FIFOs

<entity.incoming: { connection |<printExternalFifo(connection, connection.targetPort)>}; separator="\n\n">

<entity.outgoing: { connection |<printExternalFifo(connection, connection.sourcePort)>}; separator="\n\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input port
<entity.inputs: { port |<printInput(port, entity.incomingPortMap.(port))>}; separator="\n\n">

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output ports
<entity.outputs: { port |<printOutput(port, first(entity.outgoingPortMap.(port)))>}; separator="\n\n">

define void @<entity.name>_scheduler() alwaysinline nounwind {
entry:
	br label %bb_fifo_init
	
bb_fifo_init:
	<entity.inputs: {port|call void @read_<port.name>()}; separator="\n">
	<entity.outputs: {port|call void @write_<port.name>()}; separator="\n">
	br label %bb_scheduler_start

bb_scheduler_start:
	%numTokens_<first(entity.inputs).name> = load i32* @numTokens_<first(entity.inputs).name>
	%index_<first(entity.inputs).name> = load i32* @index_<first(entity.inputs).name>
	%status_<first(entity.inputs).name> = sub i32 %numTokens_<first(entity.inputs).name>, %index_<first(entity.inputs).name>
	%fireable_<first(entity.inputs).name> = icmp sge i32 %status_<first(entity.inputs).name>, 1
	<checkBcastOutputs(first(entity.outputs), rest(entity.outputs), first(entity.inputs))>
	
bb_copy:
	<printBcastCopy()>

bb_finished:
	<entity.inputs: {port|call void @read_end_<port.name>()}; separator="\n">
	<entity.outputs: {port|call void @write_end_<port.name>()}; separator="\n">
	ret void
}

>>

printBcastCopy() ::= <<
%size_<first(entity.inputs).name> = load i32* @SIZE_<first(entity.inputs).name>
%final_index_<first(entity.inputs).name>  = urem i32 %index_<first(entity.inputs).name> , %size_<first(entity.inputs).name>
%ptr_<first(entity.inputs).name> = getelementptr [<entity.incomingPortMap.(first(entity.inputs)).size> x <first(entity.inputs).type>]* @fifo_<entity.incomingPortMap.(first(entity.inputs)).id>_content, i32 0, i32 %final_index_<first(entity.inputs).name>
%value = load <first(entity.inputs).type>* %ptr_<first(entity.inputs).name>
%new_index_<first(entity.inputs).name> = add i32 %index_<first(entity.inputs).name>, 1
store i32 %new_index_<first(entity.inputs).name>, i32* @index_<first(entity.inputs).name>
<entity.outputs: copyBcastOutputs(); separator="\n">
br label %bb_scheduler_start
>>

checkBcastOutputs(port, restPorts, lastPort) ::= <<
%size_<port.name> = load i32* @SIZE_<port.name>
%index_<port.name> = load i32* @index_<port.name>
%rdIndex_<port.name> = load i32* @fifo_<first(entity.outgoingPortMap.(port)).id>_rdIndex
%tmp_<port.name> = sub i32 %size_<port.name>, %index_<port.name>
%status_<port.name> = add i32 %tmp_<port.name>, %rdIndex_<port.name>
%ready_<port.name> = icmp sge i32 %status_<port.name>, 1
%fireable_<port.name> = and i1 %ready_<port.name>, %fireable_<lastPort.name>
<if(restPorts)><
checkBcastOutputs(first(restPorts), rest(restPorts), port)><
else
>br i1 %fireable_<port.name>, label %bb_copy, label %bb_finished<
endif>
>>

copyBcastOutputs(port) ::= <<
%final_index_<port.name>  = urem i32 %index_<port.name> , %size_<port.name>
%ptr_<port.name> = getelementptr [<first(entity.outgoingPortMap.(port)).size> x <port.type>]* @fifo_<first(entity.outgoingPortMap.(port)).id>_content, i32 0, i32 %final_index_<port.name>
store <port.type> %value, <port.type>* %ptr_<port.name>
%new_index_<port.name> = add i32 %index_<port.name>, 1
store i32 %new_index_<port.name>, i32* @index_<port.name>
>>


