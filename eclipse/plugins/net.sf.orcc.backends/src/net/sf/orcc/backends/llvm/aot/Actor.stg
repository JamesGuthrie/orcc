///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

variableDeclaration(variable) ::= <<
<if(variable.type.list && !actor.templateData.castedListReferences.(variable))>
%<variable.indexedName> = alloca <variable.type>
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifoVar(port, var) ::= <<
%<var.name>_ptr = load <port.type>** <fifoVarName(port)>
%<var.name> = bitcast <port.type>* %<var.name>_ptr to <var.type>*
>>

fifoVarName(port) ::= <<
@<port.name>_ptr
>>

fifo(port) ::= <<
<fifoVarName(port)> = global <port.type>* null
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant, type) ::= <<
<if (constant.exprBool)><printBool(constant)><
elseif(constant.exprInt)><printInt(constant)><
elseif(constant.exprList)><printList(constant, type)><
elseif(constant.exprString)><printString(constant)><
endif>
>>

printBool(constant) ::= <<
<if(constant.value)>1<else>0<endif>
>>

printInt(constant) ::= <<
<constant>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant, type) ::= <<
[<constant.value: { elementValue |<type.type> <Constant(elementValue, type.type)>}; wrap, separator=", ">]
>>

printString(constant) ::= <<
c<constant>
>>


///////////////////////////////////////////////////////////////////////////////
// Argument type declaration
///////////////////////////////////////////////////////////////////////////////

argumentTypeDeclaration(param) ::= <<
<if(param.variable.type.string)
> i8* <
elseif(param.variable.type.list)
> <param.variable.type>* <
else
> <param.variable.type> <
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

Var(var) ::= <<
<if(var.global)>@<else>%<endif><var.indexedName>
>>

Expr(expr) ::= <<
<if(expr.exprVar)><Var(expr.use.variable)><else><Constant(expr, expr.type)><endif>
>>

indexes(indexes) ::= <<
<indexes: { index | <if(index.type)><index.type><else>i32<endif> <Expr(index)> }; separator=", ">
>>

printParameters(arguments, parameters) ::= <<
<arguments, parameters: { arg, param | <printParameter(arg.variable.type, param)>}; separator=", ">
>>

printParameter(type, param) ::= <<
<if (param.byRef)
>TODO <
elseif(type.string)
> i8* <if(param.value.use.variable.local)> <Expr(param.value)> <else> noalias getelementptr inbounds (<param.value.type>* <Expr(param.value)>, i64 0, i64 0) <endif><
else
> <type><if(type.list)>*<endif> <Expr(param.value)> <
endif>
>>

argumentDeclaration(param) ::= <<
<if(param.variable.type.string)
> i8* %<param.variable.name><
elseif(param.variable.type.list)
><param.variable.type>* %<param.variable.name><
else
><param.variable.type> %<param.variable.name><
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////

stateVar(variable) ::= <<
@<variable.name> = <printStateVarNature(variable)> <variable.type> <initializeStateVar(variable)>
>>

printStateVarNature(variable) ::= <<
<if(variable.assignable)>global<else>constant<endif>
>>

initializeStateVar(variable) ::= <<
<if(variable.initialValue)><Constant(variable.initialValue, variable.type)><else>zeroinitializer, align 32<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

PrintInstr(parameters) ::= <<
call i32 (i8*, ...)* @printf(<parameters:{param | <printParameter(param.value.type, param)>}; separator=", ">)
>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: printInstruction(); separator="\n">
>>

printInstruction(inst) ::= <<
<if(inst.assign)><printAssign(inst)><
elseif(inst.gep)><printGEP(inst)><
elseif(inst.phi)><printPhiAssignment(inst)><
elseif(inst.call)><printCall(inst)><
elseif(inst.load)><printLoad(inst)><
elseif(inst.return)><printReturn(inst)><
elseif(inst.store)><printStore(inst)><
elseif(inst.instCast)><printCast(inst)><
endif>
>>

printCall(call) ::= <<
<if(call.print)
><PrintInstr(call.parameters)><
else
><if(call.target)
>%<call.target.variable.indexedName> = <
endif
>call <call.procedure.returnType> @<call.procedure.name> (<printParameters(call.procedure.parameters, call.parameters)>)<
endif>
>>

printCast(cast)::= <<
%<cast.target.variable.indexedName> = <printCastOp(cast)> <printCastType(cast.source.variable)> <Var(cast.source.variable)> to <printCastType(cast.target.variable)>
>>

printCastOp(cast) ::= <<
<if(cast.source.variable.type.list)>bitcast<else><if(cast.extended)><if(cast.signed)>sext<else>zext<endif><else>trunc<endif><endif>
>>

printCastType(var) ::= <<
<var.type><if(var.type.list)>*<endif>
>>

printAssign(assign) ::= <<
%<assign.target.variable.indexedName> = <assign.value>
>>

printPhiAssignment(phi) ::= <<
<Var(phi.target.variable)> = phi <phi.target.variable.type> <printPhiPairs(phi)>
>>

printPhiPairs(phi) ::= <<
<printPhiExpr(first(phi.values), phi.target.variable.type, first(phi.block.cfgNode.predecessors).node)>, <printPhiExpr(first(rest(phi.values)), phi.target.variable.type, first(rest(phi.block.cfgNode.predecessors)).node)>
>>

printPhiExpr(expr, type, node) ::= <<
[<Expr(expr)>, %b<label(node)>]
>>

printReturn(return) ::= <<
<if(removeReturn)
><if(return.value)
>ret <return.value.type> <Expr(return.value)><
else
>ret void<
endif><
endif>
>>

printStore(store) ::= <<
store <store.target.variable.type> <Expr(store.value)>, <store.target.variable.type>* <Var(store.target.variable)>
>>

printLoad(load) ::= <<
<Var(load.target.variable)> = load <load.source.variable.type>* <Var(load.source.variable)>
>>

printGEP(gep) ::= <<
<Var(gep.target.variable)> = getelementptr <gep.source.variable.type>* <Var(gep.source.variable)>, i32 0, <indexes(gep.indexes)>
>>


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printNodes(nodes, removeReturn=true) ::= <<
<nodes:printNode(); separator="\n">
>>

printNode(node) ::= <<
<if(node.nodeBlock)><printBlockNode(node)><
elseif(node.nodeIf)><printIfNode(node)><
elseif(node.nodeWhile)><printWhileNode(node)><
endif>
>>

printBlockNode(blockNode) ::= <<
b<label(blockNode)>:
	<printInstructions(blockNode.instructions)>
	<if(blockNode.cfgNode.successors)>
	br label %b<printNextLabel(first(blockNode.cfgNode.successors).node)>
	<endif>
>>

printIfNode(ifNode) ::= <<
b<label(ifNode)>:
	br i1 <Expr(ifNode.condition)>, label %b<printNextLabel(first(ifNode.thenNodes))>, label %b<printNextLabel(first(ifNode.elseNodes))>

<printNodes(ifNode.thenNodes, removeReturn)>

<printNodes(ifNode.elseNodes, removeReturn)>

<printNodes(ifNode.joinNode, removeReturn)>
>>

printWhileNode(whileNode) ::= <<
b<label(whileNode.joinNode)>:
	<printInstructions(whileNode.joinNode.instructions)>
	br i1 <Expr(whileNode.condition)>, label %b<label(first(whileNode.Nodes))>, label %b<label(whileNode)>

<printNodes(whileNode.nodes, removeReturn)>

b<label(whileNode)>:
	br label %b<printNextLabel(first(whileNode.cfgNode.successors).node)>
>>

label(node) ::= "b<actor.templateData.nodeToLabelMap.(node)>"

printNextLabel(node)::=<<
<if(node.nodeWhile)><label(node.joinNode)><else><label(node)><endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
<if(procedure.native)>
declare <procedure.returnType> @<procedure.name>(<procedure.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind
<else>
define <procedure.returnType> @<procedure.name>(<procedure.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
<if(procedure.locals)>
	<procedure.locals: variableDeclaration()>
<endif>
	br label %b<label(first(procedure.nodes))>
	
<printNodes(procedure.nodes)>
}
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

printAction(action) ::= <<
define <action.scheduler.returnType> @<action.scheduler.name>(<action.scheduler.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
	<action.scheduler.locals: variableDeclaration()>
	<action.peekPattern.ports: { port | <fifoVar(port, action.inputPattern.portToVarMap.(port))>}; separator="\n">
	br label %b<label(first(action.scheduler.nodes))>
	
<printNodes(action.scheduler.nodes)>
}

define void @<action.body.name>(<action.body.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
	<action.body.locals: variableDeclaration()>
	<action.inputPattern.ports: { port | <fifoVar(port, action.inputPattern.portToVarMap.(port))>}; separator="\n">
	<action.outputPattern.ports: { port | <fifoVar(port, action.outputPattern.portToVarMap.(port))>}; separator="\n">
	br label %b<label(first(action.body.nodes))>

<printNodes(action.body.nodes)>
}
>>


///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actorParameter(parameter) ::= <<
@<parameter.name> = global <parameter.type> undef
>>

printActor(actor, options) ::= <<

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "<actor.name>"
declare i32 @printf(i8* noalias , ...) nounwind 

<if(actor.inputs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
<actor.inputs: fifo(); separator="\n">
<endif>

<if(actor.outputs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
<actor.outputs: fifo(); separator="\n">
<endif>

<if(actor.parameters)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<actor.parameters: actorParameter(); separator="\n">
<endif>

<if(actor.stateVars)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<actor.stateVars: stateVar(); separator="\n">
<endif>

<if(actor.procs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<actor.procs: {proc | <procedure(proc)>}>
<endif>

<if(actor.initializes)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initializes
<actor.initializes: printAction(); separator="\n\n">
<endif>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<actor.actions: printAction(); separator="\n\n">

>>
