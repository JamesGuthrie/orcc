///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

// the values of a list: {val1, val2, ..., valn}
listValue(values) ::= <<
{<values; wrap, separator=", ">}
>>

varDecl(variable) ::= <<
<variable.type> <variable.indexedName><listSize(variable.type.dimensions)>
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<if (constant.booleanExpr)><printBool(constant)><
elseif (constant.intExpr)><printInt(constant)><
elseif (constant.listExpr)><printList(constant)><
elseif (constant.stringExpr)><printString(constant)><
endif>
>>


printBool(constant) ::= <<
<if (constant.value)>true<else>false<endif>
>>

printInt(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant) ::= <<
{<constant.value: Constant(); wrap, separator=", ">}
>>

printString(constant) ::= <<
"<constant>"
>>

///////////////////////////////////////////////////////////////////////////////
// include Actors
includeActor(actor) ::= <<
#include "<if (!actor.packageAsList.empty)><actor.packageAsList; separator="/">/<endif><actor.simpleName>.h"
>>

includeActors(actors) ::= <<
<actors: includeActor(); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// initialize Instances
initializeInstance(instance) ::= <<
<if (instance.actor.parameters)
>("<instance.hierarchicalId: {id | <id>}; separator="/">", <instance.actor.parameters: {param | <Constant(instance.parameters.(param.indexedName))>}; separator=", ">, NETWORK_PROFILING_MODE)<
else
>("<instance.hierarchicalId: {id | <id>}; separator="/">", NETWORK_PROFILING_MODE)<
endif>
>>

initializeInstances(instances) ::= <<
<instances: initializeInstance(); wrap, separator=", ">
>>


///////////////////////////////////////////////////////////////////////////////
// declare FIFOs


doDeclareFifo(edge, kind) ::= <<
FifoAPI * fifo_<edge.id> = FifoFactory\<<edge.sourcePort.type>\>::allocateFifo(<if(edge.size)><edge.size><else>SIZE<endif>, <kind>);

>>

declareFifo(edge) ::= <<
<doDeclareFifo(edge=edge, kind=options.fifoKind.(edge))>
>>

declareFifos(connections) ::= <<
<network.connections: declareFifo()>

>>

///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
<if (source.actor)
><source.name>.connect(ACTOR_PORT_OUT, <source.actor.packageAsList; separator="::">::<source.actor.simpleName>_<sourcePort.name>, fifo_<count>);<
else
><source.name>.connect(ACTOR_PORT_OUT, <edge.attributes.("fifoId").value>, fifo_<count>);<
endif>

<if (target.actor)
><target.name>.connect(ACTOR_PORT_IN, <target.actor.packageAsList; separator="::">::<target.actor.simpleName>_<targetPort.name>, fifo_<count>);<
else
><target.name>.connect(ACTOR_PORT_IN, <edge.attributes.("fifoId").value>, fifo_<count>);<
endif>
>>

assignFifo(edge) ::= <<
<doAssignFifo(source=edge.source, sourcePort=edge.sourcePort, target=edge.target, targetPort=edge.targetPort, count=edge.id)>
>>

assignFifos(edges) ::= <<
<edges: assignFifo(); separator="\n">
>>


///////////////////////////////////////////////////////////////////////////////
// declare Instances

declareInstance(instance) ::= <<
<if(instance.serdes)
>WrapperAka <instance.name>("<instance.name>");<
else
><instance.actor.packageAsList; separator="::">::<instance.actor.simpleName> <instance.name><initializeInstance(instance)>;<
endif>
>>

declareInstances(instances) ::= <<
<instances: declareInstance(); separator="\n">
>>



///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()
printInitialize(instance) ::= <<
<if (instance.actor)>
<if (!instance.actor.initializes.empty)>
<instance.name>.initialize();
<endif>
<endif>
>>

printInitializes(instances) ::= <<
<instances: printInitialize()>
>>

printInitializeActor(instance) ::= <<
<if (instance.actor)>
<instance.name>.initializeActor();
<endif>
>>

printInitializeActors(instances) ::= <<
<instances: printInitializeActor()>
>>

printScheduler(instance) ::= <<
<if (!instance.serdes)>res += <instance.name>.schedule();<endif>
>>

printSchedulers(instances) ::= <<
<instances: printScheduler(); separator="\n">
>>


///////////////////////////////////////////////////////////////////////////////
// threads

declareThread(thread) ::= <<
<declareNetwork(id=thread, instances=threads.(thread))>
>>

declareThreads(threads) ::= <<
<threads.keys: declareThread(); separator="\n\n">
>>


///////////////////////////////////////////////////////////////////////////////
// scheduler

declareNetwork(id, instances) ::= <<

class network_<id> : public Threadaka
{
public:
	void run(void * args)
	{
		<printInitializeActors(instances)>
		<printInitializes(instances)>
		while (1) 
		{
			int res = 0;
			<printSchedulers(instances)>
			if(res == 0)
			yield();
		}
	}	
};

>>

startWrapper(instance) ::= <<
<if (instance.serdes)>
<instance.name>.initializeActor();
<instance.name>.start();
<endif>
>>

startWrappers(instances) ::= <<
<instances: startWrapper()>
>>

///////////////////////////////////////////////////////////////////////////////
// 

defineNetwork(id) ::= <<
network_<id> <id>;
>>

startNetwork(id) ::= <<
<id>.start();
>>

stopNetwork(id) ::= <<
<id>.stop();
>>


///////////////////////////////////////////////////////////////////////////////
// threads
printThreads(threads) ::= <<
// create threads
<threads.keys: defineNetwork(); separator="\n">

// connect fifos
<assignFifos(network.connections)>

<if (options.needSerDes)>
// start wrappers
<startWrappers(network.instances)>
<endif>

// start threads
<threads.keys: startNetwork(); separator="\n">

// join threads
<threads.keys: stopNetwork(); separator="\n">

>>

///////////////////////////////////////////////////////////////////////////////
// network

printNetwork(network, options) ::= <<
// Generated from "$network.name$"

#include "fifofactory.h"
#include "threadaka.h"

<if (options.needSerDes)>
#include "wrapperaka.h"
<endif>

extern "C" {
#include "System/orcc_util.h"
}

#include "traceaka.h"
TraceAka g_oTracer;

#ifdef __TRACE_TOKENS__
#define NETWORK_PROFILING_MODE	AKA_PROFILING_CAPTURE_TOKEN 
#else
#ifdef __TRACE_CAPTURE__
#define NETWORK_PROFILING_MODE	AKA_PROFILING_CAPTURE_TRACE
#else
#define NETWORK_PROFILING_MODE	AKA_PROFILING_NONE 
#endif
#endif

#undef min
#undef max

<includeActors(network.allActors)>

#define SIZE 10000

<declareInstances(network.instances)>

<declareFifos(network.connections)>

<declareThreads(options.threads)>

int main(int argc, char *argv[]) {
	init_orcc(argc, argv, NULL);

	<printThreads(options.threads)>

	return 0;
}


>>

