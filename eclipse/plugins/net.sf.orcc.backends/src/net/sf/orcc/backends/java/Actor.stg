import "net/sf/orcc/backends/c/Actor.stg"

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<

private Fifo fifo_<port.name>;
>>

setFifo(port) ::= <<
if ("<port.name>".equals(portName)) {
	fifo_<port.name> = fifo;
} else 
>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [][]...[]
// does not output anything if <value> is empty
// differs from inherited listSize because this one does not print any size
// information.
listDim(value) ::= <<
<value : {val | []} >
>>

// a variable definition
// called by "function parameter", or "state variable with value"
variableDeclaration(variable) ::= <<
<variable.type><listDim(variable.type.dimensions)> <variable.name>
>>

// a variable definition with initialization
// called by "local variable", or "state variable with no value"
variableDeclarationInit(variable) ::= <%
<variableDeclaration(variable)>
<if(variable.type.dimensions)> = new <variable.type><listSize(variable.type.dimensions)>
<endif>
%>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

printBool(boolean) ::= <<
<if (boolean)>true<else>false<endif>
>>

// a state variable
stateVar(variable) ::= <%
private <if(variable.initialized)>
<if (!variable.assignable)> static <endif>
<variableDeclaration(variable)> = <Constant(variable.initialValue)>;
<else>
<variableDeclarationInit(variable)>;
<endif>
%>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

getPortName(variable, action) ::= <<
<if (action.inputPattern.varToPortMap.(variable))
><action.inputPattern.varToPortMap.(variable).name><
elseif (action.outputPattern.varToPortMap.(variable))
><action.outputPattern.varToPortMap.(variable).name><
else
><action.peekPattern.varToPortMap.(variable).name><
endif>
>>

getPortType(variable) ::= <<
<if (action.inputPattern.varToPortMap.(variable))
><action.inputPattern.varToPortMap.(variable).type><
elseif (action.outputPattern.varToPortMap.(variable))
><action.outputPattern.varToPortMap.(variable).type><
else
><action.peekPattern.varToPortMap.(variable).type><
endif>
>>

printExpressionParameter(arg) ::= <%
<if (arg.value.booleanExpr || arg.value.intExpr || arg.value.floatExpr || arg.value.listExpr)>
<Constant(arg.value)>
<elseif (arg.value.binaryExpr)>
(<arg.value>)
<else>
<arg.value>
<endif>
%>

printParameter(arg) ::= <%
<if (arg.byVal)><
printExpressionParameter(arg)
><else
><arg.use.variable.name><endif>
%>

printCall(call) ::= <<

<if(call.print)>System.out.print(<call.parameters: printParameter(); separator=" + ">);<
else
><if(call.target)><call.target.variable.indexedName> = <endif><call.procedure.name>(<call.parameters: printCallParam(); separator=", ">);<
endif>
>>

printLoad(load) ::= <<

<if (action.inputPattern.varToPortMap.(load.source.variable) || action.outputPattern.varToPortMap.(load.source.variable) || action.peekPattern.varToPortMap.(load.source.variable))
><load.target.variable.indexedName> = (<getPortType(load.source.variable)>) fifo_<getPortName(load.source.variable, action)>.read();
<else><load.target.variable.indexedName> = <load.source.variable.name><load.indexes : {index | [<index>]}>;
<endif>
>>

// read instruction
printRead(read) ::= <<

<if (read.target)
>int <read.port.name>_Index = fifo_<read.port.name>.getReadIndex(<read.numTokens>);
<read.target> = fifo_<read.port.name>.getReadArray(<read.numTokens>);<
else
>fifo_<read.port.name>.getReadIndex(<read.numTokens>);
fifo_<read.port.name>.getReadArray(<read.numTokens>);<endif>
>>

printStore(store) ::= <<

< if (action.inputPattern.varToPortMap.(store.target.variable) || action.outputPattern.varToPortMap.(store.target.variable) || action.peekPattern.varToPortMap.(store.target.variable))
>fifo_<getPortName(store.target.variable, action)>.write(<store.value>);<
else
><store.target.variable.name><store.indexes : {index | [<index>]}> = <store.value>;<endif>
>>

// write instruction
printWrite(write) ::= <<

<write.target> = fifo_<write.port.name>.getWriteArray(<write.numTokens>);
int <write.port>_Index = fifo_<write.port.name>.getWriteIndex(<write.numTokens>);
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and actions
///////////////////////////////////////////////////////////////////////////////

printProcedure(procedure, action=false) ::= <<
<if(!procedure.native)>

private <procedure.returnType> <procedure.name>(<procedure.parameters: {parameter | <variableDeclaration(parameter.variable)>}; wrap, anchor, separator=", ">) {
<if(procedure.locals)>
	<procedure.locals: {local | <variableDeclarationInit(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
}

<endif>
>>

printAction(action) ::= <<
private void <action.name>() {
<if(action.body.locals)>
	<action.body.locals: {local | <variableDeclarationInit(local)>;<\n>}>
<endif>
	<printNodes(action.body.nodes)>
}

<printProcedure(action.scheduler, action)>
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
<pattern.ports:{port|fifo_<port.name>.hasRoom(<pattern.numTokensMap.(port)>)}; separator=" && ">
>>

checkInputPatternPort(port) ::= <<
fifo_<port.name>.hasTokens(<pattern.numTokensMap.(port)>)
>>

checkInputPattern(pattern) ::= <<
<pattern.ports: { port | <checkInputPatternPort(port)> && }>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<action>();
res = true;
i++;
>>

actionTest(action) ::= <<
if (<checkInputPattern(action.inputPattern)>isSchedulable_<action.name>()) {
	<if(!action.outputPattern.empty)>
	if (<outputPattern(action.outputPattern)>) {
		<actionCall(action)>
	}
	<else>
	<actionCall(action)>
	<endif>
}>>

schedulingTest(actions) ::= <<
<actions: actionTest(); separator=" else ">
>>

scheduler(actions) ::= <<
@Override
public int schedule() {
	boolean res = true;
	int i = 0;

	while (res) {
		res = false;
		<if(actions)>
		<schedulingTest(actions)>
		<endif>
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(transition) ::= <<
<transition.action>();
_FSM_state = States.s_<transition.state.name>;
res = true;
>>

actionTestState(transition) ::= <<
if (<checkInputPattern(transition.action.inputPattern)>isSchedulable_<transition.action>()) {
	<if(!transition.action.outputPattern.empty)>
	if (<outputPattern(transition.action.outputPattern)>) {
		<actionCallState(transition)>
	}
	<else>
	<actionCallState(transition)>
	<endif>
}>>

schedulingTestState(transitionsList) ::= <<
<transitionsList: actionTestState(); separator=" else ">
>>

stateScheduler(transitions) ::= <<
private boolean stateScheduler_<transitions.sourceState.name>() {
	boolean res = false;
	<schedulingTestState(transitions.list)>
	return res;
}

>>

switchTransition(transition) ::= <<
case s_<transition.sourceState.name>:
	res = stateScheduler_<transition.sourceState.name>();
	if (res) {
		i++;
	}
	break;
>>

printSwitch(transitions) ::= <<
switch (_FSM_state) {
<transitions: switchTransition()>
default:
	System.out.println("unknown state: %s\n" + _FSM_state);
	break;
}
>>

schedulerFSM(actions, fsm) ::= <<
private enum States {
	<fsm.states : {state | s_<state.name>}; separator=",\n">
};

private States _FSM_state = States.s_<fsm.initialState.name>;

<if(actions)>
private boolean outside_FSM_scheduler() {
	boolean res = false;
	int i = 0;
	<schedulingTest(actions)>
	return res;
}


<endif>
<fsm.transitions: stateScheduler(); separator="\n">
@Override
public int schedule() {
	boolean res = true;
	int i = 0;

	while (res) {
		res = false;
		<if(actions)>
		if (outside_FSM_scheduler()) {
			res = true;
			i++;
		} else {
			<printSwitch(fsm.transitions)>
		}
		<else>
		<printSwitch(fsm.transitions)>
		<endif>
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

printActor(actor, options) ::= <<
/**
 * Generated from "<actor.name>"
 */
package <actor.package>;

import net.sf.orcc.runtime.*;
import net.sf.orcc.runtime.actors.IActor;

public class <actor.simpleName> implements IActor {

	// Input FIFOs
	<actor.inputs: fifo()>
	// Output FIFOs
	<actor.outputs: fifo()>
	// Parameters of the actor
	<actor.parameters: {param|private <variableDeclarationInit(param)>;}>
	// State variables of the actor
	<actor.stateVars: stateVar(); separator="\n">
	
	public <actor.simpleName>(<actor.parameters: variableDeclaration(); wrap, separator=", ">) {
		<actor.parameters: {param|this.<param.name> = <param.name>;}; separator="\n">
	}
	
	// Functions/procedures
	<actor.procs: printProcedure()>
	// Actions
	<actor.actions: printAction()>
<if(actor.initializes)>
	// Initializes
	<actor.initializes: printAction()>
<endif>
	@Override
	public void initialize() {
<if(actor.initializes)>
		boolean res = false;
		int i = 0;
		if (res){
		}

		<schedulingTest(actor.initializes)>
<endif>
	}

	@Override
	public void setFifo(String portName, Fifo fifo) {
		<actor.inputs: setFifo()><actor.outputs: setFifo()>{
			String msg = "unknown port \"" + portName + "\"";
			throw new IllegalArgumentException(msg);
		}
	}

	// Action scheduler
<if(actor.fsm)>
	// Scheduler fsm
	<schedulerFSM(actor.actionsOutsideFsm, actor.fsm)>
<else>
	// Scheduler (simple)
	<scheduler(actor.actionsOutsideFsm)>
<endif>

}

>>
