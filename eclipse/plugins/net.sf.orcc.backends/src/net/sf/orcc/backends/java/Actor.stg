import "net/sf/orcc/backends/c/Actor.stg"

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<

private Fifo\<<port.type>\> fifo_<port.name>;
>>

setFifo(port) ::= <<
if ("<port.name>".equals(portName)) {
	fifo_<port.name> = (Fifo\<<port.type>\>) fifo;
} else 
>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// a variable definition
// called by "function parameter", or "state variable with value"
variableDeclaration(variable) ::= <<
<variable.type> <variable.name>
>>

// a variable definition with initialization
// called by "local variable", or "state variable with no value"
variableDeclarationInit(variable) ::= <%
<variableDeclaration(variable)>
<if(variable.type.dimensions)> = new <variable.type.innermostType><listSize(variable.type.dimensions)>
<endif>
%>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

printBool(boolean) ::= <<
<if (boolean)>true<else>false<endif>
>>

// a state variable
stateVar(variable) ::= <%
private <if(variable.initialized)>
<if (!variable.assignable)> static <endif>
<variableDeclaration(variable)> = <Constant(variable.initialValue)>;
<else>
<variableDeclarationInit(variable)>;
<endif>
%>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

getPortName(variable, action) ::= <<
<if (action.inputPattern.varToPortMap.(variable))
><action.inputPattern.varToPortMap.(variable).name><
elseif (action.outputPattern.varToPortMap.(variable))
><action.outputPattern.varToPortMap.(variable).name><
else
><action.peekPattern.varToPortMap.(variable).name><
endif>
>>

printExpressionParameter(arg) ::= <%
<if (arg.value.booleanExpr || arg.value.intExpr || arg.value.floatExpr || arg.value.listExpr)>
<Constant(arg.value)>
<elseif (arg.value.binaryExpr)>
(<arg.value>)
<else>
<arg.value>
<endif>
%>

printParameter(arg) ::= <%
<if (arg.byVal)><
printExpressionParameter(arg)
><else
><arg.use.variable.name><endif>
%>

printCallParam(param, actor) ::= <%
<if (param.byRef)>
&<param.use.variable><param.indexes : {index | [<index>]}>
<else>
<if (actor.templateData.castedListReferences.(param))>(<actor.templateData.castedListReferences.(param)>)(<param.value>)<else><param.value><endif>
<endif>
%>

printCallProcedure(call, actor) ::= <%
<if (call.procedure.native)>NativeProcedure.<endif>
<call.procedure.name>(<call.parameters: printCallParam(actor); separator=", ">);
%>

printCall(call, actor) ::= <<

<if(call.print)>System.out.print(<call.parameters: printParameter(); separator=" + ">);<
else
><if(call.target)><call.target.variable.indexedName> = <endif
><printCallProcedure(call, actor)><endif>
>>

printLoad(load) ::= <<

<if (action.inputPattern.varToPortMap.(load.source.variable) || action.outputPattern.varToPortMap.(load.source.variable) || action.peekPattern.varToPortMap.(load.source.variable))
><load.target.variable.indexedName> = fifo_<getPortName(load.source.variable, action)>.read();
<else><load.target.variable.indexedName> = <load.source.variable.name><load.indexes : {index | <printLoadIndex(index)>}>;
<endif>
>>

// read instruction
printRead(read) ::= <<

<if (read.target)
>int <read.port.name>_Index = fifo_<read.port.name>.getReadIndex(<read.numTokens>);
<read.target> = fifo_<read.port.name>.getReadArray(<read.numTokens>);<
else
>fifo_<read.port.name>.getReadIndex(<read.numTokens>);
fifo_<read.port.name>.getReadArray(<read.numTokens>);<endif>
>>

printStore(store) ::= <<

< if (action.inputPattern.varToPortMap.(store.target.variable) || action.outputPattern.varToPortMap.(store.target.variable) || action.peekPattern.varToPortMap.(store.target.variable))
>fifo_<getPortName(store.target.variable, action)>.write(<store.value>);<
else
><store.target.variable.name><store.indexes : {index | <printLoadIndex(index)>}> = <store.value>;<endif>
>>

// write instruction
printWrite(write) ::= <<

<write.target> = fifo_<write.port.name>.getWriteArray(<write.numTokens>);
int <write.port>_Index = fifo_<write.port.name>.getWriteIndex(<write.numTokens>);
>>


printReturn(return) ::= <<
<if(return.value)>
return (<return.block.procedure.returnType>) (<return.value>);<
endif>
>>

printLoadIndex(index) ::= <<
[<if (index.type.long)>(int) <if (index.binaryExpr)> (<index>) <else><index><endif><else><index><endif>]
>>


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// block node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.call)><printCall(call=instr,actor=actor)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
endif>}>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and actions
///////////////////////////////////////////////////////////////////////////////

printProcedure(procedure, action=false) ::= <<
<if(!procedure.native)>

private <procedure.returnType> <procedure.name>(<procedure.parameters: {parameter | <variableDeclaration(parameter.variable)>}; wrap, anchor, separator=", ">) {
<if(procedure.locals)>
	<procedure.locals: {local | <variableDeclarationInit(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
}

<endif>
>>

printAction(action) ::= <<
private void <action.name>() {
<if(action.body.locals)>
	<action.body.locals: {local | <variableDeclarationInit(local)>;<\n>}>
<endif>
	<printNodes(action.body.nodes)>
}

<printProcedure(action.scheduler, action)>
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
<pattern.ports:{port|fifo_<port.name>.hasRoom(<pattern.numTokensMap.(port)>)}; separator=" && ">
>>

checkInputPatternPort(port) ::= <<
fifo_<port.name>.hasTokens(<pattern.numTokensMap.(port)>)
>>

checkInputPattern(pattern) ::= <<
<pattern.ports: { port | <checkInputPatternPort(port)> && }>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<action>();
res = true;
i++;
>>

actionTest(action) ::= <<
if (<checkInputPattern(action.inputPattern)>isSchedulable_<action.name>()) {
	<if(!action.outputPattern.empty)>
	if (<outputPattern(action.outputPattern)>) {
		<actionCall(action)>
	}
	<else>
	<actionCall(action)>
	<endif>
}>>

schedulingTest(actions) ::= <<
<actions: actionTest(); separator=" else ">
>>

scheduler(actions) ::= <<
@Override
public int schedule() {
	boolean res = true;
	int i = 0;

	while (res) {
		res = false;
		<if(actions)>
		<schedulingTest(actions)>
		<endif>
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(transition) ::= <<
<transition.action>();
_FSM_state = States.s_<transition.target.name>;
res = true;
>>

actionTestState(transition) ::= <<
if (<checkInputPattern(transition.action.inputPattern)>isSchedulable_<transition.action>()) {
	<if(!transition.action.outputPattern.empty)>
	if (<outputPattern(transition.action.outputPattern)>) {
		<actionCallState(transition)>
	}
	<else>
	<actionCallState(transition)>
	<endif>
}>>

schedulingTestState(transitionsList) ::= <<
<transitionsList: actionTestState(); separator=" else ">
>>

stateScheduler(state) ::= <<
private boolean stateScheduler_<state.name>() {
	boolean res = false;
	<schedulingTestState(state.outgoing)>
	return res;
}

>>

switchState(state) ::= <<

case s_<state.name>:
	res = stateScheduler_<state.name>();
	if (res) {
		i++;
	}
	break;
>>

printSwitch(states) ::= <<
switch (_FSM_state) {
<states: switchState()>
default:
	System.out.println("unknown state: %s\n" + _FSM_state);
	break;
}
>>

schedulerFSM(actions, fsm) ::= <<
private enum States {
	<fsm.states : {state | s_<state.name>}; separator=",\n">
};

private States _FSM_state = States.s_<fsm.initialState.name>;

<if(actions)>
private boolean outside_FSM_scheduler() {
	boolean res = false;
	int i = 0;
	<schedulingTest(actions)>
	return res;
}

<endif>
<fsm.states: stateScheduler(); separator="\n">
@Override
public int schedule() {
	boolean res = true;
	int i = 0;

	while (res) {
		res = false;
		<if(actions)>
		if (outside_FSM_scheduler()) {
			res = true;
			i++;
		} else {
			<printSwitch(fsm.states)>
		}
		<else>
		<printSwitch(fsm.states)>
		<endif>
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

printActor(actor, options) ::= <<
/**
 * Generated from "<actor.name>"
 */
package <actor.package>;

import net.sf.orcc.runtime.Fifo;
import net.sf.orcc.runtime.actors.IActor;
<if (options.usingNativeProc)>import net.sf.orcc.runtime.NativeProcedure;<endif> 

public class <actor.simpleName> implements IActor {

	// Input FIFOs
	<actor.inputs: fifo()>
	// Output FIFOs
	<actor.outputs: fifo()>
	// Parameters of the actor
	<actor.parameters: {param|private <variableDeclarationInit(param)>;}>
	// State variables of the actor
	<actor.stateVars: stateVar(); separator="\n">
	
	public <actor.simpleName>(<actor.parameters: variableDeclaration(); wrap, separator=", ">) {
		<actor.parameters: {param|this.<param.name> = <param.name>;}; separator="\n">
	}
	
	// Functions/procedures
	<actor.procs: printProcedure()>
	// Actions
	<actor.actions: printAction()>
<if(actor.initializes)>
	// Initializes
	<actor.initializes: printAction()>
<endif>
	@Override
	public void initialize() {
<if(actor.initializes)>
		boolean res = false;
		int i = 0;
		if (res){
		}

		<schedulingTest(actor.initializes)>
<endif>
	}

	@Override
	@SuppressWarnings("unchecked")
	public \<T\> void setFifo(String portName, Fifo\<T\> fifo) {
		<actor.inputs: setFifo()><actor.outputs: setFifo()>{
			String msg = "unknown port \"" + portName + "\"";
			throw new IllegalArgumentException(msg);
		}
	}

<if(actor.fsm)>
	// Action scheduler (FSM)
	<schedulerFSM(actor.actionsOutsideFsm, actor.fsm)>
<else>
	// Action scheduler (simple)
	<scheduler(actor.actionsOutsideFsm)>
<endif>

}

>>
