import "net/sf/orcc/templates/VHDL_testbench.stg"

///////////////////////////////////////////////////////////////////////////////
// Print signal and instanciation
///////////////////////////////////////////////////////////////////////////////
printInPortSignals(port) ::= <<
<if(port.type.bool)
 >signal <port.name>_data  : std_logic := '0';
<else
 >signal <port.name>_data  : std_logic_vector(<port.type.size> -1 downto 0) := (others =\> '0');
<endif>
signal <port.name>_send  : std_logic := '0';
signal <port.name>_ack   : std_logic;
signal <port.name>_rdy   : std_logic;
signal <port.name>_count  : std_logic_vector(15 downto 0) := (others =\> '0');
>>
printOutPortSignals(port) ::= <<
<if(port.type.bool)
 >signal <port.name>_data  : std_logic;
<else
 >signal <port.name>_data  : std_logic_vector(<port.type.size> -1 downto 0);
<endif>
signal <port.name>_send  : std_logic;
signal <port.name>_ack   : std_logic := '0';
signal <port.name>_rdy   : std_logic := '0';
signal <port.name>_count  : std_logic_vector(15 downto 0);
>>

printInPorts(port) ::= <<
<if(port.type.bool)
 ><port.name>_data  : IN std_logic;
<else
 ><port.name>_data  : IN std_logic_vector(<port.type.size> -1 downto 0);
<endif>
<port.name>_send  : IN std_logic;
<port.name>_ack   : OUT std_logic;
<port.name>_rdy   : OUT std_logic;
<port.name>_count  : IN std_logic_vector(15 downto 0);
>>

printOutPorts(port) ::= <<
<if(port.type.bool)
 ><port.name>_data  : OUT std_logic;
<else
 ><port.name>_data  : OUT std_logic_vector(<port.type.size> -1 downto 0);
<endif>
<port.name>_send  : OUT std_logic;
<port.name>_ack   : IN std_logic;
<port.name>_rdy   : IN std_logic;
<port.name>_count  : OUT std_logic_vector(15 downto 0);
>>

signalsInstanciation(port) ::= <<
<port.name>_data  =\> <port.name>_data,
<port.name>_send  =\> <port.name>_send,
<port.name>_ack   =\> <port.name>_ack,
<port.name>_count   =\> <port.name>_count,
<port.name>_rdy   =\> <port.name>_rdy
>>

///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty

sig_const(input, output) ::= <<
constant PERIOD : time := 50 ns;
constant DUTY_CYCLE : real := 0.5;
constant OFFSET : time := 100 ns;
--
type severity_level is (note, warning, error, failure);
type tb_type is (after_reset, read_file, CheckRead);
--
-- Input and Output files
<input: printFSMIn(); separator="\n">
<output: printFSMOut(); separator="\n">
--
-- Input and Output signals
<input: printInPortSignals(); separator="\n">
<output: printOutPortSignals(); separator="\n">
--
-- Configuration
signal count       : integer range 255 downto 0 := 0;
signal clock       : std_logic := '0';
signal reset_n     : std_logic := '0';

>>

///////////////////////////////////////////////////////////////////////////////
// Print processes
///////////////////////////////////////////////////////////////////////////////
clock_process() ::= <<
clockProcess : process
        begin
            wait for OFFSET;
            clock_LOOP : loop
                clock \<= '0';
                wait for (PERIOD - (PERIOD * DUTY_CYCLE));
                clock \<= '1';
                wait for (PERIOD * DUTY_CYCLE);
            end loop clock_LOOP;
        end process;

>>

RESET_process() ::= <<
resetProcess : process
   begin		
	 wait for OFFSET;
      -- reset state for 100 ns.
		reset_n \<= '1';
      wait for 100 ns;
      reset_n \<= '0';	
		wait;
   end process;

>>

init_process(output) ::= <<
<output.list: RdyAckInit(); separator="\n">
>>

RdyAckInit(port) ::= <<
<port.name>_ack \<= <port.name>_send;
<port.name>_rdy \<= '1';
>>

///////////////////////////////////////////////////////////////////////////////
// testbench
///////////////////////////////////////////////////////////////////////////////
instance(instance, options) ::= <<
------------------------------------------------------------------------------
-- Generated from <instance.id>
------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.ALL;
USE std.textio.all;

library work;
use work.sim_package.all;

entity tb_<instance.id> is

end tb_<instance.id>;


architecture arch_tb_<instance.id> of tb_<instance.id> is 

<if(instance.actor)>

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.actor.inputs,output=instance.actor.outputs)>
  ---------------------------------------------------------------------------

begin
       
    <clock_process()>
    
    <init_process(output=instance.actor.outputs)>
    
    <RESET_process()>
    
    <if(instance.actor.inputs)
    ><waveform_process_in(input=instance.actor.inputs)><
    endif>
    <if(instance.actor.outputs)
    ><waveform_process_out(output=instance.actor.outputs)><
    endif>
<else>

----------------------------------------------------------------------------
-- component declaration
----------------------------------------------------------------------------

component <instance.id>
	port (
     
      <if(instance.network.inputs.list || instance.network.outputs.list)><endif>
      <instance.network.inputs.list: printInPorts(); separator="\n"><if(instance.network.inputs.list && instance.network.outputs.list)><endif>
      <instance.network.outputs.list: printOutPorts(); separator="\n"><if(!instance.network.outputs.list)>    <endif>
      clock : IN std_logic;
      reset_n : IN std_logic);
      end component;
  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.network.inputs.list,output=instance.network.outputs.list)>
  ---------------------------------------------------------------------------

begin

   uut : <instance.id> port map (
      clock      =\> clock,
      reset_n    =\> reset_n<if(instance.network.inputs.list || instance.network.outputs.list)>,<endif>
      <instance.network.inputs.list: signalsInstanciation(); separator=",\n"><if(instance.network.inputs.list && instance.network.outputs.list)>,<endif>
      <instance.network.outputs.list: signalsInstanciation(); separator=",\n"><if(!instance.network.outputs.list)>    <endif>);
      
    <clock_process()>
    
    <init_process(output=instance.network.outputs)>
    
    <RESET_process()>
    
    <if(instance.network.inputs.list)
    ><waveform_process_in(input=instance.network.inputs.list)><
    endif>
    <if(instance.network.outputs.list)
    ><waveform_process_out(output=instance.network.outputs.list)><
    endif>
<endif>

end architecture arch_tb_<instance.id>;
>>