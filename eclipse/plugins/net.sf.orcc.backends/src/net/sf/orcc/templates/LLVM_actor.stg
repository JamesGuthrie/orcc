import "net/sf/orcc/templates/LLVM_metadata.stg"

///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

variableDeclaration(variable) ::= <<
<if(!variable.port)
><if(variable.type.list)
><if(variable.instruction.store || !variable.instruction)>
<AllocaOp(result={%<variable>}, type=variable.type)>
<endif>
<endif><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
@<variable.name> = <if(variable.assignable)> global <
else> constant <endif> <variable.type> <
if(variable.initialValue)> <ConstantValue(type=variable.type, const=variable.initialValue)> 
<else> zeroinitializer, align 32 
<endif>

>>


///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
LoadOp(ty, pointer) ::= <<
load <ty>* <pointer>
>>

AndOp(result, ty, op1, op2) ::= <<
<result> = and <ty> <op1>, <op2>
>>

IcmpOp(result, cond, ty, op1, op2) ::= <<
<result> = icmp <cond> <ty> <op1>, <op2>
>>
 
GetElementPtrOp(pty, ptrval, idx0, idx) ::= <<
getelementptr <pty>* <ptrval><if(idx0)>, i32 <idx0><endif> <if(idx)>, <indexes(idx)><endif>
>>

BitcastOp(result, ty, value, ty2) ::= <<
<result> = bitcast <ty> <value> to <ty2>
>>

AllocaOp(result, type) ::= <<
<result> = alloca <type>
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
<if(cond)
>br i1 <cond>, label <iftrue>, label <iffalse><
else
>br label <dest><
endif>
>>

RetOp(type, value) ::= <<
<if(value)
>ret <type> <value><
else
>ret void<
endif>
>>

CallOp(ty, fnptrval, function_args) ::= <<
call <ty> @<fnptrval> (<function_args>)
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

StoreInstr(ty, value, pty, ptr) ::= <<
<if(value.intExpr || value.booleanExpr)
>store <pty> <value>, <pty>* <ptr><
else
>store <ty> <Expr(expr=value, type=ty)>, <pty>* <ptr><
endif>
>>

PrintInstr(parameters) ::= <<
call i32 (i8*, ...)* @printf(<parameters: PrintParameter(); separator=", ">)

>>

PrintParameter(parameter) ::= <<
<if (parameter.type.string)
> i8* noalias getelementptr inbounds (<parameter.type>* @<parameter>, i64 0, i64 0) <
else
><parameter.type> <Expr(expr=parameter, type=parameter.type)><
endif>

>>

///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

CastParameter(casts, args, params, location )::= <<
<casts, args, params: { cast, arg, param | <if(cast)> 
<BitcastOp(result={%<param><location>_cast}, ty={<param.type>*}, value=Expr(expr=param, type=param.type), ty2={<arg.type>*})>
<endif>}>
>>

IfWithThenElseNodes(ifNode) ::= <<
	<BrOp(cond=Expr(expr=ifNode.condition, type=ifNode.condition.type), iftrue={%b<label(ifNode.thenNodes)>}, iffalse={%b<label(ifNode.elseNodes)>}, dest="")>

b<label(ifNode.thenNodes)>: 
<printNodes_cond(first(ifNode.thenNodes))> <printNodes(rest(ifNode.thenNodes))>
	br label %b<label(ifNode.joinNode)>

b<label(ifNode.elseNodes)>:
<printNodes_cond(first(ifNode.elseNodes))> <printNodes(rest(ifNode.elseNodes))>
	br label %b<label(ifNode.joinNode)>

b<label(ifNode.joinNode)>:

>>

IfWithThenNode(ifNode) ::= <<
	<BrOp(cond=Expr(expr=ifNode.condition, type=ifNode.condition.type), iftrue={%b<label(ifNode.thenNodes)>}, iffalse={%b<label(ifNode.joinNode)>}, dest="")>

b<label(ifNode.thenNodes)>: 
<printNodes_cond(first(ifNode.thenNodes))> <printNodes(rest(ifNode.thenNodes))>
	br label %b<label(ifNode.joinNode)>

b<label(ifNode.joinNode)>:

>>

label(nodes) ::= "b<first(nodes):{ x | <x.label>}>"

phiPairs(phi) ::= <<
<phiExpr(expr=first(phi.values), type=phi.target.type , node = first(phi.block.predecessors))>, <phiExpr(expr=first(rest(phi.values)), type=phi.target.type, node = rest(phi.block.predecessors))>
>>

phiExpr(expr, type, node) ::= <<
[<Expr(expr=expr, type=type)> , %b<label(node)> ]
>>


///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////


printCall(call) ::= <<
<if(call.print)> 
<PrintInstr(call.parameters)> 
<else>
<CastParameter(casts=call.paramCast, args=call.procedure.parameters, params=call.parameters, location=Location(call.location))>
<if(call.target)>
%<call.target> = <CallOp(ty=call.procedure.returnType,
fnptrval=call.procedure.name,
function_args=parametersDeclaration(arguments=call.procedure.parameters, parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))>
<else>
<CallOp(ty=call.procedure.returnType, fnptrval=call.procedure.name, function_args=parametersDeclaration(arguments=call.procedure.parameters ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))>
<endif>
<endif>
>>

Cast(target, value, cast)::= <<
<if(cast.extended)>
<if(cast.signed)
>%<target> = sext <value.type> %<value> to <target.type><
else
>%<target> = zext <value.type> %<value> to <target.type><
endif>
<else>
%<target> = trunc <value.type> %<value> to <target.type>
<endif>
>>

printAssign(assign) ::= <<
<if(assign.cast)>
<Cast(target = assign.target, value = assign.value, cast = assign.cast)>
<else> 
%<assign.target.variable.indexedName> = <assign.value>
<endif>
>>

printPhiAssignment(phi) ::= <<

<Var(phi.target.variable)> = phi <phi.target.type> <phiPairs(phi)>
>>

printReturn(return) ::= <<

<if(return.value)><
RetOp(type=return.value.type, value=Expr(expr=return.value, type=return.value.type))><
else
><RetOp(type="void", value="")><
endif>
>>

printStore(store) ::= <<
<StoreInstr(ty=store.value.type, value=store.value, pty=VarType(store.target.variable), ptr=Var(store.target.variable))>

>>

printLoad(load) ::= <<
<Var(load.target.variable)> = <LoadOp(ty=VarType(load.source.variable), pointer=Var(load.source.variable))>

>>

GEP(gep) ::= <<
<Var(gep.target)> = <GetElementPtrOp(idx0="0",  pty=VarType(gep.source.variable), ptrval=Var(gep.source.variable), idx=gep.indexes)>

>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

// if node
printIfNode(ifNode) ::= <<
<if(ifNode.thenNodes)>
<if(ifNode.elseNodes)>
<IfWithThenElseNodes(ifNode)>
<else>
<IfWithThenNode(ifNode)>	
<endif>
<endif>
<printNodes_cond(first(ifNode.joinNode))>
<printNodes(rest(ifNode.joinNode))>

>>

// while node
printWhileNode(whileNode) ::= <<
<printBlockNode(whileNode.joinNode)>
	<BrOp(cond=Expr(expr=whileNode.condition, type=whileNode.condition.type), iftrue={%b<label(whileNode.Nodes)>}, iffalse={%b<label(whileNode.joinNode.successors)>}, dest="")>

b<label(whileNode.nodes)>:
<printNodes_cond(first(whileNode.nodes))>
<printNodes(rest(whileNode.nodes))>
	br label %b<label(whileNode.joinNode)>

b<label(whileNode.joinNode.successors)>:

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

Instruction(instr) ::= <<
<
if (instr.assign)><printAssign(instr)><
elseif(instr.phi)><printPhiAssignment(instr)><
elseif (instr.call)><printCall(instr)><
elseif (instr.load)><printLoad(instr)><
elseif (instr.return)><printReturn(instr)><
elseif (instr.store)><printStore(instr)><
endif>
>>

printInstructions(instructions) ::= <<
<instructions: Instruction()>
>>

printNode(node) ::= <<
<if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>
>>

printNodes(nodes) ::= <<
<nodes:printNode()>
>>


Node_cond(node) ::= <<
<if (node.blockNode)><printBlockNode_cond(node)><
elseif (node.ifNode)><printIfNode_cond(node)><
elseif (node.whileNode)><printWhileNode_cond(node)><
endif>
>>

printNodes_cond(nodes) ::= <<
<nodes: Node_cond()>
>>

printWhileNode_cond(nodes) ::= <<
<printWhileNode(nodes)>
>>

printIfNode_cond(nodes) ::= <<
<printIfNode(nodes)>
>>

printBlockNode_cond(blockNode) ::= <<
	<printInstructions(blockNode.instructions)> 
>>

// if node
printBlockNode(blockNode) ::= <<
	br label %b<label(blockNode)>

b<label(blockNode)>:
	<printInstructions(blockNode.instructions)>
	
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////
printProcedure(proc) ::= <<
<procedure(procedure = proc)>
>>

procedure(procedure, action = false) ::= <<
<if(!procedure.native)>
define <procedure.returnType> @<procedure.name>(<procedure.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
<if(procedure.locals)>
	<procedure.locals: variableDeclaration()>
<endif>
<if(action.inputPattern.ports)>
	<action.inputPattern.ports: { port | <fifoVar(port=port, var=action.inputPattern.portToVarMap.(port))>}>
<endif>
<if(action.outputPattern.ports)>
	<action.outputPattern.ports: { port | <fifoVar(port=port, var=action.outputPattern.portToVarMap.(port))>}>
<endif>
<printNodes(trunc(procedure.nodes))>
<printNode(last(procedure.nodes))>
}
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Parameters
///////////////////////////////////////////////////////////////////////////////

actorParameter(parameter) ::= <<
@<parameter.name> = global <parameter.type> undef

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printAction(action) ::= <<
<procedure(procedure = action.scheduler, action=action)>
<procedure(procedure = action.body, action=action)>
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "<actor.name>"
declare i32 @printf(i8* noalias , ...) nounwind 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
<actor.inputs: fifo()>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
<actor.outputs: fifo()>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<actor.parameters: actorParameter()>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<actor.stateVars: stateVar()>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<actor.procs: {proc | <procedure(procedure = proc)>}>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<actor.actions: printAction()>

; Initializes
<if(actor.initializes)>
<actor.initializes: printAction()>
<endif>

<decl_MD(actor)>

>>
