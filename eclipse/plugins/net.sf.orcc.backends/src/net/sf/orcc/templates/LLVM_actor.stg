import "net/sf/orcc/templates/LLVM_metadata.stg"

///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

variableDeclaration(variable) ::= <<
<if(variable.type.list && !actor.templateData.castedListReferences.(variable))>
<AllocaOp(result={%<variable.indexedName>}, type=variable.type)>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
@<variable.name> = <if(variable.assignable)>global<else>constant<endif> <variable.type> <
if(variable.initialValue)> <ConstantValue(type=variable.type, const=variable.initialValue)> 
<else> zeroinitializer, align 32 
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
LoadOp(ty, pointer) ::= <<
load <ty>* <pointer>
>>

AndOp(result, ty, op1, op2) ::= <<
<result> = and <ty> <op1>, <op2>
>>

IcmpOp(result, cond, ty, op1, op2) ::= <<
<result> = icmp <cond> <ty> <op1>, <op2>
>>
 
GetElementPtrOp(pty, ptrval, idx0, idx) ::= <<
getelementptr <pty>* <ptrval><if(idx0)>, i32 <idx0><endif> <if(idx)>, <indexes(idx)><endif>
>>

BitcastOp(result, ty, value, ty2) ::= <<
<result> = bitcast <ty> <value> to <ty2>
>>

AllocaOp(result, type) ::= <<
<result> = alloca <type>
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
<if(cond)
>br i1 <cond>, label <iftrue>, label <iffalse><
else
>br label <dest><
endif>
>>

RetOp(type, value) ::= <<
<if(value)
>ret <type> <value><
else
>ret void<
endif>
>>

CallOp(ty, fnptrval, function_args) ::= <<
call <ty> @<fnptrval> (<function_args>)
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

StoreInstr(ty, value, pty, ptr) ::= <<
<if(value.intExpr || value.booleanExpr)
>store <pty> <value>, <pty>* <ptr><
else
>store <ty> <Expr(expr=value, type=ty)>, <pty>* <ptr><
endif>
>>

PrintInstr(parameters) ::= <<
call i32 (i8*, ...)* @printf(<parameters: PrintParameter(); separator=", ">)
>>

PrintParameter(parameter) ::= <<
<if (parameter.type.string)
> i8* noalias getelementptr inbounds (<parameter.type>* @<parameter>, i64 0, i64 0) <
else
><parameter.type> <Expr(expr=parameter, type=parameter.type)><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

label(node) ::= "b<actor.templateData.nodeToLabelMap.(node)>"

phiPairs(phi) ::= <<
<phiExpr(first(phi.values), phi.target.variable.type, first(phi.block.predecessors))>, <phiExpr(first(rest(phi.values)), phi.target.variable.type, first(rest(phi.block.predecessors)))>
>>

phiExpr(expr, type, node) ::= <<
[<Expr(expr=expr, type=type)>, %b<label(node)>]
>>


///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: printInstruction(); separator="\n">
>>

printInstruction(inst) ::= <<
<if(inst.assign)><printAssign(inst)><
elseif(inst.gep)><printGEP(inst)><
elseif(inst.phi)><printPhiAssignment(inst)><
elseif(inst.call)><printCall(inst)><
elseif(inst.load)><printLoad(inst)><
elseif(inst.return)><printReturn(inst)><
elseif(inst.store)><printStore(inst)><
elseif(inst.instCast)><printCast(inst)><
endif>
>>

printCall(call) ::= <<
<if(call.print)> 
<PrintInstr(call.parameters)> 
<else>
<if(call.target)>
%<call.target.variable.indexedName> = <CallOp(ty=call.procedure.returnType,
fnptrval=call.procedure.name,
function_args=parametersDeclaration(call.procedure.parameters, call.parameters))>
<else>
<CallOp(ty=call.procedure.returnType, fnptrval=call.procedure.name, function_args=parametersDeclaration(call.procedure.parameters, call.parameters))>
<endif>
<endif>
>>

printCast(cast)::= <<
%<cast.target.variable.indexedName> = <printCastOp(cast)> <printCastType(cast.source.variable)> %<cast.source.variable.indexedName> to <printCastType(cast.target.variable)>
>>

printCastOp(cast) ::= <<
<if(cast.source.variable.type.list)>bitcast<else><if(cast.extended)><if(cast.signed)>sext<else>zext<endif><else>trunc<endif><endif>
>>

printCastType(var) ::= <<
<var.type><if(var.type.list)>*<endif>
>>

printAssign(assign) ::= <<
%<assign.target.variable.indexedName> = <assign.value>
>>

printPhiAssignment(phi) ::= <<
<Var(phi.target.variable)> = phi <phi.target.variable.type> <phiPairs(phi)>
>>

printReturn(return) ::= <<
<if(return.value)><
RetOp(type=return.value.type, value=Expr(expr=return.value, type=return.value.type))><
else
><RetOp(type="void", value="")><
endif>
>>

printStore(store) ::= <<
<StoreInstr(ty=store.value.type, value=store.value, pty=VarType(store.target.variable), ptr=Var(store.target.variable))>
>>

printLoad(load) ::= <<
<Var(load.target.variable)> = <LoadOp(ty=VarType(load.source.variable), pointer=Var(load.source.variable))>
>>

printGEP(gep) ::= <<
<Var(gep.target.variable)> = <GetElementPtrOp(idx0="0",  pty=VarType(gep.source.variable), ptrval=Var(gep.source.variable), idx=gep.indexes)>
>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

printNodes(nodes) ::= <<
<nodes:printNode()>
>>

printNode(node) ::= <<
<if(node.blockNode)><printBlockNode(node)><
elseif(node.ifNode)><printIfNode(node)><
elseif(node.whileNode)><printWhileNode(node)><
endif>
>>


printIfNode(ifNode) ::= <<
<if(ifNode.elseNodes)>
	<BrOp(cond=Expr(expr=ifNode.condition, type=ifNode.condition.type), iftrue={%b<label(first(ifNode.thenNodes))>}, iffalse={%b<label(first(ifNode.elseNodes))>}, dest="")>
<else>
	<BrOp(cond=Expr(expr=ifNode.condition, type=ifNode.condition.type), iftrue={%b<label(first(ifNode.thenNodes))>}, iffalse={%b<label(ifNode.joinNode)>}, dest="")>
<endif>

b<label(first(ifNode.thenNodes))>: 
<printNodes_cond(first(ifNode.thenNodes))> <printNodes(rest(ifNode.thenNodes))>
	br label %b<label(ifNode.joinNode)>

<if(ifNode.elseNodes)>
b<label(first(ifNode.elseNodes))>:
<printNodes_cond(first(ifNode.elseNodes))> <printNodes(rest(ifNode.elseNodes))>
	br label %b<label(ifNode.joinNode)>
<endif>

b<label(ifNode.joinNode)>:
<printNodes_cond(first(ifNode.joinNode))>
<printNodes(rest(ifNode.joinNode))>
>>

printWhileNode(whileNode) ::= <<
<printBlockNode(whileNode.joinNode)>
	<BrOp(cond=Expr(expr=whileNode.condition, type=whileNode.condition.type), iftrue={%b<label(first(whileNode.Nodes))>}, iffalse={%b<label(first(whileNode.joinNode.successors))>}, dest="")>

b<label(first(whileNode.nodes))>:
<printNodes_cond(first(whileNode.nodes))>
<printNodes(rest(whileNode.nodes))>
	br label %b<label(whileNode.joinNode)>

b<label(first(whileNode.joinNode.successors))>:
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

Node_cond(node) ::= <<
<if(node.blockNode)><printBlockNode_cond(node)><
elseif(node.ifNode)><printIfNode_cond(node)><
elseif(node.whileNode)><printWhileNode_cond(node)><
endif>
>>

printNodes_cond(nodes) ::= <<
<nodes: Node_cond()>
>>

printWhileNode_cond(nodes) ::= <<
<printWhileNode(nodes)>
>>

printIfNode_cond(nodes) ::= <<
<printIfNode(nodes)>
>>

printBlockNode_cond(blockNode) ::= <<
	<printInstructions(blockNode.instructions)> 
>>

// if node
printBlockNode(blockNode) ::= <<
	br label %b<label(blockNode)>

b<label(blockNode)>:
	<printInstructions(blockNode.instructions)>
	
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////
printProcedure(proc) ::= <<
<procedure(procedure = proc)>
>>

procedure(procedure) ::= <<
<if(!procedure.native)>
define <procedure.returnType> @<procedure.name>(<procedure.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
<if(procedure.locals)>
	<procedure.locals: variableDeclaration()>
<endif>
<printNodes(procedure.nodes)>
}
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Parameters
///////////////////////////////////////////////////////////////////////////////

actorParameter(parameter) ::= <<
@<parameter.name> = global <parameter.type> undef
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printAction(action) ::= <<
define <action.scheduler.returnType> @<action.scheduler.name>(<action.scheduler.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
	<action.scheduler.locals: variableDeclaration()>
	<action.peekPattern.ports: { port | <fifoVar(port=port, var=action.inputPattern.portToVarMap.(port))>}; separator="\n">
<printNodes(action.scheduler.nodes)>
}

define void @<action.body.name>(<action.body.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
	<action.body.locals: variableDeclaration()>
	<action.inputPattern.ports: { port | <fifoVar(port=port, var=action.inputPattern.portToVarMap.(port))>}; separator="\n">
	<action.outputPattern.ports: { port | <fifoVar(port=port, var=action.outputPattern.portToVarMap.(port))>}; separator="\n">
<printNodes(action.body.nodes)>
}
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "<actor.name>"
declare i32 @printf(i8* noalias , ...) nounwind 

<if(actor.inputs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
<actor.inputs: fifo(); separator="\n">
<endif>

<if(actor.outputs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
<actor.outputs: fifo(); separator="\n">
<endif>

<if(actor.parameters)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<actor.parameters: actorParameter(); separator="\n">
<endif>

<if(actor.stateVars)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<actor.stateVars: stateVar(); separator="\n">
<endif>

<if(actor.procs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<actor.procs: {proc | <procedure(procedure = proc)>}>
<endif>

<if(actor.initializes)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initializes
<actor.initializes: printAction()>
<endif>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<actor.actions: printAction()>

<decl_MD(actor)>

>>

instance(instance, options) ::= <<
<actor(instance.actor, options)>
>>
