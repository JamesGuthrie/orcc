import "net/sf/orcc/templates/LLVM_metadata.stg"

///////////////////////////////////////////////////////////////////////////////
// Local variables
///////////////////////////////////////////////////////////////////////////////

variableDeclaration(variable) ::= <<
<if(!variable.port)
><if(variable.type.list)
><if(variable.instruction.store || !variable.instruction)>
<AllocaOp(result={%<variable>}, type=variable.type)>
<endif>
<endif><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
@<variable> = <if(variable.assignable)> global <
else> constant <endif> <variable.type> <
if(variable.initialValue)> <ConstantValue(type=variable.type, const=variable.initialValue)> 
<else> zeroinitializer, align 32 
<endif>

>>


///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
LoadOp(ty, pointer) ::= <<
load <ty>* <pointer>
>>

AndOp(result, ty, op1, op2) ::= <<
<result> = and <ty> <op1>, <op2>
>>

IcmpOp(result, cond, ty, op1, op2) ::= <<
<result> = icmp <cond> <ty> <op1>, <op2>
>>
 
GetElementPtrOp(pty, ptrval, idx0, idx) ::= <<
getelementptr <pty>* <ptrval><if(idx0)>, i32 <idx0><endif> <if(idx)>, <indexes(idx)><endif>
>>

BitcastOp(result, ty, value, ty2) ::= <<
<result> = bitcast <ty> <value> to <ty2>
>>

AllocaOp(result, type) ::= <<
<result> = alloca <type>
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
<if(cond)
>br i1 <cond>, label <iftrue>, label <iffalse><
else
>br label <dest><
endif>
>>

RetOp(type, value) ::= <<
<if(value)
>ret <type> <value><
else
>ret void<
endif>
>>

CallOp(ty, fnptrval, function_args) ::= <<
call <ty> @<fnptrval> (<function_args>)
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

StoreInstr(ty, value, pty, ptr) ::= <<
<if(value.intExpr || value.booleanExpr)
>store <pty> <value>, <pty>* <ptr><
else
>store <ty> <Expr(expr=value, type=ty)>, <pty>* <ptr><
endif>
>>

PrintInstr(parameters) ::= <<
call i32 (i8*, ...)* @printf(<parameters: PrintParameter(); separator=", ">)

>>

PrintParameter(parameter) ::= <<
<if (parameter.type.string)
> i8* noalias getelementptr inbounds (<parameter.type>* @<parameter>, i64 0, i64 0) <
else
><parameter.type> <Expr(expr=parameter, type=parameter.type)><
endif>

>>

///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

CastParameter(casts, args, params, location )::= <<
<casts, args, params: { cast, arg, param | <if(cast)> 
<BitcastOp(result={%<param><location>_cast}, ty={<param.type>*}, value=Expr(expr=param, type=param.type), ty2={<arg.type>*})>
<endif>}>
>>

IfWithThenElseNodes(ifNode) ::= <<
	<BrOp(cond=Expr(expr=ifNode.value, type=ifNode.value.type), iftrue={%b<label(ifNode.thenNodes)>}, iffalse={%b<label(ifNode.elseNodes)>}, dest="")>

b<label(ifNode.thenNodes)>: 
<Nodes_cond(first(ifNode.thenNodes))> <Nodes(rest(ifNode.thenNodes))>
	br label %b<label(ifNode.joinNode)>

b<label(ifNode.elseNodes)>:
<Nodes_cond(first(ifNode.elseNodes))> <Nodes(rest(ifNode.elseNodes))>
	br label %b<label(ifNode.joinNode)>

b<label(ifNode.joinNode)>:

>>

IfWithThenNode(ifNode) ::= <<
	<BrOp(cond=Expr(expr=ifNode.value, type=ifNode.value.type), iftrue={%b<label(ifNode.thenNodes)>}, iffalse={%b<label(ifNode.joinNode)>}, dest="")>

b<label(ifNode.thenNodes)>: 
<Nodes_cond(first(ifNode.thenNodes))> <Nodes(rest(ifNode.thenNodes))>
	br label %b<label(ifNode.joinNode)>

b<label(ifNode.joinNode)>:

>>

label(nodes) ::= "b<first(nodes):{ x | <x.label>}>"

phiPairs(phi) ::= <<
<phiExpr(expr=first(phi.values), type=phi.target.type , node = first(phi.block.predecessors))>, <phiExpr(expr=first(rest(phi.values)), type=phi.target.type, node = rest(phi.block.predecessors))>
>>

phiExpr(expr, type, node) ::= <<
[<Expr(expr=expr, type=type)> , %b<label(node)> ]
>>


///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////


Call(call) ::= <<
<if(call.print)> 
<PrintInstr(call.parameters)> 
<else>
<CastParameter(casts=call.paramCast, args=call.procedure.parameters.list, params=call.parameters, location=Location(call.location))>
<if(call.target)>
%<call.target> = <CallOp(ty=call.procedure.returnType,
fnptrval=call.procedure,
function_args=parametersDeclaration(arguments=call.procedure.parameters.list, parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))>
<else>
<CallOp(ty=call.procedure.returnType, fnptrval=call.procedure, function_args=parametersDeclaration(arguments=call.procedure.parameters.list ,parameters=call.parameters, casts=call.paramCast, location=Location(call.location)))>
<endif>
<endif>
>>

Cast(target, value, cast)::= <<
<if(cast.extended)>
<if(cast.signed)
>%<target> = sext <value.type> %<value> to <target.type><
else
>%<target> = zext <value.type> %<value> to <target.type><
endif>
<else>
%<target> = trunc <value.type> %<value> to <target.type>
<endif>
>>

Assign(assign) ::= <<
<if(assign.cast)>
<Cast(target = assign.target, value = assign.value, cast = assign.cast)>
<else> 
%<assign.target> = <assign.value>
<endif>
>>

PhiAssignment(phi) ::= <<

%<phi.target> = phi <phi.target.type> <phiPairs(phi)>
>>

Return(return) ::= <<

<if(return.value)><
RetOp(type=return.value.type, value=Expr(expr=return.value, type=return.value.type))><
else
><RetOp(type="void", value="")><
endif>
>>

Store(store) ::= <<

<StoreInstr(ty=store.value.type, value=store.value, pty=VarType(store.target), ptr=Var(store.target))>

>>

Load(load) ::= <<
<Var(load.target)> = <LoadOp(ty=VarType(load.source.variable), pointer=Var(load.source.variable))>

>>

GEP(gep) ::= <<
<Var(gep.target)> = <GetElementPtrOp(idx0="0",  pty=VarType(gep.source.variable), ptrval=Var(gep.source.variable), idx=gep.indexes)>

>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

// if node
IfNode(ifNode) ::= <<
<if(ifNode.thenNodes)>
<if(ifNode.elseNodes)>
<IfWithThenElseNodes(ifNode)>
<else>
<IfWithThenNode(ifNode)>	
<endif>
<endif>
<Nodes_cond(first(ifNode.joinNode))>
<Nodes(rest(ifNode.joinNode))>

>>

// while node
WhileNode(whileNode) ::= <<
<BlockNode(whileNode.joinNode)>
	<BrOp(cond=Expr(expr=whileNode.value, type=whileNode.value.type), iftrue={%b<label(whileNode.Nodes)>}, iffalse={%b<label(whileNode.joinNode.successors)>}, dest="")>

b<label(whileNode.nodes)>:
<Nodes_cond(first(whileNode.nodes))>
<Nodes(rest(whileNode.nodes))>
	br label %b<label(whileNode.joinNode)>

b<label(whileNode.joinNode.successors)>:

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

Instruction(instruction) ::= <<
<(instruction.class.simpleName)(instruction)>
>>

Instructions(instructions) ::= <<
<instructions: Instruction()>
>>

Node(node) ::= <<
<(node.class.simpleName)(node)>
>>

Nodes(nodes) ::= <<
<nodes: Node()>
>>

Node_cond(node) ::= <<
<({<node.class.simpleName>_cond})(node)>
>>

Nodes_cond(nodes) ::= <<
<nodes: Node_cond()>
>>

WhileNode_cond(nodes) ::= <<
<WhileNode(nodes)>
>>

IfNode_cond(nodes) ::= <<
<IfNode(nodes)>
>>

BlockNode_cond(blockNode) ::= <<
	<Instructions(blockNode.instructions)> 
>>

// if node
BlockNode(blockNode) ::= <<
	br label %b<label(blockNode)>

b<label(blockNode)>:
	<Instructions(blockNode.instructions)>
	
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////
printProcedure(proc) ::= <<
<procedure(procedure = proc)>
>>

procedure(procedure, inputPattern = false, outputPattern = false) ::= <<
<if(!procedure.native)>
define <procedure.returnType> @<procedure>(<procedure.parameters.list: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
<if(procedure.locals.list)>
	<procedure.locals.list: variableDeclaration()>
<endif>
<if(inputPattern)>
	<inputPattern.keys: { port | <fifoVar(port=port, var=inputPattern.(port))>}>
<endif>
<if(outputPattern)>
	<outputPattern.keys: { port | <fifoVar(port=port, var=outputPattern.(port))>}>
<endif>
<Nodes(trunc(procedure.nodes))>
<Node(last(procedure.nodes))>
}
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Parameters
///////////////////////////////////////////////////////////////////////////////

actorParameter(parameter) ::= <<
@<parameter> = global <parameter.type> undef

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printAction(action) ::= <<
<procedure(procedure = action.scheduler, inputPattern = action.inputPattern.peekedMap)>
<procedure(procedure = action.body, inputPattern = action.inputPattern.variableMap, outputPattern = action.outputPattern.variableMap)>
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "<actor.name>"
declare i32 @printf(i8* noalias , ...) nounwind 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
<actor.inputs.list: fifo()>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
<actor.outputs.list: fifo()>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<actor.parameters.list: actorParameter()>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<actor.stateVars.list: stateVar()>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<actor.procs.list: {proc | <procedure(procedure = proc)>}>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<actor.actions: printAction()>

; Initializes
<if(actor.initializes)>
<actor.initializes: printAction()>
<endif>

<decl_MD(actor)>

>>
