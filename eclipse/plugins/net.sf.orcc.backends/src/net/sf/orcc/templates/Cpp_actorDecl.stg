///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

variableDeclaration(variable) ::= <<
<if (variable.type.dimensionsExpr)
><variable.type> (*<variable.indexedName>)<listSize(rest(variable.type.dimensionsExpr)) ><
else
><variable.type> <variable.indexedName><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Non-const state variables
///////////////////////////////////////////////////////////////////////////////
nonConstStateVar(variable) ::= <<
<if(variable.assignable)>
<variableDeclaration(variable)>;<\n>
<endif>
>>




///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

<if(!procedure.native)
><procedure.returnType> <procedure.name>(<procedure.parameters: variableDeclaration(); wrap, anchor, separator=", ">);<
endif>

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
<procedure(action.body)><procedure(action.scheduler)>
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

scheduler(actions) ::= <<
int schedule();
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

stateScheduler(transition) ::= <<
bool <transition.sourceState>_state_scheduler();

>>

getState(state) ::= <<state_<state> >>

schedulerFSM(actions, fsm) ::= <<
enum states 
{
	state_<first(fsm.states)> = 0,
	<rest(fsm.states) : getState(); separator=",\n">
};

int _FSM_state;


<if(actions)>
bool outside_FSM_scheduler();

<endif>
<fsm.transitions: stateScheduler(); separator="\n">
int schedule();

>>

constructor(parameters) ::= <<
<if (actor.parameters.list)>
<actor.simpleName>(const char*, <parameters: {input | <input.type>}; separator=", ">, AKA_PROFILING_MODE );
<else>
<actor.simpleName>(const char*, AKA_PROFILING_MODE);
<endif>
>>

parameters(parameters) ::= <<
<parameters: {parameter | <parameter.type> <parameter.indexedName>;}; separator="\n">

>>

startNamespace(namespace) ::= <<
namespace <namespace> 
{

>>

endNamespace(namespace) ::= <<
}

>>
///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<

#ifndef __ACTOR_<actor.packageAsList; separator="_">_<actor.simpleName>_H__
#define __ACTOR_<actor.packageAsList; separator="_">_<actor.simpleName>_H__

#include \<fstream\>
#include "actoraka.h"

<actor.packageAsList: startNamespace()>
	////////////////////////////////////////////////////////////////////////////////
	// Input FIFOs
	enum
	{
		<actor.inputs.list: {input | <actor.simpleName>_<input.name>,}; separator="\n">
		<actor.simpleName>_nbInputs
	};
	////////////////////////////////////////////////////////////////////////////////
	// Output FIFOs
	enum
	{
		<actor.outputs.list: {input | <actor.simpleName>_<input.name>,}; separator="\n">
		<actor.simpleName>_nbOutputs
	};


	class <actor.simpleName> : public ActorAKA 
	{

	public:
		<constructor(actor.parameters.list)>
		~<actor.simpleName>();
	
		void initializeActor();
	////////////////////////////////////////////////////////////////////////////////
	// Functions/procedures
		<actor.procs.list: procedure()>
	////////////////////////////////////////////////////////////////////////////////
	// Actions
		<actor.actions: action()>

	public:
		<if(actor.initializes)>
	////////////////////////////////////////////////////////////////////////////////
	// Initializes
		<actor.initializes: action()>
		void initialize();
	
	<endif>
	////////////////////////////////////////////////////////////////////////////////
	// Action scheduler
<if(actor.actionScheduler.fsm)>
	<schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)>
<else>
	<scheduler(actions=actor.actionScheduler.actions)>
<endif>

	private:
<if(actor.inputs.list)>
	const bool hasTokens(int port, int iSize) const {return  (m_avails[port] \>= iSize);};
<endif>
<if(actor.outputs.list)>
	const bool hasRooms(int port, int iSize) const {return  (m_rooms[port] \>= iSize);};
<endif>

	private:
	static const char* className;

	////////////////////////////////////////////////////////////////////////////////
	// Parameters
	<parameters(actor.parameters.list)>
	////////////////////////////////////////////////////////////////////////////////
	// Non-const state variables of the actor
	<actor.stateVars.list: nonConstStateVar()>

	};

<actor.packageAsList: endNamespace()>
#endif

>>
