import "net/sf/orcc/templates/LLVM_actor.stg"


///////////////////////////////////////////////////////////////////////////////
// Hardware FIFO instruction
///////////////////////////////////////////////////////////////////////////////

printWrite(port, source, numberOfTokens) ::= <<
tail call void asm sideeffect "STREAM_OUT_V1", "ir"(i32 %<source>) nounwind
>>

printRead(port, target, numberOfTokens) ::= <<
%<target> = tail call i32 asm sideeffect "STREAM_IN_V1", "=r,ir"(i32 0) nounwind
>>

printPeek(port, target, numberOfTokens) ::= <<
%<target> = tail call i32 asm sideeffect "STREAM_IN_PEEK_V1", "=r,ir"(i32 0) nounwind
>>

printStatus(port, dir) ::= <<
%status_<port.name> = tail call i32 asm sideeffect "STREAM_<dir>_STATUS_V1", "=r,ir"(i32 0) nounwind
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler
///////////////////////////////////////////////////////////////////////////////

printPortsStatus(dir, ports) ::= <<
<ports: { port | <printStatus(port, dir)> }; separator="\n">
>>

checkPort(action, dir, port, numTokens, index, index0, state) ::= <<
%available_<dir>_<action.name>_<state.name>_<port.name> = icmp sge i32 %status_<port.name> <numTokens>
%has_valid_<dir>s_<action.name>_<state.name>_<index> = and i1 %has_valid_<dir>s_<action.name>_<state.name>_<index0> %available_<dir>_<action.name>_<state.name>_<port.name>
>>

checkPattern(action, dir, pattern, state=false) ::= <<
%has_valid_<dir>s_<action.name>_<state.name>_0 = true
<pattern.ports: { port | <checkPort(action, dir, port, pattern.numTokensMap.(port), i, i0, state)> }; separator="\n">
>>

actionTest(action) ::= <<
	; Action <action.name>
	;; Input pattern
	<checkPattern(action, "input", action.inputPattern)>
	%is_schedulable_<action.name> = call i1 @isSchedulable_<action.name> ()
	%is_fireable_<action.name> = and i1 %is_schedulable_<action.name> %has_valid_inputs_<action.name>_<length(action.inputPattern.ports)>
	
br i1 %is_fireable_<action.name>, label %bb<action.name>_check_outputs, label %bb_<action.name>_unschedulable

bb<action.name>_check_outputs:
	;; Output pattern
	<checkPattern(action, "output", action.outputPattern)>
	
br i1 %has_valid_outputs_<action.name>_<length(action.outputPattern.ports)>, label %bb_<action.name>_fire, label %bb_<action.name>_unschedulable
	
bb_<action.name>_fire:
	call void @isSchedulable_<action.name> ()
	br label %bb1

bb_<action.name>_unfireable:
>>

printActions(actions) ::= <<
	; ------- Actions outside the FSM --------
<actions: actionTest(); separator="\n">
	; ---- End of actions outside the FSM ----
>>

schedulerWithoutFSM(actions) ::= <<
<printActions(actions)>
>>

actionTestState(sourceState, transition) ::= <<
	; Action <transition.action.name>
	;; Input pattern
	<checkPattern(transition.action, "input", transition.action.inputPattern, transition.state)>
	%is_schedulable_<transition.action.name> = call i1 @isSchedulable_<transition.action.name> ()
	%is_fireable_<transition.action.name> = and i1 %is_schedulable_<transition.action.name> %has_valid_inputs_<transition.action.name>_<length(transition.action.inputPattern.ports)>
	
br i1 %is_fireable_<transition.action.name>, label %bbXXX, label %bbZZZ

bbXXX:
	;; Output pattern
	<checkPattern(transition.action, "output", transition.action.outputPattern, transition.state)>
	
br i1 %has_valid_outputs_<transition.action.name>_<length(transition.action.outputPattern.ports)>, label %bbYYY, label %bbZZZ
	
bbYYY:
	call void @isSchedulable_<transition.action.name> ()
	store @_FSM_state, i32* <instance.actor.templateData.stateToLabelMap.(transition.state)>
	br label %bb1
	
bbZZZ:
>>

schedulingStates(sourceState, transitionsList) ::= <<
<transitionsList: { transition | <actionTestState(sourceState, transition)> }; separator="\n">
>>

printTransition(transitions) ::= <<
bb_s_<transitions.sourceState.name> :
<schedulingStates(transitions.sourceState, transitions.list)>
>>

printFsmState(state) ::= <<
i32 <instance.actor.templateData.stateToLabelMap.(state)>, label %bb_s_<state.name>
>>

printFsmSwitch(fsm) ::= <<
%local_FSM_state = load i32* @_FSM_state
switch i32 %local_FSM_state, label %default
					<fsm.states: printFsmState(); separator="\n">
>>

schedulerWithFSM(actions, fsm) ::= <<
<if(actions)>
<printActions(actions)>
<endif>


	<printFsmSwitch(fsm)>

<fsm.transitions: printTransition(); separator="\n">
>>


///////////////////////////////////////////////////////////////////////////////
// Instance
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Source file is "<actor.file>"

declare i32 @printf(i8* noalias , ...) nounwind 

<if(actor.parameters)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<actor.parameters: actorParameter(); separator="\n">
<endif>

<if(actor.stateVars)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<actor.stateVars: stateVar(); separator="\n">
<endif>

<if(actor.procs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<actor.procs: {proc | <procedure(procedure = proc)>}>
<endif>

<if(actor.initializes)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initializes
<actor.initializes: printAction(); separator="\n\n">
<endif>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<actor.actions: printAction(); separator="\n\n">

>>

instance(instance, options) ::= <<
<actor(instance.actor, options)>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Action-scheduler
<if(instance.actor.fsm)>
@_FSM_state = global i32 <instance.actor.templateData.stateToLabelMap.(instance.actor.fsm.initialState)>
<endif>

define void @<instance.id>_scheduler() nounwind {
entry:

	br label %bb1
bb1:
	<printPortsStatus("input", instance.actor.inputs)>
	<printPortsStatus("output", instance.actor.outputs)>
<if(instance.actor.fsm)
><schedulerWithFSM(instance.actor.actionsOutsideFsm, instance.actor.fsm)><
else
><schedulerWithoutFSM(instance.actor.actionsOutsideFsm)><
endif>

	br label %bb1
}
>>