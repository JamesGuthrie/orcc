import "net/sf/orcc/templates/LLVM_actor.stg"


///////////////////////////////////////////////////////////////////////////////
// Hardware FIFO instruction
///////////////////////////////////////////////////////////////////////////////

printWrite(port, source) ::= <<
tail call void asm sideeffect "STREAM_OUT_V<instance.actor.templateData.portToIndexMap.(port)>"", "ir"(i32 %<source>) nounwind
>>

printRead(port, target) ::= <<
%<target> = tail call i32 asm sideeffect "STREAM_IN_V<instance.actor.templateData.portToIndexMap.(port)>"", "=r,ir"(i32 0) nounwind
>>

printPeek(port, target) ::= <<
%<target> = tail call i32 asm sideeffect "STREAM_IN_PEEK_V<instance.actor.templateData.portToIndexMap.(port)>"", "=r,ir"(i32 0) nounwind
>>

printStatus(port, dir) ::= <<
%status_<port.name> = tail call i32 asm sideeffect "STREAM_<dir>_STATUS_V<instance.actor.templateData.portToIndexMap.(port)>", "=r,ir"(i32 0) nounwind
>>

///////////////////////////////////////////////////////////////////////////////
// FIFO functions
///////////////////////////////////////////////////////////////////////////////

printInputFifoFunction(port) ::= <<
define noalias <port.type>* @read(i32 %numTokens) nounwind {
entry:
	%<port.name>_ptr = tail call noalias <port.type>* @malloc(i32 %numTokens) nounwind
	%cond = icmp sgt i32 %numTokens, 0
  
	br i1 %cond, label %bb0, label %bb2

bb0:

	br label %bb1
	
bb1:
	%indvar = phi i32 [ 0, %bb0 ], [ %indvar.next, %bb1 ]
	%data = tail call i32 asm sideeffect "STREAM_IN_V<instance.actor.templateData.portToIndexMap.(port)>"", "=r,ir"(i32 0) nounwind
	%scevgep = getelementptr <port.type>* %<port.name>_ptr, i32 %indvar
	store <port.type> %data, <port.type>* %scevgep6, align 4
	%indvar.next = add i32 %indvar, 1
	%exitcond = icmp eq i32 %indvar.next, %numTokens

	br i1 %exitcond, label %bb2, label %bb

bb2:
	ret <port.type>* %<port.name>_ptr
}
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler
///////////////////////////////////////////////////////////////////////////////

printPortsStatus(dir, ports) ::= <<
<ports: { port | <printStatus(port, dir)> }; separator="\n">
>>

checkPorts(action, dir, port, restPorts, portToIndexMap, state, lastPort=false) ::= <<
<if(!lastPort)
>%has_valid_<dir>s_<state.name>_<action.name>_<portToIndexMap.(port)> = icmp sge i32 %status_<port.name>, <pattern.numTokensMap.(port)><
else
>%available_<dir>_<state.name>_<action.name>_<port.name> = icmp sge i32 %status_<port.name>, <pattern.numTokensMap.(port)>
%has_valid_<dir>s_<state.name>_<action.name>_<portToIndexMap.(port)> = and i1 %has_valid_<dir>s_<state.name>_<action.name>_<portToIndexMap.(lastPort)>, %available_<dir>_<state.name>_<action.name>_<port.name><
endif><
if(restPorts)>
<checkPorts(action, dir, first(restPorts), rest(restPorts), portToIndexMap, state, port)><
endif>
>>

checkPattern(action, dir, pattern, state=false) ::= <<
<checkPorts(action, dir, first(pattern.ports), rest(pattern.ports), instance.actor.templateData.portToIndexByPatternMap.(pattern), state)>
>>

actionTest(action) ::= <<
	; ACTION <action.name>
<if(!action.inputPattern.empty)
>	;; Input pattern
	<checkPattern(action, "input", action.inputPattern)>
	%is_schedulable_<action.name> = call i1 @isSchedulable_<action.name> ()
	%is_fireable_<action.name> = and i1 %is_schedulable_<action.name>, %has_valid_inputs__<action.name>_<length(action.inputPattern.ports)>
	
	br i1 %is_fireable_<action.name>, label %bb_<action.name>_check_outputs, label %bb_<action.name>_unschedulable<
else
>	;; Empty input pattern
	
	br %bb_<action.name>_check_outputs<
endif>


bb_<action.name>_check_outputs:
<if(!action.outputPattern.empty)
>	;; Output pattern
	<checkPattern(action, "output", action.outputPattern)>
	
	br i1 %has_valid_outputs_<action.name>_<length(action.outputPattern.ports)>, label %bb_<action.name>_fire, label %bb_<action.name>_unschedulable<
else
>	;; Empty output pattern
	
	br %bb_<action.name>_fire<
endif>


bb_<action.name>_fire:
	call void @<action.name> ()

	br label %bb_scheduler_start

bb_<action.name>_unschedulable:
>>

printActions(actions) ::= <<
	; ------- Actions outside the FSM --------
<actions: actionTest(); separator="\n">
	; ---- End of actions outside the FSM ----
>>

schedulerWithoutFSM(actions) ::= <<
<printActions(actions)>

	br label %bb_scheduler_start
>>

actionTestState(sourceState, transition, restTransitionsList) ::= <<
	; ACTION <transition.action.name>
<if(!transition.action.inputPattern.empty)
>	;; Input pattern
	<checkPattern(transition.action, "input", transition.action.inputPattern, sourceState)>
	%is_schedulable_<sourceState.name>_<transition.action.name> = call i1 @isSchedulable_<transition.action.name> ()
	%is_fireable_<sourceState.name>_<transition.action.name> = and i1 %is_schedulable_<sourceState.name>_<transition.action.name>, %has_valid_inputs_<sourceState.name>_<transition.action.name>_<length(transition.action.inputPattern.ports)>
	
	br i1 %is_fireable_<sourceState.name>_<transition.action.name>, label %bb_<sourceState.name>_<transition.action.name>_check_outputs, label %bb_<sourceState.name>_<transition.action.name>_unschedulable<
else
>	;; Empty input pattern
	
	br %bb_<sourceState.name>_<transition.action.name>_check_outputs<
endif>


bb_<sourceState.name>_<transition.action.name>_check_outputs:
<if(!transition.action.outputPattern.empty)
>	;; Output pattern
	<checkPattern(transition.action, "output", transition.action.outputPattern, sourceState)>
	
	br i1 %has_valid_outputs_<sourceState.name>_<transition.action.name>_<length(transition.action.outputPattern.ports)>, label %bb_<sourceState.name>_<transition.action.name>_fire, label %bb_<sourceState.name>_<transition.action.name>_unschedulable<
else
>	;; Empty output pattern
	
	br %bb_<sourceState.name>_<transition.action.name>_fire<
endif>


bb_<sourceState.name>_<transition.action.name>_fire:
	call void @<transition.action.name> ()
	store i32 <instance.actor.templateData.stateToLabelMap.(transition.state)>, i32* @_FSM_state
	
	br label %bb_scheduler_start

bb_<sourceState.name>_<transition.action.name>_unschedulable:

<if(restTransitionsList)>
<actionTestState(sourceState, first(restTransitionsList), rest(restTransitionsList))><
else
>	br label %bb_scheduler_start
<endif>
>>

schedulingStates(sourceState, transitionsList) ::= <<
<actionTestState(sourceState, first(transitionsList), rest(transitionsList))>
>>

printTransition(transitions) ::= <<
; STATE <transitions.sourceState.name>
bb_s_<transitions.sourceState.name>:
<schedulingStates(transitions.sourceState, transitions.list)>
>>

printFsmState(state) ::= <<
i32 <instance.actor.templateData.stateToLabelMap.(state)>, label %bb_s_<state.name>
>>

printFsmSwitch(fsm) ::= <<
%local_FSM_state = load i32* @_FSM_state
switch i32 %local_FSM_state, label %default [
					<fsm.states: printFsmState(); separator="\n"> ]
>>

schedulerWithFSM(actions, fsm) ::= <<
<if(actions)>
<printActions(actions)>
	br label %bb_fsm_start

bb_fsm_start:
<endif>

	<printFsmSwitch(fsm)>
	
	br label %bb_scheduler_start

default:
	; TODO: print error
	br label %bb_scheduler_start

<fsm.transitions: printTransition(); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

printAction(action) ::= <<
define <action.scheduler.returnType> @<action.scheduler.name>(<action.scheduler.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
	<action.scheduler.locals: variableDeclaration()>
	<action.peekPattern.ports: { port | <fifoVar(port=port, var=action.inputPattern.portToVarMap.(port))>}; separator="\n">
<printNodes(action.scheduler.nodes)>
}

define void @<action.body.name>(<action.body.parameters: argumentDeclaration(); wrap, anchor, separator=", ">) nounwind {
entry:
	<action.body.locals: variableDeclaration()>
<printNodes(action.body.nodes)>
}
>>

///////////////////////////////////////////////////////////////////////////////
// Instance
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Source file is "<actor.file>"

declare i32 @printf(i8* noalias , ...) nounwind 

<if(actor.parameters)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Parameter values of the instance
<actor.parameters: actorParameter(); separator="\n">
<endif>

<if(actor.stateVars)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
<actor.stateVars: stateVar(); separator="\n">
<endif>

<if(actor.procs)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
<actor.procs: {proc | <procedure(procedure = proc)>}>
<endif>

<if(actor.initializes)>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Initializes
<actor.initializes: printAction(); separator="\n\n">
<endif>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
<actor.actions: printAction(); separator="\n\n">

>>

instance(instance, options) ::= <<
<actor(instance.actor, options)>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Action-scheduler
<if(instance.actor.fsm)>
@_FSM_state = global i32 <instance.actor.templateData.stateToLabelMap.(instance.actor.fsm.initialState)>
<endif>

define void @<instance.id>_scheduler() nounwind {
entry:

	br label %bb_scheduler_start
bb_scheduler_start:
	<printPortsStatus("input", instance.actor.inputs)>
	<printPortsStatus("output", instance.actor.outputs)>
<if(instance.actor.fsm)
><schedulerWithFSM(instance.actor.actionsOutsideFsm, instance.actor.fsm)><
else
><schedulerWithoutFSM(instance.actor.actionsOutsideFsm)><
endif>
}
>>