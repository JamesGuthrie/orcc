GetInstanceId(instance) ::= <<
<if (instance.broadcast)>bcast_<endif><instance.id>
>>

BroadcastWrite(n,port) ::= <<
tok_output_<n> = fifo<printMedium(port,instance)>_<instance.broadcast.type>_write(<GetInstanceId(instance)>_output_<n>, output_<n>_buf, 1);
*tok_output_<n> = *tok_input;
>>

printBroadcastWrite(OutputNum, OutputPorts) ::= <<
<if(first(OutputNum))>
<BroadcastWrite(first(OutputNum),first(OutputPorts))>
<printBroadcastWrite(rest(OutputNum),rest(OutputPorts))>
<endif>
>>

BroadcastWriteEnd(n,port) ::= <<
fifo<printMedium(port,instance)>_<instance.broadcast.type>_write_end(<GetInstanceId(instance)>_output_<n>, output_<n>_buf, 1);
>>

printBroadcastWriteEnd(OutputNum, OutputPorts) ::= <<
<if(first(OutputNum))>
<BroadcastWriteEnd(first(OutputNum),first(OutputPorts))>
<printBroadcastWriteEnd(rest(OutputNum),rest(OutputPorts))>
<endif>
>>

outputPatternPort(num, port) ::= <<
if (!fifo<printMedium(port,instance)>_<instance.broadcast.type>_has_room(<GetInstanceId(instance)>_output_<num>, 1)) {
	ports |= (1 \<\< <num>);
}
>>

outputPattern(outputsNumPort, outputsPort) ::= <<
<if(first(outputsNumPort))>
<outputPatternPort(first(outputsNumPort),first(outputsPort))>
<outputPattern(rest(outputsNumPort),rest(outputsPort))>
<endif>
>>

printOutputPattern(outputsNumPort, outputsPort) ::= <<
<if(first(outputsNumPort))>
int ports = 0;
<outputPattern(outputsNumPort, outputsPort)>
if (ports != 0) {
	si-\>num_firings = i;
	si-\>reason = full;
	si-\>ports = ports;
	return;
}
<endif>
>>

declareBroadcast(instance) ::= <<
<if (instance.broadcast)
>
void <GetInstanceId(instance)>_scheduler(struct schedinfo_s *si) {
	int i = 0;
	<instance.broadcast.type> *tok_input, input_buf[1],
	<instance.broadcast.outputList: { n | output_<n>_buf[1], *tok_output_<n>}; separator=",\n">;

	while (fifo<printMedium(instance.broadcast.input,instance)>_<instance.broadcast.type>_has_tokens(<GetInstanceId(instance)>_input, 1)) {
		<printOutputPattern(instance.broadcast.outputList,instance.broadcast.outputs.list)>

		tok_input = fifo<printMedium(instance.broadcast.input,instance)>_<instance.broadcast.type>_read(<GetInstanceId(instance)>_input, input_buf, 1);
		<printBroadcastWrite(instance.broadcast.outputList,instance.broadcast.outputs.list)>
		fifo<printMedium(instance.broadcast.input,instance)>_<instance.broadcast.type>_read_end(<GetInstanceId(instance)>_input, 1);
		<printBroadcastWriteEnd(instance.broadcast.outputList,instance.broadcast.outputs.list)>
		i++;
	}

	si-\>reason = starved;
	si-\>num_firings = i;
	si-\>ports = 0x01;
}<
endif>

>>

declareBroadcasts(instances) ::= <<
<instances: declareBroadcast()>
>>

///////////////////////////////////////////////////////////////////////////////
// Declare predecessors and successors

Neighbor(port) ::= <<
&<GetInstanceId(map.(port))>
>>

Neighbors(map, ports) ::= <<
<ports: Neighbor(); separator=", ">
>>

goDeclarePredSucc(inputs, outputs) ::= <<
<if(!inputs.empty)
>struct actor_s *<GetInstanceId(instance)>_predecessors[] = {<Neighbors(map=network.predecessorsMap.(instance), ports=inputs)>};
<endif><
if(!outputs.empty)
>struct actor_s *<GetInstanceId(instance)>_successors[] = {<Neighbors(map=network.successorsMap.(instance), ports=outputs)>};
<endif>
>>

goDeclarePredsSuccs(instance, incoming, outgoing) ::= <<
<if (instance.actor)
><goDeclarePredSucc(inputs=instance.actor.inputs.list,
                    outputs=instance.actor.outputs.list)><
elseif (instance.broadcast)
><goDeclarePredSucc(inputs=instance.broadcast.inputs.list,
                   outputs=instance.broadcast.outputs.list)><
endif>
>>

declarePredsSuccs(instances) ::= <<
<instances:
  {inst | <goDeclarePredsSuccs(instance=inst,
    incoming=network.incomingMap.(inst),
    outgoing=network.outgoingMap.(inst))>}>
>>


///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count, port, instance) ::= <<
DECLARE_FIFO<printUpperCaseMedium(port,instance)>(<type>, <if(size)><size><else>SIZE<endif>, <count>)
>>



doAllocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
<if (source.broadcast || source.actor)>
<allocateFifoType(
  sourcePort.type, edge.size, network.connectionMap.(edge), sourcePort, source)><else>
<allocateFifoType(
  targetPort.type, edge.size, network.connectionMap.(edge), targetPort, target)><endif>
>>

tryAllocateFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAllocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)><endif>
>>

allocateFifo(edge) ::= <<
<tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

allocateFifos(edges) ::= <<
<edges: allocateFifo()>
>>


///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
<if(source.actor || source.broadcast)>
struct fifo<printMedium(sourcePort,source)>_<sourcePort.type>_s *<GetInstanceId(source)>_<sourcePort.name> = &fifo_<count>;
<endif>
<if(target.actor || target.broadcast)>
struct fifo<printMedium(targetPort,target)>_<sourcePort.type>_s *<GetInstanceId(target)>_<targetPort.name> = &fifo_<count>;
<endif>
>>

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAssignFifo(
  src.instance, edge.source,
  tgt.instance, edge.target,
  network.connectionMap.(edge))><endif>
>>

assignFifo(edge) ::= <<
<tryAssignFifo(edge, network.sourceMap.(edge), network.targetMap.(edge))>
>>

assignFifos(edges) ::= <<
<edges: assignFifo()>
>>

///////////////////////////////////////////////////////////////////////////////
// clear FIFOs

clearFifoType(type, size, count, port, instance) ::= <<
fifo_<type>_clear(&fifo_<count>);
>>

doClearFifo(edge, source, sourcePort, target, targetPort) ::= <<
<if (source.broadcast || source.actor)>
<clearFifoType(
  sourcePort.type, edge.size, network.connectionMap.(edge), sourcePort, source)><else>
<clearFifoType(
  targetPort.type, edge.size, network.connectionMap.(edge), targetPort, target)><endif>
>>

tryClearFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doClearFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)><endif>
>>

clearFifo(edge) ::= <<
<tryClearFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

printClearFifosFunction(edges) ::= <<
void clear_fifos(){
	<edges: clearFifo()>
}
>>

///////////////////////////////////////////////////////////////////////////////
// Declare actors

declareActor(instance) ::= "<GetInstanceId(instance)>"
declareActors(instances) ::= <<
struct actor_s <instances: declareActor(); wrap, separator=", ">;

>>

declareActorArray(instance) ::= "&<GetInstanceId(instance)>"

declareActorsArray(instances,thread=false) ::= <<
struct actor_s *actors<if(thread)>_<thread><endif>[] = {<instances: declareActorArray(); wrap, separator=", ">};
>>

///////////////////////////////////////////////////////////////////////////////
// Define actors

NumInputs(instance) ::= <<
<if (instance.actor)
><instance.actor.inputs.length><
elseif (instance.broadcast)>1<else>0<endif>
>>

NumOutputs(instance) ::= <<
<if (instance.actor)
><instance.actor.outputs.length><
elseif (instance.broadcast)><instance.broadcast.numOutputs><else>0<endif>
>>

fillActorStruct(instance) ::= <<
<if(instance.actor || instance.broadcast)>
struct actor_s <GetInstanceId(instance)> = {"<GetInstanceId(instance)>", <GetInstanceId(instance)>_scheduler, <
NumInputs(instance)>, <NumOutputs(instance)>, <
if(instance.actor.inputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_predecessors<endif>, <
if(instance.actor.outputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_successors<endif>};
<endif>
>>

fillActorsStructs(instances) ::= <<
<instances: fillActorStruct()>
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler actors functions

actorInitialize(instance) ::= <<
<if (instance.actor && !instance.actor.initializes.empty)>
extern void <instance.id>_initialize();
<endif>
>>

declareInstancesInitializes(instances) ::= <<
<instances: actorInitialize()>
>>

actionSchedulers(instance) ::= <<
<if(instance.actor || instance.broadcast)>
extern void <instance.id>_scheduler(struct schedinfo_s *si);
<endif>
>>

declareActionsSchedulers(instances) ::= <<
<instances: actionSchedulers()>
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
<if (instance.actor && !instance.actor.initializes.empty)
><instance.id>_initialize();
<endif>
>>

printInitializes(instances) ::= <<
<instances: printInitialize()>
>>

printScheduler() ::= <<
void *scheduler(void *data) {
	struct scheduler_s *sched = (struct scheduler_s *) data;
	struct actor_s *my_actor;
	struct schedinfo_s si;
	<if(options.needDynamicMapping)>
	
	semaphore_wait(sched-\>sem_thread); 
	
	<endif>
	while (<if(options.needDynamicMapping)>sched-\>sync-\>active_sync<else>1<endif>) {
		my_actor = sched_get_next<if(options.newScheduler)>_schedulable<endif>(sched);
		<if(options.needDynamicMapping)>
		if(my_actor == NULL){
			semaphore_set(sched-\>sync-\>sem_monitor);
			semaphore_wait(sched-\>sem_thread);
	  	}
	  	else{
			si.num_firings = 0;
			my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
			printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
			<if (options.newScheduler)>
			if (si.reason == full <if(options.needPthreads)>&& si.num_firings \>0<endif>) {
				sched_add_successors(sched, my_actor, si.ports);
			} else if (si.reason == starved <if(options.needPthreads)>&& si.num_firings \>0<endif>) {
				sched_add_predecessors(sched, my_actor, si.ports);
			}
			<endif>
			if(source_is_stopped()){
				semaphore_set(sched-\>sync-\>sem_monitor);
				semaphore_wait(sched-\>sem_thread);
			}
		}
		<else>
		si.num_firings = 0;
		my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
		printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
		<if (options.newScheduler)>
		if (si.reason == full <if(options.needPthreads)>&& si.num_firings \>0<endif>) {
			sched_add_successors(sched, my_actor, si.ports);
		} else if (si.reason == starved <if(options.needPthreads)>&& si.num_firings \>0<endif>) {
			sched_add_predecessors(sched, my_actor, si.ports);
		}
		<endif>
		<endif>
	}
}
>>

printAddSchedulable(instance) ::= <<
sched_add_schedulable(<GetInstanceId(instance)>.sched, &<GetInstanceId(instance)>);
>>

printAllAddSchedulable(instances) ::= <<
<instances: printAddSchedulable(); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// main

printMedium(port, instance) ::= <<
<network.templateData.portMedium.(instance).(port).value>
>>

printUpperCaseMedium(port, instance) ::= <<
<network.templateData.upperCasePortMedium.(instance).(port).value>
>>

fifoInit(instance, port) ::= <<
<if(instance.actor)
>fifo<printMedium(port,instance)>_<port.type>_init(<instance.id>_<port>,/*To complete !*/);<
else
>fifo<printMedium(port,instance)>_<port.type>_init(bcast_<instance.id>_<port>,/*To complete !*/);<
endif>
>>

printFifoInit(instances, ports) ::= <<
<if(first(instances))
><fifoInit(first(instances), first(ports))>
<printFifoInit(rest(instances), rest(ports))
><endif>
>>

///////////////////////////////////////////////////////////////////////////////

MediumInclude(medium) ::= <<
#include "orcc_fifo<medium>.h"
>>

printMediumInclude(mediums) ::= <<
<mediums : MediumInclude(); separator="\n">
>>

// print network
network(network, options) ::= <<

// Generated from "<network.name>"

#include \<locale.h\>
#include \<stdio.h\>
#include \<stdlib.h\>
<if (options.needDynamicMapping)>
#include \<time.h\>
<endif>

#ifdef __APPLE__
#include "SDL.h"
#endif

#ifndef _WIN32
#define __USE_GNU
#endif

#include "orcc.h"
#include "orcc_fifo.h"
<printMediumInclude(network.templateData.allMediumsAllInstances)>
#include "orcc_scheduler.h"
#include "orcc_util.h"
<if (options.needPthreads || options.needDynamicMapping)>
#include "orcc_thread.h"
<endif>
<if(options.needDynamicMapping)>
#include "orcc_genetic.h"
<endif>

<if (options.needPthreads || options.needDynamicMapping)>
#define THREAD_NB <options.threadsNb>
<endif>
<if(options.needDynamicMapping)>
#define POPULATION_SIZE 20
#define GENERATION_NB 5

#define KEEP_RATIO 0.5
#define CROSSOVER_RATIO 0.6
<endif>

#define SIZE <options.("fifoSize")>
// #define PRINT_FIRINGS


////////////////////////////////////////////////////////////////////////////////
// FIFO allocation

<allocateFifos(network.connections)>

////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments

<assignFifos(network.connections)>

////////////////////////////////////////////////////////////////////////////////
<declareBroadcasts(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Action schedulers

<declareInstancesInitializes(network.instances)>
<declareActionsSchedulers(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Declaration of a struct actor for each actor

<declareActors(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Declaration of the predecessors and successors of each actor

<if(options.newScheduler)><declarePredsSuccs(network.instances)><endif>

////////////////////////////////////////////////////////////////////////////////
// Declaration of the actors array

<fillActorsStructs(network.instances)>

<if(options.needPthreads)>
<options.threads.keys: {th | <declareActorsArray(instances=options.threads.(th),thread=th)>}; separator="\n">

struct actor_s **actors[] = {<options.threads.keys: {th | actors_<th>}; separator=", ">};
<else>
<declareActorsArray(instances=network.instances)>
<endif>

<if (options.needDynamicMapping)>
extern void remove_fps_printing();
extern int source_is_stopped();

<printClearFifosFunction(network.connections)>
<endif>

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler


<printScheduler()>

////////////////////////////////////////////////////////////////////////////////
// Initializer and launcher

static void launcher() {
<if(options.needDynamicMapping || options.needPthreads)>
	int i;
	
	cpu_set_t cpuset; 
	thread_struct threads[THREAD_NB]<if(options.needDynamicMapping)>, thread_monitor<endif>;
	thread_id_struct threads_id[THREAD_NB]<if(options.needDynamicMapping)>, thread_monitor_id<endif>;
	
	struct scheduler_s schedulers[THREAD_NB];
	<if(options.needDynamicMapping)>
	struct sync_s sched_sync;
	struct genetic_s genetic_info;
	struct monitor_s monitoring;
	
	sync_init(&sched_sync);
	genetic_init(&genetic_info, POPULATION_SIZE, GENERATION_NB, KEEP_RATIO, CROSSOVER_RATIO, actors, schedulers, sizeof(actors) / sizeof(actors[0]), THREAD_NB);
	monitor_init(&monitoring, &sched_sync, &genetic_info);
	
	remove_fps_printing();
	<else>
	int actors_size[] = {<options.threads.keys: {th | sizeof(actors_<th>) / sizeof(actors_<th>[0])}; separator=", ">};
	<endif>
	
	<printInitializes(network.instances)>
	
	for(i=0; i \< THREAD_NB; i++){
		sched_init(&schedulers[i], <if(options.needDynamicMapping)>0<else>actors_size[i]<endif>, <if(options.needDynamicMapping)>NULL<else>actors[i]<endif>, <if(options.needDynamicMapping)>&sched_sync<else>NULL<endif>);
	}
	
	<if(options.newScheduler && !options.needDynamicMapping)><printAllAddSchedulable(network.templateData.sourceInstances)><endif>
	
	clear_cpu_set(cpuset);
	
	for(i=0; i \< THREAD_NB; i++){
		thread_create(threads[i], scheduler, schedulers[i], threads_id[i]);
		set_thread_affinity(cpuset, i, threads[i]);
	}
	<if(options.needDynamicMapping)>
	thread_create(thread_monitor, monitor, monitoring, thread_monitor_id);
	<endif>
	
	for(i=0; i \< THREAD_NB; i++){
		thread_join(threads[i]);
	}
	<if(options.needDynamicMapping)>
	thread_join(thread_monitor);
	<endif>
<else>
	cpu_set_t cpuset; 

	struct scheduler_s sched;
	
	clear_cpu_set(cpuset);
	set_this_process_affinity(cpuset, 0);
	
	<printInitializes(network.instances)>

	sched_init(&sched, sizeof(actors) / sizeof(actors[0]), actors, NULL);
	
	<if(options.newScheduler)><printAllAddSchedulable(network.templateData.sourceInstances)><endif>
		
	(*scheduler)((void*) &sched);
<endif>
}

////////////////////////////////////////////////////////////////////////////////
// Main

int main(int argc, char *argv[]) {
  init_orcc(argc, argv);

  <if(network.templateData.listMediumInstances)
  ><printFifoInit(network.templateData.listMediumInstances, network.templateData.listMediumPorts)
  ><endif>

  launcher();

  printf("End of simulation!<if(!options.needDynamicMapping)> Press a key to continue<endif>\n");
  <if(!options.needDynamicMapping)>wait_for_key();<endif>

  return 0;
}

>>




