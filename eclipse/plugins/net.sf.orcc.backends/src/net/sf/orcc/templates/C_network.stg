GetInstanceId(instance) ::= <<
<if (instance.broadcast)>bcast_<endif><instance.id>
>>

BroadcastWrite(n) ::= <<
tok_output_<n> = fifo_<instance.broadcast.type>_write(<GetInstanceId(instance)>_output_<n>, output_<n>_buf, 1);
*tok_output_<n> = *tok_input;
>>

BroadcastWriteEnd(n) ::= <<
fifo_<instance.broadcast.type>_write_end(<GetInstanceId(instance)>_output_<n>, output_<n>_buf, 1);
>>

outputPatternPort(num) ::= <<
if (!fifo_<instance.broadcast.type>_has_room(<GetInstanceId(instance)>_output_<num>, 1)) {
	ports |= (1 \<\< <num>);
}
>>

outputPattern(outputs) ::= <<
int ports = 0;
<outputs: outputPatternPort(); separator="\n">
if (ports != 0) {
>>

declareBroadcast(instance) ::= <<
<if (instance.broadcast)
>
void <GetInstanceId(instance)>_scheduler(struct schedinfo_s *si) {
	int i = 0;
	<instance.broadcast.type> *tok_input, input_buf[1],
	<instance.broadcast.outputList: { n | output_<n>_buf[1], *tok_output_<n>}; separator=",\n">;

	while (fifo_<instance.broadcast.type>_has_tokens(<GetInstanceId(instance)>_input, 1)) {
		<outputPattern(instance.broadcast.outputList)>
			si-\>num_firings = i;
			si-\>reason = full;
			si-\>ports = ports;
			return;
		}

		tok_input = fifo_<instance.broadcast.type>_read(<GetInstanceId(instance)>_input, input_buf, 1);
		<instance.broadcast.outputList: BroadcastWrite(); separator="\n">
		fifo_<instance.broadcast.type>_read_end(<GetInstanceId(instance)>_input, 1);
		<instance.broadcast.outputList: BroadcastWriteEnd(); separator="\n">
		i++;
	}

	si-\>reason = starved;
	si-\>num_firings = i;
	si-\>ports = 0x01;
}<
endif>

>>

declareBroadcasts(instances) ::= <<
<instances: declareBroadcast()>
>>

///////////////////////////////////////////////////////////////////////////////
// Declare predecessors and successors

Neighbor(port) ::= <<
&<GetInstanceId(map.(port))>
>>

Neighbors(map, ports) ::= <<
<ports: Neighbor(); separator=", ">
>>

goDeclarePredSucc(inputs, outputs) ::= <<
<if(!inputs.empty)
>struct actor_s *<GetInstanceId(instance)>_predecessors[] = {<Neighbors(map=network.predecessorsMap.(instance), ports=inputs)>};
<endif><
if(!outputs.empty)
>struct actor_s *<GetInstanceId(instance)>_successors[] = {<Neighbors(map=network.successorsMap.(instance), ports=outputs)>};
<endif>
>>

goDeclarePredsSuccs(instance, incoming, outgoing) ::= <<
<if (instance.actor)
><goDeclarePredSucc(inputs=instance.actor.inputs.list,
                    outputs=instance.actor.outputs.list)><
elseif (instance.broadcast)
><goDeclarePredSucc(inputs=instance.broadcast.inputs.list,
                   outputs=instance.broadcast.outputs.list)><
endif>
>>

declarePredsSuccs(instances) ::= <<
<instances:
  {inst | <goDeclarePredsSuccs(instance=inst,
    incoming=network.incomingMap.(inst),
    outgoing=network.outgoingMap.(inst))>}>
>>


///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count) ::= <<
DECLARE_FIFO(<type>, <if(size)><size><else>SIZE<endif>, <count>)
>>

doAllocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
<if (source.broadcast)>
<allocateFifoType(
  type=targetPort.type, size=edge.size, count=network.connectionMap.(edge))><else>
<allocateFifoType(
  type=sourcePort.type, size=edge.size, count=network.connectionMap.(edge))><endif>
>>

tryAllocateFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAllocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)><endif>
>>

allocateFifo(edge) ::= <<
<tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

allocateFifos(edges) ::= <<
<edges: allocateFifo()>
>>


///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(source, sourcePort, target, targetPort, count) ::= <<
struct fifo_<sourcePort.type>_s *<GetInstanceId(source)>_<sourcePort.name> = &fifo_<count>;
struct fifo_<sourcePort.type>_s *<GetInstanceId(target)>_<targetPort.name> = &fifo_<count>;
>>

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAssignFifo(
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target,
  count=network.connectionMap.(edge))><endif>
>>

assignFifo(edge) ::= <<
<tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

assignFifos(edges) ::= <<
<edges: assignFifo()>
>>

///////////////////////////////////////////////////////////////////////////////
// Declare actors

declareActor(instance) ::= "<GetInstanceId(instance)>"
declareActors(instances) ::= <<
struct actor_s <instances: declareActor(); wrap, separator=", ">;

>>

declareActorArray(instance) ::= "&<GetInstanceId(instance)>"

declareActorsArray(instances,thread=false) ::= <<
struct actor_s *actors<if(thread)>_<thread><endif>[] = {<instances: declareActorArray(); wrap, separator=", ">};
>>

///////////////////////////////////////////////////////////////////////////////
// Define actors

NumInputs(instance) ::= <<
<if (instance.actor)
><instance.actor.inputs.length><
elseif (instance.broadcast)>1<else>0<endif>
>>

NumOutputs(instance) ::= <<
<if (instance.actor)
><instance.actor.outputs.length><
elseif (instance.broadcast)><instance.broadcast.numOutputs><else>0<endif>
>>

fillActorStruct(instance) ::= <<

struct actor_s <GetInstanceId(instance)> = {"<GetInstanceId(instance)>", <GetInstanceId(instance)>_scheduler, <
NumInputs(instance)>, <NumOutputs(instance)>, <
if(instance.actor.inputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_predecessors<endif>, <
if(instance.actor.outputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_successors<endif>};
>>

fillActorsStructs(instances) ::= <<
<instances: fillActorStruct()>
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler actors functions

actorInitialize(instance) ::= <<
<if (instance.actor && !instance.actor.initializes.empty)>
extern void <instance.id>_initialize();
<endif>
>>

declareInstancesInitializes(instances) ::= <<
<instances: actorInitialize()>
>>

declareActionsSchedulers(instances) ::= <<
<instances: {inst | extern void <inst.id>_scheduler(struct schedinfo_s *si);}; separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
<if (instance.actor && !instance.actor.initializes.empty)
><instance.id>_initialize();
<endif>
>>

printInitializes(instances) ::= <<
<instances: printInitialize()>
>>

printScheduler() ::= <<
void *scheduler(void *data) {
	struct scheduler_s *sched = (struct scheduler_s *) data;
	struct actor_s *my_actor;
	struct schedinfo_s si;
	<if(options.needDynamicMapping)>
	
	clock_t start, end;
	semaphoreWait(sched-\>sem_thread); 
	start = clock ();
	
	<endif>
	while (1) {
		my_actor = sched_get_next<if(options.newScheduler)>_schedulable<endif>(sched);
		<if(options.needDynamicMapping)>
		if(my_actor == NULL){
			semaphoreSet(sched-\>sync-\>sem_monitor);
			semaphoreWait(sched-\>sem_thread);
			start = clock ();
	  	}
	  	else{
			si.num_firings = 0;
			my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
			printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
			if(sched-\>sync-\>active_sync){
				end = clock ();
				if((((end - start) / (double)CLOCKS_PER_SEC) \>= SYNC_DELAY)){
					semaphoreSet(sched-\>sync-\>sem_monitor);
					semaphoreWait(sched-\>sem_thread);
					start = clock ();
				}
			}
		}
		<else>
		si.num_firings = 0;
		my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
		printf("%5i\t%s\t%s\n", si.num_firings, si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
		<if (options.newScheduler)>
		if (si.reason == full <if(options.needPthreads)>&& si.num_firings \>0<endif>) {
			sched_add_successors(sched, my_actor, si.ports);
		} else if (si.reason == starved <if(options.needPthreads)>&& si.num_firings \>0<endif>) {
			sched_add_predecessors(sched, my_actor, si.ports);
		}
		<endif>
		<endif>
	}
}
>>

///////////////////////////////////////////////////////////////////////////////
// print network
network(debugFifos, fifoSize, network, options) ::= <<
// Generated from "<network.name>"

#include \<locale.h\>
#include \<stdio.h\>
#include \<stdlib.h\>
<if (options.needDynamicMapping)>
#include \<time.h\>
<endif>

#ifdef __APPLE__
#include "SDL.h"
#endif

<if (options.needDynamicMapping || options.needPthreads)>
#ifndef _WIN32
#define __USE_GNU
#endif
<endif>

#include "orcc.h"
#include "orcc_fifo.h"
#include "orcc_scheduler.h"
#include "orcc_util.h"
<if (options.needPthreads || options.needDynamicMapping)>
#include "orcc_thread.h"
<endif>
<if(options.needDynamicMapping)>
#include "orcc_genetic.h"
<endif>

<if (options.needPthreads || options.needDynamicMapping)>
#define THREAD_NB <options.threadsNb>
<endif>
<if(options.needDynamicMapping)>
#define SYNC_DELAY 3

#define POPULATION_SIZE 20
#define GENERATION_NB 5

#define KEEP_RATIO 0.5
#define CROSSOVER_RATIO 0.6
<endif>

#define SIZE <fifoSize>
// #define PRINT_FIRINGS


////////////////////////////////////////////////////////////////////////////////
// FIFO allocation

<allocateFifos(network.connections)>

////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments

<assignFifos(network.connections)>

////////////////////////////////////////////////////////////////////////////////
<declareBroadcasts(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Action schedulers

<declareInstancesInitializes(network.instances)>
<declareActionsSchedulers(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Declaration of a struct actor for each actor

<declareActors(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Declaration of the predecessors and successors of each actor

<if(options.newScheduler)><declarePredsSuccs(network.instances)><endif>

////////////////////////////////////////////////////////////////////////////////
// Declaration of the actors array

<fillActorsStructs(network.instances)>

<if(options.needPthreads)>
<options.threads.keys: {th | <declareActorsArray(instances=options.threads.(th),thread=th)>}; separator="\n">

struct actor_s **actors[] = {<options.threads.keys: {th | actors_<th>}; separator=", ">};
<else>
<declareActorsArray(instances=network.instances)>
<endif>

<if (options.needDynamicMapping)>
extern void remove_fps_printing();
<endif>

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

<printScheduler()>

////////////////////////////////////////////////////////////////////////////////
// Initializer and launcher

static void launcher() {
<if(options.needDynamicMapping || options.needPthreads)>
	int i;
	
	cpu_set_t cpuset;
	thread_struct threads[THREAD_NB]<if(options.needDynamicMapping)>, thread_monitor<endif>;
	thread_id_struct threads_id[THREAD_NB]<if(options.needDynamicMapping)>, thread_monitor_id<endif>;
	
	struct scheduler_s schedulers[THREAD_NB];
	<if(options.needDynamicMapping)>
	struct sync_s sched_sync;
	struct genetic_s genetic_info;
	struct monitor_s monitoring;
	
	sync_init(&sched_sync);
	genetic_init(&genetic_info, POPULATION_SIZE, GENERATION_NB, KEEP_RATIO, CROSSOVER_RATIO, actors, schedulers, sizeof(actors) / sizeof(actors[0]), THREAD_NB);
	monitor_init(&monitoring, &sched_sync, &genetic_info);
	
	remove_fps_printing();
	<else>
	int actors_size[] = {<options.threads.keys: {th | sizeof(actors_<th>) / sizeof(actors_<th>[0])}; separator=", ">};
	<endif>
	
	<printInitializes(network.instances)>
	
	for(i=0; i \< THREAD_NB; i++){
		sched_init(&schedulers[i], <if(options.needDynamicMapping)>0<else>actors_size[i]<endif>, <if(options.needDynamicMapping)>NULL<else>actors[i]<endif>, <if(options.needDynamicMapping)>&sched_sync<else>NULL<endif>);
	}
	
	<if(options.newScheduler)>sched_add_schedulable(source.sched, &source);<endif>
	
	for(i=0; i \< THREAD_NB; i++){
		threadCreate(threads[i], scheduler, schedulers[i], threads_id[i]);
	}
	<if(options.needDynamicMapping)>
	threadCreate(thread_monitor, monitor, monitoring, thread_monitor_id);
	<endif>
	
	clear_cpu_set(cpuset);
	for(i=0; i \< THREAD_NB; i++){
		set_affinity(cpuset, i, threads[i]);
	}
	
	for(i=0; i \< THREAD_NB; i++){
		threadJoin(threads[i]);
	}
	<if(options.needDynamicMapping)>
	threadJoin(thread_monitor);
	<endif>
<else>
	struct scheduler_s sched;
	
	<printInitializes(network.instances)>

	sched_init(&sched, sizeof(actors) / sizeof(actors[0]), actors, NULL);
	
	<if(options.newScheduler)>sched_add_schedulable(&sched, &source);<endif>
	(*scheduler)((void*) &sched);
<endif>
}

////////////////////////////////////////////////////////////////////////////////
// Main

int main(int argc, char *argv[]) {
  init_orcc(argc, argv);
  
  launcher();

  printf("End of simulation! Press a key to continue\n");
  wait_for_key();

  return 0;
}

>>




