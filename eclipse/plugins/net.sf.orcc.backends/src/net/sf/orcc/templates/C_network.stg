GetInstanceId(instance) ::= <<
<if (instance.broadcast)>bcast_<endif><instance.id>
>>

BroadcastWrite(n,port) ::= <<
fifo<printMedium(port,instance)>_<instance.broadcast.type>_write_1(<GetInstanceId(instance)>_output_<n>, tok_input);
>>

printBroadcastWrite(OutputNum, OutputPorts) ::= <<
<if(first(OutputNum))>
<BroadcastWrite(first(OutputNum),first(OutputPorts))>
<printBroadcastWrite(rest(OutputNum),rest(OutputPorts))>
<endif>
>>

outputPatternPort(num, port) ::= <<
if (!fifo<printMedium(port,instance)>_<instance.broadcast.type>_has_room(<GetInstanceId(instance)>_output_<num>, 1, 1)) {
	ports |= (1 \<\< <num>);
}
>>

outputPattern(outputsNumPort, outputsPort) ::= <<
<if(first(outputsNumPort))>
<outputPatternPort(first(outputsNumPort),first(outputsPort))>
<outputPattern(rest(outputsNumPort),rest(outputsPort))>
<endif>
>>

printOutputPattern(outputsNumPort, outputsPort) ::= <<
<if(first(outputsNumPort))>
int ports = 0;
<outputPattern(outputsNumPort, outputsPort)>
if (ports != 0) {
	si-\>num_firings = i;
	si-\>reason = full;
	si-\>ports = ports;
	return;
}
<endif>
>>

declareBroadcast(instance) ::= <<
<if (instance.broadcast)
>
void <GetInstanceId(instance)>_scheduler(struct schedinfo_s *si) {
	int i = 0;
	<instance.broadcast.type> tok_input;

	while (fifo<printMedium(instance.broadcast.input,instance)>_<instance.broadcast.type>_has_tokens(<GetInstanceId(instance)>_input, 0, 1)) {
		<printOutputPattern(instance.broadcast.outputList,instance.broadcast.outputs.list)>

		tok_input = fifo<printMedium(instance.broadcast.input,instance)>_<instance.broadcast.type>_read_1(<GetInstanceId(instance)>_input, 0);
		<printBroadcastWrite(instance.broadcast.outputList,instance.broadcast.outputs.list)>
		i++;
	}

	si-\>reason = starved;
	si-\>num_firings = i;
	si-\>ports = 0x01;
}<
endif>

>>

declareBroadcasts(instances) ::= <<
<instances: declareBroadcast()>
>>

///////////////////////////////////////////////////////////////////////////////
// Declare predecessors and successors

neighbour(instance) ::= <<
<if(instance.actor || instance.broadcast)
  >&<GetInstanceId(instance)
><else
  >NULL<
endif>
>>

predecessors(map, ports) ::= <<
<ports: {port | <neighbour(map.(port))>}; separator=", ">
>>

successors(instances) ::= <<
<instances: neighbour(); separator=", ">
>>

goDeclareNumSuccessors(map,outputs) ::= <<
<outputs : {port | <length(map.(port))>}; separator=", ">
>>

goDeclareSuccPerPort(port) ::= <<
struct actor_s *<GetInstanceId(instance)>_<port>_successors[] = {<successors(map.(port))>};
>>

goDeclareSuccs(map,outputs) ::= <<
<outputs : goDeclareSuccPerPort(); separator="\n">
int <GetInstanceId(instance)>_num_successors[] = {<goDeclareNumSuccessors(map,outputs)>};
>>

goDeclarePredSucc(inputs, outputs) ::= <<
<if(!inputs.empty)
>struct actor_s *<GetInstanceId(instance)>_predecessors[] = {<predecessors(map=network.predecessorsMap.(instance), ports=inputs)>};
<endif><
if(!outputs.empty)
><goDeclareSuccs(network.successorsMap.(instance), outputs)>
struct actor_s **<GetInstanceId(instance)>_successors[] = {<outputs: {port | <GetInstanceId(instance)>_<port>_successors}; separator=", ">};
<endif>
>>

goDeclarePredsSuccs(instance) ::= <<
<if (instance.actor)><goDeclarePredSucc(
					inputs=instance.actor.inputs.list,
                    outputs=instance.actor.outputs.list)>
<elseif (instance.broadcast)><goDeclarePredSucc(
					inputs=instance.broadcast.inputs.list,
					outputs=instance.broadcast.outputs.list)>
<endif>
>>

declarePredsSuccs(instances) ::= <<
<instances: {inst | <goDeclarePredsSuccs(instance=inst)>}>
>>


///////////////////////////////////////////////////////////////////////////////
// allocates FIFOs

allocateFifoType(type, size, count, port, instance) ::= <<
DECLARE_FIFO<printUpperCaseMedium(port,instance)>(<type>, <if(size)><size><else>SIZE<endif>, <count>, <readers_nb>)
>>

doAllocateFifo(edge, source, sourcePort, target, targetPort) ::= <<
<if (source.broadcast || source.actor)>
<allocateFifoType(
  sourcePort.type, edge.size, network.connectionMapWithoutBroadcast.(edge), sourcePort, source)><else>
<allocateFifoType(
  targetPort.type, edge.size, network.connectionMapWithoutBroadcast.(edge), targetPort, target)><endif>
>>

tryAllocateFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAllocateFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)><endif>
>>

allocateFifo(edge, readers_nb) ::= <<
<tryAllocateFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

allocateFifosWithMap(outgoingMap) ::= <<
<outgoingMap.keys: { instance | <outgoingMap.(instance).keys: { port | <allocateFifo(first(outgoingMap.(instance).(port)), length(outgoingMap.(instance).(port)))> }> }>
>>


///////////////////////////////////////////////////////////////////////////////
// assigns FIFOs

doAssignFifo(instance, port, count) ::= <<
<if(instance.actor || instance.broadcast)>struct fifo<printMedium(port,instance)>_<port.type>_s *<GetInstanceId(instance)>_<port.name> = &fifo_<count>;<endif>
>>

tryAssignFifoTgt(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAssignFifo(
  tgt.instance, edge.target,
  network.connectionMapWithoutBroadcast.(edge))><endif>
>>

tryAssignFifoSrc(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doAssignFifo(
  src.instance, edge.source,
  network.connectionMapWithoutBroadcast.(edge))><endif>
>>

assignFifos(edges, readers_nb) ::= <<

<tryAssignFifoSrc(first(edges), network.sourceMap.(first(edges)), network.targetMap.(first(edges)))>
<edges: {edge | <tryAssignFifoTgt(edge, network.sourceMap.(edge), network.targetMap.(edge))> }>

>>

assignFifosWithMap(outgoingMap) ::= <<
<outgoingMap.keys: { instance | <outgoingMap.(instance).keys: { port | <assignFifos(outgoingMap.(instance).(port), length(outgoingMap.(instance).(port)))> }> }>
>>

///////////////////////////////////////////////////////////////////////////////
// clear FIFOs

clearFifoType(type, size, count, port, instance) ::= <<
fifo_<type>_clear(&fifo_<count>);
>>

doClearFifo(edge, source, sourcePort, target, targetPort) ::= <<
<if (source.broadcast || source.actor)>
<clearFifoType(
  sourcePort.type, edge.size, network.connectionMapWithoutBroadcast.(edge), sourcePort, source)><else>
<clearFifoType(
  targetPort.type, edge.size, network.connectionMap.(edge), targetPort, target)><endif>
>>

tryClearFifo(edge, src, tgt) ::= <<
<if (src.instance && tgt.instance)>
<doClearFifo(
  edge=edge,
  source=src.instance, sourcePort=edge.source,
  target=tgt.instance, targetPort=edge.target)><endif>
>>

clearFifo(edge) ::= <<
<tryClearFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

clearFifosWithMap(outgoingMap) ::= <<
<outgoingMap.keys: { instance | <outgoingMap.(instance).keys: { port | <clearFifo(first(outgoingMap.(instance).(port)))> }> }>
>>

printClearFifosFunction() ::= <<
void clear_fifos(){
	<clearFifosWithMap(network.outgoingMap)>
}
>>

///////////////////////////////////////////////////////////////////////////////
// Declare actors

printActor(instance, addComma) ::= <<
<if(instance.actor || instance.broadcast)><if(addComma)>, <endif><GetInstanceId(instance)><endif>
>>


declareActor(instances, addComma = false) ::= <<
<if(rest(instances))
><printActor(first(instances),addComma)
><	if(first(instances).actor || first(instances).broadcast)
><declareActor(rest(instances),"true")
><	else
><declareActor(rest(instances),addComma)
	><endif
><else
><printActor(first(instances),addComma)
><endif>
>>

declareActors(instances) ::= <<
struct actor_s <declareActor(instances)>;

>>

printActorAddress(instance, addComma) ::= <<
<if(instance.actor || instance.broadcast)><if(addComma)>, <endif>&<GetInstanceId(instance)><endif>
>>

declareActorArray(instances, addComma = false) ::= <<
<if(rest(instances))
><printActorAddress(first(instances),addComma)
><	if(first(instances).actor || first(instances).broadcast)
><declareActorArray(rest(instances),"true")
><	else
><declareActorArray(rest(instances),addComma)
	><endif
><else
><printActorAddress(first(instances),addComma)
><endif>
>>

declareActorsArray(instances, thread=false) ::= <<
struct actor_s *actors<if(thread)>_<thread><endif>[] = {<declareActorArray(instances)>};
>>

///////////////////////////////////////////////////////////////////////////////
// Define actors

NumInputs(instance) ::= <<
<if (instance.actor)
><instance.actor.inputs.length><
elseif (instance.broadcast)>1<else>0<endif>
>>

NumOutputs(instance) ::= <<
<if (instance.actor)
><instance.actor.outputs.length><
elseif (instance.broadcast)><instance.broadcast.numOutputs><else>0<endif>
>>

fillActorStruct(instance) ::= <<
<if(instance.actor || instance.broadcast)>
struct actor_s <GetInstanceId(instance)> = {"<GetInstanceId(instance)>", <GetInstanceId(instance)>_scheduler, <
NumInputs(instance)>, <NumOutputs(instance)>, <
if(instance.actor.inputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_predecessors<endif>, <
if(instance.actor.outputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_num_successors<endif>, <
if(instance.actor.outputs.list.empty || !options.newScheduler)>NULL<else><GetInstanceId(instance)>_successors<endif>};
<endif>
>>

fillActorsStructs(instances) ::= <<
<instances: fillActorStruct()>
>>

///////////////////////////////////////////////////////////////////////////////
// declares initialize and scheduler actors functions

actorInitialize(instance) ::= <<
<if (instance.actor)>
extern void <instance.id>_initialize(<instance.actor.inputs.list: { port | unsigned int fifo_<port>_id}; separator=", ">);
<endif>
>>

declareInstancesInitializes(instances) ::= <<
<instances: actorInitialize()>
>>

actionSchedulers(instance) ::= <<
<if(instance.actor || instance.broadcast)>
extern void <instance.id>_scheduler(struct schedinfo_s *si);
<endif>
>>

declareActionsSchedulers(instances) ::= <<
<instances: actionSchedulers()>
>>

///////////////////////////////////////////////////////////////////////////////
// print timeout

printTimeout() ::= <<
static int timeout = 0;

int is_timeout(){
	return timeout;
}
>>

///////////////////////////////////////////////////////////////////////////////
// print calls to initialize() and scheduler()

printInitialize(instance) ::= <<
<if(instance.actor)>
<instance.id>_initialize(<instance.actor.inputs.list: { port | <network.incomingMap.(instance).(port).fifoId>}; separator=",">);<
endif>
>>

printInitializes(instances) ::= <<
void initialize_instances(){
	<instances: {instance|<printInitialize(instance)>}>
}
>>

printScheduler() ::= <<
void *scheduler(void *data) {
	struct scheduler_s *sched = (struct scheduler_s *) data;
	struct actor_s *my_actor;
	struct schedinfo_s si;
	<if(options.needDynamicMapping)>
	
	int i = 0;
	clock_t start, end;	
	semaphore_wait(sched-\>sem_thread);
	start = clock ();
	
	<endif>
	while (1) {
		my_actor = sched_get_next<if(options.newScheduler)>_schedulable(sched, RING_TOPOLOGY, <if(options.needDynamicMapping || options.threads)>THREAD_NB<else>1<endif>)<else>(sched)<endif>;
		if(my_actor != NULL){
			si.num_firings = 0;
			my_actor-\>sched_func(&si);
#ifdef PRINT_FIRINGS
			printf("%2i  %5i\t<if (options.newScheduler)>%5i\t<endif>%s\t%s\n", sched-\>id, si.num_firings, <if (options.newScheduler)>si.ports, <endif>si.reason == starved ? "starved" : "full", my_actor-\>name);
#endif
			<if (options.newScheduler)>
			if (si.reason == full<if(options.needDynamicMapping || options.threads)> && (si.num_firings || !sched-\>round_robin)<endif>) {
				sched_add_successors(sched, my_actor, si.ports, RING_TOPOLOGY);
			}
			<endif>
		}
		<if(options.needDynamicMapping)>
		i++;
		if(i \> STEP_BW_CHK){
			end = clock ();
			timeout = ((end - start) / (double)CLOCKS_PER_SEC) \>= TIMEOUT;
			i = 0;
		}
		if(source_is_stopped() || timeout){
			semaphore_set(sched-\>sync-\>sem_monitor);
			clean_cache(CACHE_SIZE);
			semaphore_wait(sched-\>sem_thread);
			timeout = 0;
			start = clock ();
		}
		<endif>
	}
}
>>

printAddSchedulable(instance) ::= <<
sched_add_schedulable(<GetInstanceId(instance)>.sched, &<GetInstanceId(instance)>, RING_TOPOLOGY);
>>

printAllAddSchedulable(instances) ::= <<
<instances: printAddSchedulable(); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// main

printMedium(port, instance) ::= <<
<network.templateData.portMedium.(instance).(port).value>
>>

printUpperCaseMedium(port, instance) ::= <<
<network.templateData.upperCasePortMedium.(instance).(port).value>
>>

fifoInit(instance, port, connectionId) ::= <<
<if(instance.actor)
>fifo<printMedium(port,instance)>_<port.type>_init(<instance.id>_<port>, <connectionId.value>/*To complete !*/);<
else
>fifo<printMedium(port,instance)>_<port.type>_init(bcast_<instance.id>_<port>, <connectionId.value>/*To complete !*/);<
endif>
>>

printFifoInit(instances, ports, connectionId) ::= <<
<if(first(instances))
><fifoInit(first(instances), first(ports), first(connectionId))>
<printFifoInit(rest(instances), rest(ports), rest(connectionId))
><endif>
>>

///////////////////////////////////////////////////////////////////////////////

MediumInclude(medium) ::= <<
#include "orcc_fifo<medium>.h"
>>

printMediumInclude(mediums) ::= <<
<mediums : MediumInclude(); separator="\n">
>>

// print network
network(network, options) ::= <<

// Generated from "<network.name>"

#include \<locale.h\>
#include \<stdio.h\>
#include \<stdlib.h\>
<if (options.needDynamicMapping)>
#include \<time.h\>
<endif>

#ifdef __APPLE__
#include "SDL.h"
#endif

#ifndef _WIN32
#define __USE_GNU
#endif

#include "orcc_types.h"
#include "orcc_fifo.h"
<printMediumInclude(network.templateData.allMediumsAllInstances)>
#include "orcc_scheduler.h"
#include "orcc_util.h"
<if (options.threads || options.needDynamicMapping)>
#include "orcc_thread.h"
<endif>
<if(options.needDynamicMapping)>
#include "orcc_genetic.h"
<endif>

<if (options.threads || options.needDynamicMapping)>
#define THREAD_NB <options.threadsNb>
<endif>
<if(options.newScheduler)>
#define RING_TOPOLOGY <if(options.ringTopology)>1<else>0<endif>
<endif>
<if(options.needDynamicMapping)>
#define POPULATION_SIZE 20
#define GENERATION_NB 5

#define KEEP_RATIO 0.5
#define CROSSOVER_RATIO 0.6

#define TIMEOUT 120
#define STEP_BW_CHK 1000000

#define CACHE_SIZE 4096
<endif>

#define SIZE <options.fifoSize>
// #define PRINT_FIRINGS


////////////////////////////////////////////////////////////////////////////////
// FIFO allocation

<allocateFifosWithMap(network.outgoingMap)>

////////////////////////////////////////////////////////////////////////////////
// FIFO pointer assignments

<assignFifosWithMap(network.outgoingMap)>

////////////////////////////////////////////////////////////////////////////////
<declareBroadcasts(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Action schedulers

<declareInstancesInitializes(network.instances)>
<declareActionsSchedulers(network.instances)>

////////////////////////////////////////////////////////////////////////////////
// Declaration of a struct actor for each actor

<declareActors(network.instances)>

<if(options.newScheduler)>
////////////////////////////////////////////////////////////////////////////////
// Declaration of the predecessors and successors of each actor

<declarePredsSuccs(network.instances)>
<endif>

////////////////////////////////////////////////////////////////////////////////
// Declaration of the actors array

<fillActorsStructs(network.instances)>

<if(options.threads)>
<options.threads.keys: {th | <declareActorsArray(instances=options.threads.(th),thread=th)>}; separator="\n">

struct actor_s **actors[] = {<options.threads.keys: {th | actors_<th>}; separator=", ">};
<else>
<declareActorsArray(instances=network.instances)>
<endif>

<if (options.needDynamicMapping)>
extern int source_is_stopped();
extern int clean_cache(int size);

<printClearFifosFunction()>

<printTimeout()>
<endif>

////////////////////////////////////////////////////////////////////////////////
// Actor scheduler

<printScheduler()>

////////////////////////////////////////////////////////////////////////////////
// Initializer and launcher

<printInitializes(network.instances)>

static void launcher() {
<if(options.needDynamicMapping || options.threads)>
	int i;
	
	cpu_set_t cpuset; 
	thread_struct threads[THREAD_NB]<if(options.needDynamicMapping)>, thread_monitor<endif>;
	thread_id_struct threads_id[THREAD_NB]<if(options.needDynamicMapping)>, thread_monitor_id<endif>;
	
	struct scheduler_s schedulers[THREAD_NB];
	struct waiting_s waiting_schedulables[THREAD_NB];
	<if(options.needDynamicMapping)>
	struct sync_s sched_sync;
	struct genetic_s genetic_info;
	struct monitor_s monitoring;
	
	sync_init(&sched_sync);
	genetic_init(&genetic_info, POPULATION_SIZE, GENERATION_NB, KEEP_RATIO, CROSSOVER_RATIO, actors, schedulers, sizeof(actors) / sizeof(actors[0]), THREAD_NB, <if(options.newScheduler)>RING_TOPOLOGY<else>0<endif>);
	monitor_init(&monitoring, &sched_sync, &genetic_info);
	
	<else>
	int actors_size[] = {<options.threads.keys: {th | sizeof(actors_<th>) / sizeof(actors_<th>[0])}; separator=", ">};
	<endif>
	
	initialize_instances();
	
	for(i=0; i \< THREAD_NB; i++){
		sched_init(&schedulers[i], i, <if(options.needDynamicMapping)>0<else>actors_size[i]<endif>, <if(options.needDynamicMapping)>NULL<else>actors[i]<endif>, &waiting_schedulables[i], &waiting_schedulables[(i+1) % THREAD_NB], THREAD_NB, <if(options.needDynamicMapping)>&sched_sync<else>NULL<endif>);
	}
	
	<if(options.newScheduler && !options.needDynamicMapping)><printAllAddSchedulable(network.templateData.sourceInstances)><endif>
	
	clear_cpu_set(cpuset);
	
	for(i=0; i \< THREAD_NB; i++){
		thread_create(threads[i], scheduler, schedulers[i], threads_id[i]);
		set_thread_affinity(cpuset, i, threads[i]);
	}
	<if(options.needDynamicMapping)>
	thread_create(thread_monitor, monitor, monitoring, thread_monitor_id);
	<endif>
	
	for(i=0; i \< THREAD_NB; i++){
		thread_join(threads[i]);
	}
	<if(options.needDynamicMapping)>
	thread_join(thread_monitor);
	<endif>
<else>
	cpu_set_t cpuset; 

	struct scheduler_s sched;
	struct waiting_s waiting_schedulable;
	
	clear_cpu_set(cpuset);
	set_this_process_affinity(cpuset, 0);
	
	initialize_instances();

	sched_init(&sched, 0, sizeof(actors) / sizeof(actors[0]), actors, &waiting_schedulable, &waiting_schedulable, 1, NULL);
	
	<if(options.newScheduler)><printAllAddSchedulable(network.templateData.sourceInstances)><endif>
		
	(*scheduler)((void*) &sched);
<endif>
}

////////////////////////////////////////////////////////////////////////////////
// Main

int main(int argc, char *argv[]) {
  init_orcc(argc, argv);

  <if(network.templateData.listMediumInstances)
  ><printFifoInit(network.templateData.listMediumInstances, network.templateData.listMediumPorts, network.templateData.listConnectionId)
  ><endif>

  launcher();

  printf("End of simulation!<if(!options.needDynamicMapping)> Press a key to continue<endif>\n");
  <if(!options.needDynamicMapping)>wait_for_key();<endif>

  return 0;
}

>>




