///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

varDecl(variable, sep="") ::= <<
<if(!variable.port)><variable.type> <variable.name><listSize(variable.type.dimensions)><sep><endif>
>>

getPortName(port) ::= <<
<instance.id>_<port.name>
>>

getFifoId(port, instance) ::= <<
<network.incomingMap.(instance).(port).fifoId>
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<(constant.class.simpleName)(constant)>
>>

BoolExpr(constant) ::= <<
<if (constant.value)>1<else>0<endif>
>>

IntExpr(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
ListExpr(constant) ::= <<
{<constant.value: Constant(); wrap, separator=", ">}
>>

StringExpr(constant) ::= <<
"<constant>"
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
<if(variable.initialized)>
<if(!variable.assignable)>
<if(!variable.type.list)>
#define <variable> <Constant(variable.initialValue)>
<else>
static const <varDecl(variable)> = <Constant(variable.initialValue)>;
<endif>
<else>
<if(variable.type.list)>
static <varDecl(variable)>_backup = <Constant(variable.initialValue)>;
<endif>
static <varDecl(variable)>;
<endif>
<else>
static <varDecl(variable)>;
<endif>
>>

initializeStateVar(variable) ::= <<
<if(variable.assignable && variable.initialized)>
<if(!variable.type.list)>
<variable.name> = <Constant(variable.initialValue)>;
<else>
memcpy(<variable.name>, <variable.name>_backup, sizeof(<variable.name>_backup));
<endif>
<endif>
>>

initializeFunction() ::= <<
<if(instance.actor.initializes)>
<instance.actor.initializes: printAction()>
static void initialize(struct schedinfo_s *si) {
	int i = 0;
	<if(instance.actor.initializes)>
	<printActions(instance.actor.initializes)>
	<endif>
	
finished:
	// no read_end/write_end here!
	return;
}

<endif>
void <instance.id>_initialize(struct schedinfo_s *si) {
	/* Set initial state to current FSM state */
	<if(instance.actor.actionScheduler.fsm)>
	_FSM_state = my_state_<instance.actor.actionScheduler.fsm.initialState>;
	<endif>
	
	/* Set initial value to global variable */
	<instance.actor.stateVars.list: initializeStateVar()>
	<if(instance.actor.initializes)>
	/* Launch CAL initialize procedure */
	initialize(si);
	<endif>
}
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<

<assign.target> = <assign.value>;
>>

printFormatType(type) ::= <<
<if (type.bool)
>i<
elseif (type.float)
>f<
elseif (type.int)
><if (type.long)>ll<endif>i<
elseif (type.list)
>p<
elseif (type.string)
>s<
elseif (type.uint)
><if (type.long)>ll<endif>u<
elseif (type.void)
>p<
endif>
>>

printFormat(parameter) ::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
> "%<printFormatType(parameter.type)>" <
endif>
>>

printParameter(parameter) ::= <<
<if (!parameter.stringExpr)>, <parameter><endif>
>>

printCall(call) ::= <<

<if(call.print)>printf(<call.parameters: printFormat()><call.parameters: printParameter()>);<
else
><if(call.target)><call.target> = <endif><call.procedure>(<call.parameters; separator=", ">);<
endif>
>>

printLoad(load) ::= <<

<if (load.source.variable.port && !load.indexes.empty)
><load.target> = tokens_<load.source.variable.instruction.port.name>[(index_<load.source.variable.instruction.port.name> + <first(load.indexes)>) % SIZE_<load.source.variable.instruction.port.name>];<
else
><load.target> = <load.source><load.indexes : {index | [<index>]}>;<endif>
>>

printPeek(peek) ::= ""

printRead(read) ::= ""

printReadEnd(readEnd) ::= <<

<if(options.("net.sf.orcc.backends.enableTrace"))>
{
	int i;
	for (i = 0; i \< <readEnd.numTokens>; i++) {
		fprintf(file_<readEnd.port.name>, "%<printFormatType(readEnd.port.type)>\n", tokens_<readEnd.port.name>[index_<readEnd.port.name> + i]);
	}
}

<endif
>index_<readEnd.port.name> += <readEnd.numTokens>;
>>

printReturn(return) ::= <<
<if(return.value)>
return <return.value>;<
endif>
>>

printStore(store) ::= <<

<if (store.target.port && !store.indexes.empty)
>tokens_<store.target.instruction.port.name>[(index_<store.target.instruction.port.name> + <first(store.indexes)>) % SIZE_<store.target.instruction.port.name>] = <store.value>;<
else
><store.target><store.indexes : {index | [<index>]}> = <store.value>;<endif>
>>

printWrite(write) ::= ""

printWriteEnd(writeEnd) ::= <<
<if(options.("net.sf.orcc.backends.enableTrace"))>
{
	int i;
	for (i = 0; i \< <writeEnd.numTokens>; i++) {
		fprintf(file_<writeEnd.port.name>, "%<printFormatType(writeEnd.port.type)>\n", tokens_<writeEnd.port.name>[index_<writeEnd.port.name> + i]);
	}
}
<endif>

index_<writeEnd.port.name> += <writeEnd.numTokens>;
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.peek)><printPeek(peek=instr)><
elseif (instr.read)><printRead(read=instr)><
elseif (instr.readEnd)><printReadEnd(readEnd=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
elseif (instr.write)><printWrite(write=instr)><
elseif (instr.writeEnd)><printWriteEnd(writeEnd=instr)><
endif>}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// block node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.value>) {
	<printNodes(ifNode.thenNodes)>
}<if(ifNode.elseNodes)> else {
	<printNodes(ifNode.elseNodes)>
}<endif>
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.value>) {
	<printNodes(whileNode.nodes)>
}
<printBlockNode(whileNode.joinNode)>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

printProcedure(procedure) ::= <<
<if(!procedure.native)>

static <procedure.returnType> <procedure>(<
  procedure.parameters.list: {param | <varDecl(variable=param)>}; wrap, anchor, separator=", ">) {
<if(procedure.locals.list)>
	<procedure.locals.list: {local | <varDecl(variable=local,sep=";\n")>}>
<endif>
	<printNodes(procedure.nodes)>
}

<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

printAction(action) ::= <<
<printProcedure(action.body)><printProcedure(action.scheduler)>
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

printOutputPatternPort(port) ::= <<
if (index_<port.name> + <pattern.(port)> \> numFree_<port.name>) {
	ports |= 0x0<instance.actor.templateData.maskOutputs.(port)>;
}
>>

printOutputPattern(pattern) ::= <<
int ports = 0;
<pattern.keys: printOutputPatternPort(); separator="\n">
if (ports != 0) {
>>

checkInputPattern(pattern) ::= <<
<pattern.keys: { port | index_<port.name> + <pattern.(port)> \<= numTokens_<port.name> && }>
>>

printReadTokensFunction(port) ::= <<


static void read_<port.name>() {
	index_<port.name> = <getPortName(port)>-\>read_inds[<getFifoId(port,instance)>];
	numTokens_<port.name> = index_<port.name> + fifo<printMedium(port)>_<port.type>_get_num_tokens(<getPortName(port)>, <getFifoId(port,instance)>);
}

static void read_end_<port.name>() {
	<getPortName(port)>-\>read_inds[<getFifoId(port,instance)>] = index_<port.name> % SIZE_<port.name>;
}
>>

printWriteTokensFunction(port) ::= <<


static void write_<port.name>() {
	index_<port.name> = <getPortName(port)>-\>write_ind;
	numFree_<port.name> = index_<port.name> + fifo<printMedium(port)>_<port.type>_get_room(<getPortName(port)>);
}

static void write_end_<port.name>() {
	<getPortName(port)>-\>write_ind = index_<port.name> % SIZE_<port.name>;
}
>>

printTokensFunctions() ::= <<
<instance.actor.inputs.list: printReadTokensFunction()>
<instance.actor.outputs.list: printWriteTokensFunction()>
>>

printCallTokenFunctions() ::= <<
<instance.actor.inputs.list: {port|read_<port.name>();
}>
<instance.actor.outputs.list: {port|write_<port.name>();
}>
>>

printOpenFiles() ::= <<
<instance.actor.inputs.list:
	{ port | file_<port.name> = fopen("<getPortName(port)>.txt", "a");
}><instance.actor.outputs.list:
	{ port | file_<port.name> = fopen("<getPortName(port)>.txt", "a");
}>
>>

printCloseFiles() ::= <<
<instance.actor.inputs.list:
	{ port | fclose(file_<port.name>);
}><instance.actor.outputs.list:
	{ port | fclose(file_<port.name>);
}>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionTest(action, restActions) ::= <<
if (<checkInputPattern(action.inputPattern)>isSchedulable_<action>()) {
	<if(action.outputPattern)>
	<printOutputPattern(pattern=action.outputPattern)>
		si-\>num_firings = i;
		si-\>reason = full;
		si-\>ports = ports;
		goto finished;
	}
	<endif>
	<action.body>();
	i++;
} else {
	<printActions(restActions)>
}
>>

printActions(actions) ::= <<
<if (first(actions))
><actionTest(action=first(actions), restActions=rest(actions))><
else
><printTransitionPattern(pattern=instance.actor.templateData.inputPattern,
	maskInputs=instance.actor.templateData.maskInputs)>
goto finished;<
endif>
>>

printActionLoop(actions) ::= <<
while (1) {
	<printActions(actions)>
}
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionTestState(state, restStates) ::= <<
if (<checkInputPattern(state.action.inputPattern)>isSchedulable_<state.action>()) {
	<if (state.action.outputPattern)>
	<printOutputPattern(state.action.outputPattern)>
		_FSM_state = my_state_<transition.sourceState>;
		si-\>num_firings = i;
		si-\>reason = full;
		si-\>ports = ports;
		goto finished;
	}
	<endif>
	<state.action.body>();
	i++;
	goto l_<state.targetState>;
} else {
	<schedulingStates(restStates)>
}
>>

printInputPatternPort(port) ::= <<
if (index_<port.name> \> numTokens_<port.name> - <pattern.(port)>) {
	ports |= 0x0<maskInputs.(port)>;
}
>>

printTransitionPattern(pattern, maskInputs) ::= <<
int ports = 0;
<pattern.keys: printInputPatternPort(); separator="\n">
si-\>num_firings = i;
si-\>reason = starved;
si-\>ports |= ports;
>>

schedulingStates(states) ::= <<
<if (first(states))
><actionTestState(state=first(states), restStates=rest(states))><
else
><printTransitionPattern(pattern=instance.actor.templateData.transitionPattern.(transition),
	maskInputs=instance.actor.templateData.maskInputs)>
_FSM_state = my_state_<transition.sourceState>;
goto finished;<
endif>
>>

printTransition(transition) ::= <<


l_<transition.sourceState>:
	<if (actions)>
	<instance.id>_outside_FSM_scheduler(si);
	i += si-\>num_firings;
	<endif>
	<if (transition.nextStateInfo.empty)>
	printf("stuck in state \"<transition.sourceState>\" in the instance <instance.id>\n");
	wait_for_key();
	exit(1);
	<else>
	<schedulingStates(transition.nextStateInfo)>
	<endif>
>>

switchTransition(transition) ::= <<

case my_state_<transition.sourceState>:
	goto l_<transition.sourceState>;
>>

printSwitch(transitions) ::= <<
switch (_FSM_state) {
<transitions: switchTransition()>
default:
	printf("unknown state in <instance.id>.c : %s\n", stateNames[_FSM_state]);
	wait_for_key();
	exit(1);
}
>>

schedulerFSM(actions, fsm) ::= <<
<if(actions)>
void <instance.id>_outside_FSM_scheduler(struct schedinfo_s *si) {
	int i = 0;

	<printActionLoop(actions)>

finished:
	// no read_end/write_end here!
	return;
}
<endif>

void <instance.id>_scheduler(struct schedinfo_s *si) {
	int i = 0;
	si-\>ports = 0;

	<printCallTokenFunctions()>
<if(options.("net.sf.orcc.backends.enableTrace"))>
	<printOpenFiles()>
<endif>

	// jump to FSM state 
	<printSwitch(fsm.transitions)>

	// FSM transitions
<fsm.transitions: printTransition()>
finished:
<if(options.("net.sf.orcc.backends.enableTrace"))>
	<printCloseFiles()>
<endif>
	read_end();
	write_end();
}

>>

statesFSM(fsm) ::= <<
enum states {
	my_state_<first(fsm.states)> = 0,
	<rest(fsm.states) : {state | my_state_<state>}; separator=",\n">
};

static char *stateNames[] = {
	<fsm.states : {state | "<state>"}; separator=",\n">
};

static enum states _FSM_state = my_state_<fsm.initialState>;
>>

parameters(parameters) ::= <<
<parameters.keys: { k | #define <k> <Constant(parameters.(k))>
}>
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

MediumInclude(medium) ::= <<
#include "orcc_fifo<medium>.h"
>>

printMediumInclude(mediums) ::= <<
<mediums : MediumInclude(); separator="\n">
>>

printMedium(port) ::= <<
<network.templateData.portMedium.(instance).(port).value>
>>

printFifoSize(size) ::= <<
<if(size)><size><else>SIZE<endif>
>>

printInputPort(port) ::= <<
static unsigned int index_<port.name>;
static unsigned int numTokens_<port.name>;
#define SIZE_<port.name> (<printFifoSize(network.incomingMap.(instance).(port).size)> + 1)
#define tokens_<port.name> <getPortName(port)>-\>contents


>>

printOutputPort(port) ::= <<
static unsigned int index_<port.name>;
static unsigned int numFree_<port.name>;
#define SIZE_<port.name> (<printFifoSize(first(network.outgoingMap.(instance).(port)).size)> + 1)
#define tokens_<port.name> <getPortName(port)>-\>contents


>>

instance(instance, network, options) ::= <<
// Source file is "<instance.actor.file>"

#include \<stdio.h\>
#include \<stdlib.h\>

#include "orcc.h"
#include "orcc_fifo.h"
#include "orcc_util.h"
<printMediumInclude(network.templateData.listAllMedium.(instance))>

#define SIZE <options.("fifoSize")>

////////////////////////////////////////////////////////////////////////////////
// Input FIFOs
<instance.actor.inputs.list: { port | extern struct fifo<printMedium(port)>_<port.type>_s *<getPortName(port)>;
}>
<instance.actor.inputs.list: printInputPort()>
<if(options.("net.sf.orcc.backends.enableTrace"))>
<instance.actor.inputs.list: { port | FILE *file_<port.name>;
}>
<endif>
////////////////////////////////////////////////////////////////////////////////
// Output FIFOs
<instance.actor.outputs.list: { port | extern struct fifo<printMedium(port)>_<port.type>_s *<getPortName(port)>;
}>
<instance.actor.outputs.list: printOutputPort()>
<if(options.("net.sf.orcc.backends.enableTrace"))>
<instance.actor.outputs.list: { port | FILE *file_<port.name>;
}>
<endif>
////////////////////////////////////////////////////////////////////////////////
// Parameter values of the instance
<parameters(instance.parameters)>
////////////////////////////////////////////////////////////////////////////////
// State variables of the actor
<instance.actor.stateVars.list: stateVar()>
<if(instance.actor.actionScheduler.fsm)>
////////////////////////////////////////////////////////////////////////////////
// Initial FSM state of the actor
<statesFSM(fsm=instance.actor.actionScheduler.fsm)>
<endif>
////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
<instance.actor.procs.list: printProcedure()>
////////////////////////////////////////////////////////////////////////////////
// Actions
<instance.actor.actions: printAction()>

////////////////////////////////////////////////////////////////////////////////
// Token functions
<printTokensFunctions()>

static void read_end() {
	<instance.actor.inputs.list: {port|read_end_<port.name>();
}>
}

static void write_end() {
	<instance.actor.outputs.list: {port|write_end_<port.name>();
}>
}

////////////////////////////////////////////////////////////////////////////////
// Initializes
<initializeFunction()>

////////////////////////////////////////////////////////////////////////////////
// Action scheduler
<if(instance.actor.actionScheduler.fsm)>
<schedulerFSM(actions=instance.actor.actionScheduler.actions, fsm=instance.actor.actionScheduler.fsm)>
<else>
void <instance.id>_scheduler(struct schedinfo_s *si) {
	int i = 0;
	si-\>ports = 0;

	<printCallTokenFunctions()>
<if(options.("net.sf.orcc.backends.enableTrace"))>
	<printOpenFiles()>
<endif>

	<printActionLoop(instance.actor.actionScheduler.actions)>

finished:
<if(options.("net.sf.orcc.backends.enableTrace"))>
	<printCloseFiles()>
<endif>
	read_end();
	write_end();
}
<endif>

>>
