///////////////////////////////////////////////////////////////////////////////
// Functions for generating schedules
///////////////////////////////////////////////////////////////////////////////

arrayDim(values) ::= <<
<values : {value | [0]} >
>>

printActionName() ::= <<
#ifdef PNAME
printf("<instance.Id>.<action.name>();\n");
#endif
>>

printActionState() ::= <<
<if (actor.stateVars.list)>
#ifdef PSTATE
printf("<actor.stateVars.list : {var | <var.name><arrayDim(var.type.dimensions)>=%d}; separator=";">\n\n", <actor.stateVars.list : {var | <var.name><arrayDim(var.type.dimensions)>}; separator=",">);
#endif
<endif>
>>

printFSMState() ::= <<
#ifdef PFSM
printf("state = state_<tr.state.name>;\n");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// Port declaration
///////////////////////////////////////////////////////////////////////////////

// TODO: the [1] is not OK, it did not work with the "port.type.dimensions"


printFifoSize(size) ::= <<
<if(size)><size><else>SIZE<endif>
>>

portDeclaration(port) ::= <<
	<port.type> <port.name>[<printFifoSize(options.network.incomingMap.(instance).(port).size)>];
>>


///////////////////////////////////////////////////////////////////////////////
// parameters
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : { value | [<value>]} >
>>

varDecl(variable, sep="") ::= <<
<variable.type> <variable.indexedName><listSize(variable.type.dimensions)><sep>
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<if (constant.booleanExpr)><printBool(constant)><
elseif (constant.intExpr)><printInt(constant)><
elseif (constant.listExpr)><printList(constant)><
elseif (constant.stringExpr)><printString(constant)><
endif>
>>

printBool(constant) ::= <<
<if (constant.value)>1<else>0<endif>
>>

printInt(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant) ::= <<
1 /*{<constant.value: Constant(); wrap, separator=", ">}*/
>>

printString(constant) ::= <<
"<constant>"
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<

<assign.target.variable.indexedName> = <assign.value>;
>>

printFormatType(type) ::= <<
<if (type.bool)
>i<
elseif (type.float)
>f<
elseif (type.int)
><if (type.long)>ll<endif>i<
elseif (type.list)
>p<
elseif (type.string)
>s<
elseif (type.uint)
><if (type.long)>ll<endif>u<
elseif (type.void)
>p<
endif>
>>

printFormat(parameter) ::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
> "%<printFormatType(parameter.type)>" <
endif>
>>

printParameter(parameter) ::= <<
<if (!parameter.stringExpr)>, <parameter><endif>
>>

printCall(call) ::= << 
//ERROR this function call must be removed, in this case we give a 1, it is OK if it is "data"
<if(call.print)>printf(<call.parameters: PrintFormat()><call.parameters: PrintParameter()>);<
else
><if(call.target)><call.target.variable.name> = <endif> 1;<
endif>
>>


printLoad(load) ::= <<

<load.target.variable.indexedName> = <load.source.variable.indexedName><load.indexes : {index | [<index>]}>;
>>


printRead(read) ::= <<

<if (read.target)>
chan_<instance.id>_<read.port>?<read.target>[0];
<endif>
>>

printStore(store) ::= <<

<store.target.variable.name><store.indexes : {index | [<index>]}> = <store.value>;
>>

Write(write) ::= <<

chan_<instance.id>_<write.port>!<write.target>[0];
>>

printReturn(return) ::= <<

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes 
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
endif>}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// block node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if 
:: (<ifNode.condition>) -\>
	<printNodes(ifNode.thenNodes)>
<if(ifNode.elseNodes)>:: else -\>
	<printNodes(ifNode.elseNodes)>
<endif>
fi;
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

do 
:: <whileNode.condition> -\>
	<printNodes(whileNode.nodes)>
:: else -\> break;
od;

<printBlockNode(whileNode.joinNode)>
>>


///////////////////////////////////////////////////////////////////////////////
// State variable declaration
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
<if(variable.initialized)>
<if(!variable.assignable)>
<if(!variable.type.list)>
<variable.type> <variable.name> = <Constant(variable.initialValue)>;
<else>
<varDecl(variable)> = <Constant(variable.initialValue)>;
<endif>
<else>
<if(variable.type.list)>
<variable.type> <variable.name>_backup<listSize(variable.type.dimensions)> = <Constant(variable.initialValue)>;
<endif>
<varDecl(variable)>;
<endif>
<else>
<varDecl(variable)>;
<endif>
>>

initializeStateVar(variable) ::= <<
<if(variable.assignable && variable.initialized)>
<if(!variable.type.list)>
<variable.name> = <Constant(variable.initialValue)>;
<else>
memcpy(<variable.name>, <variable.name>_backup, sizeof(<variable.name>_backup));
<endif>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with fsm
///////////////////////////////////////////////////////////////////////////////

newState() ::= << 
::	<instance.id>_state == state_<fsm_trans.SourceState.name> -\> {
	<fsm_trans.list: { tr | <peekPattern(pattern=tr.action.peekPattern, action=tr.action)>}>
	<actionsInState(fsm_trans.list)>
	}
>>

actionsInState(trans) ::= <<
if
:: <first(trans): {tr | <schedulerFSM(tr.action)> }>
:: else -\>
	<if (rest(trans))><actionsInState(rest(trans))><else>skip;<endif>
fi;

>>

schedulerFSM(action) ::= <<
	/* <action.name> */ atomic { 
	<guardFSM()>
	-\>
	// Block on channels if needed
	<inputChannelCheck(action.inputPattern)>
	<outputChannelCheck(action.outputPattern)>
	/* Temp variables*/
	int promela_io_index; // used for reading/writing multiple tokens
	<if(action.body.locals)>
	<action.body.locals: { var | <varDecl(var)>;<\n>}>
	<endif>
	 
	<inputPattern(action.inputPattern)>
	
	<printNodes(action.body.nodes)>
	
	<outputPattern(action.outputPattern)>
	
	<instance.id>_state = state_<tr.state.name>;
	
	<printActionName()>
	<printFSMState()>
	<printActionState()>
}
>>

guardFSM() ::= <<
<if (options.guards.(action))>
 <options.guards.(action); separator=" && ">
<else>
skip
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler without fsm
///////////////////////////////////////////////////////////////////////////////

scheduler(action) ::= <<
:: /* <action.name> */ atomic { 
	<guard()>
	-\>
	// Block on channels if needed
	<inputChannelCheck(action.inputPattern)> 
	<outputChannelCheck(action.outputPattern)>
	
	/* Temp variables*/
	int promela_io_index; // used for reading/writing multiple tokens
	<if(action.body.locals)>
	<action.body.locals: {var | <varDecl(var)>;<\n>}>
	<endif> 
	<inputPattern(action.inputPattern)>
	<printNodes(action.body.nodes)>
	<outputPattern(action.outputPattern)>
	<printActionName()>
	<printActionState()>
}	
>>

guard() ::= <<
<options.guards.(action); separator=" && ">
<options.priority.(action): priorities()>
>>

///////////////////////////////////////////////////////////////////////////////
// Action Templates
///////////////////////////////////////////////////////////////////////////////

priorities(act) ::= << 
 /*priority*/ 
 && !(<options.guards.(act); separator=" && ">)

>> 

inputPatternPort(variable) ::= <<
promela_io_index=0;
do
:: promela_io_index \< <variable.type.dimensions> -\> 
	chan_<instance.id>_<pattern.varToPortMap.(variable).name>?<variable.name>[promela_io_index];
	promela_io_index = promela_io_index + 1;
:: else -\> break
od;

>>

inputPattern(pattern) ::= <<
<pattern.variables: inputPatternPort()>
>>

outputPatternPort(variable) ::= <<
promela_io_index=0;
do
:: promela_io_index \< <variable.type.dimensions> -\> 
	chan_<instance.id>_<pattern.varToPortMap.(variable).name>!<variable.name>[promela_io_index];
	promela_io_index = promela_io_index + 1;
:: else -\> break
od;

>>

outputPattern(pattern) ::= <<
<pattern.variables: outputPatternPort()>
>>

peekPatternVar() ::= <<
<options.loadPeeks.(action): {ld | <ld.target.variable.type> <ld.target.variable.name>; }>

>>

peekPatternPort(variable) ::= <<
chan_<instance.id>_<pattern.varToPortMap.(variable).name>?\<<variable.name>[0]\>;

>>

peekPatternLoad(variable) ::= <<
<options.loadPeeks.(action): printLoad()>

>>

peekPattern(pattern, action) ::= <<
<peekPatternVar()>
<pattern.variables: peekPatternPort()>
<pattern.variables: peekPatternLoad()>
>>

inputChannelCheck(pattern) ::= <<
<pattern.ports: {port | nempty(chan_<instance.id>_<port.name>)};separator=" && " ><if (pattern.ports)>;<endif>
>>

outputChannelCheck(pattern) ::= <<
<pattern.ports: {port | nfull(chan_<instance.id>_<port.name>)};separator=" && " ><if (pattern.ports)>;<endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Process declaration
///////////////////////////////////////////////////////////////////////////////

proctype(instance, actor) ::= <<
proctype <instance.id>(<actor.parameters.list: varDecl(); wrap, separator=", ">) {

	<if (actor.fsm)>
	/* States of the FSM */
	<actor.fsm.states: {s | int state_<s.name> = <i0>;}; separator="\n">
	<endif>

	/* State variables */
	<actor.stateVars : stateVar()>
	<actor.stateVars : initializeStateVar()>
	
	/* Ports */
    < [instance.actor.inputs, instance.actor.outputs] : portDeclaration(); separator="\n">

	<if (actor.fsm)>
	/* Initial State */
	<instance.id>_state = state_<actor.fsm.initialState.name>;
	
	do
	<actor.fsm.transitions: { fsm_trans| <newState()> }>
	od;
	<else>
	do
	:: skip -\> 
	  <actor.actionsOutsideFsm: { a | <peekPattern(pattern=a.peekPattern,action=a)>}>
	  if
	  <actor.actionsOutsideFsm: scheduler(); separator="\n">
	  fi;
	od;
	<endif>
}
>>


instance(instance, options) ::= <<
/*state need to be global in order to reach it from never claims*/
int <instance.id>_state;

/* Process */
<proctype(instance=instance, actor=instance.actor)>

>>
