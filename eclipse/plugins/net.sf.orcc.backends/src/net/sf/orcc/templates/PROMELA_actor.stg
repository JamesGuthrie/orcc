///////////////////////////////////////////////////////////////////////////////
// Functions for generating schedules
///////////////////////////////////////////////////////////////////////////////

arrayDim(values) ::= <<
<values : {value | [0]} >
>>

printActionName() ::= <<
#ifdef PNAME
printf("<instance.Id>.<action.name>();\n");
#endif
>>

printActionState() ::= <<
<if (actor.stateVars.list)>
#ifdef PSTATE
printf("<actor.stateVars.list : {var | <var.name><arrayDim(var.type.dimensions)>=%d}; separator=";">\n\n", <actor.stateVars.list : {var | <var.name><arrayDim(var.type.dimensions)>}; separator=",">);
#endif
<endif>
>>

printFSMState() ::= <<
#ifdef PFSM
printf("state = state_<fsm_nsi.targetState>;\n");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// Port declaration
///////////////////////////////////////////////////////////////////////////////

// TODO: the [1] is not OK, it did not work with the "port.type.dimensions"

portDeclaration(port) ::= <<
	<port.type> <port.name>[1];
>>

///////////////////////////////////////////////////////////////////////////////
// parameters
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : { value | [<value>]} >
>>

varDecl(variable) ::= <<
<
if(variable.port)
><
else
><variable.type> <variable.indexedName><listSize(variable.type.dimensions)><
endif
>
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<if (constant.booleanExpr)><printBool(constant)><
elseif (constant.intExpr)><printInt(constant)><
elseif (constant.listExpr)><printList(constant)><
elseif (constant.stringExpr)><printString(constant)><
endif>
>>

printBool(constant) ::= <<
<if (constant.value)>1<else>0<endif>
>>

printInt(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant) ::= <<
{<constant.value: Constant(); wrap, separator=", ">}
>>

printString(constant) ::= <<
"<constant>"
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<

<assign.target.variable.indexedName> = <assign.value>;
>>

printFormatType(type) ::= <<
<if (type.bool)
>i<
elseif (type.float)
>f<
elseif (type.int)
><if (type.long)>ll<endif>i<
elseif (type.list)
>p<
elseif (type.string)
>s<
elseif (type.uint)
><if (type.long)>ll<endif>u<
elseif (type.void)
>p<
endif>
>>

printFormat(parameter) ::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
> "%<printFormatType(parameter.type)>" <
endif>
>>

printParameter(parameter) ::= <<
<if (!parameter.stringExpr)>, <parameter><endif>
>>

printCall(call) ::= << 
//ERROR this function call must be removed, in this case we give a 1, it is OK if it is "data"
<if(call.print)>printf(<call.parameters: PrintFormat()><call.parameters: PrintParameter()>);<
else
><if(call.target)><call.target> = <endif> 1;<
endif>
>>


printLoad(load) ::= <<

<load.target.variable.indexedName> = <load.source.variable.indexedName><load.indexes : {index | [<index>]}>;
>>


printRead(read) ::= <<

<if (read.target)>
chan_<instance.id>_<read.port>?<read.target>[0];
<endif>
>>

printStore(store) ::= <<

<store.target.variable.name><store.indexes : {index | [<index>]}> = <store.value>;
>>

Write(write) ::= <<

chan_<instance.id>_<write.port>!<write.target>[0];
>>

printReturn(return) ::= <<

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes 
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
endif>}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// block node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if 
:: (<ifNode.condition>) -\>
	<printNodes(ifNode.thenNodes)>
<if(ifNode.elseNodes)>:: else -\>
	<printNodes(ifNode.elseNodes)>
<endif>
fi;
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

do 
:: <whileNode.condition> -\>
	<printNodes(whileNode.nodes)>
:: else -\> break;
od
}
<printBlockNode(whileNode.joinNode)>
>>


///////////////////////////////////////////////////////////////////////////////
// State variable declaration
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
<if(variable.initialized)>
<if(!variable.assignable)>
<if(!variable.type.list)>
#define <variable.name> <Constant(variable.initialValue)>
<else>
static const <varDecl(variable)> = <Constant(variable.initialValue)>;
<endif>
<else>
<if(variable.type.list)>
static <variable.type> <variable.name>_backup<listSize(variable.type.dimensions)> = <Constant(variable.initialValue)>;
<endif>
static <varDecl(variable)>;
<endif>
<else>
static <varDecl(variable)>;
<endif>
>>

initializeStateVar(variable) ::= <<
<if(variable.assignable && variable.initialized)>
<if(!variable.type.list)>
<variable.name> = <Constant(variable.initialValue)>;
<else>
memcpy(<variable.name>, <variable.name>_backup, sizeof(<variable.name>_backup));
<endif>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with fsm
///////////////////////////////////////////////////////////////////////////////

newState() ::= << 
:: <instance.id>_state == state_<fsm_trans.SourceState.name> -\> {
	<fsm_trans.list: { tr | <peekPattern(tr.action.peekPattern)>}>
	if
	<fsm_trans.NextStateInfo: {
			fsm_nsi|
:: <fsm_nsi.action: schedulerFSM(); separator="\n"> }>
	fi;}
>>

schedulerFSM(action) ::= <<
	/* <action.name> */ atomic { 
	<guardFSM()> <inputChannelCheck(action.inputPattern)> <outputChannelCheck(action.outputPattern)>
	-\> 
	/* Temp variables*/
	<if(action.body.locals.list)>
	<action.body.locals.list: { var | <if(!var.port)> <varDecl(var)>;<\n><endif>}>
	<endif> 
	<inputPattern(action.inputPattern)>
	<action.body.nodes: { node | <(node.class.simpleName)(node)>}>
	<outputPattern(action.outputPattern)>
	<instance.id>_state = state_<fsm_nsi.targetState>;
	<printActionName()>
	<printFSMState()>
	<printActionState()>
}
>>

guardFSM() ::= <<
<if (options.guards.(action))>
 <options.guards.(action); separator=" && ">
<else>
skip
<endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler without fsm
///////////////////////////////////////////////////////////////////////////////

scheduler(action) ::= <<
:: /* <action.name> */ atomic { 
	<guard()> <inputChannelCheck(action.inputPattern)> <outputChannelCheck(action.outputPattern)>
	-\>
	/* Temp variables*/
	<if(action.body.locals.list)>
	<action.body.locals.list: {var | <if(!var.port)><varDecl(var)>;<\n><endif>}>
	<endif> 
	<inputPattern(action.inputPattern)>
	<printNodes(action.body.nodes)>
	<outputPattern(action.outputPattern)>
	<printActionName()>
	<printActionState()>
}	
>>

guard() ::= <<
<options.guards.(action); separator=" && ">
>>

///////////////////////////////////////////////////////////////////////////////
// Action Templates
///////////////////////////////////////////////////////////////////////////////

priorities() ::= << 
<if (rest(options.guards.(action)))>
 /*priority*/ && !( <rest(options.guards.(action)); separator=" && "> )
<endif>
>> 

inputPatternPort(port) ::= <<
chan_<port.name>?trash;
>>

inputPattern(pattern) ::= <<
<pattern.ports: inputPatternPort(); separator="\n">
>>

outputPatternPort(port) ::= <<
chan_<port.name>!trash;
>>

outputPattern(pattern) ::= <<
<pattern.ports: outputPatternPort(); separator="\n">
>>

peekPatternPort(port) ::= <<
chan_<port.name>!\<trash\>;
>>

peekPattern(pattern) ::= <<
<pattern.ports: peekPatternPort(); separator="\n">
>>

inputChannelCheck(pattern) ::= <<
<pattern.keys: {key | && nempty(chan_<instance.id>_<key>)} >
>>

outputChannelCheck(pattern) ::= <<
<pattern.keys: {key | && nfull(chan_<instance.id>_<key>)} >
>>



///////////////////////////////////////////////////////////////////////////////
// Process declaration
///////////////////////////////////////////////////////////////////////////////

proctype(instance, actor) ::= <<
proctype <instance.id>(<actor.parameters.list: varDecl(); wrap, separator=", ">) {

	/* State variables */
	<actor.stateVars : stateVar()>
	<actor.stateVars : initializeStateVar()>
	
	/* Ports */
    < [instance.actor.inputs, instance.actor.outputs] : portDeclaration(); separator="\n">

	<if (actor.fsm)>
	/* States of the FSM */
	<actor.fsm.states: {s | int state_<s.name> = <i0>;}; separator="\n">
	
	/* Initial State */
	<instance.id>_state = state_<actor.fsm.initialState.name>;
	
	do
	<actor.fsm.transitions: { fsm_trans| <newState()> }>
	od;
	<else>
	do
	:: skip -\> 
	  <actor.actionsOutsideFsm: { a | <peekPattern(a.peekPattern)>}>
	  if
	  <actor.actionsOutsideFsm: scheduler(); separator="\n">
	  fi;
	od;
	<endif>
}
>>


instance(instance, options) ::= <<
/*state need to be global in order to reach it from never claims*/
int <instance.id>_state;

/* Process */
<proctype(instance=instance, actor=instance.actor)>

>>
