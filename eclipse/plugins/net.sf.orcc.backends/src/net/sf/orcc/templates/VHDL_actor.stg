///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
portType(port, IOtype, dataType) ::= <<
<if(port.type.bool)
><port.name>_<dataType>  :<IOtype>std_logic;<
else
><port.name>_<dataType>  :<IOtype>std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print instance's ports
///////////////////////////////////////////////////////////////////////////////
PrintInputPorts(port) ::= <<
<portType(port=port, IOtype=" in  ", dataType="data")>
<port.name>_send  : in  std_logic;
<if(last(port.name))
><port.name>_ack   : out  std_logic<
else
><port.name>_ack   : out  std_logic;<
endif>
>>

PrintOutputPorts(port) ::= <<
<portType(port=port, IOtype=" out ", dataType="data")>
<port.name>_send  : out std_logic;
<if(last(port.name))
><port.name>_ack   : in  std_logic<
else
><port.name>_ack   : in  std_logic;<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print signal and constant
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : {value | <value>}; separator=" * ">
>>

// These signals are used by the IOs management processes
IOsManagementSignals(port)::= <<
signal <port.name>_rdy    : std_logic;
signal <port.name>_isend  : std_logic;
signal <portType(port=port, IOtype=" ", dataType="idata")>
>>

signalDeclaration(variable) ::= <<
<if(variable.type.list)>
<if(variable.assignable)>
-- RAM signals for "<variable.name>"
signal <variable.name>_wren_p1       : std_logic;
signal <variable.name>_address_p1    : std_logic_vector(bit_width(<listSize(variable.type.dimensions)>)-1 downto 0);
signal <variable.name>_data_p1       : std_logic_vector(<variable.type.type.size> -1 downto 0);
signal <variable.name>_q_p1          : std_logic_vector(<variable.type.type.size> -1 downto 0);
signal <variable.name>_wren_p2       : std_logic;
signal <variable.name>_address_p2    : std_logic_vector(bit_width(<listSize(variable.type.dimensions)>)-1 downto 0);
signal <variable.name>_data_p2       : std_logic_vector(<variable.type.type.size> -1 downto 0);
signal <variable.name>_q_p2          : std_logic_vector(<variable.type.type.size> -1 downto 0);

<else>
type memory_type_<variable> is array (0 to <listSize(variable.type.dimensions)> -1) of <variable.type>;
constant <variable> : memory_type_<variable><if(variable.initialized)> := <variable.initialValue><endif>;
<endif>
<else>
<if(variable.assignable)>
signal <variable.name> : <variable.type>;
<else>
constant <variable> : <variable.type> := <variable.initialValue>;
<endif>
<endif>
>>

ramDeclaration(variable) ::= <<
<if(variable.type.list)>
<if(variable.assignable)>
<if(actor.templateData.customInitMap.(variable))>
-- custom init of arrays not supported
<else>
-- RAM instantiation for "<variable.name>"
DP_genericRam_<variable.name> : entity work.DP_genericRam
  generic map (
    depth =\> <listSize(variable.type.dimensions)>,
    width =\> <variable.type.type.size>,
    initVal =\> <actor.templateData.initValueMap.(variable)>)
  port map (
    clk        =\> clock,
    wren_p1    =\> <variable.name>_wren_p1,
    address_p1 =\> <variable.name>_address_p1,
    data_p1    =\> <variable.name>_data_p1,
    q_p1       =\> <variable.name>_q_p1,
    wren_p2    =\> <variable.name>_wren_p2,
    address_p2 =\> <variable.name>_address_p2,
    data_p2    =\> <variable.name>_data_p2,
    q_p2       =\> <variable.name>_q_p2);

<endif>
<endif>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print variables
///////////////////////////////////////////////////////////////////////////////
VarDeclaration(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! variable <variable.name> : <variable.type> (0 to <listSize(variable.type.dimensions)> -1)<
else
>variable <variable.name> : <variable.type><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Init at reset
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
<if(variable.assignable)>
<if(variable.type.list)>
--
<variable.name>_wren_p1    \<= '0';
<variable.name>_address_p1 \<= (others =\> '0');
<variable.name>_data_p1    \<= (others =\> '0');
<variable.name>_wren_p2    \<= '0';
<variable.name>_address_p2 \<= (others =\> '0');
<variable.name>_data_p2    \<= (others =\> '0');
--
<elseif(variable.initialized)>
<variable.name> \<= <variable.initialValue>;
<endif>
<endif>
>>

resetReadWriteEnable(variable) ::= <<
<if(variable.assignable && variable.type.list)>
<variable.name>_wren_p1 \<= '0';
<variable.name>_wren_p2 \<= '0';
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print cast operations (when source.size != target.size)
///////////////////////////////////////////////////////////////////////////////
CastStore(target, targetSize, value, cast)::= <<
<if(cast.extended)
><target> := <value><
else
><if(target.type.uint)
><target> := ucast(<value>, <value.type.size>, <targetSize>)<  
  else
><target> := cast(<value>, <value.type.size>, <targetSize>)<  
  endif><
endif>
>>

CastLoad(target, source, cast)::= <<
<if(cast.extended)
><target> := <source><
else
><if(target.type.uint)
><target> := ucast(<source>, <source.type.size>, <target.type.size>)<
  else
><target> := cast(<source>, <source.type.size>, <target.type.size>)<
  endif><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<
<if (assign.cast)
><CastStore(target=assign.target, targetSize=assign.target.type.size, value=assign.value, cast=assign.cast)>;<
else
><assign.target> := <assign.value>;<
endif
>
>>

printAssignIndex(assignIndex) ::= <<
<assignIndex.target> := to_integer(unsigned(<assignIndex.indexes: {index | std_logic_vector(to_unsigned(<index>, <index.type.size>))}; separator=" & ">));
>>

printCall(call) ::= <<
<if(call.target)
><call.target> := <call.procedure>(<call.procedure.loadedVariables: {var | <var>, }><call.parameters: {param | <param>, }>'1');<
elseif(call.parameters)
><call.procedure>(<call.parameters; separator=", ">, '1');<
else
><call.procedure>('1');<
endif>
>>

getPort(variable) ::= <<
<if (action.inputPattern.inverseVariableMap.(variable))
><action.inputPattern.inverseVariableMap.(variable).name><
else
><action.outputPattern.inverseVariableMap.(variable).name><
endif>
>>

getPortSize(variable) ::= <<
<if (action.inputPattern.inverseVariableMap.(variable))
><action.inputPattern.inverseVariableMap.(variable).type.size><
else
><action.outputPattern.inverseVariableMap.(variable).type.size><
endif>
>>

printLoad(load) ::= <<
<if(load.indexes)
><if (action.inputPattern.inverseVariableMap.(load.source.variable) || action.outputPattern.inverseVariableMap.(load.source.variable))
><if(load.cast)><CastLoad(target=load.target, source={<procedure.name>_<getPort(load.source.variable)>}, cast=load.cast)>;<
else><load.target> := <procedure.name>_<getPort(load.source.variable)>;<
endif
><else><load.target> := <load.source>(<load.indexes : {index | <index>}; separator=", ">);<
endif
><else><load.target> := <load.source>;<endif>
>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
printReturn(return) ::= <<
<if(return.value)
><  if(transformReturn)
><procedure>_go := <return.value>;<
  else
>return <return.value>;<
  endif><
endif>
>>

printStore(store) ::= <<
<if(store.indexes)
><if(action.inputPattern.inverseVariableMap.(store.target) || action.outputPattern.inverseVariableMap.(store.target))
><if(store.cast)><CastStore(value=store.value, target={<procedure.name>_<getPort(store.target)>}, targetSize={<getPortSize(store.target)>}, cast=store.cast)>;
<else><procedure.name>_<getPort(store.target)> := <store.value>;<
endif><
else><store.target>(<store.indexes : {index | <index>}; separator=", ">) \<= <store.value>;<
endif
><else><store.target> \<= <store.value>;<endif>
>>

/////////////////////
// port read/write //

printRead(procedure, port, variable) ::= <<
<if(variable)
><if(port.type.bool)
><procedure.name>_<variable.name> := <port.name>_data;<
elseif(port.type.int)
><procedure.name>_<variable.name> := to_integer(signed(<port.name>_data));<
elseif(port.type.uint)
><procedure.name>_<variable.name> := to_integer(unsigned(<port.name>_data));<
endif
><endif>
>>

printWrite(procedure, port, variable) ::= <<
<if(port.type.bool)
><port.name>_idata \<= <procedure.name>_<variable.name>;<
elseif(port.type.int)
><port.name>_idata \<= std_logic_vector(to_signed(<procedure.name>_<variable.name>, <port.type.size>));<
else
><port.name>_idata \<= std_logic_vector(to_unsigned(<procedure.name>_<variable.name>, <port.type.size>));<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// RAM
///////////////////////////////////////////////////////////////////////////////

printRamRead(ramRead) ::= <<
<ramRead.target.name> := <if(ramRead.variable.type.type.bool)
><ramRead.value>;<
elseif(ramRead.variable.type.type.int)
>to_integer(signed(<ramRead.variable.name>_q_p<ramRead.port>));<
else
>to_integer(unsigned(<ramRead.variable.name>_q_p<ramRead.port>));<
endif>
>>

printRamWrite(ramWrite) ::= <<
<ramWrite.variable.name>_data_p<ramWrite.port> \<= <
if(ramWrite.variable.type.type.bool)
><ramWrite.value>;
<elseif(ramWrite.variable.type.type.int)
>std_logic_vector(to_signed(<ramWrite.value>, <ramWrite.variable.type.type.size>));
<else
>std_logic_vector(to_unsigned(<ramWrite.value>, <ramWrite.variable.type.type.size>));
<endif>
<ramWrite.variable.name>_wren_p<ramWrite.port> \<= '1';
>>

printRamSetAddress(ramSetAddress) ::= <<
<ramSetAddress.variable.name>_address_p<ramSetAddress.port> \<= <ramSetAddress.indexes: {index | std_logic_vector(to_unsigned(<index>, <index.type.size>))}; separator=" & ">;
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////
printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.assignIndex)><printAssignIndex(assignIndex=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><

elseif (instr.ramRead)><printRamRead(ramRead=instr)><
elseif (instr.ramWrite)><printRamWrite(ramWrite=instr)><
elseif (instr.ramSetAddress)><printRamSetAddress(ramSetAddress=instr)><
endif>}; separator="\n">
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// if node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.value>) then
  <printNodes(ifNode.thenNodes)><if(ifNode.elseNodes)>
else
  <printNodes(ifNode.elseNodes)>
end if;<endif>
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.value>) loop
  <printNodes(whileNode.nodes)><printBlockNode(whileNode.joinNode)>
end loop;
>>



///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////
function(procedure) ::= <<
<if (!procedure.native)
  ><if (procedure.returnType.void)
>procedure <procedure>(<printParameters(procedure.parameters.list)>dummy : std_logic) is
<else
>function <procedure>(<VarUsed(procedure)><printParameters(procedure)>dummy : std_logic) <returnFunction(procedure.returnType)> is
<endif>
  <if(procedure.locals.list)
><procedure.locals.list: {variable| <VarInFctDeclaration(variable)>;<\n>}><
  endif>
begin
  <printNodes(procedure.nodes)>
end <procedure>;<
endif>

>>

VarUsed(procedure) ::= <<
<procedure.loadedVariables: functionParameter(); wrap>
>>

printParameters(procedure) ::= <<
<procedure.parameters.list: functionParameter()>
>>

functionParameter(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! type memory type<
else
><variable.name> : <typeFunction(variable.type)>; <
endif
>
>>

VarInFctDeclaration(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! type memory_type<
else
>variable <variable.name> : <typeFunction(variable.type)><
endif>
>>


returnFunction(type) ::= <<
<if(type.bool)
>return std_logic<
elseif(type.int)
>return integer<
endif>
>>

typeFunction(type) ::= <<
<if(type.bool)
>std_logic<
elseif(type.int)
>integer<
else
>integer<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printProcedure(procedure, transformReturn) ::= <<
<printNodes(procedure.nodes)>
>>

printLocals(procedure) ::= <<
<if(procedure.locals.list)
><procedure.locals.list: {variable| <VarDeclaration(variable)>;<\n>}><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Management of Outputs 
///////////////////////////////////////////////////////////////////////////////
OutputsManag() ::= <<
---------------------------------------------------------------------------
-- Transmission manager
---------------------------------------------------------------------------
<actor.outputs.list : printArbiter(); separator="\n\n">
>>

// instanciate an arbiter which manage the communication between actors.
printArbiter(port) ::= <<
comArbiter_<port.name> : entity work.comArbiter
generic map (
  width =\> <if(port.type.bool)>(1)<else><port.type.size><endif>)
port map (
  reset_n      =\> reset_n,
  clock        =\> clock,
  actor_data<if(port.type.bool)>(0)<endif>   =\> <port.name>_idata,
  actor_send   =\> <port.name>_isend,
  actor_rdy    =\> <port.name>_rdy,
  network_data<if(port.type.bool)>(0)<endif> =\> <port.name>_data,
  network_send =\> <port.name>_send,
  network_ack  =\> <port.name>_ack);
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Scheduler process
///////////////////////////////////////////////////////////////////////////////
Actor_Scheduler(actor) ::= <<
<actor.simpleName>_scheduler : process(<actor.templateData.signals; wrap, anchor, separator=", ">)
  <actor.actions : { action |<printLocals(action.scheduler)>
variable <action.scheduler>_go : std_logic;
<action.inputPattern.ports: { port |<if(action.inputPattern.peekedMap.(port))>variable <action.scheduler.name>_<port.name> : <port.type>;
<endif>}>
}>--
begin
  <actor.actions: {action|-- test if "<action>" action is schedulable
<action.inputPattern.ports: { port |<printRead(procedure=action.body, port=port, variable=action.inputPattern.peekedMap.(port))>
}>
<printProcedure(procedure=action.scheduler, transformReturn="true")>}; separator="\n\n">

  --
  -- Test the action's inputs to fire (or not) an action  
  <actor.actions : {action|<action>_go \<= '0';}; separator="\n">
  <actor.inputs.list :{port|<port.name>_ack \<= '0';}; separator="\n">  
<if(actor.actionScheduler.fsm)    
>  <printActionFireFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)><
else  
>  if <actor.actions: printActionFire(); separator="\n  elsif">
  end if;<
endif>

end process;

>>

// prints the condition on the ack and go signals according to the input and output pattern
printActionFire(action) ::= <<
((isSchedulable_<action>_go <action.inputPattern.ports : {port| and <port.name>_send }>) = '1') then
<if(action.inputPattern.ports)
>< if(action.outputPattern.ports)
>    <action>_go \<= isSchedulable_<action>_go and <action.outputPattern.ports : {port|<port.name>_rdy}; separator=" and ">;
    <action.inputPattern.ports : {
      port|<port.name>_ack \<= isSchedulable_<action>_go and <action.outputPattern.ports : {port|<port.name>_rdy}; separator=" and ">} ; separator=";\n">;<
  else
>    <action>_go \<= isSchedulable_<action>_go;
    <action.inputPattern.ports : {port|<port.name>_ack \<= isSchedulable_<action>_go;} ; separator="\n"><
  endif><
else
>< if(action.outputPattern.ports)
>    <action>_go \<= isSchedulable_<action>_go and <action.outputPattern.ports : {port|<port.name>_rdy}; separator=" and ">;<
  else
>    <action>_go \<= isSchedulable_<action>_go;<
  endif><
endif>  
>>

printActionFireFSM(actions, fsm) ::= <<
<if(actions)
>if<printActionFire(actions)>
else
  case FSM is
  <TransitionFire()>
      end case;
end if;<
else
>  case FSM is
<fsm.transitions: TransitionFire(); separator="\n\n">
  end case;<
endif>
>>

TransitionFire(transition) ::= <<
    when s_<transition.sourceState> =\>
      if <transition.nextStateInfo: actionFire(); separator="\n      elsif">
      end if;
>>

actionFire(nextstate) ::= <<
    <printActionFire(nextstate.action)>
>>



///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Execute process
///////////////////////////////////////////////////////////////////////////////
Actor_Exec(actor) ::= <<
<actor.simpleName>_execute : process (reset_n, clock) is
  <actor.actions: {action |<printLocals(action.body)>
<action.inputPattern.ports: { port |variable <action.body.name>_<port.name> : <port.type>;
}><action.outputPattern.ports: { port |variable <action.body.name>_<port.name> : <port.type>;
}>
}>  --
begin
  if reset_n = '0' then
<if(actor.stateVars.list)>
    <actor.stateVars.list: stateConst()>    --
<endif>
    <actor.outputs.list : port_out_init()>
<if(actor.actionScheduler.fsm)>
    FSM    \<= s_<actor.actionScheduler.fsm.initialState>;
<endif>
    --
  elsif rising_edge(clock) then
    <actor.outputs.list :{port|<port.name>_isend \<= '0';}; separator="\n">
    <actor.stateVars.list: resetReadWriteEnable()>
    --  
<if(actor.actionScheduler.fsm)>
    <executeCoreFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)>
<else>
    <executeCore(actor.actions)>
<endif>

  end if;
end process <actor.simpleName>_execute;

>>

printActionBody(action) ::= <<
<action.inputPattern.ports: { port |<printRead(procedure=action.body, port=port, variable=action.inputPattern.variableMap.(port))>
}
><printProcedure(procedure=action.body, transformReturn="true")
><action.outputPattern.ports: { port |<printWrite(procedure=action.body, port=port, variable=action.outputPattern.variableMap.(port))>
}
>
>>

actionTestScheduler(action) ::= <<
(<action>_go = '1') then
  -- body of "<action>" action
  <printActionBody(action)>
  --
  <action.outputPattern.ports: {port|<port.name>_isend \<= '1';
}>
>>

port_out_init(port) ::=<<

<port.name>_isend \<= '0';
<if(port.type.bool)>
<port.name>_idata \<= '0';
<else>
<port.name>_idata \<= (others =\> '0');
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - NO FSM

executeCore(actions) ::= <<
    if <executeIndent(actions)>
>>

// just to have a correct indentation
executeIndent(actions) ::= <<
    <actions: actionTestScheduler(); separator="\nelsif ">
    end if;
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - WITH FSM

executeCoreFSM(actions, fsm) ::= <<
<if(actions)
><executeCore(actions)>
else
  case FSM is
  <switchTransition()>
      end case;
end if;<
else
>    case FSM is
  <fsm.transitions: switchTransition(); separator="\n\n">
    end case;<
endif>
>>

switchTransition(transition) ::= <<
    when s_<transition.sourceState> =\>
      if <transition.nextStateInfo: actionTestState(); separator="\n      elsif">
      end if;
>>

actionTestState(nextState) ::= <<
      <actionTestScheduler(nextState.action)>
        FSM \<= s_<nextState.targetState>;
>>



///////////////////////////////////////////////////////////////////////////////
// Print the actor
///////////////////////////////////////////////////////////////////////////////
actor(actor, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Actor: <actor.simpleName>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <actor.name>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------


------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;


------------------------------------------------------------------------------
entity <actor.simpleName> is
  port (
  -- Inputs
  clock    : in  std_logic;
  reset_n  : in  std_logic<if(actor.inputs.list || actor.outputs.list)>;<endif>
  <actor.inputs.list: PrintInputPorts(); separator=";\n"><if(actor.inputs.list && actor.outputs.list)>;<endif>
  -- Outputs
  <actor.outputs.list: PrintOutputPorts(); separator=";\n">);
end <actor.simpleName>;


------------------------------------------------------------------------------
architecture rtl_<actor.simpleName> of <actor.simpleName> is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  <actor.actions:       {action| signal <action>_go    : std_logic;}; separator="\n">
  --
  <actor.outputs.list :IOsManagementSignals(); separator="\n">
  --
  <actor.stateVars.list: signalDeclaration()>

<if (actor.procs.list)
>  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  <actor.procs.list: {proc|<function(procedure=proc)>}; separator="\n\n"><
endif>

  <if(actor.actionScheduler.fsm)
  >  ---------------------------------------------------------------------------
  -- FSM
  ---------------------------------------------------------------------------
  type FSM_type is (<actor.actionScheduler.fsm.states: {state|s_<state>}; separator=", ">);
  signal FSM : FSM_type;<
  endif>


begin

  <Actor_Scheduler(actor)>
  
  <Actor_Exec(actor)>

  <OutputsManag()>
  
  <actor.stateVars.list: ramDeclaration()>

end architecture rtl_<actor.simpleName>;

>>