///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
getPortName(port, dataType) ::= <%
<if (port.native)>
<port.name>
<else>
<port.name><dataType>
<endif>
%>

portType(port, IOtype, dataType) ::= <%
<if(port.type.bool)>
<getPortName(port, dataType)>  : <IOtype>std_logic
<else>
<getPortName(port, dataType)>  : <IOtype>std_logic_vector(<port.type.size> -1 downto 0)
<endif>
%>



///////////////////////////////////////////////////////////////////////////////
// Print instance's ports
///////////////////////////////////////////////////////////////////////////////
printPort(port, dirSend, dirAck) ::= <<
<portType(port=port, IOtype=dirSend, dataType="_data")><if (!port.native)>;
<port.name>_send  : <dirSend>std_logic;
<port.name>_ack   : <dirAck>std_logic<endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print signal and constant
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : {value | <value>}; separator=" * ">
>>

// These signals are used by the IOs management processes
IOsManagementSignals(port)::= <<
<if (!port.native)>signal <port.name>_rdy    : std_logic;
signal <port.name>_isend  : std_logic;
signal <portType(port=port, IOtype="", dataType="_idata")>;<endif>
>>

signalDeclaration(variable) ::= <<
<if(variable.type.list)>
<if(variable.assignable)>
-- RAM signals for "<variable.name>"
signal <variable.name>_wren_p1       : std_logic;
signal <variable.name>_address_p1    : std_logic_vector(bit_width(<listSize(variable.type.dimensions)>)-1 downto 0);
signal <variable.name>_data_p1       : std_logic_vector(<variable.type.innermostType.sizeInBits> -1 downto 0);
signal <variable.name>_q_p1          : std_logic_vector(<variable.type.innermostType.sizeInBits> -1 downto 0);
signal <variable.name>_wren_p2       : std_logic;
signal <variable.name>_address_p2    : std_logic_vector(bit_width(<listSize(variable.type.dimensions)>)-1 downto 0);
signal <variable.name>_data_p2       : std_logic_vector(<variable.type.innermostType.sizeInBits> -1 downto 0);
signal <variable.name>_q_p2          : std_logic_vector(<variable.type.innermostType.sizeInBits> -1 downto 0);

<else>
type memory_type_<variable.name> is array (0 to <listSize(variable.type.dimensions)> -1) of <variable.type>;
constant <variable.name> : memory_type_<variable.name><if(variable.initialized)> := <variable.initialValue><endif>;
<endif>
<else>
<if(variable.assignable)>
signal <variable.name> : <variable.type>;
<else>
constant <variable.name> : <variable.type> := <variable.initialValue>;
<endif>
<endif>
>>

printValue(type, value) ::= <<
<if (type.bool)><if (value)>1<else>0<endif><else><value><endif>
>>

ramDeclaration(variable) ::= <<
<if(variable.type.list)>
<if(variable.assignable)>
<if(actor.templateData.customInitMap.(variable))>
-- custom init of arrays not supported
<else>
-- RAM instantiation for "<variable.name>"
DP_genericRam_<variable.name> : entity work.DP_genericRam
  generic map (
    depth =\> <listSize(variable.type.dimensions)>,
    width =\> <variable.type.innermostType.sizeInBits>,
    initVal =\> <printValue(variable.type.innermostType, actor.templateData.initValueMap.(variable))>)
  port map (
    clk        =\> clock,
    wren_p1    =\> <variable.name>_wren_p1,
    address_p1 =\> <variable.name>_address_p1,
    data_p1    =\> <variable.name>_data_p1,
    q_p1       =\> <variable.name>_q_p1,
    wren_p2    =\> <variable.name>_wren_p2,
    address_p2 =\> <variable.name>_address_p2,
    data_p2    =\> <variable.name>_data_p2,
    q_p2       =\> <variable.name>_q_p2);

<endif>
<endif>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print variables
///////////////////////////////////////////////////////////////////////////////
VarDeclaration(variable) ::= <<
<if(variable.type.list)
>-- !! error !! variable <variable.name> tabular type size = <listSize(variable.type.dimensions)> of <variable.type>;<
else
>variable <variable.indexedName> : <variable.type>;<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Init at reset
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
<if(variable.assignable)>
<if(variable.type.list)>
--
<variable.name>_wren_p1    \<= '0';
<variable.name>_address_p1 \<= (others =\> '0');
<variable.name>_data_p1    \<= (others =\> '0');
<variable.name>_wren_p2    \<= '0';
<variable.name>_address_p2 \<= (others =\> '0');
<variable.name>_data_p2    \<= (others =\> '0');
--
<elseif(variable.initialized)>
<variable.name> \<= <variable.initialValue>;
<endif>
<endif>
>>

resetReadWriteEnable(variable) ::= <<
<if(variable.assignable && variable.type.list)>
<variable.name>_wren_p1 \<= '0';
<variable.name>_wren_p2 \<= '0';
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print cast operations (when source.size != target.size)
///////////////////////////////////////////////////////////////////////////////
CastStore(targetName, targetTypeIsUint, targetSize, value, cast)::= <<
<if(cast.extended)
><targetName> := <value><
else
><if(targetTypeIsUint)
><targetName> := ucast(<value>, <value.type.size>, <targetSize>)<  
  else
><targetName> := cast(<value>, <value.type.size>, <targetSize>)<  
  endif><
endif>
>>

CastLoad(targetName, targetTypeIsUint, targetSize, source, cast)::= <<
<if(cast.extended)
><targetName> := <source><
else
><if(targetTypeIsUint)
><targetName> := ucast(<source>, <source.type.size>, <targetSize>)<
  else
><targetName> := cast(<source>, <source.type.size>, caca<targetSize>)<
  endif><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<
<if (assign.cast)
><CastStore(targetName=assign.target.variable.indexedName,
targetTypeIsUint=assign.target.variable.type.uint, targetSize=assign.target.variable.type.size,
value=assign.value, cast=assign.cast)>;<
else
><assign.target.variable.indexedName> := <assign.value>;<
endif>
>>

printAssignIndex(assignIndex) ::= <<
<assignIndex.target.variable.indexedName> := to_integer(unsigned(<assignIndex.indexes: {index | std_logic_vector(to_unsigned(<index>, <index.type.size>))}; separator=" & ">));
>>

printCall(call) ::= <%
<if(call.target)>
<call.target.variable.indexedName> := 
<endif>
<call.procedure.name>(<call.parameters; separator=", ">);
%>

getPort(variable) ::= <<
<if (action.inputPattern.varToPortMap.(variable))
><action.inputPattern.varToPortMap.(variable).name><
elseif (action.outputPattern.varToPortMap.(variable))
><action.outputPattern.varToPortMap.(variable).name><
else
><action.peekPattern.varToPortMap.(variable).name><
endif>
>>

getPortTypeUint(variable) ::= <<
<if (action.inputPattern.varToPortMap.(variable))
><action.inputPattern.varToPortMap.(variable).type.uint><
elseif (action.outputPattern.varToPortMap.(variable))
><action.outputPattern.varToPortMap.(variable).type.uint><
else
><action.peekPattern.varToPortMap.(variable).type.uint><
endif>
>>

getPortTypeSize(variable) ::= <<
<if (action.inputPattern.varToPortMap.(variable))
><action.inputPattern.varToPortMap.(variable).type.size><
elseif (action.outputPattern.varToPortMap.(variable))
><action.outputPattern.varToPortMap.(variable).type.size><
else
><action.peekPattern.varToPortMap.(variable).type.size><
endif>
>>

printLoad(load) ::= <<
<if(load.indexes)
><if (action.inputPattern.varToPortMap.(load.source.variable) || action.outputPattern.varToPortMap.(load.source.variable) || action.peekPattern.varToPortMap.(load.source.variable))
><if(load.cast)><CastLoad(targetName=load.target.variable.indexedName,
targetTypeIsUint=load.target.variable.type.uint, targetSize=load.target.variable.size,
source={<procedure.name>_<getPort(load.source.variable)>}, cast=load.cast)>;<
else><load.target.variable.indexedName> := <procedure.name>_<getPort(load.source.variable)>_i;<
endif
><else><load.target.variable.indexedName> := <load.source.variable.name>(<load.indexes : {index | <index>}; separator=", ">);<
endif
><else><load.target.variable.indexedName> := <load.source.variable.name>;<endif>
>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
printReturn(return) ::= <<
<if(return.value)
 ><if(insideIsSchedulable)
   ><procedure.name>_go := <return.value>;<
  else
   >return <return.value>;<
  endif><
endif>
>>

printStore(store) ::= <<
<if(store.indexes)
 ><if(action.inputPattern.varToPortMap.(store.target.variable) || action.outputPattern.varToPortMap.(store.target.variable) || action.peekPattern.varToPortMap.(store.target.variable))
  ><if(store.cast)
    ><CastStore(targetName={<procedure.name>_<getPort(store.target.variable)>},
targetTypeIsUint=getPortTypeUint(store.target.variable), targetSize=getPortTypeSize(store.target.variable),
cast=store.cast, value=store.value)>;<
   else
    ><procedure.name>_<getPort(store.target.variable)>_o := <store.value>;<
   endif><
  else
   ><store.target.variable.name>(<store.indexes : {index | <index>}; separator=", ">) \<= <store.value>;<
  endif><
else
 ><store.target.variable.name> \<= <store.value>;<
endif>
>>

/////////////////////
// port read/write //

printRead(procedure, port, variable) ::= <<
<if(port.type.bool)
><procedure.name>_<variable.name>_i := <getPortName(port, "_data")>;<
elseif(port.type.int)
><procedure.name>_<variable.name>_i := to_integer(signed(<getPortName(port, "_data")>));<
elseif(port.type.uint)
><procedure.name>_<variable.name>_i := to_integer(unsigned(<getPortName(port, "_data")>));<
endif>
>>

printWrite(procedure, port, variable) ::= <<
<if(port.type.bool)
><getPortName(port, "_idata")> \<= <procedure.name>_<variable.name>_o;<
elseif(port.type.int)
><getPortName(port, "_idata")> \<= std_logic_vector(to_signed(<procedure.name>_<variable.name>_o, <port.type.size>));<
else
><getPortName(port, "_idata")> \<= std_logic_vector(to_unsigned(<procedure.name>_<variable.name>_o, <port.type.size>));<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// RAM
///////////////////////////////////////////////////////////////////////////////

printRamRead(ramRead) ::= <<
<ramRead.target.variable.indexedName> := <if(ramRead.variable.type.innermostType.bool)
><ramRead.variable.name>_q_p<ramRead.port>(0);<
elseif(ramRead.variable.type.innermostType.int)
>to_integer(signed(<ramRead.variable.name>_q_p<ramRead.port>));<
else
>to_integer(unsigned(<ramRead.variable.name>_q_p<ramRead.port>));<
endif>
>>

printRamWrite(ramWrite) ::= <<
<ramWrite.variable.name>_data_p<ramWrite.port><if(ramWrite.variable.type.innermostType.bool)
>(0) \<= <ramWrite.value>;
<elseif(ramWrite.variable.type.innermostType.int)
> \<= std_logic_vector(to_signed(<ramWrite.value>, <ramWrite.variable.type.innermostType.size>));
<else
> \<= std_logic_vector(to_unsigned(<ramWrite.value>, <ramWrite.variable.type.innermostType.size>));
<endif>
<ramWrite.variable.name>_wren_p<ramWrite.port> \<= '1';
>>

printRamSetAddress(ramSetAddress) ::= <<
<ramSetAddress.variable.name>_address_p<ramSetAddress.port> \<= <ramSetAddress.indexes, ramSetAddress.indexesSizes: {index, size | std_logic_vector(to_unsigned(<index>, <size>))}; separator=" & ">;
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////
printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.assignIndex)><printAssignIndex(assignIndex=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
elseif (instr.ramRead)><printRamRead(ramRead=instr)><
elseif (instr.ramWrite)><printRamWrite(ramWrite=instr)><
elseif (instr.ramSetAddress)><printRamSetAddress(ramSetAddress=instr)><
endif>

}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// if node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.condition>) then
  <printNodes(ifNode.thenNodes)><if(ifNode.elseNodes)
>else
  <printNodes(ifNode.elseNodes)
><endif>
end if;
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.condition>) loop
  <printNodes(whileNode.nodes)><printBlockNode(whileNode.joinNode)>
end loop;
>>



///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////
printFunction(procedure, insideIsSchedulable=false) ::= <<
<if (!procedure.native)
><if (procedure.returnType.void)>procedure<else>function<endif> <procedure.name>(<
procedure.parameters: varFunction(); separator="; "
>) <if (!procedure.returnType.void)>return <typeFunction(procedure.returnType)><endif> is
<if(procedure.locals)>
  <procedure.locals: {variable| variable <varFunction(variable)>;}; separator="\n">
<endif>
begin
  <printNodes(procedure.nodes)>end <procedure.name>;<
endif>

>>

varFunction(variable) ::= <%
<if(variable.type.list)>
-- error !!!!! type memory type
<else>
<variable.indexedName> : <typeFunction(variable.type)>
<endif>
%>

typeFunction(type) ::= <%
<if(type.bool)>
std_logic
<elseif(type.int)>
integer
<else>
integer
<endif>
%>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printProcedure(procedure, insideIsSchedulable=false) ::= <<
<printNodes(procedure.nodes)>
>>

printLocals(procedure) ::= <<
<if(procedure.locals)
><procedure.locals: VarDeclaration(); separator="\n"><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Management of Outputs 
///////////////////////////////////////////////////////////////////////////////
OutputsManag() ::= <<
---------------------------------------------------------------------------
-- Transmission manager
---------------------------------------------------------------------------
<actor.outputs: {port|<if(!port.native)><printArbiter(port)><endif>}; separator="\n\n">
>>

// instanciate an arbiter which manage the communication between actors.
printArbiter(port) ::= <<
comArbiter_<port.name> : entity work.comArbiter
generic map (
  width =\> <if(port.type.bool)>(1)<else><port.type.size><endif>)
port map (
  reset_n      =\> reset_n,
  clock        =\> clock,
  actor_data<if(port.type.bool)>(0)<endif>   =\> <port.name>_idata,
  actor_send   =\> <port.name>_isend,
  actor_rdy    =\> <port.name>_rdy,
  network_data<if(port.type.bool)>(0)<endif> =\> <port.name>_data,
  network_send =\> <port.name>_send,
  network_ack  =\> <port.name>_ack);
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Scheduler process
///////////////////////////////////////////////////////////////////////////////
Actor_Scheduler(actor) ::= <<
<actor.simpleName>_scheduler : process(<actor.templateData.signals; wrap, anchor, separator=", ">)
  <actor.actions : { action |<printLocals(action.scheduler)>
variable <action.scheduler.name>_go : std_logic; <action.peekPattern.ports: {port |
variable <action.scheduler.name>_<port.name>_i : <port.type>;}; separator="\n">
}>  --
begin
  <actor.actions: {action|-- test if "<action.name>" action is schedulable
<action.peekPattern.ports: { port |<printRead(procedure=action.scheduler, port=port, variable=action.peekPattern.portToVarMap.(port))>}; separator="\n">
<printProcedure(procedure=action.scheduler, insideIsSchedulable=true)>}; separator="\n">
  --
  -- Test the action's inputs to fire (or not) an action  
  <actor.actions : {action|<action.name>_go \<= '0';}; separator="\n">
  <actor.inputs :{port|<port.name>_ack \<= '0';}; separator="\n">  
<if(actor.fsm)    
>  <printActionFireFSM(actions=actor.actionsOutsideFsm, fsm=actor.fsm)><
else  
>  if <actor.actions: printActionFire(); separator="\n  elsif">
  end if;<
endif>

end process;

>>

// prints the condition on the ack and go signals according to the input and output pattern
printActionFire(action) ::= <<
((isSchedulable_<action.name>_go<action.inputPattern.ports : {port|<if(!port.native)> and <port.name>_send<endif>}>) = '1') then
    <action.name>_go \<= isSchedulable_<action.name>_go<action.outputPattern.ports : {port|<if(!port.native)> and <port.name>_rdy<endif>}>;<
action.inputPattern.ports : {port|<if(!port.native)>
    <port.name>_ack \<= isSchedulable_<action.name>_go<action.outputPattern.ports : {port|<if(!port.native)> and <port.name>_rdy<endif>}>;<endif>
}>
>>

printActionFireFSM(actions, fsm) ::= <<
<if(actions)
>if<printActionFire(actions)>
else
case FSM is
<TransitionFire()>
  end case;
end if;<
else
>case FSM is
<fsm.transitions: TransitionFire(); separator="\n\n">
  end case;<
endif>
>>

TransitionFire(transitions) ::= <<
    when s_<transitions.sourceState.name> =\>
      if <transitions.list: actionFire(); separator="\n      elsif">
      end if;
>>

actionFire(transition) ::= <<
    <printActionFire(transition.action)>
>>



///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Execute process
///////////////////////////////////////////////////////////////////////////////
Actor_Exec(actor) ::= <<
<actor.simpleName>_execute : process (reset_n, clock) is
  <actor.actions: {action |<printLocals(action.body)><
action.inputPattern.ports : { port | 
variable <action.body.name>_<port.name>_i : <port.type>;}><
action.outputPattern.ports: { port | 
variable <action.body.name>_<port.name>_o : <port.type>;}>
}>  --
begin
  if reset_n = '0' then
<if(actor.stateVars)>
    <actor.stateVars: stateConst()>    --
<endif>
    <actor.outputs : port_out_init()>    --
<if(actor.fsm)>
    FSM    \<= s_<actor.fsm.initialState.name>;    --
<endif>
  elsif rising_edge(clock) then
    <actor.outputs: {port|<if(!port.native)>
<port.name>_isend \<= '0';<endif>}>
    <actor.stateVars: resetReadWriteEnable()>
    --  
<if(actor.fsm)>
    <executeCoreFSM(actions=actor.actionsOutsideFsm, fsm=actor.fsm)>
<else>
    <executeCore(actor.actions)>
<endif>
  end if;
end process <actor.simpleName>_execute;

>>

printActionBody(action) ::= <<
<action.inputPattern.ports: { port |<printRead(procedure=action.body, port=port, variable=action.inputPattern.portToVarMap.(port))>}; separator="\n">
<printProcedure(procedure=action.body, insideIsSchedulable=true)><
action.outputPattern.ports: { port |<printWrite(procedure=action.body, port=port, variable=action.outputPattern.portToVarMap.(port))>}; separator="\n">
>>

actionTestScheduler(action) ::= <<
(<action.name>_go = '1') then
  -- body of "<action.name>" action
  <printActionBody(action)><
  action.outputPattern.ports: {port|<if(!port.native)>
  <port.name>_isend \<= '1';<endif>}>

>>

port_out_init(port) ::=<<

<if (port.native)><if(port.type.bool)>
<port.name> \<= 'Z';
<else>
<port.name> \<= (others =\> 'Z');
<endif><else><port.name>_isend \<= '0';
<if(port.type.bool)>
<port.name>_idata \<= '0';
<else>
<port.name>_idata \<= (others =\> '0');
<endif><endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - NO FSM

executeCore(actions) ::= <<
if <actions: actionTestScheduler(); separator="--\nelsif ">--
end if;
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - WITH FSM

executeCoreFSM(actions, fsm) ::= <<
<if(actions)
><executeCore(actions)>
else
case FSM is
  <switchTransition()>
end case;
end if;<
else
>case FSM is
  <fsm.transitions: switchTransition(); separator="\n\n">
end case;<
endif>
>>

switchTransition(transitions) ::= <<
when s_<transitions.sourceState.name> =\>
  if <transitions.list: actionTestState(); separator="\n  elsif">
  end if;
>>

actionTestState(transition) ::= <<
  <actionTestScheduler(transition.action)>    FSM \<= s_<transition.state.name>;
>>



///////////////////////////////////////////////////////////////////////////////
// Print the actor
///////////////////////////////////////////////////////////////////////////////
actor(actor, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Actor: <actor.simpleName>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <actor.name>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------


------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;


------------------------------------------------------------------------------
entity <actor.simpleName> is
  port (
  -- Inputs
  clock    : in  std_logic;
  reset_n  : in  std_logic<if(actor.inputs || actor.outputs)>;<endif>
  <actor.inputs: {port|<printPort(port, "in  ", "out ")>}; separator=";\n"><if(actor.inputs && actor.outputs)>;<endif>
  -- Outputs
  <actor.outputs: {port|<printPort(port, "out ", "in  ")>}; separator=";\n">);
end <actor.simpleName>;


------------------------------------------------------------------------------
architecture rtl_<actor.simpleName> of <actor.simpleName> is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  <actor.actions:       {action| signal <action.name>_go    : std_logic;}; separator="\n">
  --
  <actor.outputs: IOsManagementSignals(); separator="\n">
  --
  <actor.stateVars: signalDeclaration()>

<if (actor.procs)
>  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  <actor.procs: {proc|<printFunction(procedure=proc)>}; separator="\n\n">
<endif>

<if(actor.fsm)
>  ---------------------------------------------------------------------------
  -- FSM
  ---------------------------------------------------------------------------
  type FSM_type is (<actor.fsm.states: {state|s_<state.name>}; separator=", ">);
  signal FSM : FSM_type;
<endif>

begin

  <Actor_Scheduler(actor)>
  
  <Actor_Exec(actor)>

  <OutputsManag()>
  
  <actor.stateVars: ramDeclaration()>

end architecture rtl_<actor.simpleName>;

>>