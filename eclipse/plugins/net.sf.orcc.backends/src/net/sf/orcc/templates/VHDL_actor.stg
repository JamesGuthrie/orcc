///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
portType(port, IOtype, dataType) ::= <<
<if(port.type.bool)
><port.name>_<dataType>  :<IOtype>std_logic;<
else
><port.name>_<dataType>  :<IOtype>std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print instance's ports
///////////////////////////////////////////////////////////////////////////////
PrintInputPorts(port) ::= <<
<portType(port=port, IOtype=" in  ", dataType="data")>
<port.name>_send  : in  std_logic;
<if(last(port.name))
><port.name>_ack   : out  std_logic<
else
><port.name>_ack   : out  std_logic;<
endif>
>>

PrintOutputPorts(port) ::= <<
<portType(port=port, IOtype=" out ", dataType="data")>
<port.name>_send  : out std_logic;
<if(last(port.name))
><port.name>_ack   : in  std_logic<
else
><port.name>_ack   : in  std_logic;<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print signal and constant
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : {value | <value>}; separator=" * ">
>>

// These signals are used by the IOs management processes
IOsManagementSignals(port)::= <<
signal <port.name>_rdy    : std_logic;
signal <port.name>_isend  : std_logic;
signal <portType(port=port, IOtype=" ", dataType="idata")>
>>

signalDeclaration(variable) ::= <<
<if(variable.type.list)>
<if(variable.assignable)>
-- RAM signals for "<variable.name>"
signal <variable.name>_wren_p1       : std_logic;
signal <variable.name>_address_p1    : std_logic_vector(bit_width(<listSize(variable.type.dimensions)>)-1 downto 0);
signal <variable.name>_data_p1       : std_logic_vector(<variable.type.type.size> -1 downto 0);
signal <variable.name>_q_p1          : std_logic_vector(<variable.type.type.size> -1 downto 0);
signal <variable.name>_wren_p2       : std_logic;
signal <variable.name>_address_p2    : std_logic_vector(bit_width(<listSize(variable.type.dimensions)>)-1 downto 0);
signal <variable.name>_data_p2       : std_logic_vector(<variable.type.type.size> -1 downto 0);
signal <variable.name>_q_p2          : std_logic_vector(<variable.type.type.size> -1 downto 0);

<else>
type memory_type_<variable.name> is array (0 to <listSize(variable.type.dimensions)> -1) of <variable.type>;
constant <variable.name> : memory_type_<variable.name><if(variable.initialized)> := <variable.initialValue><endif>;
<endif>
<else>
<if(variable.assignable)>
signal <variable.name> : <variable.type>;
<else>
constant <variable.name> : <variable.type> := <variable.initialValue>;
<endif>
<endif>
>>

ramDeclaration(variable) ::= <<
<if(variable.type.list)>
<if(variable.assignable)>
<if(actor.templateData.customInitMap.(variable))>
-- custom init of arrays not supported
<else>
-- RAM instantiation for "<variable.name>"
DP_genericRam_<variable.name> : entity work.DP_genericRam
  generic map (
    depth =\> <listSize(variable.type.dimensions)>,
    width =\> <variable.type.type.size>,
    initVal =\> <actor.templateData.initValueMap.(variable)>)
  port map (
    clk        =\> clock,
    wren_p1    =\> <variable.name>_wren_p1,
    address_p1 =\> <variable.name>_address_p1,
    data_p1    =\> <variable.name>_data_p1,
    q_p1       =\> <variable.name>_q_p1,
    wren_p2    =\> <variable.name>_wren_p2,
    address_p2 =\> <variable.name>_address_p2,
    data_p2    =\> <variable.name>_data_p2,
    q_p2       =\> <variable.name>_q_p2);

<endif>
<endif>
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print variables
///////////////////////////////////////////////////////////////////////////////
VarDeclaration(variable) ::= <<
<if(variable.type.list)
>-- !! error !! variable <variable.name> tabular type size = <listSize(variable.type.dimensions)> of <variable.type>;<
else
>variable <variable.indexedName> : <variable.type>;<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Init at reset
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
<if(variable.assignable)>
<if(variable.type.list)>
--
<variable.name>_wren_p1    \<= '0';
<variable.name>_address_p1 \<= (others =\> '0');
<variable.name>_data_p1    \<= (others =\> '0');
<variable.name>_wren_p2    \<= '0';
<variable.name>_address_p2 \<= (others =\> '0');
<variable.name>_data_p2    \<= (others =\> '0');
--
<elseif(variable.initialized)>
<variable.name> \<= <variable.initialValue>;
<endif>
<endif>
>>

resetReadWriteEnable(variable) ::= <<
<if(variable.assignable && variable.type.list)>
<variable.name>_wren_p1 \<= '0';
<variable.name>_wren_p2 \<= '0';
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print cast operations (when source.size != target.size)
///////////////////////////////////////////////////////////////////////////////
CastStore(targetName, targetType, value, cast)::= <<
<if(cast.extended)
><targetName> := <value><
else
><if(targetType.uint)
><targetName> := ucast(<value>, <value.type.size>, <targetType.size>)<  
  else
><targetName> := cast(<value>, <value.type.size>, <targetType.size>)<  
  endif><
endif>
>>

CastLoad(targetName, targetType, source, cast)::= <<
<if(cast.extended)
><targetName> := <source><
else
><if(targetType.uint)
><targetName> := ucast(<source>, <source.type.size>, <targetType.size>)<
  else
><targetName> := cast(<source>, <source.type.size>, <targetType.size>)<
  endif><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<
<if (assign.cast)
><CastStore(targetName=assign.target.variable.indexedName, targetType=assign.target.variable.type, value=assign.value, cast=assign.cast)>;<
else
><assign.target.variable.indexedName> := <assign.value>;<
endif>
>>

printAssignIndex(assignIndex) ::= <<
<assignIndex.target.variable.indexedName> := to_integer(unsigned(<assignIndex.indexes: {index | std_logic_vector(to_unsigned(<index>, <index.type.size>))}; separator=" & ">));
>>

printCall(call) ::= <<
<if(call.target)
><call.target.variable.indexedName> := <call.procedure.name>(<call.procedure.loadedVariables: {var | <var>, }><call.parameters: {param | <param>, }>'1');<
elseif(call.parameters)
><call.procedure.name>(<call.parameters; separator=", ">, '1');<
else
><call.procedure.name>('1');<
endif>
>>

getPort(variable) ::= <<
<if (action.inputPattern.inverseVariableMap.(variable))
><action.inputPattern.inverseVariableMap.(variable).name><
else
><action.outputPattern.inverseVariableMap.(variable).name><
endif>
>>

getPortType(variable) ::= <<
<if (action.inputPattern.inverseVariableMap.(variable))
><action.inputPattern.inverseVariableMap.(variable).type><
else
><action.outputPattern.inverseVariableMap.(variable).type><
endif>
>>

printLoad(load) ::= <<
<if(load.indexes)
><if (action.inputPattern.inverseVariableMap.(load.source.variable) || action.outputPattern.inverseVariableMap.(load.source.variable))
><if(load.cast)><CastLoad(targetName=load.target.variable.indexedName, targetType=load.target.variable.type, source={<procedure.name>_<getPort(load.source.variable)>}, cast=load.cast)>;<
else><load.target.variable.indexedName> := <procedure.name>_<getPort(load.source.variable)>;<
endif
><else><load.target.variable.indexedName> := <load.source.variable.name>(<load.indexes : {index | <index>}; separator=", ">);<
endif
><else><load.target.variable.indexedName> := <load.source.variable.name>;<endif>
>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
printReturn(return) ::= <<
<if(return.value)
 ><if(transformReturn)
   ><procedure.name>_go := <return.value>;<
  else
   >return <return.value>;<
  endif><
endif>
>>

printStore(store) ::= <<
<if(store.indexes)
 ><if(action.inputPattern.inverseVariableMap.(store.target.variable) || action.outputPattern.inverseVariableMap.(store.target.variable))
  ><if(store.cast)
    ><CastStore(value=store.value, targetName={<procedure.name>_<getPort(store.target.variable)>}, targetType={<getPortType(store.target)>}, cast=store.cast)>;<
   else
    ><procedure.name>_<getPort(store.target.variable)> := <store.value>;<
   endif><
  else
   ><store.target.variable.name>(<store.indexes : {index | <index>}; separator=", ">) \<= <store.value>;<
  endif><
else
 ><store.target.variable.name> \<= <store.value>;<
endif>
>>

/////////////////////
// port read/write //

printRead(procedure, port, variable) ::= <<
<if(variable)
><if(port.type.bool)
><procedure.name>_<variable.name> := <port.name>_data;<
elseif(port.type.int)
><procedure.name>_<variable.name> := to_integer(signed(<port.name>_data));<
elseif(port.type.uint)
><procedure.name>_<variable.name> := to_integer(unsigned(<port.name>_data));<
endif
><endif>
>>

printWrite(procedure, port, variable) ::= <<
<if(port.type.bool)
><port.name>_idata \<= <procedure.name>_<variable.name>;<
elseif(port.type.int)
><port.name>_idata \<= std_logic_vector(to_signed(<procedure.name>_<variable.name>, <port.type.size>));<
else
><port.name>_idata \<= std_logic_vector(to_unsigned(<procedure.name>_<variable.name>, <port.type.size>));<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// RAM
///////////////////////////////////////////////////////////////////////////////

printRamRead(ramRead) ::= <<
<ramRead.target.name> := <if(ramRead.variable.type.type.bool)
><ramRead.value>;<
elseif(ramRead.variable.type.type.int)
>to_integer(signed(<ramRead.variable.name>_q_p<ramRead.port>));<
else
>to_integer(unsigned(<ramRead.variable.name>_q_p<ramRead.port>));<
endif>
>>

printRamWrite(ramWrite) ::= <<
<ramWrite.variable.name>_data_p<ramWrite.port> \<= <
if(ramWrite.variable.type.type.bool)
><ramWrite.value>;
<elseif(ramWrite.variable.type.type.int)
>std_logic_vector(to_signed(<ramWrite.value>, <ramWrite.variable.type.type.size>));
<else
>std_logic_vector(to_unsigned(<ramWrite.value>, <ramWrite.variable.type.type.size>));
<endif>
<ramWrite.variable.name>_wren_p<ramWrite.port> \<= '1';
>>

printRamSetAddress(ramSetAddress) ::= <<
<ramSetAddress.variable.name>_address_p<ramSetAddress.port> \<= <ramSetAddress.indexes, ramSetAddress.indexesSizes: {index, size | std_logic_vector(to_unsigned(<index>, <size>))}; separator=" & ">;
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////
printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.assignIndex)><printAssignIndex(assignIndex=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
elseif (instr.ramRead)><printRamRead(ramRead=instr)><
elseif (instr.ramWrite)><printRamWrite(ramWrite=instr)><
elseif (instr.ramSetAddress)><printRamSetAddress(ramSetAddress=instr)><
endif>}; separator="\n">
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// if node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.condition>) then
  <printNodes(ifNode.thenNodes)><if(ifNode.elseNodes)>
else
  <printNodes(ifNode.elseNodes)>
end if;
<endif>
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.condition>) loop
  <printNodes(whileNode.nodes)><printBlockNode(whileNode.joinNode)>
end loop;
>>



///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////
function(procedure) ::= <<
<if (!procedure.native)
  ><if (procedure.returnType.void)
>procedure <procedure>(<printParameters(procedure.parameters)>dummy : std_logic) is
<else
>function <procedure>(<VarUsed(procedure)><printParameters(procedure)>dummy : std_logic) <returnFunction(procedure.returnType)> is
<endif>
  <if(procedure.locals)
><procedure.locals: {variable| <VarInFctDeclaration(variable)>;<\n>}><
  endif>
begin
  <printNodes(procedure.nodes)>
end <procedure>;<
endif>

>>

VarUsed(procedure) ::= <<
<procedure.loadedVariables: functionParameter(); wrap>
>>

printParameters(procedure) ::= <<
<procedure.parameters: functionParameter()>
>>

functionParameter(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! type memory type<
else
><variable.name> : <typeFunction(variable.type)>; <
endif
>
>>

VarInFctDeclaration(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! type memory_type<
else
>variable <variable.name> : <typeFunction(variable.type)><
endif>
>>


returnFunction(type) ::= <<
<if(type.bool)
>return std_logic<
elseif(type.int)
>return integer<
endif>
>>

typeFunction(type) ::= <<
<if(type.bool)
>std_logic<
elseif(type.int)
>integer<
else
>integer<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printProcedure(procedure, transformReturn) ::= <<
<printNodes(procedure.nodes)>
>>

printLocals(procedure) ::= <<
<if(procedure.locals)
><procedure.locals: VarDeclaration(); separator="\n"><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Management of Outputs 
///////////////////////////////////////////////////////////////////////////////
OutputsManag() ::= <<
---------------------------------------------------------------------------
-- Transmission manager
---------------------------------------------------------------------------
<actor.outputs : printArbiter(); separator="\n\n">
>>

// instanciate an arbiter which manage the communication between actors.
printArbiter(port) ::= <<
comArbiter_<port.name> : entity work.comArbiter
generic map (
  width =\> <if(port.type.bool)>(1)<else><port.type.size><endif>)
port map (
  reset_n      =\> reset_n,
  clock        =\> clock,
  actor_data<if(port.type.bool)>(0)<endif>   =\> <port.name>_idata,
  actor_send   =\> <port.name>_isend,
  actor_rdy    =\> <port.name>_rdy,
  network_data<if(port.type.bool)>(0)<endif> =\> <port.name>_data,
  network_send =\> <port.name>_send,
  network_ack  =\> <port.name>_ack);
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Scheduler process
///////////////////////////////////////////////////////////////////////////////
Actor_Scheduler(actor) ::= <<
<actor.simpleName>_scheduler : process(<actor.templateData.signals; wrap, anchor, separator=", ">)
  <actor.actions : { action |<printLocals(action.scheduler)>
variable <action.scheduler.name>_go : std_logic; <action.inputPattern.ports: {port | <if(action.inputPattern.peekedMap.(port))>
variable <action.scheduler.name>_<port.name> : <port.type>;<
endif>}; separator="\n">
}>  --
begin
  <actor.actions: {action|-- test if "<action.name>" action is schedulable
<action.inputPattern.ports: { port |<printRead(procedure=action.scheduler, port=port, variable=action.inputPattern.peekedMap.(port))>}; separator="\n">
<printProcedure(procedure=action.scheduler, transformReturn="true")>}; separator="\n\n">

  --
  -- Test the action's inputs to fire (or not) an action  
  <actor.actions : {action|<action.name>_go \<= '0';}; separator="\n">
  <actor.inputs :{port|<port.name>_ack \<= '0';}; separator="\n">  
<if(actor.fsm)    
>  <printActionFireFSM(actions=actor.actionsOutsideFsm, fsm=actor.fsm)><
else  
>  if <actor.actions: printActionFire(); separator="\n  elsif">
  end if;<
endif>

end process;

>>

// prints the condition on the ack and go signals according to the input and output pattern
printActionFire(action) ::= <<
((isSchedulable_<action.name>_go <action.inputPattern.ports : {port| and <port.name>_send }>) = '1') then
<if(action.inputPattern.ports)
>< if(action.outputPattern.ports)
>    <action.name>_go \<= isSchedulable_<action.name>_go and <action.outputPattern.ports : {port|<port.name>_rdy}; separator=" and ">;
    <action.inputPattern.ports : {
      port|<port.name>_ack \<= isSchedulable_<action.name>_go and <action.outputPattern.ports : {port|<port.name>_rdy}; separator=" and ">} ; separator=";\n">;<
  else
>    <action.name>_go \<= isSchedulable_<action.name>_go;
    <action.inputPattern.ports : {port|<port.name>_ack \<= isSchedulable_<action.name>_go;} ; separator="\n"><
  endif><
else
>< if(action.outputPattern.ports)
>    <action.name>_go \<= isSchedulable_<action.name>_go and <action.outputPattern.ports : {port|<port.name>_rdy}; separator=" and ">;<
  else
>    <action.name>_go \<= isSchedulable_<action.name>_go;<
  endif><
endif>  
>>

printActionFireFSM(actions, fsm) ::= <<
<if(actions)
>if<printActionFire(actions)>
else
case FSM is
<TransitionFire()>
  end case;
end if;<
else
>case FSM is
<fsm.transitions: TransitionFire(); separator="\n\n">
  end case;<
endif>
>>

TransitionFire(transition) ::= <<
    when s_<transition.sourceState> =\>
      if <transition.nextStateInfo: actionFire(); separator="\n      elsif">
      end if;
>>

actionFire(nextstate) ::= <<
    <printActionFire(nextstate.action)>
>>



///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Execute process
///////////////////////////////////////////////////////////////////////////////
Actor_Exec(actor) ::= <<
<actor.simpleName>_execute : process (reset_n, clock) is
  <actor.actions: {action |<printLocals(action.body)><
action.inputPattern.ports : { port | 
variable <action.body.name>_<port.name> : <port.type>;}><
action.outputPattern.ports: { port | 
variable <action.body.name>_<port.name> : <port.type>;}>
}>  --
begin
  if reset_n = '0' then
<if(actor.stateVars)>
    <actor.stateVars: stateConst()>    --
<endif>
    <actor.outputs : port_out_init()>    --
<if(actor.fsm)>
    FSM    \<= s_<actor.fsm.initialState>;    --
<endif>
  elsif rising_edge(clock) then
    <actor.outputs :{port|<port.name>_isend \<= '0';}; separator="\n">
    <actor.stateVars: resetReadWriteEnable()>
    --  
<if(actor.fsm)>
    <executeCoreFSM(actions=actor.actionsOutsideFsm, fsm=actor.fsm)>
<else>
    <executeCore(actor.actions)>
<endif>
  end if;
end process <actor.simpleName>_execute;

>>

printActionBody(action) ::= <<
<action.inputPattern.ports: { port |<printRead(procedure=action.body, port=port, variable=action.inputPattern.variableMap.(port))>}; separator="\n">
<printProcedure(procedure=action.body, transformReturn="true")><
action.outputPattern.ports: { port |<printWrite(procedure=action.body, port=port, variable=action.outputPattern.variableMap.(port))>}; separator="\n">
>>

actionTestScheduler(action) ::= <<
(<action.name>_go = '1') then
  -- body of "<action.name>" action
  <printActionBody(action)><
  if(action.outputPattern.ports)>
  <action.outputPattern.ports: {port|<port.name>_isend \<= '1';}; separator="\n">
  <endif>
>>

port_out_init(port) ::=<<

<port.name>_isend \<= '0';
<if(port.type.bool)>
<port.name>_idata \<= '0';
<else>
<port.name>_idata \<= (others =\> '0');
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - NO FSM

executeCore(actions) ::= <<
if <actions: actionTestScheduler(); separator="--\nelsif ">--
end if;
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - WITH FSM

executeCoreFSM(actions, fsm) ::= <<
<if(actions)
><executeCore(actions)>
else
case FSM is
  <switchTransition()>
end case;
end if;<
else
>case FSM is
  <fsm.transitions: switchTransition(); separator="\n\n">
end case;<
endif>
>>

switchTransition(transition) ::= <<
when s_<transition.sourceState> =\>
  if <transition.nextStateInfo: actionTestState(); separator="\n      elsif">
  end if;
>>

actionTestState(nextState) ::= <<
    <actionTestScheduler(nextState.action)>      FSM \<= s_<nextState.targetState>;
>>



///////////////////////////////////////////////////////////////////////////////
// Print the actor
///////////////////////////////////////////////////////////////////////////////
actor(actor, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Actor: <actor.simpleName>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <actor.name>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------


------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;


------------------------------------------------------------------------------
entity <actor.simpleName> is
  port (
  -- Inputs
  clock    : in  std_logic;
  reset_n  : in  std_logic<if(actor.inputs || actor.outputs)>;<endif>
  <actor.inputs: PrintInputPorts(); separator=";\n"><if(actor.inputs && actor.outputs)>;<endif>
  -- Outputs
  <actor.outputs: PrintOutputPorts(); separator=";\n">);
end <actor.simpleName>;


------------------------------------------------------------------------------
architecture rtl_<actor.simpleName> of <actor.simpleName> is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  <actor.actions:       {action| signal <action.name>_go    : std_logic;}; separator="\n">
  --
  <actor.outputs :IOsManagementSignals(); separator="\n">
  --
  <actor.stateVars: signalDeclaration()>

<if (actor.procs)
>  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  <actor.procs: {proc|<function(procedure=proc)>}; separator="\n\n"><
endif>

<if(actor.fsm)
>  ---------------------------------------------------------------------------
  -- FSM
  ---------------------------------------------------------------------------
  type FSM_type is (<actor.fsm.states: {state|s_<state>}; separator=", ">);
  signal FSM : FSM_type;
<endif>

begin

  <Actor_Scheduler(actor)>
  
  <Actor_Exec(actor)>

  <OutputsManag()>
  
  <actor.stateVars: ramDeclaration()>

end architecture rtl_<actor.simpleName>;

>>