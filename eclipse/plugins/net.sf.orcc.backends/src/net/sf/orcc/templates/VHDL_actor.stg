///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
portType(port, IOtype, dataType) ::= <<
<if(port.type.bool)
><port.name>_<dataType>  :<IOtype>std_logic;<
else
><port.name>_<dataType>  :<IOtype>std_logic_vector(<port.type.size> -1 downto 0);<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print instance's ports
///////////////////////////////////////////////////////////////////////////////
PrintInputPorts(port) ::= <<
<portType(port=port, IOtype=" in  ", dataType="data")>
<port.name>_send  : in  std_logic;
<if(last(port.name))
><port.name>_ack   : out  std_logic<
else
><port.name>_ack   : out  std_logic;<
endif>
>>

PrintOutputPorts(port) ::= <<
<portType(port=port, IOtype=" out ", dataType="data")>
<port.name>_send  : out std_logic;
<if(last(port.name))
><port.name>_ack   : in  std_logic<
else
><port.name>_ack   : in  std_logic;<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print signal and constant
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty
listSize(values) ::= <<
<values : {value | <value>}; separator=" * ">
>>

// These signals are used by the IOs management processes
IOsManagementSignals(port)::= <<
signal <port.name>_rdy    : std_logic;
signal <port.name>_isend  : std_logic;
signal <portType(port=port, IOtype=" ", dataType="idata")>
>>

signalDeclaration(variable) ::= <<
<if(!variable.type.list)
 ><if(variable.assignable)
    >signal <variable> : <variable.type>;
  <else
    >constant <variable> : <variable.type> := <variable.initialValue>;
  <endif><
else
  >type memory_type_<variable> is array (0 to <listSize(variable.type.dimensions)> -1) of <variable.type>;<\n><
  if(variable.assignable)
    >signal <variable> : memory_type_<variable> <if(variable.initialized)>:= <variable.initialValue><endif>;
  <else
    >constant <variable> : memory_type_<variable> <if(variable.initialized)>:= <variable.initialValue><endif>;
  <endif>
<endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print variables
///////////////////////////////////////////////////////////////////////////////
VarDeclaration(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! variable <variable.name> : <variable.type> (0 to <listSize(variable.type.dimensions)> -1)<
else
>variable <variable.name> : <variable.type><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Init at reset
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
<if(variable.initialized && variable.assignable &&!variable.type.list)>
    <variable> \<= <variable.initialValue>;
<endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Print cast operations (when source.size != target.size)
///////////////////////////////////////////////////////////////////////////////
CastStore(target, value, cast)::= <<
<if(cast.extended)
><target> := <value><
else
><if(target.type.uint)
><target> := ucast(<value>, <value.type.size>, <target.type.size>)<  
  else
><target> := cast(<value>, <value.type.size>, <target.type.size>)<  
  endif><
endif>
>>

CastLoad(target, source, cast)::= <<
<if(cast.extended)
><target> := <source><
else
><if(target.type.uint)
><target> := ucast(<source>, <source.type.size>, <target.variable.type.size>)<
  else
><target> := cast(<source>, <source.type.size>, <target.variable.type.size>)<
  endif><
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////
printAssign(assign) ::= <<

<if (assign.cast)
><CastStore(target=assign.target, value=assign.value, cast=assign.cast)>;<
else
><assign.target> := <assign.value>;<
endif
>
>>

printAssignIndex(assignIndex) ::= <<

<assignIndex.target> := to_integer(unsigned(<assignIndex.indexes: {index | std_logic_vector(to_unsigned(<index>, <index.type.size>))}; separator=" & ">));
>>

printCall(call) ::= <<

<if(call.target)
><call.target> := <call.procedure>(<call.procedure.loadedVariables: {var | <var>, }><call.parameters: {param | <param>, }>'1');<
elseif(call.parameters)
><call.procedure>(<call.parameters; separator=", ">, '1');<
else
><call.procedure>('1');<
endif>
>>

getPort(variable) ::= <<
<if (action.inputPattern.inverseVariableMap.(variable))
><action.inputPattern.inverseVariableMap.(variable).name><
else
><action.outputPattern.inverseVariableMap.(variable).name><
endif>
>>

printLoad(load) ::= <<

<if(load.indexes)
><if (action.inputPattern.inverseVariableMap.(load.source.variable) || action.outputPattern.inverseVariableMap.(load.source.variable))
  ><if(load.cast)
     ><CastLoad(target=load.target, source={<procedure.name>_<getPort(load.source.variable)>}, cast=load.cast)>;<
    else
     ><load.target> := <procedure.name>_<getPort(load.source.variable)>;<
    endif><
  else
   ><load.target> := <load.source>(<load.indexes : {index | <index>}; separator=", ">);<
  endif><
else
><load.target> := <load.source>;<
endif>
>>

printPeek(peek) ::= <<

<if(peek.unit)
  ><if(peek.target.type.bool)
     ><procedure.name>_<peek.target> := <peek.port>_data;<
    else
     ><if(peek.target.type.int)
        ><procedure.name>_<peek.target> := to_integer(signed(<peek.port>_data));<
       else
        ><procedure.name>_<peek.target> := to_integer(unsigned(<peek.port>_data));<
       endif><
    endif><
else
  >-- peek multiple token not coded yet<
endif
>

>>

printRead(read) ::= <<

<if(read.unit)
  ><if(read.target.type.bool)
     ><procedure.name>_<read.target> := <read.port>_data;<
   elseif(read.target.type.int)
     ><procedure.name>_<read.target> := to_integer(signed(<read.port>_data));<
   elseif (read.target)
     ><procedure.name>_<read.target> := to_integer(unsigned(<read.port>_data));<
   endif><
else
  >-- read multiple token not coded yet<
endif>
>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
printReturn(return) ::= <<

<if(return.value)
><  if(transformReturn)
><procedure>_go := <return.value>;<
  else
>return <return.value>;<
  endif><
endif>
>>

printStore(store) ::= <<

<if(store.indexes)
 ><if (action.inputPattern.inverseVariableMap.(store.target) || action.outputPattern.inverseVariableMap.(store.target))
  ><if(store.cast)
      ><CastStore(value=store.value, target={<procedure.name>_<getPort(store.target)>}, cast=store.cast)>;<
     else
      ><procedure.name>_<getPort(store.target)> := <store.value>;<
     endif><
   else
    ><store.target>(<store.indexes : {index | <index>}; separator=", ">) \<= <store.value>;<
   endif><
else
 ><store.target> \<= <store.value>;<
endif>
>>

printWrite(write) ::= <<

<if(write.target.type.bool)
><write.port>_idata \<= <write.target>;<
elseif(write.target.type.int)
><write.port>_idata \<= std_logic_vector(to_signed(<write.target>, <write.port.type.size>));<
else
><write.port>_idata \<= std_logic_vector(to_unsigned(<write.target>, <write.port.type.size>));<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////
printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.assignIndex)><printAssignIndex(assignIndex=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.peek)><printPeek(peek=instr)><
elseif (instr.read)><printRead(read=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
elseif (instr.write)><printWrite(write=instr)><
endif>}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// if node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.value>) then
  <printNodes(ifNode.thenNodes)><if(ifNode.elseNodes)>
else
  <printNodes(ifNode.elseNodes)>
end if;<endif>
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.value>) loop
  <printNodes(whileNode.nodes)><printBlockNode(whileNode.joinNode)>
end loop;
>>



///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////
function(procedure) ::= <<
<if (!procedure.native)
  ><if (procedure.returnType.void)
>procedure <procedure>(<printParameters(procedure.parameters.list)>dummy : std_logic) is
<else
>function <procedure>(<VarUsed(procedure)><printParameters(procedure)>dummy : std_logic) <returnFunction(procedure.returnType)> is
<endif>
  <if(procedure.locals.list)
><procedure.locals.list: {variable| <VarInFctDeclaration(variable)>;<\n>}><
  endif>
begin
  <printNodes(procedure.nodes)>
end <procedure>;<
endif>

>>

VarUsed(procedure) ::= <<
<procedure.loadedVariables: functionParameter(); wrap>
>>

printParameters(procedure) ::= <<
<procedure.parameters.list: functionParameter()>
>>

functionParameter(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! type memory type<
else
><variable.name> : <typeFunction(variable.type)>; <
endif
>
>>

VarInFctDeclaration(variable) ::= <<
<if(variable.type.list)
>-- error !!!!! type memory_type<
else
>variable <variable.name> : <typeFunction(variable.type)><
endif>
>>


returnFunction(type) ::= <<
<if(type.bool)
>return std_logic<
elseif(type.int)
>return integer<
endif>
>>

typeFunction(type) ::= <<
<if(type.bool)
>std_logic<
elseif(type.int)
>integer<
else
>integer<
endif>
>>



///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
printProcedure(procedure, transformReturn) ::= <<
<printNodes(procedure.nodes)>
>>

printLocals(procedure) ::= <<
<if(procedure.locals.list)
><procedure.locals.list: {variable| <VarDeclaration(variable)>;<\n>}><
endif>
>>

// prints the body of the given action "inline" (ie not within a function)
printActionBodyInline(action) ::= <<
<printProcedure(procedure=action.body, transformReturn="true")>
>>



///////////////////////////////////////////////////////////////////////////////
// Management of Outputs 
///////////////////////////////////////////////////////////////////////////////
OutputsManag() ::= <<
---------------------------------------------------------------------------
-- Transmission manager
---------------------------------------------------------------------------
<actor.outputs.list : printArbiter(); separator="\n\n">
>>

// instanciate an arbiter which manage the communication between actors.
printArbiter(port) ::= <<
comArbiter_<port.name> : entity work.comArbiter
generic map (
  width =\> <if(port.type.bool)>(1)<else><port.type.size><endif>)
port map (
  reset_n      =\> reset_n,
  clock        =\> clock,
  actor_data<if(port.type.bool)>(0)<endif>   =\> <port.name>_idata,
  actor_send   =\> <port.name>_isend,
  actor_rdy    =\> <port.name>_rdy,
  network_data<if(port.type.bool)>(0)<endif> =\> <port.name>_data,
  network_send =\> <port.name>_send,
  network_ack  =\> <port.name>_ack);
>>


///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Scheduler process
///////////////////////////////////////////////////////////////////////////////
Actor_Scheduler(actor) ::= <<
<actor.simpleName>_scheduler : process(<sensitivity(actor)>)
  <actor.actions : { action |<printLocals(action.scheduler)>
variable <action.scheduler>_go : std_logic;
<action.inputPattern.ports: { port |<if(action.inputPattern.peekedMap.(port))>variable <action.scheduler.name>_<port.name> : <port.type>;
<endif>}>
}>--
begin
  <actor.actions: {action|-- test if "<action>" action is schedulable
<printProcedure(procedure=action.scheduler, transformReturn="true")>}; separator="\n\n">

  --
  -- Test the action's inputs to fire (or not) an action  
  <actor.actions : {actions|<actions>_go \<= '0';}; separator="\n">
  <actor.inputs.list :{port|<port.name>_ack \<= '0';}; separator="\n">  
<if(actor.actionScheduler.fsm)    
>  <printActionFireFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)><
else  
>  if <actor.actions: printActionFire(); separator="\n  elsif">
  end if;<
endif>

end process;

>>

// print the sensitivity list of the actor
sensitivity(actor) ::= <<
<actor.inputs.list: {port|<port.name>_send}; separator=", "><
if(actor.inputs.list)
><if(actor.outputs.list || actor.templateData || actor.actionScheduler.fsm)
>, <
endif><
endif
><actor.outputs.list: {port|<port.name>_rdy}; separator=", "><
if(actor.outputs.list)
><if(actor.actionScheduler.fsm || actor.templateData || actor.actionScheduler.fsm)
>, <
endif><
endif
><actor.templateData: {d|<d>}; separator=", "><
if(actor.templateData && actor.actionScheduler.fsm)    
>, FSM<
elseif(actor.actionScheduler.fsm)
>FSM<
endif>
>>

// prints the condition on the ack and go signals according to the input and output pattern
printActionFire(action) ::= <<
((isSchedulable_<action>_go <action.inputPattern.keys : {port| and <port.name>_send }>) = '1') then
<if(action.inputPattern.keys)
>< if(action.outputPattern.keys)
>    <action>_go  \<= isSchedulable_<action>_go and <action.outputPattern.keys : {port|<port.name>_rdy}; separator=" and ">;
    <action.inputPattern.keys : {
      port|<port.name>_ack \<= isSchedulable_<action>_go and <action.outputPattern.keys : {port|<port.name>_rdy}; separator=" and ">} ; separator=";\n">;<
  else
>    <action>_go  \<= isSchedulable_<action>_go;
    <action.inputPattern.keys : {port|<port.name>_ack \<= isSchedulable_<action>_go;} ; separator="\n"><
  endif><
else
>< if(action.outputPattern.keys)
>    <action>_go  \<= isSchedulable_<action>_go and <action.outputPattern.keys : {port|<port.name>_rdy}; separator=" and ">;<
  else
>    <action>_go  \<= isSchedulable_<action>_go;<
  endif><
endif>  
>>

printActionFireFSM(actions, fsm) ::= <<
<if(actions)
>if<printActionFire(actions)>
else
  case FSM is
  <TransitionFire()>
      end case;
end if;<
else
>  case FSM is
<fsm.transitions: TransitionFire(); separator="\n\n">
  end case;<
endif>
>>

TransitionFire(transition) ::= <<
    when s_<transition.sourceState> =\>
      if <transition.nextStateInfo: actionFire(); separator="\n      elsif">
      end if;
>>

actionFire(nextstate) ::= <<
    <printActionFire(nextstate.action)>
>>



///////////////////////////////////////////////////////////////////////////////
// Actor VHDL Architecture - Execute process
///////////////////////////////////////////////////////////////////////////////
Actor_Exec(actor) ::= <<
<actor.simpleName>_execute : process (reset_n, clock) is
  <actor.actions: {action |<printLocals(action.body)>
<action.inputPattern.ports: { port |variable <action.body.name>_<port.name> : <port.type>;}>
<action.outputPattern.ports: { port |variable <action.body.name>_<port.name> : <port.type>;}>
}>  --
begin
  if reset_n = '0' then
<if(actor.stateVars.list)
><actor.stateVars.list: stateConst()>    --<
endif>
    <actor.outputs.list : port_out_init()>
<if(actor.actionScheduler.fsm)    
>    FSM    \<= s_<actor.actionScheduler.fsm.initialState>;
<
endif>  --
  elsif rising_edge(clock) then
    <actor.outputs.list :{port|<port.name>_isend \<= '0';}; separator="\n">
    --  
<if(actor.actionScheduler.fsm)    
>    <executeCoreFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)><
else
>    <executeCore(actor.actions)><
endif>

  end if;
end process <actor.simpleName>_execute;

>>

actionTestScheduler(action) ::= <<
(<action>_go = '1') then
  -- body of "<action>" action
  <printActionBodyInline(action)>  --<actor.outputs.list: writeManagement()>
>>

writeManagement(port) ::= <<
<if(action.outputPattern.(port))
>
  <port.name>_isend \<= '1';<
endif>
>>

port_out_init(port) ::=<<

<port.name>_isend \<= '0';
<if(port.type.bool)
><port.name>_idata  \<= '0';<
else
><port.name>_idata  \<= (others =\> '0');<
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - NO FSM

executeCore(actions) ::= <<
    if <executeIndent(actions)>
>>

// just to have a correct indentation
executeIndent(actions) ::= <<
    <actions: actionTestScheduler(); separator="\nelsif ">
    end if;
>>

///////////////////////////////////////////////////////////////////////////////
// Core of an action - WITH FSM

executeCoreFSM(actions, fsm) ::= <<
<if(actions)
><executeCore(actions)>
else
  case FSM is
  <switchTransition()>
      end case;
end if;<
else
>    case FSM is
  <fsm.transitions: switchTransition(); separator="\n\n">
    end case;<
endif>
>>

switchTransition(transition) ::= <<
    when s_<transition.sourceState> =\>
      if <transition.nextStateInfo: actionTestState(); separator="\n      elsif">
      end if;
>>

actionTestState(nextState) ::= <<
      <actionTestScheduler(nextState.action)>
        FSM \<= s_<nextState.targetState>;
>>



///////////////////////////////////////////////////////////////////////////////
// Print the actor
///////////////////////////////////////////////////////////////////////////////
actor(actor, options) ::= <<
-------------------------------------------------------------------------------
-- Title      : Actor: <actor.simpleName>
-- Project    : 
-------------------------------------------------------------------------------
-- File       : <actor.name>.vhd
-- Author     : Orcc - VHDL
-- Company    : 
-- Created    : 
-- Standard   : VHDL'93
-------------------------------------------------------------------------------
-- Copyright (c)  
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 
-------------------------------------------------------------------------------


------------------------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;


------------------------------------------------------------------------------
entity <actor.simpleName> is
  port (
  -- Inputs
  clock    : in  std_logic;
  reset_n  : in  std_logic<if(actor.inputs.list || actor.outputs.list)>;<endif>
  <actor.inputs.list: PrintInputPorts(); separator=";\n"><if(actor.inputs.list && actor.outputs.list)>;<endif>
  -- Outputs
  <actor.outputs.list: PrintOutputPorts(); separator=";\n">);
end <actor.simpleName>;


------------------------------------------------------------------------------
architecture rtl_<actor.simpleName> of <actor.simpleName> is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  ---------------------------------------------------------------------------
  <actor.actions:       {action| signal <action>_go    : std_logic;}; separator="\n">
  --
  <actor.outputs.list :IOsManagementSignals(); separator="\n">
  --
  <actor.stateVars.list: signalDeclaration()>

<if (actor.procs.list)
>  ---------------------------------------------------------------------------
  -- Functions and procedures
  ---------------------------------------------------------------------------
  <actor.procs.list: {proc|<function(procedure=proc)>}; separator="\n\n"><
endif>

  <if(actor.actionScheduler.fsm)
  >  ---------------------------------------------------------------------------
  -- FSM
  ---------------------------------------------------------------------------
  type FSM_type is (<actor.actionScheduler.fsm.states: {state|s_<state>}; separator=", ">);
  signal FSM : FSM_type;<
  endif>


begin

  <Actor_Scheduler(actor)>
  
  <Actor_Exec(actor)>

  <OutputsManag()>

end architecture rtl_<actor.simpleName>;

>>