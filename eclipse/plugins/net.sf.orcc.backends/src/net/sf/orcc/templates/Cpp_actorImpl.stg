import "net/sf/orcc/templates/C_actor.stg"

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(values) ::= <<
<values : {value | [<value>]} >
>>

// the values of a list: {val1, val2, ..., valn}
listValue(values) ::= <<
{<values; wrap, separator=", ">}
>>

variableDeclaration(variable) ::= <<
<variable.type> <variable.indexedName><listSize(variable.type.dimensions)>
>>

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

Constant(constant) ::= <<
<if (constant.booleanExpr)><printBool(constant)><
elseif (constant.intExpr)><printInt(constant)><
elseif (constant.listExpr)><printList(constant)><
elseif (constant.stringExpr)><printString(constant)><
endif>
>>


printBool(constant) ::= <<
<if (constant.value)>true<else>false<endif>
>>

printInt(number) ::= <<
<number><if (number.long)>L<endif>
>>

// the values of a list: {val1, val2, ..., valn}
printList(constant) ::= <<
{<constant.value: Constant(); wrap, separator=", ">}
>>

printString(constant) ::= <<
"<constant>"
>>


///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

defineConstantVars(variables) ::= <<
namespace
{
	<variables:defineConstantVar()>}
>>

defineConstantVar(variable) ::= <<
<if(!variable.assignable)>
const <variableDeclaration(variable)> = <Constant(variable.initialValue)>;<\n><endif>
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
StateVarAllocation(variable) ::= <<
<if(variable.assignable)>
<if (variable.type.dimensionsExpr)>
<variable.indexedName>(new <variable.type><listSize(variable.type.dimensions)>),
<else>
<if (variable.initialized)>
<variable.indexedName>(<Constant(variable.initialValue)>),
<endif>
<endif>
<endif>

>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
StateVarDestruction(variable) ::= <<
<if(variable.assignable)><if (variable.type.dimensions)>delete [] <variable.indexedName>;<endif><endif>
>>


///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
ListStateVarInitialization(variable) ::= <<
<if(variable.assignable)>
<if (variable.type.dimensions)>
<if (variable.initialized)>
const <variable.type> tmp_<variable>[<variable.type.dimensions>] = <Constant(variable.initialValue)>;
memcpy(<variable>, tmp_<variable>, <variable.type.dimensions> * sizeof(<variable.type>));
<endif>
<endif>
<endif>

>>
///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

printAssign(assign) ::= <<

<assign.target.variable.indexedName> = <assign.value>;
>>

printParameter(parameter)::= <<
<if (parameter.stringExpr)
>"<parameter>"<
else
><parameter><
endif>
>>

printCall(call) ::= <<

<if(call.print)>std::cout \<\< <call.parameters: printParameter(); separator=" << ">;<
else
><if(call.target)><call.target.variable.indexedName> = <endif><call.procedure.name>(<call.parameters; separator=", ">);<
endif>
>>

printLoad(load) ::= <<

<load.target.variable.indexedName> = <load.source.variable.name><load.indexes : {index | [<index>]}>;
>>

printPeek(port, variable, numTokens) ::= <<
m_poTabIn[<actor.simpleName>_<port.name>]-\>peek(<variable.name>, <numTokens>);<\n>
>>

printRead(port, variable, numTokens) ::= <<
<if(variable)>
m_poTabIn[<actor.simpleName>_<port.name>]-\>get(<variable.name>, <numTokens>);
m_avails[<actor.simpleName>_<port.name>] -= <numTokens>;
<else>
m_poTabIn[<actor.simpleName>_<read.port>]-\>skip(<read.numTokens>);<\n>
m_avails[<actor.simpleName>_<read.port>] -= <read.numTokens>;
<endif>
>>

printReturn(return) ::= <<

<if(return.value)>
return <return.value>;
<endif>
>>

printStore(store) ::= <<

<store.target.variable.name><store.indexes : {index | [<index>]}> = <store.value>;
>>

printWrite(port, variable, numTokens) ::= <<

m_poTabOut[<actor.simpleName>_<port.name>]-\>put(<variable.name>, <numTokens>);
m_rooms[<actor.simpleName>_<port.name>] -= <numTokens>;
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printInstructions(instructions) ::= <<
<instructions: {instr | <
if (instr.assign)><printAssign(assign=instr)><
elseif (instr.call)><printCall(call=instr)><
elseif (instr.load)><printLoad(load=instr)><
elseif (instr.return)><printReturn(return=instr)><
elseif (instr.store)><printStore(store=instr)><
endif>}>
>>

printNodes(nodes) ::= <<
<nodes: {node | <if (node.blockNode)><printBlockNode(node)><
elseif (node.ifNode)><printIfNode(node)><
elseif (node.whileNode)><printWhileNode(node)><
endif>}>
>>

// block node
printBlockNode(blockNode) ::= <<
<printInstructions(blockNode.instructions)>
>>

// if node
printIfNode(ifNode) ::= <<

if (<ifNode.condition>) {
	<printNodes(ifNode.thenNodes)>
}<if(ifNode.elseNodes)> else {
	<printNodes(ifNode.elseNodes)>
}<endif>
<printBlockNode(ifNode.joinNode)>
>>

// while node
printWhileNode(whileNode) ::= <<

while (<whileNode.condition>) {
	<printNodes(whileNode.nodes)>
}
<printBlockNode(whileNode.joinNode)>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
<if(!procedure.native)
><procedure.returnType> <actor.simpleName>::<procedure.name>(<procedure.parameters: variableDeclaration(); wrap, anchor, separator=", ">)
{
<if(procedure.locals)>
	<procedure.locals: {local | <variableDeclaration(local)>;<\n>}>

<endif>
	<printNodes(procedure.nodes)>}<
else
	>extern <procedure.returnType> <procedure.name>(<procedure.parameters: variableDeclaration(); wrap, anchor, separator=", ">);
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

printActionBody(procedure) ::= <<
<if(!procedure.native)
><procedure.returnType> <actor.simpleName>::<procedure.name>(<procedure.parameters: {param | <variableDeclaration(param)>}; wrap, anchor, separator=", ">)
{
	<action.inputPattern.ports : {port | <variableDeclaration(action.inputPattern.variableMap.(port))>;}>
	<action.outputPattern.ports : {port | <variableDeclaration(action.outputPattern.variableMap.(port))>;}>
	<action.inputPattern.ports : {port | <printRead(port=port, variable=action.inputPattern.variableMap.(port), numTokens=action.inputPattern.numTokensMap.(port))>}>

<if(procedure.locals)>
	<procedure.locals: {local | <variableDeclaration(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
	<action.outputPattern.ports : {port | <printWrite(port=port, variable=action.outputPattern.variableMap.(port), numTokens=action.outputPattern.numTokensMap.(port))>}>
}<
endif>
>>

printActionScheduler(procedure) ::= <<
<procedure.returnType> <actor.simpleName>::<procedure.name>(<procedure.parameters: {param | <variableDeclaration(param)>}; wrap, anchor, separator=", ">)
{
	<action.inputPattern.ports : {port | <if(action.inputPattern.peekedMap.(port))><variableDeclaration(action.inputPattern.peekedMap.(port))>;<endif>}>
	<action.inputPattern.ports : {port | <if(action.inputPattern.peekedMap.(port))><printPeek(port=port, variable=action.inputPattern.peekedMap.(port), numTokens=action.inputPattern.numTokensMap.(port))><endif>}>

<if(procedure.locals)>
	<procedure.locals: {local | <variableDeclaration(local)>;<\n>}>
<endif>
	<printNodes(procedure.nodes)>
}
>>

action(action) ::= <<

<printActionBody(action.body)>

<printActionScheduler(action.scheduler)>

>>

actionTrace(action) ::= <<
#ifdef __TRACE_CAPTURE__
g_oTracer.captureAction(this, "<action.name>");
#endif
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
<pattern.ports:{port | hasRooms(<actor.simpleName>_<port.name>, <pattern.numTokensMap.(port)>)}; wrap, anchor, separator=" && ">
>>

inputPattern(pattern) ::= <<
<pattern.ports:{port | hasTokens(<actor.simpleName>_<port.name>, <pattern.numTokensMap.(port)>) && }>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
<actionTrace(action)>
<action.body.name>();
res = true;
i++;
>>

actionTest(action) ::= <<
if(<inputPattern(action.inputPattern)>isSchedulable_<action>())
{
	<if(!action.outputPattern.empty)>
	if(<outputPattern(pattern=action.outputPattern)>)
	{
		<actionCall(action)>
	}
	<else>
	<actionCall(action)>
	<endif>
}
>>

schedulingTest(actions) ::= <<
<actionTest(first(actions))>
<if(rest(actions))>
else
{
	<schedulingTest(rest(actions))>
}
<endif>
>>

scheduler(actions) ::= <<
int <actor.simpleName>::schedule()
{
	getFifoStatus();

	bool res = true;
	int i = 0;
  
	while (res) 
	{
		res = false;
		<if(actions)>
		<schedulingTest(actions)>
		<endif>
	}
	
	updateFifoStatus();
	
	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
<actionTrace(nextState.action)>
<nextState.action.body.name>();
_FSM_state = state_<nextState.targetState>;
res = true;
>>

actionTestState(nextState) ::= <<
if(<inputPattern(nextState.action.inputPattern)>isSchedulable_<nextState.action>())
{
	<if(!nextState.action.outputPattern.empty)>
	if(<outputPattern(nextState.action.outputPattern)>)
	{
		<actionCallState(nextState)>
	}
	<else>
	<actionCallState(nextState)>
	<endif>
}>>

schedulingTestState(nextStates) ::= <<
<actionTestState(first(nextStates))>
<if(rest(nextStates))>
else
{
	<schedulingTestState(rest(nextStates))>
}
<endif>

>>

stateScheduler(transition) ::= <<
bool <actor.simpleName>::<transition.sourceState>_state_scheduler()
{
	bool res = false;
	<schedulingTestState(nextStates=transition.nextStateInfo)>
	return res;
}

>>

switch(transitions) ::= <<
switch (_FSM_state)
{
<transitions: {transition | case state_<transition.sourceState>:
	res = <transition.sourceState>_state_scheduler();
	break;
}>
default:
	std::cout \<\< "unknown state: " \<\< _FSM_state \<\< std::endl;
	break;
}
if (res){i++;}
>>

schedulerFSM(actions, fsm) ::= <<
<if(actions)>
bool <actor.simpleName>::outside_FSM_scheduler()
{
	bool res = false;
	int i = 0;
	<schedulingTest(actions)>
	return res;
}


<endif>
<fsm.transitions: stateScheduler(); separator="\n">
int <actor.simpleName>::schedule()
{
	getFifoStatus();

	bool res = true;
	int i = 0;

	while (res)
	{
		res = false;
			
		<if(actions)>
		if(outside_FSM_scheduler())
		{
			res = true;
			i++;
		}
		else
		{
			<switch(fsm.transitions)>
		}
		<else>
		<switch(fsm.transitions)>
		<endif>
	}
	
	updateFifoStatus();
	
	return i;
}

>>

constructor(parameters, stateVars) ::= <<
<if (actor.parameters)>
<actor.simpleName>::<actor.simpleName>(const char* instanceName, <if(parameters)><parameters: {param | <param.type> <param.indexedName>}; separator=", ">,<endif> AKA_PROFILING_MODE eProfilingMode)
<else>
<actor.simpleName>::<actor.simpleName>(const char* instanceName, AKA_PROFILING_MODE eProfilingMode)
<endif>
:
<parameters: {param | <param.indexedName>(<param.indexedName>),}; wrap, separator="\n">
<if(actor.actionScheduler.fsm)>
_FSM_state(state_<actor.actionScheduler.fsm.initialState>),
<endif>
<stateVars : StateVarAllocation()>
ActorAKA("<actor.simpleName>", instanceName, <length(actor.inputs.list)>, <length(actor.outputs.list)>, eProfilingMode)
{
<stateVars : ListStateVarInitialization()>
}

>>

destructor(stateVars) ::= <<
<actor.simpleName>::~<actor.simpleName>()
{
	<stateVars: StateVarDestruction(); separator="\n">
}

>>


///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actor, options) ::= <<
#include \<iostream\>
#include \<string.h\>

#include "<actor.simpleName>.h"
<if (!actor.packageAsList.empty)>
using namespace <actor.packageAsList; separator="::">;
<endif>
#ifdef __TRACE_CAPTURE__
extern TraceAka g_oTracer;
#endif

const char* <actor.simpleName>::className = "<actor.simpleName>";

<defineConstantVars(actor.stateVars.list)>

<constructor(parameters=actor.parameters.list, stateVars=actor.stateVars.list)>

<destructor(stateVars=actor.stateVars.list)>

void <actor.simpleName>::initializeActor()
{
}


////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
<actor.procs.list: procedure()>
////////////////////////////////////////////////////////////////////////////////
// Actions
<actor.actions: action()>
<if(actor.initializes)>
////////////////////////////////////////////////////////////////////////////////
// Initializes
<actor.initializes: action()>
void <actor.simpleName>::initialize()
{
	bool res = true;
	int i = 0;

	<if(actor.initializes)>
	<schedulingTest(actor.initializes)>
	<endif>
}

<endif>
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
<if(actor.actionScheduler.fsm)>
<schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)>
<else>
<scheduler(actions=actor.actionScheduler.actions)>
<endif>


void <actor.simpleName>::getFifoStatus()
{
<if(actor.inputs.list)>
  	for(int i=0; i\<<actor.simpleName>_nbInputs; i++) 
	{
		m_initialAvails[i] = m_avails[i] = m_poTabIn[i]-\>getCount();
	}
<endif>
<if(actor.outputs.list)>
	for(int i=0; i\<<actor.simpleName>_nbOutputs; i++) 
	{
	   m_initialRooms[i] = m_rooms[i] = m_poTabOut[i]-\>getRooms();
	}
<endif>
}

void <actor.simpleName>::updateFifoStatus()
{
<if(actor.inputs.list)>
  	for(int i=0; i\<<actor.simpleName>_nbInputs; i++) 
	{
	   m_poTabIn[i]-\>setCount(m_initialAvails[i] - m_avails[i]);
	}
<endif>
<if(actor.outputs.list)>
	for(int i=0; i\<<actor.simpleName>_nbOutputs; i++) 
	{
		m_poTabOut[i]-\>setRooms(m_initialRooms[i] - m_rooms[i]);
	}
<endif>
}

>>
