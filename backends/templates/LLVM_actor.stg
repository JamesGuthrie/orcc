group main;

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(actorName, portName) ::= <<
@$actorName$_$portName$ = common global %struct.lff_t* null

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
[$value; wrap, separator=", "$]
>>

// phi definition
phiPair(value, label) ::= <<
[$value$, %$label$]
>>


// a variable definition
vardef(var) ::= <<
$if(var.isGlobal)$
$var.name$ = internal global $var.type$
$else$
$if(var.isPort)$
$var.name$ = alloca $var.type$

$endif$
$endif$>>

// a state variable
stateVar(vardef, value) ::= <<
$if(value)$
$vardef(vardef)$ $value$$\n$
$else$
$vardef(vardef)$ 0$\n$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

// assignment node
assignVarNode(var, expr) ::= <<
	$var$ = $expr$

>>

// call node
callNode(res, name, return, parameters) ::= <<
$if(res)$
	$res$ = 
$endif$
call $return$ @$name$($parameters; separator=", "$)

>>

// getElementPtrNode node
getElementPtrNode(target, source, indexes) ::= <<
	$target$ = getelementptr $source$, i32 0, $indexes : {$it; separator=", "$}$

>>

// initialization port node
initPortNode(actorName, fifoName, expr, index) ::= <<
	%$fifoName$_ptr = getelementptr %struct.lff_t** $expr$, i32 $index$
	%$fifoName$_val = load %struct.lff_t** %$fifoName$_ptr
	store %struct.lff_t* %$fifoName$_val, %struct.lff_t** @$actorName$_$fifoName$

>>

// hasTokens node
hasTokensNode(var, actorName, fifoName, numTokens) ::= <<
	%$actorName$_$fifoName$ = load %struct.lff_t** @$actorName$_$fifoName$
	$var$ = call i1 @lff_hasTokens(%struct.lff_t* %$actorName$_$fifoName$, i32 $numTokens$)

>>

// selectnode
selectNode(var, type, expr, trueVar, falseVar) ::= <<
	$var$ = select $expr$, $trueVar$, $falseVar$

>>

// bitcastnode
BitcastNode(var, type, expr) ::= <<
	$var$ = bitcast $expr$ to $type$

>>

// truncnode
TruncNode(var, type, expr) ::= <<
	$var$ = trunc $expr$ to $type$

>>

// zextnode
ZextNode(var, type, expr) ::= <<
	$var$ = zext $expr$ to $type$

>>

// sextnode
SextNode(var, type, expr) ::= <<
	$var$ = sext $expr$ to $type$

>>

// brnode
brNode(expr, thenLabelNode, thenNodes, elseLabelNode, elseNodes, endLabelNode) ::= <<
	br $expr$, label %$thenLabelNode$, label %$elseLabelNode$

$if(thenNodes)$
$thenLabelNode$:

$thenNodes$
$endif$

$if(elseNodes)$
$elseLabelNode$:
	
$elseNodes$
$endif$

$if(endLabelNode)$
$endLabelNode$:

$endif$
>>


// label node
labelNode(name) ::= <<
$name$:

>>

// phi node
phiNode(target, type, assignements) ::= <<
	$target$ = phi $type$ $assignements: {$it$}; separator=", "$

>>

// brlabel node
brlabelNode(name) ::= <<
	br label %$name$

>>

// load node
loadNode(target, source) ::= <<
	$target$ = load $source$

>>

// peek node
peekNode(typevar, var, actorName, fifoName, numTokens) ::= <<
	call void @lff_peek(%struct.lff_t* %$actorName$_$fifoName$, $typevar$ $var$)
	
>>

// read node
readNode(var, actorName, fifoName, numTokens) ::= <<
	call void @lff_read(%struct.lff_t* %$actorName$_$fifoName$, i8* $var$)

>>

// loadfifo node
loadFifo(actorName, fifoName, index) ::= <<
	%$actorName$_$fifoName$_$index$ = load %struct.lff_t** @$actorName$_$fifoName$

>>

loadFifoTmp(var, actorName, fifoName) ::= <<
	%$var$ = load %struct.lff_t** @$actorName$_$fifoName$

>>

// return node
returnNode(expr) ::= <<
	ret $expr$

>>

// self-assignment node
selfAssignmentNode(var, op, expr) ::= <<
$var$ $op$= $expr$;

>>

// store node
storeNode(var, expr) ::= <<
	store $expr$, $var$

>>

// hasRoom node
hasRoomNode(var, expr, token) ::= <<
	%$var$ =  call i1 @lff_hasRoom(%struct.lff_t* $expr$, i32 $token$)
	
>>

// andNode node
andNode(var, e1, e2) ::= <<
	%$var$ = and i1 $e1$, $e2$
>>

// write node
writeNode(var, actorName, fifoName, numTokens) ::= <<
	call void @lff_write(%struct.lff_t* %$actorName$_$fifoName$, $var$)

>>

///////////////////////////////////////////////////////////////////////////////
// Instantiation
///////////////////////////////////////////////////////////////////////////////

inst(name, nodes) ::= <<

define internal void @$name$(%struct.lff_t** %fifo) {
entry:
$nodes$	ret void
}
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and actions
///////////////////////////////////////////////////////////////////////////////

proc(name, type, parameters, locals, nodes) ::= <<

define internal $type$ @$name$($parameters; wrap, anchor, separator=", "$) {
entry:
$if(locals)$
	$locals: {$vardef(it)$}$

$endif$
$nodes$
}
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(actorName, pattern, token, iterator) ::= <<
$loadFifoTmp(var=iterator.index, actorName= actorName, fifoName=pattern)$ $hasRoomNode(var=iterator.nextNodeIndex.index, expr="%"+iterator.lastIndex, token=token)$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
	call void @$action.tag$()
	br label %bb
	
>>

actionTest(actorName, action, iterator) ::= <<
	%$action.tag$ = call i1 @isSchedulable_$action.tag$()
	br i1 %$action.tag$, label %fire_$action.tag$, label %skip_$action.tag$

fire_$action.tag$:
$if(action.outputPattern)$
$first(action.outputPattern.keys):{port|$outputPattern(actorName=actorName, pattern=port, token = action.outputPattern.(port), iterator=iterator)$}$
$first(rest(action.outputPattern.keys)):{port|$outputPattern(actorName=actorName, pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$ $andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$}$
$rest(rest(action.outputPattern.keys)):{port|$outputPattern(actorName=actorName, pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$
$andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$$\n$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %hasRoom_$action.tag$, label %hasNoRoom_$action.tag$

hasRoom_$action.tag$:
$actionCall(action)$
hasNoRoom_$action.tag$:
	br label %return

$else$
$actionCall(action)$
$endif$

skip_$action.tag$:

>>

schedulingTest(actorName, actions, iterator) ::= <<
$actions: actionTest(actorName=actorName, action=it, iterator = iterator)$
>>

scheduler(actorName, actions, iterator) ::= <<
define i32 @$actorName$_scheduler() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(actions)$
$schedulingTest(actorName=actorName, actions=actions, iterator = iterator)$
$endif$
	br label %return

return:
	%i_ret = load i32* %i
	ret i32 %i_ret
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
	call void @$nextState.action.tag$()
	store i32 $nextState.targetIntState$, i32* @_FSM_state
	ret i1 1

>>

actionTestState(actorName, nextState, br, iterator) ::= <<

$if(nextState.action.outputPattern)$
	%sched_$nextState.action.tag$ = call i1 @isSchedulable_$nextState.action.tag$()
	br i1 %sched_$nextState.action.tag$, label %$nextState.action.tag$, label %$br$

$nextState.action.tag$:
$nextState.action.outputPattern.keys:{port|$outputPattern(actorName=actorName, pattern=port, token = nextState.action.outputPattern.(port), iterator = iterator.init)$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %n_$nextState.action.tag$, label %$br$

n_$nextState.action.tag$:
$actionCallState(nextState)$
$br$:
$else$
	%sched_$nextState.action.tag$ = call i1 @isSchedulable_$nextState.action.tag$()
	br i1 %sched_$nextState.action.tag$, label %$nextState.action.tag$, label %$br$

$nextState.action.tag$:
$actionCallState(nextState)$

$br$:
$endif$

>>

schedulingTestState(actorName, nextStates, iterator) ::= <<
$trunc(nextStates): actionTestState(actorName=actorName, nextState=it, br = "bb"+i0, iterator = iterator)$
$last(nextStates): actionTestState(actorName=actorName, nextState=it, br = "return", iterator = iterator)$
>>

stateScheduler(actorName, transition, iterator) ::= <<
define internal i1 @$transition.sourceState$_state_scheduler() {
entry:
$schedulingTestState(actorName=actorName, nextStates=transition.nextStateInfo, iterator = iterator)$
	ret i1 0
}

>>

switch(transitions) ::= <<
	%_FSM_state = load i32* @_FSM_state
	switch i32 %_FSM_state, label %default [$\n$$transitions:{$\t\t$i32 $it.indexState$, label %s_$it.sourceState$$\n$}$$\t$]
$transitions: {
s_$it.sourceState$:
	%$it.sourceState$_res = call i1 @$it.sourceState$_state_scheduler();
	br i1 %$it.sourceState$_res, label %bb, label %return
}$
default:
	br label %return

>>

schedulerFSM(actorName, actions, fsm, iterator) ::= <<

@_FSM_state = internal global i32 $fsm.initialIntState$

$if(actions)$
static int outside_FSM_scheduler() {
	int res = 0;
	int i = 0;
	$schedulingTest(actorName=actorName, actions=actions, iterator = iterator)$
	return res;
}


$endif$
$fsm.transitions: stateScheduler(actorName=actorName, transition=it, iterator = iterator); separator="\n"$
define i32 @$actorName$_scheduler() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(actions)$
if (outside_FSM_scheduler()) {
res = 1;
i++;
} else {
$switch(fsm.transitions)$
}
$else$ $switch(fsm.transitions)$
$endif$

return:
	%i_ret = load i32* %i
	ret i32 %i_ret
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(name, inputs, outputs, stateVars, insts, procs,  
      actions, initializes, scheduler, initialize, iterator) ::= <<
; Generated from "$name$"

%struct.lff_t = type { i32, i8*, i32, i32, i32 }

;function declaration
declare void @lff_read(%struct.lff_t* %lff, i8* %data)
declare i1 @lff_hasTokens(%struct.lff_t* %lff, i32 %nbTokens)
declare i1 @lff_hasRoom(%struct.lff_t* %lff, i32 %room)
declare void @lff_peek(%struct.lff_t* %lff, i8* %data)
declare void @lff_write(%struct.lff_t* %lff, i8* %data)


;Input FIFOs
$inputs: fifo(actorName=name, portName=it)$

;Output FIFOs
$outputs: fifo(actorName=name, portName=it)$


;State variables of the actor
$stateVars$

$insts$

$procs$

; Actions
$actions$
$if(initializes)$
;////////////////////////////////////////////////////////////////////////////////
;// Initializes
$initializes$
define internal void @$name$_initialize() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(initialize)$
$schedulingTest(actorName=name, actions=initialize)$
$endif$
	ret void
}

$endif$

;////////////////////////////////////////////////////////////////////////////////
;// Action scheduler
$if(scheduler.fsm)$
$schedulerFSM(actorName=name, actions=scheduler.actions, fsm=scheduler.fsm, iterator = iterator)$
$else$
$scheduler(actorName=name, actions=scheduler.actions, iterator= iterator)$
$endif$
>>
