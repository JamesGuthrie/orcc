group C_actor;

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
extern struct fifo_s *$actorName$_$port.name$;

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

variableDeclaration(variable) ::= <<
$if(variable.port)$
$variable.type$ *$variable$
$else$
$variable.type$ $variable$$listSize(variable.type.dimensions)$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
$if(variable.init)$
static $variableDeclaration(variable)$ = $variable.init$;$\n$
$else$
static $variableDeclaration(variable)$;$\n$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<
$assign.target$ = $assign.value$;

>>

Call(call) ::= <<
$if(call.target)$
$call.target$ = 
$endif$
$call.procedure$($call.parameters; separator=", "$);

>>

Decrement(decrement) ::= <<
$decrement.target$--;

>>

HasTokens(hasTokens) ::= <<
$hasTokens.target$ = hasTokens($actorName$_$hasTokens.port$, $hasTokens.numTokens$);

>>

Increment(increment) ::= <<
$increment.target$++;

>>

Load(load) ::= <<
$load.target$ = $load.source$$load.indexes : {[$it$]}$;

>>

Peek(peek) ::= <<
$peek.target$ = getPeekPtr($actorName$_$peek.port$, $peek.numTokens$);

>>

Read(read) ::= <<
$read.target$ = getReadPtr($actorName$_$read.port$, $read.numTokens$);

>>

ReadEnd(readEnd) ::= <<
setReadEnd($actorName$_$readEnd.port$);

>>

Return(return) ::= <<
return $return.value$;

>>

SelfAssignment(selfAssign) ::= <<
$selfAssign.target$ $selfAssign.op.text$= $selfAssign.value$;

>>

Store(store) ::= <<
$store.target$$store.indexes : {[$it$]}$ = $store.value$;

>>

Write(write) ::= <<
$write.target$ = getWritePtr($actorName$_$write.port$, $write.numTokens$);

>>

WriteEnd(writeEnd) ::= <<
setWriteEnd($actorName$_$writeEnd.port$);

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<
if ($ifNode.value$) {
	$nodes(ifNode.thenNodes)$}$if(ifNode.elseNodes)$ else {
	$nodes(ifNode.elseNodes)$}$endif$
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<
while ($whileNode.value$) {
	$nodes(whileNode.nodes)$}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

static $procedure.returnType$ $procedure$($procedure.parameters.list: {$variableDeclaration(it)$}; wrap, anchor, separator=", "$) {
$if(procedure.locals.list)$
	$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$

$endif$
	$procedure.nodes: {$(it.class.simpleName)(it)$}$}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|hasRoom($actorName$_$port$, $pattern.(port)$)}; separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
$action.body$();
res = 1;
i++;
>>

actionTest(action) ::= <<
if (isSchedulable_$action$()) {
	$if(action.outputPattern)$
	if ($outputPattern(pattern=action.outputPattern)$) {
		$actionCall(action)$
	}
	$else$
	$actionCall(action)$
	$endif$
}>>

schedulingTest(actions) ::= <<
$actions: actionTest(action=it); separator=" else "$
>>

scheduler(actions) ::= <<
int $actorName$_scheduler() {
	int res = 1;
	int i = 0;
  
	while (res) {
		res = 0;
		$if(actions)$
		$schedulingTest(actions)$
		$endif$
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
$nextState.action.body$();
_FSM_state = s_$nextState.targetState$;
res = 1;
>>

actionTestState(nextState) ::= <<
if (isSchedulable_$nextState.action$()) {
	$if(nextState.action.outputPattern)$
	if ($outputPattern(nextState.action.outputPattern)$) {
		$actionCallState(nextState)$
	}
	$else$
	$actionCallState(nextState)$
	$endif$
}>>

schedulingTestState(nextStates) ::= <<
$nextStates: actionTestState(nextState=it); separator=" else "$
>>

stateScheduler(transition) ::= <<
static int $transition.sourceState$_state_scheduler() {
	int res = 0;
	$schedulingTestState(nextStates=transition.nextStateInfo)$
	return res;
}

>>

switch(transitions) ::= <<
switch (_FSM_state) {
$transitions: {case s_$it.sourceState$:
	res = $it.sourceState$_state_scheduler();
	break;
}$
default:
	printf("unknown state: %s\n", stateNames[_FSM_state]);
	break;
}
>>

schedulerFSM(actions, fsm) ::= <<
enum states {
	s_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {s_$it$}; separator=",\n"$
};

static char *stateNames[] = {
	$fsm.states : {"s_$it$"}; separator=",\n"$
};

static enum states _FSM_state = s_$fsm.initialState$;

$if(actions)$
static int outside_FSM_scheduler() {
	int res = 0;
	int i = 0;
	$schedulingTest(actions)$
	return res;
}


$endif$
$fsm.transitions: stateScheduler(transition=it); separator="\n"$
int $actorName$_scheduler() {
	int res = 1;
	int i = 0;
	
	while (res) {
		res = 0;
		$if(actions)$
		if (outside_FSM_scheduler()) {
			res = 1;
			i++;
		} else {
			$switch(fsm.transitions)$
		}
		$else$
		$switch(fsm.transitions)$
		$endif$
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actorName, actor) ::= <<
// Generated from "$actor.name$"

#include <stdio.h>
#include <stdlib.h>

#include "fifo.h"

////////////////////////////////////////////////////////////////////////////////
// Input FIFOs
$actor.inputs.list: fifo(it)$
////////////////////////////////////////////////////////////////////////////////
// Output FIFOs
$actor.outputs.list: fifo(it)$
////////////////////////////////////////////////////////////////////////////////
// State variables of the actor
$actor.stateVars.list: stateVar(it)$
////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
$actor.procs.list: procedure(it)$
////////////////////////////////////////////////////////////////////////////////
// Actions
$actor.actions: action(it)$
$if(actor.initializes)$
////////////////////////////////////////////////////////////////////////////////
// Initializes
$actor.initializes: action(it)$
void $actorName$_initialize() {
	int res = 1;
	int i = 0;

	$if(actor.initializes)$
	$schedulingTest(actor.initializes)$
	$endif$
}

$endif$
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$

>>
