group C_scheduled_actor;

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(actorName, portName) ::= <<
extern struct fifo_s *$actorName$_$portName$;

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[$it$]} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

// a variable definition
// called by "function parameter", or "state variable with value"
vardef(var) ::= <<
$var.type$ $var.name$$listSize(var.size)$
>>

// a variable definition with initialization
// called by "local variable", or "state variable with no value"
vardefInit(var) ::= <<
$if(var.isPort)$
$var.type$ *$var.name$
$else$
$var.type$ $var.name$$listSize(var.size)$
$endif$>>

// a state variable
stateVar(vardef, value) ::= <<
$if(value)$
static $vardef(vardef)$ = $value$;$\n$
$else$
static $vardefInit(vardef)$;$\n$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

// assignment node
assignVarNode(var, expr) ::= <<
$var$ = $expr$;

>>

// call node
callNode(res, name, parameters) ::= <<
$if(res)$
$res$ = 
$endif$
$name$($parameters; separator=", "$);

>>

// decrement node
decrementNode(var) ::= <<
$var$--;

>>

// hasTokens node
hasTokensNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = hasTokens($actorName$_$fifoName$, $numTokens$);

>>

// if node
ifNode(expr, thenNodes, elseNodes) ::= <<
if ($expr$) {
	$thenNodes$}$if(elseNodes)$ else {
	$elseNodes$}$endif$$\n$
>>

// increment node
incrementNode(var) ::= <<
$var$++;

>>

// load node
loadNode(target, source, indexes) ::= <<
$target$ = $source$$indexes : {[$it$]}$;

>>

// peek node
peekNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = getPeekPtr($actorName$_$fifoName$, $numTokens$);

>>

// read node
readNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = getReadPtr($actorName$_$fifoName$, $numTokens$);

>>

// return node
returnNode(expr) ::= <<
return $expr$;

>>

// self-assignment node
selfAssignmentNode(var, op, expr) ::= <<
$var$ $op$= $expr$;

>>

// store node
storeNode(target, indexes, expr) ::= <<
$target$$indexes : {[$it$]}$ = $expr$;

>>

// while node
whileNode(expr, nodes) ::= <<
while ($expr$) {
	$nodes$}

>>

// write node
writeNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = getWritePtr($actorName$_$fifoName$, $numTokens$);

>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and actions
///////////////////////////////////////////////////////////////////////////////

proc(name, type, parameters, locals, nodes) ::= <<

static $type$ $name$($parameters:vardef(); wrap, anchor, separator=", "$) {
$if(locals)$
	$locals: {$vardefInit(it)$;$\n$}$

$endif$
	$nodes$}

>>

///////////////////////////////////////////////////////////////////////////////
// Methods for scheduler
///////////////////////////////////////////////////////////////////////////////
sche_proc(actorName, action) ::= <<

//Action $action.tag$
void $actorName$_$action.tag$(){
	$if(action.inputPattern)$
	$action.inputPattern.keys:{port|hasTokens($actorName$_$port$, $action.inputPattern.(port)$)}; separator=";\n"$
	$endif$	
	$if(action.outputPattern)$
	$action.outputPattern.keys:{port|hasRoom($actorName$_$port$, $action.outputPattern.(port)$)}; separator=";\n"$
	$endif$
	$action.tag$();
}>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(actorName, pattern) ::= <<
$pattern.keys:{port|hasRoom($actorName$_$port$, $pattern.(port)$)}; separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
$action.tag$();
res = 1;
i++;
>>

actionTest(actorName, action) ::= <<
if (isSchedulable_$action.tag$()) {
	$if(action.outputPattern)$
	if ($outputPattern(actorName=actorName, pattern=action.outputPattern)$) {
		$actionCall(action)$
	}
	$else$
	$actionCall(action)$
	$endif$
}>>

schedulingTest(actorName, actions) ::= <<
$actions: actionTest(actorName=actorName, action=it); separator=" else "$
>>

scheduler(actorName, actions) ::= <<
int $actorName$_scheduler() {
	int res = 1;
	int i = 0;
  
	while (res) {
		res = 0;
		$if(actions)$
		$schedulingTest(actorName=actorName, actions=actions)$
		$endif$
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
$nextState.action.tag$();
_FSM_state = s_$nextState.targetState$;
res = 1;
>>

actionTestState(actorName, nextState) ::= <<
if (isSchedulable_$nextState.action.tag$()) {
	$if(nextState.action.outputPattern)$
	if ($outputPattern(actorName=actorName, pattern=nextState.action.outputPattern)$) {
		$actionCallState(nextState)$
	}
	$else$
	$actionCallState(nextState)$
	$endif$
}>>

schedulingTestState(actorName, nextStates) ::= <<
$nextStates: actionTestState(actorName=actorName, nextState=it); separator=" else "$
>>

stateScheduler(actorName, transition) ::= <<
static int $transition.sourceState$_state_scheduler() {
	int res = 0;
	$schedulingTestState(actorName=actorName, nextStates=transition.nextStateInfo)$
	return res;
}

>>

switch(transitions) ::= <<
switch (_FSM_state) {
$transitions: {case s_$it.sourceState$:
	res = $it.sourceState$_state_scheduler();
	break;
}$
default:
	printf("unknown state: %s\n", stateNames[_FSM_state]);
	break;
}
>>

schedulerFSM(actorName, actions, fsm) ::= <<
enum states {
	s_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {s_$it$}; separator=",\n"$
};

static char *stateNames[] = {
	$fsm.states : {"s_$it$"}; separator=",\n"$
};

static enum states _FSM_state = s_$fsm.initialState$;

$if(actions)$
static int outside_FSM_scheduler() {
	int res = 0;
	int i = 0;
	$schedulingTest(actorName=actorName, actions=actions)$
	return res;
}


$endif$
$fsm.transitions: stateScheduler(actorName=actorName, transition=it); separator="\n"$
int $actorName$_scheduler() {
	int res = 1;
	int i = 0;
	
	while (res) {
		res = 0;
		$if(actions)$
		if (outside_FSM_scheduler()) {
			res = 1;
			i++;
		} else {
			$switch(fsm.transitions)$
		}
		$else$
		$switch(fsm.transitions)$
		$endif$
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(name, inputs, outputs, stateVars, procs,
      actions, initializes, scheduler, initialize, scheduleActions) ::= <<
// Generated from "$name$"

#include <stdio.h>
#include <stdlib.h>

#include "fifo.h"

////////////////////////////////////////////////////////////////////////////////
// Input FIFOs
$inputs: fifo(actorName=name, portName=it)$
////////////////////////////////////////////////////////////////////////////////
// Output FIFOs
$outputs: fifo(actorName=name, portName=it)$
////////////////////////////////////////////////////////////////////////////////
// State variables of the actor
$stateVars$
////////////////////////////////////////////////////////////////////////////////
// Functions/procedures
$procs$
////////////////////////////////////////////////////////////////////////////////
// Actions
$actions$
$if(initializes)$
////////////////////////////////////////////////////////////////////////////////
// Initializes
$initializes$
void $name$_initialize() {
	int res = 1;
	int i = 0;

	$if(initialize)$
	$schedulingTest(actorName=name, actions=initialize)$
	$endif$
}

$endif$
////////////////////////////////////////////////////////////////////////////////
// Action scheduler
$if(scheduler.fsm)$
$schedulerFSM(actorName=name, actions=scheduler.actions, fsm=scheduler.fsm)$
$else$
$scheduler(actorName=name, actions=scheduler.actions)$
$endif$
////////////////////////////////////////////////////////////////////////////////
// Schedule Methods
$scheduleActions$
>>

display_actor(name, inputs, outputs, stateVars, procs,
      actions, initializes, scheduler, initialize, scheduleActions) ::= <<
/*
 * Copyright (c) 2009, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "SDL.h"

#include "fifo.h"

#ifdef BENCHMARK
	#include <locale.h>
	#include <time.h>
	FILE * pFile;
	static Uint32 tInit = 0;
#endif


extern struct fifo_s *display_B;
extern struct fifo_s *display_WIDTH;
extern struct fifo_s *display_HEIGHT;

static SDL_Surface *m_screen;
static SDL_Overlay *m_overlay;

#define MAX_WIDTH 704
#define MAX_HEIGHT 576


static int m_x;
static int m_y;
static int m_width;
static int m_height;
static int comp;

static unsigned char img_buf_y[MAX_WIDTH * MAX_HEIGHT];
static unsigned char img_buf_u[MAX_WIDTH * MAX_HEIGHT / 4];
static unsigned char img_buf_v[MAX_WIDTH * MAX_HEIGHT / 4];

static void press_a_key(int code) {
	char buf[2];
	printf("Press enter to continue\n");
	fgets(buf, 2, stdin);
	exit(code);
}

void display_show_image(void) {
	static Uint32 t;
	static int num_images_start;
	static int num_images_end;

	SDL_Rect rect = { 0, 0, m_width, m_height };

	int t2;
	SDL_Event event;

	if (t == 0) {
		t = SDL_GetTicks();
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
#ifndef NO_DISPLAY
	if (SDL_LockYUVOverlay(m_overlay) < 0) {
		fprintf(stderr, "Can't lock screen: %s\n", SDL_GetError());
		press_a_key(-1);
	}
#endif
	
	memcpy(m_overlay->pixels[0], img_buf_y, m_width * m_height );
	memcpy(m_overlay->pixels[1], img_buf_u, m_width * m_height / 4 );
	memcpy(m_overlay->pixels[2], img_buf_v, m_width * m_height / 4 );

	
#ifndef NO_DISPLAY
	SDL_UnlockYUVOverlay(m_overlay);
	SDL_DisplayYUVOverlay(m_overlay, &rect);
#endif

	///////////////////////////////////////////////////////////////////////////////////////////////
	num_images_end++;
	t2 = SDL_GetTicks();
	if (t2 - t > 3000) {
		printf("%f images/sec\n", 1000.0f * (float)(num_images_end - num_images_start) / (float)(t2 - t));

#ifdef BENCHMARK
	if (tInit == 0)
		tInit = t2;
	
	fprintf (pFile, "%d \t %f \n",(t2-tInit),1000.0f * (float)(num_images_end - num_images_start) / (float)(t2 - t));

#endif
		t = t2;
		num_images_start = num_images_end;
	}

	/* Grab all the events off the queue. */
	while (SDL_PollEvent(&event)) {
		switch (event.type) {
			case SDL_QUIT:
				exit(0);
				break;
			default:
				break;
		}
	}
}

static void y_channel(short tokens[64], int base, int x, int y)
{
	int i, j, cnt, idx;

	cnt = 0;

	for (i = 0; i < 8; i++) {
		for (j = 0; j < 8; j++) {
			int tok = tokens[cnt];
			cnt++;

			if (tok < 0) {
				tok = 0;
			} else if (tok > 255) {
				tok = 255;
			}

			idx = base + (i + 8 * y) * m_width + (j + 8 * x);
			img_buf_y[idx] = tok;
		}
	}
}

static void c_channel(unsigned char *dst, short tokens[64], int base)
{
	int i, j, cnt, idx;

	cnt = 0;

	for (i = 0; i < 8; i++) {
		for (j = 0; j < 8; j++) {
			int tok = tokens[cnt];
			cnt++;

			if (tok < 0) {
				tok = 0;
			} else if (tok > 255) {
				tok = 255;
			}

			idx = base + i * m_width / 2 + j;
			dst[idx] = tok;
		}
	}
}

void display_write_mb(short tokens[64]) {

	switch(comp)
	{
	case 0:
		y_channel(tokens, m_y * m_width + m_x, 0, 0);
		break;
	case 1:
		y_channel(tokens, m_y * m_width + m_x, 1, 0);
		break;
	case 2:
		y_channel(tokens, m_y * m_width + m_x, 0, 1);
		break;
	case 3:
		y_channel(tokens, m_y * m_width + m_x, 1, 1);
		break;
	case 4:
		c_channel(img_buf_u, tokens, m_y / 2 * m_width / 2 + m_x / 2);
		break;
	case 5:
		c_channel(img_buf_v, tokens, m_y / 2 * m_width / 2 + m_x / 2);

		m_x += 16;
		if (m_x == m_width) {
			m_x = 0;
			m_y += 16;
		}

		if (m_y == m_height) {
			m_x = 0;
			m_y = 0;
			display_show_image();
		}
		break;
	default:
		printf("unknown phase");
		while(1);
	}

	comp ++;
	comp = comp % 6;
}

static int init = 0;

static void display_init() {
	// First, initialize SDL's video subsystem.
    if (SDL_Init( SDL_INIT_VIDEO ) < 0) {
        fprintf(stderr, "Video initialization failed: %s\n", SDL_GetError());
		press_a_key(-1);
    }

	SDL_WM_SetCaption("display", NULL);

#ifdef BENCHMARK
	{
		char sFile [80];	
		time_t rawtime;
		struct tm * timeinfo;

		time ( &rawtime );
		timeinfo = localtime ( &rawtime );

		strftime (sFile,80,".//Bench/bench_%d-%m-%y_%H-%M-%S.log",timeinfo);

		pFile = fopen (sFile,"w");
		if (pFile== NULL)
		{
			fprintf(stderr, "Can't create log file, try to disable BENCHMARK preprocessor\n");
			exit(1);
		}
		setlocale(LC_NUMERIC, "");
		fprintf (pFile, "Time (in ms) \t fps \n");
	}
#endif

	atexit(SDL_Quit);
	init = 1;
	comp = 0;
}

static void display_set_video(int width, int height) {
	if (width == m_width && height == m_height) {
		// video mode is already good
		return;
	}

	m_width = width;
	m_height = height;
	printf("set display to %ix%i\n", width, height);

	m_screen = SDL_SetVideoMode(m_width, m_height, 24, SDL_HWSURFACE | SDL_DOUBLEBUF);
	if (m_screen == NULL) {
		fprintf(stderr, "Couldn't set %ix%ix24 video mode: %s\n", m_width, m_height,
			SDL_GetError());
		press_a_key(-1);
	}

	if (m_overlay != NULL) {
		SDL_FreeYUVOverlay(m_overlay);
	}

	m_overlay = SDL_CreateYUVOverlay(m_width, m_height, SDL_IYUV_OVERLAY, m_screen);
	if (m_overlay == NULL) {
		fprintf(stderr, "Couldn't create overlay: %s\n", SDL_GetError());
		press_a_key(-1);
	}
}

int display_scheduler() {
	int res = 1;
	while (res) {
		if (hasTokens(display_WIDTH, 1) && hasTokens(display_HEIGHT, 1)) {
			short *ptr, width, height;
			ptr = getReadPtr(display_WIDTH, 1);
			width = ptr[0] * 16;
			ptr = getReadPtr(display_HEIGHT, 1);
			height = ptr[0] * 16;

			display_set_video(width, height);
		}

		if (hasTokens(display_B, 64)) {
			if (init) {
				display_write_mb(getReadPtr(display_B, 64));
				//display_show_image();
			} else {
				display_init();
			}
			res = 1;
		} else {
			res = 0;
		}
	}

	return 0;
}
>>
