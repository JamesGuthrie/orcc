group VHDL_actor;

fifo_in(port) ::= <<
$actorName$_$port.name$_data  : in $port.type$;
$actorName$_$port.name$_empty : in std_logic;
$actorName$_$port.name$_read  : out std_logic;

>>

fifo_out(port) ::= <<
$actorName$_$port.name$_full  : in std_logic;
$if(last(port.name))$
$actorName$_$port.name$_data  : out $port.type$;
$actorName$_$port.name$_write : out std_logic
$else$
$actorName$_$port.name$_data  : out $port.type$;
$actorName$_$port.name$_write : out std_logic;
$endif$
>>

fifo_in_init(port) ::=<<
$actorName$_$port.name$_read <= '0';$"\n"$
>>
fifo_out_init(port) ::=<<
$actorName$_$port.name$_write <= '0';$"\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {$it $} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

signalDeclaration(variable) ::= <<
$if(variable.port)$
signal $variable$ : $variable.type$;

$else$
  $if(!(listSize(variable.type.dimensions)))$
signal $variable$ : $variable.type$;

  $else$
type memory_type_$variable$ is array ($listSize(variable.type.dimensions)$ -1 downto 0) of $variable.type$;
signal $variable$ : memory_type_$variable$;

  $endif$
$endif$
>>

variableDeclaration(variable) ::= <<
$variable.type.dimensions$
$if(variable.port)$
variable $variable$ : $variable.type$
$else$
  $if(!(listSize(variable.type.dimensions)))$
variable $variable$ : $variable.type$ $listSize(variable.type.dimensions)$
  $else$
-- error !!!!! type memory_type_$variable$ is array ($listSize(variable.type.dimensions)$ -1 downto 0) of $variable.type$;
-- error !!!!! variable $variable$ : memory_type_$variable$
  $endif$
$endif$
>>

functionDeclaration(variable) ::= <<
$variable.type.dimensions$
$if(!(listSize(variable.type.dimensions)))$
$variable$ : $variable.type$ $listSize(variable.type.dimensions)$
$else$
-- error !!!!! type memory type
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Constant Signal
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
$if(variable.constantValue)$
$variable$ <= $variable.constantValue$;
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<
$assign.target$ := $assign.value$;

>>

Call(call) ::= <<
$if(call.target)$
$call.target$ := 
$endif$
$call.procedure$($call.parameters; separator=", "$);

>>

HasTokens(hasTokens) ::= <<
$hasTokens.target$ := not $actorName$_$hasTokens.port$_empty;

>>

Load(load) ::= <<
$if(load.indexes)$
$if(load.source.variable.port)$
$load.target$ := $load.source$;

$else$
$load.target$ := $load.source$($load.indexes : {$it$}$);

$endif$
$else$
$load.target$ := $load.source$; 

$endif$
>>

Peek(peek) ::= <<>>
// $if(peek.numTokens)$
// $peek.target$ := $actorName$_$peek.port$_data;
// read_FIFO_$actorName$_$peek.port$ <= '1';
// $else$
// -- ERROR multiple token : $peek.numTokens$ 
// $endif$


Read(read) ::= <<
$if(read.unit)$
$read.target$ := $actorName$_$read.port$_data;
$actorName$_$read.port$_read <= '1';
$else$
-- read multiple token not coded yet
$endif$


>>

ReadEnd(readEnd) ::= <<>>

/**
 * calls are inlined, so the only returns still there are in the
 * isSchedulable procedures
 */
Return(return) ::= <<
$if(return.value)$
$procedure$_go := $return.value$;

$endif$
>>

Store(store) ::= <<
$if(store.indexes)$
$if(store.target.variable.port)$
$store.target$ := $store.value$;

$else$
$store.target$($store.indexes : {$it$}$) <= $store.value$;

$endif$
$else$
$store.target$ <= $store.value$;

$endif$

>>

Write(write) ::= <<
$actorName$_$write.port$_data <= $write.target$;
$actorName$_$write.port$_write <= '1';

>>

WriteEnd(writeEnd) ::= <<>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<
if ($ifNode.value$) then
  $nodes(ifNode.thenNodes)$$if(ifNode.elseNodes)$else
  $nodes(ifNode.elseNodes)$end if;	
  $endif$
$BlockNode(ifNode.joinNode)$
$endif$
>>

// while node
WhileNode(whileNode) ::= <<
while ($whileNode.value$) {
  $nodes(whileNode.nodes)$}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and function
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
$procedure.nodes: {$(it.class.simpleName)(it)$}$
>>

function(procedure) ::= <<
function $procedure$($procedure.parameters.list: { $functionDeclaration(it)$}; wrap, anchor, separator=", "$) return $procedure.returnType$ is 
begin
  $if(procedure.locals.list)$
  $procedure.locals.list: {$variableDeclaration(it)$;$\n$}$
  $endif$
  $procedure.nodes: {$(it.class.simpleName)(it)$}$end $procedure$;

>>

PrintLocals(procedure) ::= <<
$if(procedure.locals.list)$
$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////
action(action) ::= <<
-- $action$ Scheduler 
$procedure(action.scheduler)$
>>


PrintActionLocals(action) ::= <<
$PrintLocals(action.body)$$PrintLocals(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|$actorName$_$port$_full = '0'}; separator=" and "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
$procedure(action.body)$
>>

actionTest(action) ::= <<
(isSchedulable_$action$_go = '1') then 
$if(action.outputPattern)$
if ($outputPattern(pattern=action.outputPattern)$) then
  $actionCall(action)$
end if;
$else$
$procedure(action.body)$
$endif$

>>

schedulingTest(actions) ::= <<
-- Actions
if $actions: actionTest(action=it); separator="\nelsif "$
end if;

>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

DefineFSM(actions, fsm) ::= <<
$if(fsm)$
type FSM_type is ($first(fsm.states)$, $rest(fsm.states) : {$it$}; separator=", "$);
signal FSM : FSM_type;
$endif$

>>

InitFSM(fsm) ::= <<
FSM <= $fsm.initialState$;

>>

schedulerFSM(actions, fsm) ::= <<
case FSM is
  $if(actions)$
  static int outside_FSM_scheduler() {
	  int res = 0;
	  int i = 0;
	  $schedulingTest(actions)$
	  return res;
  }
  $endif$	
  $if(actions)$
  if (outside_FSM_scheduler()) {
	  res = 1;
	  i++;
  } else {
	  $switch(fsm.transitions)$
  }
  $else$
  $switch(fsm.transitions)$
  $endif$
end case;
>>


switch(transitions) ::= <<
$transitions: {when $it.sourceState$ =>
$stateScheduler(transition=it)$}$
>>

stateScheduler(transition) ::= <<
  -- $transition.sourceState$_state_scheduler
  $schedulingTestState(nextStates=transition.nextStateInfo)$

>>

schedulingTestState(nextStates) ::= <<
if $nextStates: actionTestState(nextState=it); separator="elsif"$end if;

>>

actionTestState(nextState) ::= <<
(isSchedulable_$nextState.action$_go = '1') then
  $if(nextState.action.outputPattern)$
  if ($outputPattern(nextState.action.outputPattern)$) then
    $actionCallState(nextState)$
  end if;
  $else$
  $actionCallState(nextState)$
  $endif$

>>

actionCallState(nextState) ::= <<
$procedure(nextState.action.body)$FSM <= $nextState.targetState$;
>>


///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////
actor(actorName, actor) ::= <<
------------------------------------------------------------------------------
-- Generated from $actor.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;

entity $actor.name$ is
  port (
  -- Inputs
  clock   : in std_logic;
  reset_n : in std_logic;
  $actor.inputs.list: fifo_in(it)$  -- Outputs
  $actor.outputs.list: {$fifo_out(it)$}; separator=";\n"$);  
end $actor.name$;


$actor.procs.list: function(it); separator="\n"$


architecture rtl_$actor.name$ of $actor.name$ is 

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  $actor.stateVars.list: signalDeclaration(it)$
  -- FSM
  $DefineFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
  ---------------------------------------------------------------------------

begin

$if(actor.actionScheduler.actions)$
  $actor.name$_proc : process (reset_n, clock) is
    $actor.actions: {action|variable $action.scheduler$_go : std_logic;}; separator="\n"$
    --
    $actor.actions: PrintActionLocals(it)$  --
  begin
    if reset_n = '0' then 
  	  $actor.stateVars.list: stateConst(it); separator="\n"$
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
    elsif rising_edge(clock) then
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
      $actor.actions: action(it); separator="\n"$
      $schedulingTest(actor.actionScheduler.actions)$
    end if;
  end process $actor.name$_proc;

$else$
  $if(actor.actionScheduler.fsm)$
  $actor.name$_proc : process (reset_n, clock) is
    $actor.actions: {action|variable $action.scheduler$_go : std_logic;}; separator="\n"$
    --
    $actor.actions: PrintActionLocals(it)$  --
  begin
    if reset_n = '0' then 
  	  $actor.stateVars.list: stateConst(it); separator="\n"$
  	  $InitFSM(actor.actionScheduler.fsm)$
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
    elsif rising_edge(clock) then
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
      $actor.actions: action(it); separator="\n"$
      $schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
    end if;
  end process $actor.name$_proc;
  $endif$
$endif$

end architecture rtl_$actor.name$;
>>