group VHDL_actor;

fifo_in(port) ::= <<
$actorName$_$port.name$_data  : in $port.type$;
$actorName$_$port.name$_empty : in std_logic;
$actorName$_$port.name$_read  : out std_logic;

>>

fifo_out(port) ::= <<
$actorName$_$port.name$_full  : in std_logic;
$if(last(port.name))$
$actorName$_$port.name$_data  : out $port.type$;
$actorName$_$port.name$_write : out std_logic
$else$
$actorName$_$port.name$_data  : out $port.type$;
$actorName$_$port.name$_write : out std_logic;
$endif$
>>

fifo_in_init(port) ::=<<
$actorName$_$port.name$_read <= '0';$"\n"$
>>
fifo_out_init(port) ::=<<
$actorName$_$port.name$_write <= '0';$"\n"$
>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {$it $} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

signalDeclaration(variable) ::= <<
$if(variable.port)$
signal $variable$ : $variable.type$;

$else$
  $if(!(listSize(variable.type.dimensions)))$
signal $variable$ : $variable.type$;

  $else$
type memory_type_$variable$ is array ($listSize(variable.type.dimensions)$ -1 downto 0) of $variable.type$;
signal $variable$ : memory_type_$variable$;

  $endif$
$endif$
>>

variableDeclaration(variable) ::= <<
$variable.type.dimensions$
$if(variable.port)$
variable $variable$ : $variable.type$
$else$
  $if(!(listSize(variable.type.dimensions)))$
variable $variable$ : $variable.type$ $listSize(variable.type.dimensions)$
  $else$
-- error !!!!! type memory_type
  $endif$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Constant Signal
///////////////////////////////////////////////////////////////////////////////
stateConst(variable) ::= <<
$if(variable.constantValue)$
$declareConst(variable=variable)$
$endif$
>>


declareConst(variable) ::= <<
$variable$ <= $variable.constantValue$;

>>



///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<
$assign.target$ := $assign.value$;

>>

Call(call) ::= <<
$if(call.target)$
$call.target$ := $call.procedure$($call.procedure.stateVarsUsed: {$it$, }$$call.parameters: {$it$, }$'1');

$else$
$call.procedure$($call.parameters; separator=", "$, '1');

$endif$
>>

HasTokens(hasTokens) ::= <<
$hasTokens.target$ := not $actorName$_$hasTokens.port$_empty;

>>

Load(load) ::= <<
$if(load.indexes)$
$if(load.source.variable.port)$
$load.target$ := $load.source$;

$else$
$load.target$ := $load.source$($load.indexes : {$it$}$);

$endif$
$else$
$load.target$ := $load.source$; 

$endif$
>>

Peek(peek) ::= <<>>
// $if(peek.numTokens)$
// $peek.target$ := $actorName$_$peek.port$_data;
// read_FIFO_$actorName$_$peek.port$ <= '1';
// $else$
// -- ERROR multiple token : $peek.numTokens$ 
// $endif$


Read(read) ::= <<
$if(read.unit)$
$read.target$ := $actorName$_$read.port$_data;
$actorName$_$read.port$_read <= '1';
$else$
-- read multiple token not coded yet
$endif$


>>

ReadEnd(readEnd) ::= <<>>

// a "return" must be transformed when the attribute "transformReturn"
// is present, which normally only occurs when printActionSchedulerInline
// is called
Return(return) ::= <<
$if(return.value)$
$if(transformReturn)$
$procedure$_go := $return.value$;

$else$
return $return.value$;

$endif$
$endif$
>>

Store(store) ::= <<
$if(store.indexes)$
$if(store.target.variable.port)$
$store.target$ := $store.value$;

$else$
$store.target$($store.indexes : {$it$}$) <= $store.value$;

$endif$
$else$
$store.target$ <= $store.value$;

$endif$

>>

Write(write) ::= <<
$actorName$_$write.port$_data <= $write.target$;
$actorName$_$write.port$_write <= '1';

>>

WriteEnd(writeEnd) ::= <<>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<
if ($ifNode.value$) then
  $nodes(ifNode.thenNodes)$$if(ifNode.elseNodes)$else
  $nodes(ifNode.elseNodes)$end if;	
  $endif$
$BlockNode(ifNode.joinNode)$
$endif$
>>

// while node
WhileNode(whileNode) ::= <<
while ($whileNode.value$) {
  $nodes(whileNode.nodes)$}
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Prints functions
///////////////////////////////////////////////////////////////////////////////

functionParameter(variable) ::= <<
$if(!(listSize(variable.type.dimensions)))$
$variable$ : $variable.type$
$else$
-- error !!!!! type memory type
$endif$
>>

VarInFctDeclaration(variable) ::= <<
$variable.type.dimensions$
$if(variable.port)$
variable $variable$ : $variable.type$
$else$
  $if(!(listSize(variable.type.dimensions)))$
variable $variable$ : $variable.type$
  $else$
-- error !!!!! type memory_type
  $endif$
$endif$
>>

returnFunction(type) ::= <<
$if(type.bool)$
return std_logic 
$else$
$if(type.int)$
return integer 
$endif$
$endif$
>>

parameters(params) ::= <<
$params: { $functionParameter(it)$; }; wrap$
>>

function(procedure, transformReturn) ::= <<
$if (procedure.returnType.void)$
procedure $procedure$($parameters(procedure.parameters.list)$dummy : std_logic) is
$else$
function $procedure$($parameters(procedure.stateVarsUsed)$$parameters(procedure.parameters.list)$dummy : std_logic) $returnFunction(procedure.returnType)$is
$endif$

  $if(procedure.locals.list)$
  $procedure.locals.list: {$VarInFctDeclaration(it)$;$\n$}$
  $endif$begin
  $procedure.nodes: {$(it.class.simpleName)(it)$}$end $procedure$;

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

procedure(procedure, transformReturn) ::= <<
$procedure.nodes: {$(it.class.simpleName)(it)$}$
>>

// prints the scheduler of the given action "inline" (ie not within a function)
printActionSchedulerInline(action) ::= <<
-- tests if "$action$" action is schedulable
$procedure(procedure=action.scheduler, transformReturn="true")$
>>

printLocals(procedure) ::= <<
$if(procedure.locals.list)$
$procedure.locals.list: {$variableDeclaration(it)$;$\n$}$
$endif$
>>

// this template prints the locals of the body and the scheduler function
// of the given action
printActionLocals(action) ::= <<
$printLocals(action.body)$$printLocals(action.scheduler)$
>>

// prints the body of the given action "inline" (ie not within a function)
printActionBodyInline(action) ::= <<
-- body of "$action$" action
$procedure(procedure=action.body)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern) ::= <<
$pattern.keys:{port|$actorName$_$port$_full = '0'}; separator=" and "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionTest(action) ::= <<
(isSchedulable_$action$_go = '1') then 
$if(action.outputPattern)$
if ($outputPattern(pattern=action.outputPattern)$) then
  $printActionBodyInline(action)$
end if;
$else$
$printActionBodyInline(action)$
$endif$

>>

schedulingTest(actions) ::= <<
-- Actions
if $actions: actionTest(action=it); separator="\nelsif "$
end if;

>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

DefineFSM(actions, fsm) ::= <<
$if(fsm)$
type FSM_type is ($fsm.states: {s_$it$}; separator=", "$);
signal FSM : FSM_type;
$endif$

>>

InitFSM(fsm) ::= <<
FSM <= s_$fsm.initialState$;

>>

schedulerFSM(actions, fsm) ::= <<
case FSM is
  $if(actions)$
  static int outside_FSM_scheduler() {
	  int res = 0;
	  int i = 0;
	  $schedulingTest(actions)$
	  return res;
  }
  $endif$	
  $if(actions)$
  if (outside_FSM_scheduler()) {
	  res = 1;
	  i++;
  } else {
	  $switch(fsm.transitions)$
  }
  $else$
  $switch(fsm.transitions)$
  $endif$
end case;
>>


switch(transitions) ::= <<
$transitions: {when s_$it.sourceState$ =>
$stateScheduler(transition=it)$}$
>>

stateScheduler(transition) ::= <<
  -- $transition.sourceState$_state_scheduler
  $schedulingTestState(nextStates=transition.nextStateInfo)$

>>

schedulingTestState(nextStates) ::= <<
if $nextStates: actionTestState(nextState=it); separator="elsif"$end if;

>>

// prints the action referenced by the "nextState" parameter
// and updates the FSM state
actionCallState(nextState) ::= <<
$printActionBodyInline(nextState.action)$FSM <= s_$nextState.targetState$;
>>

actionTestState(nextState) ::= <<
(isSchedulable_$nextState.action$_go = '1') then
  $if(nextState.action.outputPattern)$
  if ($outputPattern(nextState.action.outputPattern)$) then
    $actionCallState(nextState)$
  end if;
  $else$
  $actionCallState(nextState)$
  $endif$

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////
actor(actorName, actor) ::= <<
------------------------------------------------------------------------------
-- Generated from $actor.name$ actor
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.orcc_package.all;

entity $actor.name$ is
  port (
  -- Inputs
  clock   : in std_logic;
  reset_n : in std_logic;
  $actor.inputs.list: fifo_in(it)$  -- Outputs
  $actor.outputs.list: {$fifo_out(it)$}; separator=";\n"$);  
end $actor.name$;


architecture rtl_$actor.name$ of $actor.name$ is

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  $actor.stateVars.list: signalDeclaration(it)$

  ---------------------------------------------------------------------------
  -- Functions and procedures
  $actor.procs.list: function(procedure=it); separator="\n"$

  ---------------------------------------------------------------------------
  -- FSM
  $DefineFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
  ---------------------------------------------------------------------------

begin

$if(actor.actionScheduler.actions)$
  $actor.name$_proc : process (reset_n, clock) is
    $actor.actions: {action|variable $action.scheduler$_go : std_logic;}; separator="\n"$
    --
    $actor.actions: printActionLocals(it)$  --
  begin
    if reset_n = '0' then 
      $actor.stateVars.list: stateConst(it)$      --
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
    elsif rising_edge(clock) then
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
      $actor.actions: printActionSchedulerInline(it); separator="\n"$
      $schedulingTest(actor.actionScheduler.actions)$
    end if;
  end process $actor.name$_proc;

$else$
  $if(actor.actionScheduler.fsm)$
  $actor.name$_proc : process (reset_n, clock) is
    $actor.actions: {action|variable $action.scheduler$_go : std_logic;}; separator="\n"$
    --
    $actor.actions: printActionLocals(it)$  --
  begin
    if reset_n = '0' then 
      $actor.stateVars.list: stateConst(it)$$InitFSM(actor.actionScheduler.fsm)$      --
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
    elsif rising_edge(clock) then
      $actor.inputs.list: fifo_in_init(it)$$actor.outputs.list: fifo_out_init(it)$      --
      $actor.actions: printActionSchedulerInline(it); separator="\n"$
      $schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
    end if;
  end process $actor.name$_proc;
  $endif$
$endif$

end architecture rtl_$actor.name$;
>>