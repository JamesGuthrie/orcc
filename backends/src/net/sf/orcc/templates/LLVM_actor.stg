group LLVM_actor;

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////
Var(var) ::= <<
$if(var.variable.global)$@$else$%$endif$$var$
>>

Type(var) ::= <<
$if(var.variable.global)$i32$else$i32*$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// LLVM Operations
///////////////////////////////////////////////////////////////////////////////
StoreOp(ty, value, pty, pointer) ::= <<
store $ty$ $value$, $pty$* $pointer$
>>

LoadOp(result, ty, pointer,alignment) ::= <<
$result$ = load $ty$* $pointer$ $if(alignment)$
[, align <alignment>]
$endif$
>>  

AddOp(result, ty, op1, op2) ::= <<
$result$ = add $ty$ $op1$, $op2$
>>  

GetElementPtrOp(result, pty, ptrval, idx) ::= <<
$result$ = getelementptr $pty$* $ptrval$, i32 0 $if(idx)$
, $indexes(idx)$
$endif$
>>

BitcastOp(result, ty, value, ty2) ::= <<
$result$ = bitcast $ty$ $value$ to $ty2$
>>

AllocaOp(result, type, NumElements, alignment) ::= <<
$result$ = alloca $type$ $if(NumElements)$
[, i32 <NumElements>]
$endif$
$if(alignment)$
[, align <alignment>]
$endif$
>>

BrOp(cond, iftrue, iffalse, dest) ::= <<
$if(cond)$br i1 $cond$, label $iftrue$, label $iffalse$
$else$
br label $dest$
$endif$
>>

RetOp(type, value) ::= <<
$if(value)$
ret $type$ $value$
$else$
ret void
$endif$
>>  

CallOp(result, tail, cconv, ret_attrs, ty, fnty, fnptrval, function_args, fn_attrs) ::= <<
$if(result)$$result$ = $endif$$if(tail)$ [tail] $endif$call$if(cconv)$ [cconv] $endif$$if(ret_attrs)$ [ret_attrs] $endif$ $ty$$if(fnty)$ [<fnty>*] $endif$ $fnptrval$ ($if(function_args)$$function_args$$endif$) $if(fn_attrs)$ [fn_attrs] $endif$
>>

PhiOp(result, ty, pairs) ::= << 
$result$ = phi $ty$ $pairs$ 
>>

///////////////////////////////////////////////////////////////////////////////
// Conversion instructions
///////////////////////////////////////////////////////////////////////////////

StoreWithIndex(value, target, indexes) ::= <<
$if(target.variable.port)$
$BitcastOp(result = "%"+target+"_cast", ty = "i8**", value = "%"+target, ty2 = target.variable.type+"*")$
$endif$


$GetElementPtrOp(result="%"+target+"_ptr", pty=target.variable.type, ptrval="%"+target+"_cast", idx = indexes)$
$StoreOp(ty="i32", value=value, pty="i32", pointer="%"+target+"_ptr")$

>>


StoreWithoutIndex(value, target) ::= <<
$StoreOp(ty="i32", value=value, pty=Type(target), pointer=Var(target))$

>>


IfWithThenElseNodes(ifNode) ::= <<
	$BrOp(cond=ifNode.value, iftrue="%b"+label(ifNode.thenNodes), iffalse="%b"+label(ifNode.elseNodes))$

b$label(ifNode.thenNodes)$: 
$nodes(ifNode.thenNodes)$	$BrOp(dest ="%b"+ifNode.joinNode.label)$

b$label(ifNode.elseNodes)$:
$nodes(ifNode.elseNodes)$	$BrOp(dest ="%b"+ifNode.joinNode.label)$

b$ifNode.joinNode.label$:
>>


LoadLocalPort(instr) ::= <<
$LoadOp(result="%local_"+instr.port+instr.block.label, ty="%struct.fifo_s*", pointer="@"+actorName+"_"+instr.port)$
>>


label(nodes) ::= "b$first(nodes):{ x | $x.label$}$"


phiPredecessors(vars) ::= <<
$vars: { var |[ %$var.variable$, %bb$var.variable.instruction.block.label$ ]}; separator=", "$
>>


HasRoom(result, action, actor, port, numToken) ::= <<
$LoadOp(result="%"+port+"_"+action, ty="%struct.fifo_s*", pointer="@"+actor+"_"+port)$
$CallOp(result="%"+result, ty="i1", fnptrval="@hasRoom", function_args="%struct.fifo_s* %"+port+"_"+action+", i32 "+numToken)$

>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Instructions
///////////////////////////////////////////////////////////////////////////////

Assign(assign) ::= <<
%$assign.target$ = $assign.value$

>>

PhiAssignment(phi) ::= <<
$PhiOp(result="%"+phi.target, ty=phi.target.type, pairs=phiPredecessors(phi.vars))$

>>

Read(read) ::= <<
$LoadLocalPort(read)$
$CallOp(result="%"+read.target+"_"+read.block.label, ty ="i8*", fnptrval="@getReadPtr", function_args="%struct.fifo_s* %local_"+read.target+read.block.label+", i32 "+read.numTokens)$
$StoreOp(ty="i8*", value="%"+read.target+"_"+read.block.label, pty="i8*", pointer="%"+read.port)$

>>

ReadEnd(readEnd) ::= <<
$LoadOp(result="%end_"+readEnd.port, ty="%struct.fifo_s*", pointer="@"+actorName+"_"+readEnd.port)$
$CallOp(ty ="void", fnptrval="@setReadEnd", function_args="%struct.fifo_s* %end_"+readEnd.port)$

>>

Write(write) ::= <<
$LoadLocalPort(write)$
%$write.target$_$write.block.label$ = call i8* @getWritePtr(%struct.fifo_s* %local_$write.target$$write.block.label$, i32 $write.numTokens$)
store i8* %$write.target$_$write.block.label$, i8** %$write.port$

>>

WriteEnd(writeEnd) ::= <<
$LoadOp(result="%end_"+writeEnd.port, ty="%struct.fifo_s*", pointer="@"+actorName+"_"+writeEnd.port)$
$CallOp(ty ="void", fnptrval="@setWriteEnd", function_args="%struct.fifo_s* %end_"+writeEnd.port)$

>>

Return(return) ::= <<
$if(return.value)$
$RetOp(type="i1", value=return.value)$
$else$
$RetOp()$

$endif$

>>

HasTokens(hasTokens) ::= <<
$LoadLocalPort(hasTokens)$
$CallOp(result="%"+hasTokens.target, ty="i1", fnptrval="@hasTokens", function_args="%struct.fifo_s* %local_"+hasTokens.port+hasTokens.block.label+", i32 "+hasTokens.numTokens)$

>>

Store(store) ::= <<
$if(store.indexes.empty)$
$StoreWithoutIndex(value=store.value, target=store.target)$
$else$
$StoreWithIndex(value=store.value, target=store.target, indexes = store.indexes)$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// ORCC IR Nodes
///////////////////////////////////////////////////////////////////////////////

// if node
IfNode(ifNode) ::= <<
$if(ifNode.thenNodes)$
$if(ifNode.elseNodes)$
$IfWithThenElseNodes(ifNode)$
$else$
2	
	$endif$
$else$
	$if(ifNode.elseNodes)$
3
$endif$
$endif$
$BlockNode(ifNode.joinNode)$

>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern, action) ::= <<
$pattern.keys:{port|
	$HasRoom(result=it+"_room", action=action,  actor=actorName, port=port, numToken=pattern.(port))$}; separator=" && "$ >>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM
///////////////////////////////////////////////////////////////////////////////

actionCall(action) ::= <<
	$CallOp(ty="void", fnptrval=action.body)$
>>

actionTestOutputs(action) ::= <<
$outputPattern(pattern=action.outputPattern, action=action)$
	$BrOp(cond="%"+action+"_room", iftrue="%hasroom_"+action, iffalse="%skip_"+action)$

hasroom_$action$:
$actionCall(action)$
	$BrOp(dest="%inc_i")$
	
>>

actionTest(action) ::= <<
	$CallOp(result="%"+action, ty="i1", fnptrval="@isSchedulable_"+action)$
	$BrOp(cond="%"+action, iftrue="%fire_"+action, iffalse="%skip_"+action)$

fire_$action$:
$if(action.outputPattern)$
$actionTestOutputs(action)$
$else$
$actionCall(action)$
	$BrOp(dest="%inc_i")$
$endif$
	
skip_$action$:

>>

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Not structured
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
@$actorName$_$port.name$ = common global %struct.fifo_s* null

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
[$value; wrap, separator=", "$]
>>

// phi definition
phiPair(value, label) ::= <<
[$value$, %$label$]
>>

variableDeclaration(variable) ::= <<
$if(variable.port)$
%$variable$ = alloca i8*

$endif$
>>

argumentDeclaration(variable) ::= <<
$variable.type$ %$variable$
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
$if(variable.constantValue)$
@$variable$ = internal global $variable.type$ $variable.constantValue$

$else$
@$variable$ = internal global $variable.type$ zeroinitializer

$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

/* // selectnode
selectNode(var, type, expr, trueVar, falseVar) ::= <<
	$var$ = select $expr$, $trueVar$, $falseVar$

>>

// bitcastnode
BitcastNode(var, type, expr) ::= <<
	$var$ = bitcast $expr$ to $type$

>>

// truncnode
TruncNode(var, type, expr) ::= <<
	$var$ = trunc $expr$ to $type$

>>

// zextnode
ZextNode(var, type, expr) ::= <<
	$var$ = zext $expr$ to $type$

>>

// sextnode
SextNode(var, type, expr) ::= <<
	$var$ = sext $expr$ to $type$

>>

// initialization port node
initPortNode(fifoName, expr, index) ::= <<
	%$fifoName$_ptr = getelementptr %struct.lff_t** $expr$, i32 $index$
	%$fifoName$_val = load %struct.lff_t** %$fifoName$_ptr
	store %struct.lff_t* %$fifoName$_val, %struct.lff_t** @$actorName$_$fifoName$

>>

>> */

///////////////////////////////////////////////////////////////////////////////
// Variables
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// ORCC Nodes
///////////////////////////////////////////////////////////////////////////////

indexes(indexes) ::= <<
$indexes: { index | i32 $index$ }; separator=", "$
>>


Call(call) ::= <<
$if(call.target)$
$call.target$ = 
$endif$
call $call.procedure.returnType$ @$call.procedure$($call.parameters; separator=", "$)

>>


Load(load) ::= <<
$if(load.indexes.empty)$
%$load.target$ = load $load.source.variable.type$* @$load.source$

$else$
$if(load.source.variable.port)$
%$load.target$_cast = bitcast i8** %$load.source$ to $load.source.variable.type$*

$endif$
%$load.target$_ptr = getelementptr $load.source.variable.type$* $if(load.source.variable.global)$
@
$else$
%
$endif$
$if(load.source.variable.port)$
$load.target$_cast 
$else$
$load.source$ 
$endif$
, i32 0, $indexes(load.indexes)$
%$load.target$ = load $load.target.type$* %$load.target$_ptr

$endif$
>>

Peek(peek) ::= <<
$LoadLocalPort(peek)$
%$peek.target$_$peek.block.label$ = call i8* @getPeekPtr(%struct.fifo_s* %local_$peek.target$$peek.block.label$, i32 $peek.numTokens$)
store i8* %$peek.target$_$peek.block.label$, i8** %$peek.port$

>>

/*
Store(store) ::= <<
$if(store.indexes.empty)$
store i32 $store.value$, i32* @$store.target$

$else$
$if(store.target.variable.port)$
%$store.target$_cast = bitcast  i8** %$store.target$ to $store.target.variable.type$* 

$endif$
%$store.target$_ptr = getelementptr $store.target.variable.type$* $if(store.target.variable.global)$
@
$else$
%
$endif$
$store.target$$if(store.target.variable.port)$
_cast
$endif$
, i32 0, $indexes(store.indexes)$
store i32 $store.value$, i32* %$store.target$_ptr

$endif$
>>
*/


///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////


instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
	$instructions(blockNode.instructions)$
>>


// while node
WhileNode(whileNode) ::= <<
	br i1 $whileNode.value$, label %$label(whileNode.Nodes)$, label %$label(whileNode.joinNode)$

$label(whileNode.Nodes)$:
$nodes(whileNode.nodes)$	br i1 $whileNode.value$, label %$label(whileNode.Nodes)$, label %$label(whileNode.joinNode)$

b$whileNode.joinNode.label$:
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Instantiation
///////////////////////////////////////////////////////////////////////////////

inst(name, nodes) ::= <<

define internal void @$name$(%struct.lff_t** %fifo) {
entry:
$nodes$	ret void
}
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

define internal $procedure.returnType$ $procedure$($procedure.parameters.list: {$argumentDeclaration(it)$}; wrap, anchor, separator=", "$) {
entry:
$if(procedure.locals.list)$
	$procedure.locals.list: variableDeclaration(it)$
$endif$
$procedure.nodes: {$(it.class.simpleName)(it)$}$}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM
///////////////////////////////////////////////////////////////////////////////


/*
actionCall(action) ::= <<
	call void @$action$()
>>
*/

/*
actionTest(action, iterator) ::= <<
	%$action$ = call i1 @isSchedulable_$action$()
	br i1 %$action$, label %fire_$action$, label %skip_$action$

fire_$action$:
$if(action.outputPattern)$

$first(action.outputPattern.keys):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator)$}$
$first(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$ $andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$}$
$rest(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$
$andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$$\n$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %hasRoom_$action$, label %hasNoRoom_$action$

hasRoom_$action$:
$actionCall(action)$
	br label %bb 
hasNoRoom_$action$:
	br label %return

$else$
$actionCall(action)$
	br label %bb
	
$endif$

skip_$action$:

>>
*/

outside_FSM_actionTest(action, iterator) ::= <<
	%$action$ = call i1 @isSchedulable_$action$()
	br i1 %$action$, label %fire_$action$, label %skip_$action$

fire_$action$:
$if(action.outputPattern)$
$first(action.outputPattern.keys):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator)$}$
$first(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$ $andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$}$
$rest(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$
$andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$$\n$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %hasRoom_$action$, label %hasNoRoom_$action$

hasRoom_$action$:
$actionCall(action)$
	br label %bb
hasNoRoom_$action$:
	br label %return

$else$
$actionCall(action)$
ret i1 1
$endif$

skip_$action$:

>>

schedulingTest(actions, iterator) ::= <<
$actions: actionTest(action=it)$
>>

outside_FSM_schedulingTest(actions, iterator) ::= <<
$actions: outside_FSM_actionTest(action=it, iterator = iterator)$
>>

scheduler(actions, iterator) ::= <<
define i32 @$actorName$_scheduler() {
entry:
	$AllocaOp(result="%i", type="i32")$ 
	$StoreOp(ty="i32", value="0", pty="i32", pointer="%i")$
	$BrOp(dest="%bb")$
	
bb:  
$if(actions)$
$schedulingTest(actions=actions, iterator = iterator)$
$endif$
	$BrOp(dest="%return")$

inc_i:
  $LoadOp(result="%i_load", ty="i32", pointer="%i")$
  $AddOp(result="%i_add", ty="i32", op1="%i_load", op2="1")$
  $StoreOp(ty="i32", value="%i_add", pty="i32", pointer="%i")$
  $BrOp(dest="%bb")$

return:
	$LoadOp(result="%i_ret", ty="i32", pointer="%i")$
	$RetOp(type="i32", value="%i_ret")$
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
	call void @$nextState.action$()
	store i32 $nextState.targetState.index$, i32* @_FSM_state
	ret i1 1

>>

actionTestState(nextState, br, iterator) ::= <<

$if(nextState.action.outputPattern)$
	%sched_$nextState.action$ = call i1 @isSchedulable_$nextState.action$()
	br i1 %sched_$nextState.action$, label %$nextState.action$, label %$br$

$nextState.action$:
$first(nextState.action.outputPattern.keys):{port|$outputPattern(pattern=port, token = nextState.action.outputPattern.(port), iterator = iterator)$}$ $rest(nextState.action.outputPattern.keys):{port|$outputPattern(pattern=port, token = nextState.action.outputPattern.(port), iterator = iterator.nextNodeIndex)$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %n_$nextState.action$, label %$br$

n_$nextState.action$:
$actionCallState(nextState)$
$br$:
$else$
	%sched_$nextState.action$ = call i1 @isSchedulable_$nextState.action$()
	br i1 %sched_$nextState.action$, label %$nextState.action$, label %$br$

$nextState.action$:
$actionCallState(nextState)$

$br$:
$endif$

>>

schedulingTestState(nextStates, iterator) ::= <<
$trunc(nextStates): actionTestState(nextState=it, br = "bb"+i0, iterator = iterator)$
$last(nextStates): actionTestState(nextState=it, br = "return", iterator = iterator)$
>>

stateScheduler(transition, iterator) ::= <<
define internal i1 @$transition.sourceState$_state_scheduler() {
entry:
$schedulingTestState(nextStates=transition.nextStateInfo, iterator = iterator.init)$
	ret i1 0
}

>>

switch(transitions) ::= <<
	%_FSM_state = load i32* @_FSM_state
	switch i32 %_FSM_state, label %default [
$transitions:{$\t\t$i32 $it.sourceState.index$, label %s_$it.sourceState$$\n$}$$\t$]
$transitions: {
s_$it.sourceState$:
	%$it.sourceState$_res = call i1 @$it.sourceState$_state_scheduler();
	br i1 %$it.sourceState$_res, label %bb, label %return
}$
default:
	br label %return

>>

schedulerFSM(actions, fsm, iterator) ::= <<

@_FSM_state = internal global i32 $fsm.initialState.index$

$if(actions)$
define i1 @outside_FSM_scheduler() {
entry:
	$outside_FSM_schedulingTest(actions=actions, iterator = iterator)$
	ret i1 0
}


$endif$
$fsm.transitions: stateScheduler(transition=it, iterator = iterator); separator="\n"$
define i32 @$actorName$_scheduler() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(actions)$
	%out = call i1 @outside_FSM_scheduler()
	br i1 %out, label %bb1, label %bb2

bb1:
	%0 = load i32* %i
	%1 = add i32 %0, 1
	store i32 %1, i32* %i
	br label %bb
	
bb2:
$switch(fsm.transitions)$
$else$ $switch(fsm.transitions)$
$endif$

return:
	%i_ret = load i32* %i
	ret i32 %i_ret
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actorName, actor) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "$actor.name$"

%struct.fifo_s = type opaque

; { i32, i32, i8*, i32, i32 }

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIFO functions declarations

declare i8* @getPeekPtr(%struct.fifo_s* %fifo, i32 %n)
declare i8* @getReadPtr(%struct.fifo_s* %fifo, i32 %n)
declare i8* @getWritePtr(%struct.fifo_s* %fifo, i32 %n)
declare i1 @hasRoom(%struct.fifo_s* %fifo, i32 %n)
declare i1 @hasTokens(%struct.fifo_s* %fifo, i32 %n)
declare void @setReadEnd(%struct.fifo_s* %fifo)
declare void @setWriteEnd(%struct.fifo_s* %fifo)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
$actor.inputs.list: fifo(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
$actor.outputs.list: fifo(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
$actor.stateVars.list: stateVar(it)$

$! TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO !$
$! $insts$ !$
$! TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO !$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
$actor.procs.list: procedure(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
$actor.actions: action(it)$

$!
$if(initializes)$
;////////////////////////////////////////////////////////////////////////////////
;// Initializes
$initializes$
define internal void @$name$_initialize() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(initialize)$
$schedulingTest(initialize)$
$endif$
	br label %return
	
return:
	ret void
}

$endif$
!$
;////////////////////////////////////////////////////////////////////////////////
;// Action scheduler
$if(actor.actionScheduler.fsm)$
$schedulerFSM(actions=actor.actionScheduler.actions, fsm=actor.actionScheduler.fsm)$
$else$
$scheduler(actions=actor.actionScheduler.actions)$
$endif$ 
>>
