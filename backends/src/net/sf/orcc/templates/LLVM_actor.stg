group LLVM_actor;

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(port) ::= <<
@$actorName$_$port.name$ = common global %struct.fifo_s* null

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
[$value; wrap, separator=", "$]
>>

// phi definition
phiPair(value, label) ::= <<
[$value$, %$label$]
>>

variableDeclaration(variable) ::= <<
$if(variable.port)$
%$variable$ = alloca i8*

$endif$
>>

argumentDeclaration(variable) ::= <<
$variable.type$ %$variable$
>>

///////////////////////////////////////////////////////////////////////////////
// State variables
///////////////////////////////////////////////////////////////////////////////
stateVar(variable) ::= <<
$if(variable.constantValue)$
@$variable$ = internal global $variable.type$ $variable.constantValue$

$else$
@$variable$ = internal global $variable.type$ zeroinitializer

$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

/* // selectnode
selectNode(var, type, expr, trueVar, falseVar) ::= <<
	$var$ = select $expr$, $trueVar$, $falseVar$

>>

// bitcastnode
BitcastNode(var, type, expr) ::= <<
	$var$ = bitcast $expr$ to $type$

>>

// truncnode
TruncNode(var, type, expr) ::= <<
	$var$ = trunc $expr$ to $type$

>>

// zextnode
ZextNode(var, type, expr) ::= <<
	$var$ = zext $expr$ to $type$

>>

// sextnode
SextNode(var, type, expr) ::= <<
	$var$ = sext $expr$ to $type$

>>

// initialization port node
initPortNode(fifoName, expr, index) ::= <<
	%$fifoName$_ptr = getelementptr %struct.lff_t** $expr$, i32 $index$
	%$fifoName$_val = load %struct.lff_t** %$fifoName$_ptr
	store %struct.lff_t* %$fifoName$_val, %struct.lff_t** @$actorName$_$fifoName$

>>

>> */

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

indexes(indexes) ::= <<
$indexes: { index | i32 $index$ }; separator=", "$
>>

loadLocalPort(instr) ::= <<
%local_$instr.port$$instr.block.label$ = load %struct.fifo_s** @$actorName$_$instr.port$
>>

// $assign.value$
Assign(assign) ::= <<
%$assign.target$ = $assign.value$

>>

Call(call) ::= <<
$if(call.target)$
$call.target$ = 
$endif$
call $call.procedure.returnType$ @$call.procedure$($call.parameters; separator=", "$)

>>

HasTokens(hasTokens) ::= <<
$loadLocalPort(hasTokens)$
%$hasTokens.target$ = call i32 @hasTokens(%struct.fifo_s* %local_$hasTokens.port$$hasTokens.block.label$, i32 $hasTokens.numTokens$)

>>

Load(load) ::= <<
$if(load.indexes.empty)$
%$load.target$ = load $load.source.variable.type$* @$load.source$

$else$
$if(load.source.variable.port)$
%$load.target$_cast = bitcast i8** %$load.source$ to $load.source.variable.type$*

$endif$
%$load.target$_ptr = getelementptr $load.source.variable.type$* $if(load.source.variable.global)$
@
$else$
%
$endif$
$if(load.source.variable.port)$
$load.target$_cast
$else$
$load.source$
$endif$
, i32 0, $indexes(load.indexes)$
%$load.target$ = load $load.target.type$* %$load.target$_ptr

$endif$
>>

Peek(peek) ::= <<
$loadLocalPort(peek)$
%$peek.target$_$peek.block.label$ = call i8* @getPeekPtr(%struct.fifo_s* %local_$peek.target$$peek.block.label$, i32 $peek.numTokens$)
store i8* %$peek.target$_$peek.block.label$, i8** %$peek.port$

>>

phiPredecessors(vars) ::= <<
$vars: { var |[ %$var.variable$, %b$var.variable.instruction.block.label$ ]}; separator=", "$
>>

PhiAssignment(phi) ::= <<
%$phi.target$ = phi $phi.target.type$ $phiPredecessors(phi.vars)$

>>

Read(read) ::= <<
$loadLocalPort(read)$
%$read.target$_$read.block.label$ = call i8* @getReadPtr(%struct.fifo_s* %local_$read.target$$read.block.label$, i32 $read.numTokens$)
store i8* %$read.target$_$read.block.label$, i8** %$read.port$

>>

// return node
Return(return) ::= <<
$if(return.value)$
ret i1 $return.value$

$else$
ret void

$endif$
>>

Store(store) ::= <<
$if(store.indexes.empty)$
store i32 $store.value$, $store.target.variable.type$* @$store.target$

$else$
$if(store.target.variable.port)$
$store.target$_cast = bitcast $store.target.variable.type$* %$store.target$
$endif$
%$store.target$_ptr = getelementptr $store.target.variable.type$* $if(store.target.variable.global)$
@
$else$
%
$endif$
$store.target$$if(store.target.variable.port)$
_cast
$endif$
, i32 0, $indexes(store.indexes)$
store i32 $store.value$, i32* %$store.target$_ptr

$endif$
>>

// write node
Write(write) ::= <<
$loadLocalPort(write)$
%$write.target$_$write.block.label$ = call i8* @getWritePtr(%struct.fifo_s* %local_$write.target$$write.block.label$, i32 $write.numTokens$)
store i8* %$write.target$_$write.block.label$, i8** %$write.port$

>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

label(nodes) ::= "b$first(nodes):{ x | $x.label$}$"

instructions(instructions) ::= <<
$instructions: {$(it.class.simpleName)(it)$}$
>>

nodes(nodes) ::= <<
$nodes: {$(it.class.simpleName)(it)$}$
>>

// if node
BlockNode(blockNode) ::= <<
	$instructions(blockNode.instructions)$
>>

// if node
IfNode(ifNode) ::= <<
	br i1 $ifNode.value$, label %$label(ifNode.thenNodes)$, label %$label(ifNode.elseNodes)$

$label(ifNode.thenNodes)$:
$nodes(ifNode.thenNodes)$	br label %b$ifNode.joinNode.label$

$label(ifNode.elseNodes)$:
$nodes(ifNode.elseNodes)$	br label %b$ifNode.joinNode.label$

b$ifNode.joinNode.label$:
$BlockNode(ifNode.joinNode)$
>>

// while node
WhileNode(whileNode) ::= <<
	br i1 $whileNode.value$, label %$label(whileNode.Nodes)$, label %$label(whileNode.joinNode)$

$label(whileNode.Nodes)$:
$nodes(whileNode.nodes)$	br i1 $whileNode.value$, label %$label(whileNode.Nodes)$, label %$label(whileNode.joinNode)$

b$whileNode.joinNode.label$:
$BlockNode(whileNode.joinNode)$
>>

///////////////////////////////////////////////////////////////////////////////
// Instantiation
///////////////////////////////////////////////////////////////////////////////

inst(name, nodes) ::= <<

define internal void @$name$(%struct.lff_t** %fifo) {
entry:
$nodes$	ret void
}
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<

define internal $procedure.returnType$ $procedure$($procedure.parameters.list: {$argumentDeclaration(it)$}; wrap, anchor, separator=", "$) {
entry:
$if(procedure.locals.list)$
	$procedure.locals.list: variableDeclaration(it)$
$endif$
$procedure.nodes: {$(it.class.simpleName)(it)$}$}

>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

action(action) ::= <<
$procedure(action.body)$$procedure(action.scheduler)$
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(pattern, token, iterator) ::= <<
$loadFifoTmp(var=iterator.index, fifoName=pattern)$ $hasRoomNode(var=iterator.nextNodeIndex.index, expr="%"+iterator.lastIndex, token=token)$
>>


///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
	call void @$action$()
>>

actionTest(action, iterator) ::= <<
	%$action$ = call i1 @isSchedulable_$action$()
	br i1 %$action$, label %fire_$action$, label %skip_$action$

fire_$action$:
$if(action.outputPattern)$
$first(action.outputPattern.keys):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator)$}$
$first(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$ $andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$}$
$rest(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$
$andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$$\n$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %hasRoom_$action$, label %hasNoRoom_$action$

hasRoom_$action$:
$actionCall(action)$
	br label %bb
hasNoRoom_$action$:
	br label %return

$else$
$actionCall(action)$
	br label %return
$endif$

skip_$action$:

>>

outside_FSM_actionTest(action, iterator) ::= <<
	%$action$ = call i1 @isSchedulable_$action$()
	br i1 %$action$, label %fire_$action$, label %skip_$action$

fire_$action$:
$if(action.outputPattern)$
$first(action.outputPattern.keys):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator)$}$
$first(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$ $andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$}$
$rest(rest(action.outputPattern.keys)):{port|$outputPattern(pattern=port, token = action.outputPattern.(port), iterator=iterator.nextNodeIndex)$
$andNode(var= iterator.nextNodeIndex.index, e1="%"+iterator.firstIndex, e2="%"+iterator.secondIndex)$$\n$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %hasRoom_$action$, label %hasNoRoom_$action$

hasRoom_$action$:
$actionCall(action)$
	br label %bb
hasNoRoom_$action$:
	br label %return

$else$
$actionCall(action)$
ret i1 1
$endif$

skip_$action$:

>>

schedulingTest(actions, iterator) ::= <<
$actions: actionTest(action=it, iterator = iterator)$
>>

outside_FSM_schedulingTest(actions, iterator) ::= <<
$actions: outside_FSM_actionTest(action=it, iterator = iterator)$
>>

scheduler(actions, iterator) ::= <<
define i32 @$actorName$_scheduler() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(actions)$
$schedulingTest(actions=actions, iterator = iterator)$
$endif$
	br label %return

return:
	%i_ret = load i32* %i
	ret i32 %i_ret
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
	call void @$nextState.action$()
	store i32 $nextState.targetState.index$, i32* @_FSM_state
	ret i1 1

>>

actionTestState(nextState, br, iterator) ::= <<

$if(nextState.action.outputPattern)$
	%sched_$nextState.action$ = call i1 @isSchedulable_$nextState.action$()
	br i1 %sched_$nextState.action$, label %$nextState.action$, label %$br$

$nextState.action$:
$first(nextState.action.outputPattern.keys):{port|$outputPattern(pattern=port, token = nextState.action.outputPattern.(port), iterator = iterator)$}$ $rest(nextState.action.outputPattern.keys):{port|$outputPattern(pattern=port, token = nextState.action.outputPattern.(port), iterator = iterator.nextNodeIndex)$}$
	br i1 %$iterator.nextNodeIndex.lastIndex$, label %n_$nextState.action$, label %$br$

n_$nextState.action$:
$actionCallState(nextState)$
$br$:
$else$
	%sched_$nextState.action$ = call i1 @isSchedulable_$nextState.action$()
	br i1 %sched_$nextState.action$, label %$nextState.action$, label %$br$

$nextState.action$:
$actionCallState(nextState)$

$br$:
$endif$

>>

schedulingTestState(nextStates, iterator) ::= <<
$trunc(nextStates): actionTestState(nextState=it, br = "bb"+i0, iterator = iterator)$
$last(nextStates): actionTestState(nextState=it, br = "return", iterator = iterator)$
>>

stateScheduler(transition, iterator) ::= <<
define internal i1 @$transition.sourceState$_state_scheduler() {
entry:
$schedulingTestState(nextStates=transition.nextStateInfo, iterator = iterator.init)$
	ret i1 0
}

>>

switch(transitions) ::= <<
	%_FSM_state = load i32* @_FSM_state
	switch i32 %_FSM_state, label %default [
$transitions:{$\t\t$i32 $it.sourceState.index$, label %s_$it.sourceState$$\n$}$$\t$]
$transitions: {
s_$it.sourceState$:
	%$it.sourceState$_res = call i1 @$it.sourceState$_state_scheduler();
	br i1 %$it.sourceState$_res, label %bb, label %return
}$
default:
	br label %return

>>

schedulerFSM(actions, fsm, iterator) ::= <<

@_FSM_state = internal global i32 $fsm.initialState.index$

$if(actions)$
define i1 @outside_FSM_scheduler() {
entry:
	$outside_FSM_schedulingTest(actions=actions, iterator = iterator)$
	ret i1 0
}


$endif$
$fsm.transitions: stateScheduler(transition=it, iterator = iterator); separator="\n"$
define i32 @$actorName$_scheduler() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(actions)$
	%out = call i1 @outside_FSM_scheduler()
	br i1 %out, label %bb1, label %bb2

bb1:
	%0 = load i32* %i
	%1 = add i32 %0, 1
	store i32 %1, i32* %i
	br label %bb
	
bb2:
$switch(fsm.transitions)$
$else$ $switch(fsm.transitions)$
$endif$

return:
	%i_ret = load i32* %i
	ret i32 %i_ret
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(actorName, actor) ::= <<
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generated from "$actor.name$"

%struct.fifo_s = type opaque

; { i32, i32, i8*, i32, i32 }

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; FIFO functions declarations

declare i8* @getPeekPtr(%struct.fifo_s* %fifo, i32 %n)
declare i8* @getReadPtr(%struct.fifo_s* %fifo, i32 %n)
declare i8* @getWritePtr(%struct.fifo_s* %fifo, i32 %n)
declare i32 @hasRoom(%struct.fifo_s* %fifo, i32 %n)
declare i32 @hasTokens(%struct.fifo_s* %fifo, i32 %n)
declare void @setReadEnd(%struct.fifo_s* %fifo)
declare void @setWriteEnd(%struct.fifo_s* %fifo)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input FIFOs
$actor.inputs.list: fifo(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Output FIFOs
$actor.outputs.list: fifo(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; State variables of the actor
$actor.stateVars.list: stateVar(it)$

$! TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO !$
$! $insts$ !$
$! TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO !$

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Functions/procedures
$actor.procs.list: procedure(it)$
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actions
$actor.actions: action(it)$

$!
$if(initializes)$
;////////////////////////////////////////////////////////////////////////////////
;// Initializes
$initializes$
define internal void @$name$_initialize() {
entry:
	%i = alloca i32
	store i32 0, i32* %i
	br label %bb
	
bb:  
$if(initialize)$
$schedulingTest(initialize)$
$endif$
	br label %return
	
return:
	ret void
}

$endif$

;////////////////////////////////////////////////////////////////////////////////
;// Action scheduler
$if(scheduler.fsm)$
$schedulerFSM(actions=scheduler.actions, fsm=scheduler.fsm, iterator = iterator)$
$else$
$scheduler(actions=scheduler.actions, iterator= iterator)$
$endif$ !$
>>
