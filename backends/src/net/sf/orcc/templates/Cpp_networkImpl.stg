group Cpp_networkImpl;

setFifo(fifo) ::= <<
$fifo.source$.connect(ACTOR_PORT_OUT, $fifo.source$_$fifo.src_port$, fifo_$fifo.count$);
$fifo.target$.connect(ACTOR_PORT_IN, $fifo.target$_$fifo.tgt_port$, fifo_$fifo.count$);

>>

network(debugFifos, name, size, broadcasts, initializes, instances, connections) ::= <<
/**
 * Generated from "$name$"
 */
 
#include "Network_$name$.h"

#include <iostream>

extern "C" {
#include "orcc/orcc_util.h"
}

$connections:{ fifo | FifoAPI * network_$name$::fifo_$fifo.count$ = (FifoAPI *)new CalOrientedBoundedFifo<$fifo.type$>($fifo.size$);}; separator="\n"$

network_$name$::network_$name$()
{
	$connections:setFifo()$
}

network_$name$::~network_$name$(){}

void network_$name$::start(std::string &strErr)
{
	$instances: {$it$.initializeActor();}; separator="\n"$
	
	$instances: {$it$.startActorExecution();}; separator="\n"$
}

void network_$name$::stop(std::string &strErr)
{
	$instances: {inst |$inst$.stop();}; separator="\n"$
}

void network_$name$::schedule() {
	$initializes: { init | $init$.initialize();}; separator="\n"$

	while (1) {
		$instances: { inst | $inst$.scheduler();$\n$}$
	}
}

#ifdef __TRACE_TOKENS__
TraceAka g_oTracer;
#endif

int main(int argc, char *argv[]) {

	init_orcc(argc, argv, NULL);

	std::string strErr="";

	network_$name$ network;
	network.start(strErr);
	network.schedule();
	
	int i=0;
	std::cout << "Capture Key to terminate..." << std::endl;
	std::cin \>\> i;

	network.stop(strErr);
	
	return 0;
}

>>

