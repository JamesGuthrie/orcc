// Algo_Interpolation_halfpel
//
// Author: David B. Parlour (dave.parlour@xilinx.com)
//
// Copyright (c) 2004-2005 Xilinx Inc.
// All Rights Reserved
//
// Disclaimer:  THIS PROGRAM IS PROVIDED "AS IS" WITH NO WARRANTY 
//              WHATSOEVER AND XILINX SPECIFICALLY DISCLAIMS ANY 
//              IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
//              A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.
// Interpolation for motion compensation
import all caltrop.lib.BitOps;
actor E___Algo_Interpolation_halfpel () int(size=PIX_SZ) RD, int(size=FLAG_SZ) halfpel ==>
int(size=PIX_SZ) MOT :

// Port size declaration
	int FLAG_SZ = 4;

	int PIX_SZ = 9;


	none: action halfpel:[ flags ], RD:[ rd ] repeat 81 ==> MOT:[ mot ] repeat 64
	guard
		rshift(flags, 1) = 0
	var
		int rdRow , int motRow , int k , List(type: int(size=9), size=64) mot := [ 0
		: for int i in Integers(0, 63) ]
	do
	// mot := [ rd[9*j+k] : for k in Integers(0,7), for j in Integers(0,7)]
		rdRow := 0;
		motRow := 0;
		while (motRow < 64) do
			k := 0;
			while (k < 8) do
				mot[motRow + k] := rd[rdRow + k];
				k := k + 1;
			end
			rdRow := rdRow + 9;
			motRow := motRow + 8;
		end
	end

	row: action halfpel:[ flags ], RD:[ rd ] repeat 81 ==> MOT:[ mot ] repeat 64
	guard
		rshift(flags, 1) = 1
	var
		int round := 1 - bitand(flags, 1) , int rdRow , int motRow , int k ,
		List(type: int(size=9), size=64) mot := [ 0 : for int i in Integers(0, 63) ]
	do
	// mot := [ rshift(rd[9*j+k] + rd[9*(j+1)+k] + round, 1) 

	//          : for k in Integers(0,7), for j in Integers(0,7)]
		rdRow := 0;
		motRow := 0;
		while (motRow < 64) do
			k := 0;
			while (k < 8) do
				mot[motRow + k] := rshift(rd[rdRow + k] + rd[rdRow + k + 9] + round, 1);
				k := k + 1;
			end
			rdRow := rdRow + 9;
			motRow := motRow + 8;
		end
	end

	col: action halfpel:[ flags ], RD:[ rd ] repeat 81 ==> MOT:[ mot ] repeat 64
	guard
		rshift(flags, 1) = 2
	var
		int round := 1 - bitand(flags, 1) , int rdRow , int motRow , int k ,
		List(type: int(size=9), size=64) mot := [ 0 : for int i in Integers(0, 63) ]
	do
	// mot := [ rshift(rd[9*j+k] + rd[9*j+k+1] + round, 1) 

	//          : for k in Integers(0,7), for j in Integers(0,7)]
		rdRow := 0;
		motRow := 0;
		while (motRow < 64) do
			k := 0;
			while (k < 8) do
				mot[motRow + k] := rshift(rd[rdRow + k] + rd[rdRow + k + 1] + round, 1);
				k := k + 1;
			end
			rdRow := rdRow + 9;
			motRow := motRow + 8;
		end
	end

	both: action halfpel:[ flags ], RD:[ rd ] repeat 81 ==> MOT:[ mot ] repeat 64 
	var
		int round := 2 - bitand(flags, 1) , int rdRow , int motRow , int k ,
		List(type: int(size=9), size=64) mot := [ 0 : for int i in Integers(0, 63) ]
	do
	// mot := [ rshift(rd[9*j+k] + rd[9*(j+1)+k]

	//                 rd[9*(j+1)+k] + rd[9*(j+1)+k+1] + round, 2) 

	//          : for k in Integers(0,7), for j in Integers(0,7)]
		rdRow := 0;
		motRow := 0;
		while (motRow < 64) do
			k := 0;
			while (k < 8) do
				mot[motRow + k] := rshift(rd[rdRow + k] + rd[rdRow + k + 1] + rd[rdRow + k
				+ 9] + rd[rdRow + k + 10] + round, 2);
				k := k + 1;
			end
			rdRow := rdRow + 9;
			motRow := motRow + 8;
		end
	end

	priority
		none > col > row > both;
	end

end