puts "initializing orcc.exp"

# front-end command-line
set cmd_frontend "java -cp \"../plugin/lib/antlr-runtime-3.1.3.jar;../plugin/lib/jgrapht-jdk1.6.jar;../plugin/bin\" net.sf.orcc.frontend.Frontend "

# back-end command-line
set cmd_backend "java -cp \"../plugin/lib/jgrapht-jdk1.6.jar;../plugin/bin;../backends/lib/antlr-2.7.7.jar;../backends/lib/stringtemplate.jar;../backends/bin\" net.sf.orcc.backends.c."

# initialize output path
set outputDir "output"
if { ![file exists outputDir] } {
  file mkdir $outputDir
}

# createNetwork
#
#	Creates an XDF that has the given name, and contains an instance whose class is given.
#
# Arguments:
#   outputFile	output file.
#   name		name of the network.
#	clasz		class of the unique instance.

proc createNetwork {outputFile name clasz} {
  global emptyNetwork

  set chan [open $outputFile w]
  puts $chan "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<XDF name=\"$name\">
    <Instance id=\"inst\">
        <Class name=\"$clasz\"/>
    </Instance>
</XDF>"
  close $chan
}

# frontendOneActor
#
#	Calls the front-end on the given actor.
#
# Arguments:
#   actor a source file that contains an actor

proc frontendOneActor {actor} {
  global cmd_frontend outputDir
  
  regsub {(.*)\.c(al)?} $actor {\1} clasz
  regsub {.*/(.*)} $clasz {\1} network
  createNetwork "$outputDir/$network.xdf" "output-$network" "../$clasz"
  
  set network "$outputDir/$network.xdf"
  
  # read the actor    
  set chan [open $actor r]
  set data [read $chan]
  close $chan

  # get expected test result
  set reason []
  if {[regexp {PASS: ([^\n]*)} $data dummy reason]} {
    set expected PASS
  } elseif {[regexp {XFAIL: ([^\n]*)} $data dummy reason]} {
    set expected XFAIL
  } else {
    warning "Test case must begin with // PASS or // XFAIL: $clasz"
    return
  }

  # execute the front-end
  set retval [ catch { eval exec -keepnewline -- $cmd_frontend $network $outputDir } errmsg ]

  if {$retval == 0} {
    if {$expected == "PASS"} {
      pass "$actor: $reason"
    } else {
      xpass "ERROR: $actor was expected to fail because: $reason\n$errmsg"
    }
  } else {
    if {$expected == "XFAIL"} {
      xfail "$actor: $reason"
    } else {
      fail "ERROR: $actor was expected to succeed because: $reason\n$errmsg"
    }
  }
}

# frontend
#
#	Calls the front-end on the given network.
#
# Arguments:
#   inputNetwork top-level XDF network

proc frontend {inputNetwork} {
  global cmd_frontend outputDir

  # execute the front-end
  set retval [ catch { eval exec -keepnewline -- $cmd_frontend $inputNetwork $outputDir } errmsg ]

  if {$retval != 0} {
      fail "ERROR when compiling $inputNetwork: $errmsg"
  }
}

# backend
#
#	Calls the back-end on the given network.
#
# Arguments:
#   name name of the back-end
#   inputNetwork top-level XDF network

proc backend {name inputNetwork} {
  global cmd_backend

  # execute the back-end
  set retval [ catch { eval exec -keepnewline -- "$cmd_backend$name" $inputNetwork } errmsg ]

  if {$retval != 0} {
      fail "ERROR when compiling $inputNetwork: $errmsg"
  }
}
