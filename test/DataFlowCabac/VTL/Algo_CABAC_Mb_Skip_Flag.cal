/*
 * Copyright (C) 2010 Swiss Federal Institution of Technology (EPFL)
 * Author: Endri Bezati
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

actor Algo_CABAC_Mb_Skip_Flag()
	uint(size=4)	bits,
	uint(size=4)	Cabac_Init_Idc,
	uint(size=4)	Entropy_Coding,
	uint(size=9)	In_CodIRange,
	uint(size=9)	In_CodIOffset,
	uint(size=32)	Curr_Mb_Addr,
	uint(size=32)	Pic_Width_In_Mbs,
	uint(size=32)	Pic_Size_In_Mbs,
	uint(size=3)	Slice_Type,
	uint(size=5)	Syntax_Element,
	uint(size=6) 	val_QP
		==>
			uint(size=4)	Mb_Skip_Flag,
			uint(size=9)	Dbits_Read,
			uint(size=9)	Out_CodIRange,
			uint(size=9)	Out_CodIOffset:


/******************************************************************************
								Global Variables/Constants
******************************************************************************/
	/* Constants */
	// Cabac Initialization Arrays for mb_skip_flag
	List ( type: List ( type: List (type: int, size = 2) , size = 3), size = 3 ) Cabac_Context_Init_P_SP =
	[
		/* i_cabac_init_idc == 0 */
		[
			[23,33], [23,2], [21,0]
		],
		
		/* i_cabac_init_idc == 1 */
		[
			[22,25], [34,0], [16,0]
		],
		
		/* i_cabac_init_idc == 2 */
		[
			[29,16], [25,0], [14,0]
		]
	];
	
	List ( type: List ( type: List (type: int, size = 2) , size = 3), size = 3 ) Cabac_Context_Init_B = 
	[
		/* i_cabac_init_idc == 0 */
		[
			[18,64], [9,43], [29,0]
		],
		
		/* i_cabac_init_idc == 1 */
		[
			[26,34], [19,22], [40,0]
		],
		
		/* i_cabac_init_idc == 2 */
		[
			[20,40], [20,10], [29,0]
		]
	];
	
	/* CABAC Arithmetic Decoding qCodIRangeIdx */
	List ( type:uint, size = 64 ) transIdxMPS = 
	[
		1, 2, 3, 4, 5, 6, 7, 8,
		9,10,11,12,13,14,15,16,
		17,18,19,20,21,22,23,24,
		25,26,27,28,29,30,31,32,
		33,34,35,36,37,38,39,40,
		41,42,43,44,45,46,47,48,
		49,50,51,52,53,54,55,56,
		57,58,59,60,61,62,62,63
	];
	//
	List ( type:uint, size = 64 ) transIdxLPS = 
	[
		0, 0, 1, 2, 2, 4, 4, 5,
		6, 7, 8, 9, 9,11,11,12,
		13,13,15,15,16,16,18,18,
		19,19,21,21,22,22,23,24,
		24,25,26,26,27,27,28,29,
		29,30,30,30,31,32,32,33,
		33,33,34,34,35,35,35,36,
		36,36,37,37,37,38,38,63
	];
	
	//
	List ( type: List ( type: uint , size = 4), size = 64 ) rangeTabLPS = 
	
	[
		[128,176,208,240], [128,167,197,227], [128,158,187,216], [123,150,178,205],
		[116,142,169,195], [111,135,160,185], [105,128,152,175], [100,122,144,166],
		[ 95,116,137,158], [ 90,110,130,150], [ 85,104,123,142], [ 81, 99,117,135],
		[ 77, 94,111,128], [ 73, 89,105,122], [ 69, 85,100,116], [ 66, 80, 95,110],
		[ 62, 76, 90,104], [ 59, 72, 86, 99], [ 56, 69, 81, 94], [ 53, 65, 77, 89],
		[ 51, 62, 73, 85], [ 48, 59, 69, 80], [ 46, 56, 66, 76], [ 43, 53, 63, 72],
		[ 41, 50, 59, 69], [ 39, 48, 56, 65], [ 37, 45, 54, 62], [ 35, 43, 51, 59],
		[ 33, 41, 48, 56], [ 32, 39, 46, 53], [ 30, 37, 43, 50], [ 29, 35, 41, 48],
		[ 27, 33, 39, 45], [ 26, 31, 37, 43], [ 24, 30, 35, 41], [ 23, 28, 33, 39],
		[ 22, 27, 32, 37], [ 21, 26, 30, 35], [ 20, 24, 29, 33], [ 19, 23, 27, 31],
		[ 18, 22, 26, 30], [ 17, 21, 25, 28], [ 16, 20, 23, 27], [ 15, 19, 22, 25],
		[ 14, 18, 21, 24], [ 14, 17, 20, 23], [ 13, 16, 19, 22], [ 12, 15, 18, 21],
		[ 12, 14, 17, 20], [ 11, 14, 16, 19], [ 11, 13, 15, 18], [ 10, 12, 15, 17],
		[ 10, 12, 14, 16], [  9, 11, 13, 15], [  9, 11, 12, 14], [  8, 10, 12, 14],
		[  8,  9, 11, 13], [  7,  9, 11, 12], [  7,  9, 10, 12], [  7,  8, 10, 11],
		[  6,  8,  9, 11], [  6,  7,  9, 10], [  6,  7,  8,  9], [  2,  2,  2,  2]
	];
	
	uint(size=7) PICWIDTH = 1280/16;
	

	// AVC/H.264 Slice Types
	
	uint(size=3) SLICE_TYPE_P  = 0;
	uint(size=3) SLICE_TYPE_SP = 3;
	
	/* Mb skip Flag */
	int CABAC_MB_SKIP_FLAG_SE = 5;
	int CABAC_INIT_SE = 25;
	/* Variables */
	
	/* Input binary Array */
	int maxReadBits = 32;
	
	int ReadBits := maxReadBits;
	int ReadResult := 0;
	List ( type : int (size = 6), size = 32 ) readBits := [0:for int i in Integers(0,31)] ;
	
	
	List ( type : int (size = 6), size = 3 ) pStateIdx	:= [0:for int i in Integers(0,2)] ;
	List ( type : int (size = 4), size = 3 ) valMPS		:= [0:for int i in Integers(0,2)] ;
	
	List ( type : int (size=4), size = PICWIDTH + 1) mb_skip_flag := [0:for int i in Integers(0,PICWIDTH)] ;
	
	
	//Basic Variables
	
	uint SliceType;
	uint(size=6) QP;
	int preCtxState;
	uint(size=4) CabacInitIdc; 
	uint PicWidthInMbs;
	uint PicSizeInMbs;
	uint CurrMbAddr;

	
	//Cabac Variables
	uint codIRange;
	uint codIOffset;
	uint ctxIdx;
	uint qCodIRangeIdx;
	uint codIRangeLPS;
	uint CabacValue;

	// Neighbouring Variables
	int  NeighMbAddr;
	bool NeighMbAvail;
	int SE;
	
/******************************************************************************
								Fucntions
******************************************************************************/
	function Clip3( int Min, int Max, int Val  ) --> int :  
		if (Val < Min) then 
			Min 
		else 
			if (Val > Max) then 
				Max 
			else 
				Val 
			end 
		end 
	end
	
	function mbAddrAvailable( int mbAddrX ) --> bool : 
		if ( ( mbAddrX < 0 ) or ( mbAddrX > PicSizeInMbs ) )then 
			false  //return 
		else 
			true  //return
		end 
	end
	
	function CabacCurrMbAddr(int mbAddr) --> int: 
		if mbAddr >= PicWidthInMbs + 1 then 
			PicWidthInMbs 
		else 
			mbAddr 
		end 
	end
	
	function GiveMbAddrA( ) --> int :
		CabacCurrMbAddr(CurrMbAddr) - 1
	end
	
	function mbAddrA_Avail() --> bool :
		if CurrMbAddr = 0 then
			false
		else 
			( CurrMbAddr mod PicWidthInMbs ) != 0
		end
	end
	
	function GiveMbAddrB( ) --> int :
		CabacCurrMbAddr(CurrMbAddr) - PicWidthInMbs
	end
	
	
	function mbAddrB_Avail() --> bool :
		mbAddrAvailable( GiveMbAddrB() )
	end
	function intXOR(int value) --> int: if value = 0 then 1 else 0 end end

	
/******************************************************************************
								Procedures
******************************************************************************/
	
	procedure read_bits(int count)
	begin
		ReadBits := ReadBits - count;
		
		foreach int i in Integers(ReadBits, maxReadBits) do
			ReadResult := bitor( lshift( ReadResult, 1), readBits[maxReadBits - i] );
		end
	end
	
	procedure preCtxState_pro(int QPy, int m, int n)
	begin
		preCtxState := Clip3( 1, 126, ( ( m * Clip3( 0, 51, QPy ) ) >> 4 ) + n );
	end
	
	procedure getNeighbouring(int xN, int yN, int maxW, int maxH)
	begin
		if xN < 0 then
  			if yN < maxH - 1 then
				NeighMbAvail := mbAddrA_Avail();
				NeighMbAddr := GiveMbAddrA();
  			else
				NeighMbAvail := false;
  			end
 		else
			if xN < maxW - 1 then
  				if yN < 0 then
					NeighMbAvail := mbAddrB_Avail();
					NeighMbAddr := GiveMbAddrB();
  				else
    				if yN < maxH - 1 then
      					NeighMbAvail := true;
      					NeighMbAddr  := CabacCurrMbAddr(CurrMbAddr);
    				end
			end
			else
				NeighMbAvail := false;
			end
		end
	end
	
	procedure CabacCycleCopy()
	begin
		if CurrMbAddr >= PicWidthInMbs + 1 then
			foreach int i in Integers(1,PicWidthInMbs + 1) do
				mb_skip_flag[i-1] := mb_skip_flag[i];
			end
			
			mb_skip_flag[CabacCurrMbAddr(CurrMbAddr)] := 0;
		end
	end
	
	
	
/******************************************************************************
								Actions
******************************************************************************/	
	
	CabacInitialization: action ==>
	guard
		SE = CABAC_INIT_SE
	do
		foreach int i in Integers(0, 2) do	
			if SliceType = SLICE_TYPE_P or SliceType = SLICE_TYPE_SP then
				preCtxState_pro(QP, Cabac_Context_Init_P_SP[CabacInitIdc][i][0], Cabac_Context_Init_P_SP[CabacInitIdc][i][1]);
			else
				preCtxState_pro(QP, Cabac_Context_Init_B[CabacInitIdc][i][0], Cabac_Context_Init_B[CabacInitIdc][i][1]);
			end
											
			if ( preCtxState  <=  63 )  then
				pStateIdx[i]	:= 63 - preCtxState;
				valMPS[i]		:= 0 ;
			else 
				pStateIdx[i]	:= preCtxState - 64;
				valMPS[i]		:= 1;
			end
		end
		
		codIRange	:= 0x01FE;
		read_bits(9);
		codIOffset	:= ReadResult;
	end
	
	GetCtxIdxmbSkipFlag: action ==>
	guard
		SE = CABAC_MB_SKIP_FLAG_SE
	var
		int  condTermFlagA,
		int  condTermFlagB,
		int  mbAddr,
		bool AvailMb
	do
		//N = A
		getNeighbouring(-1, 0, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagA := 0;
		else
			if mb_skip_flag[mbAddr] = 1 then
				 condTermFlagA := 0;
			else
				 condTermFlagA := 1;
			end	
		end
		
		//N = B
		getNeighbouring(0, -1, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagB := 0;
		else
			if mb_skip_flag[mbAddr] = 1 then
				 condTermFlagB := 0;
			else
				 condTermFlagB := 1;
			end	
		end
		
		ctxIdx := condTermFlagA + condTermFlagB;
		
		//Cycle Copy
		CabacCycleCopy();
	end
	
	DecodeDecion: action ==>
	do
		qCodIRangeIdx	:= ( codIRange >> 6 ) & 3;
		codIRangeLPS	:= rangeTabLPS[pStateIdx[ctxIdx]][qCodIRangeIdx];
		codIRange		:= codIRange - codIRangeLPS;
		
		if codIOffset >= codIRange then
			CabacValue     := intXOR(valMPS[ctxIdx]);
			codIOffset := codIOffset - codIRange;
			codIRange  := codIRangeLPS;
			
			if pStateIdx[ctxIdx] = 0 then
				valMPS[ctxIdx] := 1 - valMPS[ctxIdx];
			end
			pStateIdx[ctxIdx] := transIdxLPS[pStateIdx[ctxIdx]];
		else
			CabacValue := valMPS[ctxIdx]; 
			pStateIdx[ctxIdx] := transIdxMPS[pStateIdx[ctxIdx]];
		end
		
		mb_skip_flag[CabacCurrMbAddr(CurrMbAddr)] := CabacValue;
	end
	
	RenormD: action ==>
	guard
		codIRange < 0x0100
	do
		//Read one bit
		
		codIRange  := codIRange  << 1;
		codIOffset := codIOffset << 1;
		read_bits(1);
		codIOffset := codIOffset | ReadResult;
	end
	
	
	SentValue: action ==> Dbits_Read:[ReadBits], Mb_Skip_Flag:[CabacValue],
                          Out_CodIRange:[codIRange], Out_CodIOffset:[codIOffset]
	guard
		codIRange >= 0x0100
	end
	
	ReadSE: action bits:[ bRead ] repeat 32,
				   Cabac_Init_Idc:[a],
				   In_CodIRange:[b],
				   In_CodIOffset:[c],
				   Curr_Mb_Addr:[d],
				   Entropy_Coding:[entropy],
				   Pic_Width_In_Mbs:[e],
				   Pic_Size_In_Mbs:[f],
				   Slice_Type:[g],
				   Syntax_Element:[se],
				   val_QP:[i]==>
	guard
		( se = CABAC_MB_SKIP_FLAG_SE or se = CABAC_INIT_SE ) and entropy = 1
	do
		//Copy bRead List;
		
		foreach int s in Integers(0, maxReadBits-1) do
			readBits[s] := bRead[s];
		end
		
		CabacInitIdc	:= a;
		codIRange		:= b;
		codIOffset		:= c;
		CurrMbAddr		:= d;
		PicWidthInMbs	:= e;
		PicSizeInMbs	:= f;
		SliceType		:= g;
		SE				:= se;
		QP				:= i;
	end 
	
	Skip_ReadSE: action bits:[ bRead ] repeat 32,
				   		Cabac_Init_Idc:[a],
				   		In_CodIRange:[b],
				   		In_CodIOffset:[c],
				   		Curr_Mb_Addr:[d],
				   		Entropy_Coding:[e],
				   		Pic_Width_In_Mbs:[f],
				   		Pic_Size_In_Mbs:[g],
				   		Slice_Type:[h],
				   		Syntax_Element:[se],
				   		val_QP:[j]==>
	guard
		se != CABAC_MB_SKIP_FLAG_SE or se != CABAC_INIT_SE
	end 
	
	schedule fsm Read:
		Read				(ReadSE)				--> Decode;
		Read				(Skip_ReadSE)			--> Read;
		Decode				(CabacInitialization)	--> Read;
		Decode				(GetCtxIdxmbSkipFlag)	--> DecodeValue;
		DecodeValue			(DecodeDecion)			--> Renorm;
		Renorm				(RenormD)				--> Renorm;
		Renorm				(SentValue)				--> Read;
	end
end