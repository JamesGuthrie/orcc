/*************************************************************************
This software module was originally developed by Endri Bezati, 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

Swiss Federal Institution of Technology grants ISO/IEC all rights necessary 
to include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that Swiss Federal Institution 
of Technology owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, Swiss Federal 
Institution of Technology will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing the ISO/IEC 23002-4

Swiss Federal Institution of Technology retains full right to modify and use 
the code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2007.
*************************************************************************/

actor Algo_CABAC_Prev_Intra_Pred_Mode_Flag()
	int(size=4)	 bits,
	int(size=4)	 Entropy_Coding,
	int(size=9)	 In_CodIRange,
	int(size=9)	 In_CodIOffset,
	int(size=32) Curr_Mb_Addr,
	int(size=32) Pic_Width_In_Mbs,
	int(size=5)	 Syntax_Element,
	int(size=6)  val_QP
		==>
			int(size=4)	Prev_Intra_Pred_Mode_Flag,
			int(size=9)	Dbits_Read,
			int(size=9)	Out_CodIRange,
			int(size=9)	Out_CodIOffset:


/******************************************************************************
								Global Variables/Constants
******************************************************************************/
	/* Constants */
	// Cabac Initialization Arrays for mb_skip_flag
	
	
	List (type: int, size = 2 ) Cabac_Context_Init = [13,41];
	
	
	/* CABAC Arithmetic Decoding qCodIRangeIdx */
	List ( type:int, size = 64 ) transIdxMPS = 
	[
		1, 2, 3, 4, 5, 6, 7, 8,
		9,10,11,12,13,14,15,16,
		17,18,19,20,21,22,23,24,
		25,26,27,28,29,30,31,32,
		33,34,35,36,37,38,39,40,
		41,42,43,44,45,46,47,48,
		49,50,51,52,53,54,55,56,
		57,58,59,60,61,62,62,63
	];
	//
	List ( type:int, size = 64 ) transIdxLPS = 
	[
		0, 0, 1, 2, 2, 4, 4, 5,
		6, 7, 8, 9, 9,11,11,12,
		13,13,15,15,16,16,18,18,
		19,19,21,21,22,22,23,24,
		24,25,26,26,27,27,28,29,
		29,30,30,30,31,32,32,33,
		33,33,34,34,35,35,35,36,
		36,36,37,37,37,38,38,63
	];
	
	//
	List ( type: List ( type: int , size = 4), size = 64 ) rangeTabLPS = 
	
	[
		[128,176,208,240], [128,167,197,227], [128,158,187,216], [123,150,178,205],
		[116,142,169,195], [111,135,160,185], [105,128,152,175], [100,122,144,166],
		[ 95,116,137,158], [ 90,110,130,150], [ 85,104,123,142], [ 81, 99,117,135],
		[ 77, 94,111,128], [ 73, 89,105,122], [ 69, 85,100,116], [ 66, 80, 95,110],
		[ 62, 76, 90,104], [ 59, 72, 86, 99], [ 56, 69, 81, 94], [ 53, 65, 77, 89],
		[ 51, 62, 73, 85], [ 48, 59, 69, 80], [ 46, 56, 66, 76], [ 43, 53, 63, 72],
		[ 41, 50, 59, 69], [ 39, 48, 56, 65], [ 37, 45, 54, 62], [ 35, 43, 51, 59],
		[ 33, 41, 48, 56], [ 32, 39, 46, 53], [ 30, 37, 43, 50], [ 29, 35, 41, 48],
		[ 27, 33, 39, 45], [ 26, 31, 37, 43], [ 24, 30, 35, 41], [ 23, 28, 33, 39],
		[ 22, 27, 32, 37], [ 21, 26, 30, 35], [ 20, 24, 29, 33], [ 19, 23, 27, 31],
		[ 18, 22, 26, 30], [ 17, 21, 25, 28], [ 16, 20, 23, 27], [ 15, 19, 22, 25],
		[ 14, 18, 21, 24], [ 14, 17, 20, 23], [ 13, 16, 19, 22], [ 12, 15, 18, 21],
		[ 12, 14, 17, 20], [ 11, 14, 16, 19], [ 11, 13, 15, 18], [ 10, 12, 15, 17],
		[ 10, 12, 14, 16], [  9, 11, 13, 15], [  9, 11, 12, 14], [  8, 10, 12, 14],
		[  8,  9, 11, 13], [  7,  9, 11, 12], [  7,  9, 10, 12], [  7,  8, 10, 11],
		[  6,  8,  9, 11], [  6,  7,  9, 10], [  6,  7,  8,  9], [  2,  2,  2,  2]
	];
	
	int(size=7) PICWIDTH = 1280/16;
	

	// AVC/H.264 Slice Types
	
	/* Mb skip Flag */
	int CABAC_PREV_INTRA_PRED_MODE_FLAG_SE = 13;
	int CABAC_INIT_SE = 25;
	/* Variables */
	
	/* Input binary Array */
//	int maxReadBits = 32;
//	int ctxIdxOffset = 68;
	int ReadBitsIdx := 0;
	int ReadResult := 0;
	List ( type : int (size = 6), size = 32 ) readBits := [0:for int i in 0 .. 31] ;
	
	
	
	int pStateIdx;
	int valMPS;
	
	List ( type : int (size=4), size = PICWIDTH + 1) mb_skip_flag := [0:for int i in 0 .. PICWIDTH] ;
	
	
	//Basic Variables
	
	int(size=6) QP;
	int preCtxState;
	int PicWidthInMbs;
	int CurrMbAddr;

	
	//Cabac Variables
	int codIRange;
	int codIOffset;
	int ctxIdx;
	int qCodIRangeIdx;
	int codIRangeLPS;
	int CabacValue;

	// Neighbouring Variables
	int SE;
	
/******************************************************************************
								Fucntions
******************************************************************************/
	function Clip3( int Min, int Max, int Val  ) --> int :  
		if (Val < Min) then 
			Min 
		else 
			if (Val > Max) then 
				Max 
			else 
				Val 
			end 
		end 
	end
	
	function CabacCurrMbAddr(int mbAddr) --> int: 
		if mbAddr >= PicWidthInMbs + 1 then 
			PicWidthInMbs 
		else 
			mbAddr 
		end 
	end
	
	
	function intXOR(int value) --> int: if value = 0 then 1 else 0 end end

	
/******************************************************************************
								Procedures
******************************************************************************/
	
	procedure read_bits(int count)
	begin
		
		foreach int i in 0 .. count - 1 
		do
			ReadResult := bitor( lshift( ReadResult, 1), readBits[ReadBitsIdx] );
			ReadBitsIdx := ReadBitsIdx + 1;
		end
	end
	
	procedure preCtxState_pro(int QPy, int m, int n)
	begin
		preCtxState := Clip3( 1, 126, ( ( m * Clip3( 0, 51, QPy ) ) >> 4 ) + n );
	end
	
	procedure CabacCycleCopy()
	begin
		if CurrMbAddr >= PicWidthInMbs + 1 then
			foreach int i in 1 .. PicWidthInMbs + 1
			do
				mb_skip_flag[i-1] := mb_skip_flag[i];
			end
			
			mb_skip_flag[CabacCurrMbAddr(CurrMbAddr)] := 0;
		end
	end
	
	
	
/******************************************************************************
								Actions
******************************************************************************/	
	
	CabacInitialization: action ==>
	guard
		SE = CABAC_INIT_SE
	do
			preCtxState_pro(QP, Cabac_Context_Init[0], Cabac_Context_Init[1]);
									
			if ( preCtxState  <=  63 )  then
				pStateIdx	:= 63 - preCtxState;
				valMPS		:= 0 ;
			else 
				pStateIdx	:= preCtxState - 64;
				valMPS		:= 1;
			end
	end
	
	GetCtxIdxPrevIntraPredModeFlag: action ==>
	guard
		SE = CABAC_PREV_INTRA_PRED_MODE_FLAG_SE

	do
		ctxIdx := 0;
		//Cycle Copy
		CabacCycleCopy();
	end
	
	DecodeDecion: action ==>
	do
		qCodIRangeIdx	:= ( codIRange >> 6 ) & 3;
		codIRangeLPS	:= rangeTabLPS[pStateIdx][qCodIRangeIdx];
		codIRange		:= codIRange - codIRangeLPS;
		
		if codIOffset >= codIRange then
			CabacValue     := intXOR(valMPS);
			codIOffset := codIOffset - codIRange;
			codIRange  := codIRangeLPS;
			
			if pStateIdx = 0 then
				valMPS := 1 - valMPS;
			end
			pStateIdx := transIdxLPS[pStateIdx];
		else
			CabacValue := valMPS; 
			pStateIdx := transIdxMPS[pStateIdx];
		end
		
		mb_skip_flag[CabacCurrMbAddr(CurrMbAddr)] := CabacValue;
	end
	
	RenormD: action ==>
	guard
		codIRange < 0x0100
	do
		//Read one bit
		
		codIRange  := codIRange  << 1;
		codIOffset := codIOffset << 1;
		read_bits(1);
		codIOffset := codIOffset | ReadResult;
	end
	
	
	SentValue: action ==> Dbits_Read:[ReadBitsIdx], Prev_Intra_Pred_Mode_Flag:[CabacValue],
                          Out_CodIRange:[codIRange], Out_CodIOffset:[codIOffset]
					
	guard
		codIRange >= 0x0100
	end
	
	ReadSE: action bits:[ bRead ] repeat 32,
				   In_CodIRange:[b],
				   In_CodIOffset:[c],
				   Curr_Mb_Addr:[g],
				   Entropy_Coding:[entropy],
				   Pic_Width_In_Mbs:[h],
				   Syntax_Element:[se],
				   val_QP:[i] ==>
	guard
		( se = CABAC_PREV_INTRA_PRED_MODE_FLAG_SE or se = CABAC_INIT_SE ) and entropy = 1
	do
		//Copy bRead List;
		
		readBits := [bRead[s]:for int s in 0 .. 31];
		
		codIRange		:= b;
		codIOffset		:= c;
		CurrMbAddr		:= g;
		PicWidthInMbs	:= h;
		SE				:= se;
		QP				:= i;		
	end 
	
	Skip_ReadSE: action bits:[ bRead ] repeat 32,
				   In_CodIRange:[b],
				   In_CodIOffset:[c],
				   Curr_Mb_Addr:[g],
				   Entropy_Coding:[entropy],
				   Pic_Width_In_Mbs:[h],
				   Syntax_Element:[se],
				   val_QP:[i] ==>
	guard
		se != CABAC_PREV_INTRA_PRED_MODE_FLAG_SE or se != CABAC_INIT_SE
	end 
	
	schedule fsm Read:
		Read				(ReadSE)							--> Decode;
		Read				(Skip_ReadSE)						--> Read;
		Decode				(CabacInitialization)				--> Read;
		Decode				(GetCtxIdxPrevIntraPredModeFlag)	--> DecodeValue;
		DecodeValue			(DecodeDecion)						--> Renorm;
		Renorm				(RenormD)							--> Renorm;
		Renorm				(SentValue)							--> Read;
	end
end