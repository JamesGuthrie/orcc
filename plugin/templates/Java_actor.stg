group Java_actor : C_actor;

///////////////////////////////////////////////////////////////////////////////
// FIFO declaration
///////////////////////////////////////////////////////////////////////////////

fifo(actorName, portName) ::= <<
	private IntFifo $actorName$_$portName$;

>>

///////////////////////////////////////////////////////////////////////////////
// Types and variables
///////////////////////////////////////////////////////////////////////////////

// the dimensions of a list: [][]...[]
// does not output anything if $value$ is empty
listSize(value) ::= <<
$value : {[]} $
>>

// the values of a list: {val1, val2, ..., valn}
listValue(value) ::= <<
{$value; wrap, separator=", "$}
>>

// a variable definition
vardef(name, type, size, isPort) ::= <<
$if(isPort)$
$type$[] $name$
$else$
$type$$listSize(size)$ $name$
$endif$>>

// a state variable
stateVar(vardef, value) ::= <<
$if(value)$
private $vardef$ = $value$;$\n\n$
$else$
private $vardef$;$\n\n$
$endif$
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

// hasTokens node
hasTokensNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = hasTokens($actorName$_$fifoName$, $numTokens$);

>>

// peek node
peekNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = getPeekPtr($actorName$_$fifoName$, $numTokens$);

>>

// read node
readNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = getReadPtr($actorName$_$fifoName$, $numTokens$);

>>

// self-assignment node
selfAssignmentNode(var, op, expr) ::= <<
$var$ $op$= $expr$;

>>

// write node
writeNode(var, actorName, fifoName, numTokens) ::= <<
$var$ = getWritePtr($actorName$_$fifoName$, $numTokens$);

>>

///////////////////////////////////////////////////////////////////////////////
// Procedure and actions
///////////////////////////////////////////////////////////////////////////////

proc(name, type, parameters, locals, nodes) ::= <<

private $type$ $name$($parameters; wrap, anchor, separator=", "$) {
$if(locals)$
	$locals: {$it$;$\n$}$

$endif$
	$nodes$}

>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////

outputPattern(actorName, pattern) ::= <<
$pattern.keys:{port|hasRoom($actorName$_$port$, $pattern.(port)$)}; separator=" && "$
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
$action.tag$();
res = 1;
i++;
>>

actionTest(actorName, action) ::= <<
if (isSchedulable_$action.tag$()) {
	$if(action.outputPattern)$
	if ($outputPattern(actorName=actorName, pattern=action.outputPattern)$) {
		$actionCall(action)$
	}
	$else$
	$actionCall(action)$
	$endif$
}>>

schedulingTest(actorName, actions) ::= <<
$actions: actionTest(actorName=actorName, action=it); separator=" else "$
>>

scheduler(actorName, actions) ::= <<
int $actorName$_scheduler() {
	int res = 1;
	int i = 0;
  
	while (res) {
		res = 0;
		$if(actions)$
		$schedulingTest(actorName=actorName, actions=actions)$
		$endif$
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(nextState) ::= <<
$nextState.action.tag$();
_FSM_state = s_$nextState.targetState$;
res = 1;
>>

actionTestState(actorName, nextState) ::= <<
if (isSchedulable_$nextState.action.tag$()) {
	$if(nextState.action.outputPattern)$
	if ($outputPattern(actorName=actorName, pattern=nextState.action.outputPattern)$) {
		$actionCallState(nextState)$
	}
	$else$
	$actionCallState(nextState)$
	$endif$
}>>

schedulingTestState(actorName, nextStates) ::= <<
$nextStates: actionTestState(actorName=actorName, nextState=it); separator=" else "$
>>

stateScheduler(actorName, transition) ::= <<
static int $transition.sourceState$_state_scheduler() {
	int res = 0;
	$schedulingTestState(actorName=actorName, nextStates=transition.nextStateInfo)$
	return res;
}

>>

switch(transitions) ::= <<
switch (_FSM_state) {
$transitions: {case s_$it.sourceState$:
	res = $it.sourceState$_state_scheduler();
	break;
}$
default:
	printf("unknown state: %s\n", stateNames[_FSM_state]);
	break;
}
>>

schedulerFSM(actorName, actions, fsm) ::= <<
enum states {
	s_$first(fsm.states)$ = 0,
	$rest(fsm.states) : {s_$it$}; separator=",\n"$
};

static char *stateNames[] = {
	$fsm.states : {"s_$it$"}; separator=",\n"$
};

static enum states _FSM_state = s_$fsm.initialState$;

$if(actions)$
static int outside_FSM_scheduler() {
	int res = 0;
	int i = 0;
	$schedulingTest(actorName=actorName, actions=actions)$
	return res;
}


$endif$
$fsm.transitions: stateScheduler(actorName=actorName, transition=it); separator="\n"$
int $actorName$_scheduler() {
	int res = 1;
	int i = 0;
	
	while (res) {
		res = 0;
		$if(actions)$
		if (outside_FSM_scheduler()) {
			res = 1;
			i++;
		} else {
			$switch(fsm.transitions)$
		}
		$else$
		$switch(fsm.transitions)$
		$endif$
	}

	return i;
}

>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

actor(name, inputs, outputs, stateVars, procs,
      actions, initializes, scheduler, initialize) ::= <<
/**
 * Generated from "$name$"
 */

public class Actor$name$ implements IActor {

	////////////////////////////////////////////////////////////////////////////////
	// Input FIFOs
	$inputs: fifo(actorName=name, portName=it)$
	////////////////////////////////////////////////////////////////////////////////
	// Output FIFOs
	$outputs: fifo(actorName=name, portName=it)$
	////////////////////////////////////////////////////////////////////////////////
	// State variables of the actor
	$stateVars$
	////////////////////////////////////////////////////////////////////////////////
	// Functions/procedures
	$procs$
	////////////////////////////////////////////////////////////////////////////////
	// Actions
	$actions$
$if(initializes)$
	////////////////////////////////////////////////////////////////////////////////
	// Initializes
	$initializes$
	public void $name$_initialize() {
		int res = 1;
		int i = 0;

		$if(initialize)$
		$schedulingTest(actorName=name, actions=initialize)$
		$endif$
	}

$endif$
	////////////////////////////////////////////////////////////////////////////////
	// Action scheduler
$if(scheduler.fsm)$
	$schedulerFSM(actorName=name, actions=scheduler.actions, fsm=scheduler.fsm)$
$else$
	$scheduler(actorName=name, actions=scheduler.actions)$
$endif$

}

>>
