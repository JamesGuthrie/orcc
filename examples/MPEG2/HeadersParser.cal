/**
 * Copyright (c) 2009, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Pierre-Laurent Lagalaye

/******************************************************************************
 * HeadersParser : MPEG2 sequence and picture layer headers parser            *
 ******************************************************************************/
actor HeadersParser() uint(size=32) Symbol ==> uint(size=8) CtrlBitstreamReader,
uint(size=12) Width, uint(size=12) Height, uint(size=1) HasIntraQuant,
uint(size=1) HasNonIntraQuant, uint(size=8) NonIntraQuantCoeff :

	///////////////////////////////////////////////////////////////////////////
	//// LOCAL VARIABLES AND CONSTANTS
	///////////////////////////////////////////////////////////////////////////
	
	// Bitstream reader control flags
	uint(size=8) CTRL_RESYNC = 0x80;
	uint(size=8) CTRL_FLUSH  = 0x40;
	uint(size=8) CTRL_NB_BITS = 0x3F;
	// Bitstream control value
	uint(size=8) control := 0x00;
	
	// Start codes
	uint(size=32) START_CODE_MASK = -256;
	uint(size=32) START_CODE_NULL = 0x00000100;
	uint(size=32) START_CODE_PREFIX = 0x000001;
	uint(size=32) SEQUENCE_HEADER_CODE = 0x000001B3;
    uint(size=32) SEQUENCE_END_CODE = 0x000001B7;
    uint(size=32) EXTENSION_START_CODE = 0x000001B5;
    uint(size=32) USER_DATA_START_CODE = 0x000001B2;
    // Extensions ID
    uint(size=4) SEQUENCE_EXTENSION_ID = 1;
    uint(size=4) SEQUENCE_DISPLAY_EXTENSION_ID = 2;
    uint(size=4) SEQUENCE_SCALABLE_EXTENSION_ID = 5;

	//
	// MPEG2 syntax descriptors
	//
	// Sequence_header :
	List(type:uint(size=8), size=10) seq_hd_ctrl :=
		[CTRL_FLUSH+32, // sequence_header_code
		 CTRL_FLUSH+12, // horizontal_size_value
		 CTRL_FLUSH+12, // vertical_size_value
		 CTRL_FLUSH+4,  // aspect_ratio_information
		 CTRL_FLUSH+4,  // frame_rate_code
		 CTRL_FLUSH+18, // bit_rate_value
		 CTRL_FLUSH+1,  // marker_bit
		 CTRL_FLUSH+10, // vbv_buffer_size_value
		 CTRL_FLUSH+1,  // constrained_parameters_flag
		 CTRL_FLUSH+1   // load_intra_quantiser_matrix
		 ];
	uint(size=12) horizontal_size_value; uint(size=8) H_SIZE_IDX = 1;
	uint(size=12) vertical_size_value; uint(size=8) V_SIZE_IDX = 2;
	uint(size=1) load_intra_quantiser_matrix; uint(size=8) LOAD_INTRA_QUANT = 9;
	List(type:uint(size=8), size=64) intra_quantiser_matrix;
	uint(size=1) load_non_intra_quantiser_matrix;
	List(type:uint(size=8), size=64) non_intra_quantiser_matrix;
	List(type:uint(size=8), size=64) quant_matrix_ctrl :=
		[CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8,
		 CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8, CTRL_FLUSH+8];
	// Sequence_extension
	List(type:uint(size=8), size=11) seq_ext_ctrl :=
		[CTRL_FLUSH+8,  // profile_and_level_indication
		 CTRL_FLUSH+1,  // progressive_sequence
		 CTRL_FLUSH+2,  // chroma_format
		 CTRL_FLUSH+2,  // horizontal_size_extension
		 CTRL_FLUSH+2,  // vertical_size_extension
		 CTRL_FLUSH+12, // bit_rate_extension
		 CTRL_FLUSH+1,  // marker_bit
		 CTRL_FLUSH+8,  // vbv_buffer_size_extension
		 CTRL_FLUSH+1,  // low_delay
		 CTRL_FLUSH+2,  // frame_rate_extension_n
		 CTRL_FLUSH+5   // frame_rate_extension_d
		 ];
	// Sequence_display_extension
	List(type:uint(size=8), size=2) seq_display_ctrl :=
		[CTRL_FLUSH+3,  // video_format
		 CTRL_FLUSH+1   // colour_description
		 ];
	// Colour_description
	List(type:uint(size=8), size=3) colour_desc_ctrl :=
		[CTRL_FLUSH+8,  // colour_primaries
		 CTRL_FLUSH+8,  // transfer_characteristics
		 CTRL_FLUSH+8   // matrix_coefficients
		 ];
	// Display_parameters
	List(type:uint(size=8), size=3) display_param_ctrl :=
		[CTRL_FLUSH+14, // display_horizontal_size
		 CTRL_FLUSH+1,  // marker_bit
		 CTRL_FLUSH+14  // display_vertical_size
		 ];

	///////////////////////////////////////////////////////////////////////////
	//// LOCAL PROCEDURES AND FUNCTIONS
	///////////////////////////////////////////////////////////////////////////
	
	
	///////////////////////////////////////////////////////////////////////////
	//// ACTIONS
	///////////////////////////////////////////////////////////////////////////
	
	resync_bitstream: action ==> CtrlBitstreamReader:[CTRL_RESYNC|32]
	end
		
	next_start_code: action Symbol:[next_bits] ==> CtrlBitstreamReader:[control]
	guard
	  (next_bits & START_CODE_MASK) != START_CODE_NULL
	do
	  control := CTRL_FLUSH|8;
	end
	  
	sequence_header: action Symbol:[next_bits] ==> CtrlBitstreamReader:[seq_hd_ctrl] repeat 10
	guard
	  next_bits = SEQUENCE_HEADER_CODE  
	end

	get_sequence_info: action Symbol:[sequence_info] repeat 10 ==>
	Width:[horizontal_size_value], Height:[vertical_size_value],
	HasIntraQuant:[load_intra_quantiser_matrix]
	do
		horizontal_size_value := sequence_info[H_SIZE_IDX];
		vertical_size_value := sequence_info[V_SIZE_IDX];
		load_intra_quantiser_matrix := sequence_info[LOAD_INTRA_QUANT];	  
	end
	
	load_intra_quantiser_matrix: action ==> CtrlBitstreamReader:[quant_matrix_ctrl] repeat 64
	guard
		load_intra_quantiser_matrix = 1
	end
	
	store_intra_quantiser_matrix: action Symbol:[intra_quant_matrix] repeat 64 ==>
	guard
		load_intra_quantiser_matrix = 1
	end

	check_non_intra_quantiser_matrix: action ==> CtrlBitstreamReader:[control]
	do
		control := CTRL_FLUSH|1;
	end
	
	load_non_intra_quantiser_matrix: action Symbol:[next_bits] ==> CtrlBitstreamReader:[quant_matrix_ctrl] repeat 64,
	HasNonIntraQuant:[load_non_intra_quantiser_matrix]
	guard
		next_bits = 1
	do
		load_non_intra_quantiser_matrix := 1;
	end
	
	store_non_intra_quantiser_matrix: action Symbol:[non_intra_quant_matrix] repeat 64 ==> 
	NonIntraQuantCoeff:[non_intra_quant_matrix] repeat 64
	guard
		load_non_intra_quantiser_matrix = 1
	end
	
	extension_and_user_data: action Symbol:[next_bits] ==> CtrlBitstreamReader:[control]
	guard
	  next_bits = EXTENSION_START_CODE
	do
		// Remove start code from bitstream
	    control := CTRL_FLUSH|32;
	end
		
	extension_id: action Symbol:[next_bits] ==> CtrlBitstreamReader:[control]
	guard
	  next_bits = EXTENSION_START_CODE
	do
		// Get extension ID
	    control := CTRL_FLUSH|4;
	end

	sequence_extension: action Symbol:[next_bits] ==> CtrlBitstreamReader:[seq_ext_ctrl] repeat 11
	guard
	  next_bits = SEQUENCE_EXTENSION_ID
	end
	
	sequence_display_extension: action Symbol:[next_bits] ==> CtrlBitstreamReader:[seq_display_ctrl] repeat 2
	guard
	  next_bits = SEQUENCE_DISPLAY_EXTENSION_ID
	end
	
	colour_description: action Symbol:[next_bits] ==> CtrlBitstreamReader:[colour_desc_ctrl] repeat 3
	guard
	  next_bits = 1
	end
	
	display_parameters: action Symbol:[next_bits] ==> CtrlBitstreamReader:[display_param_ctrl] repeat 3
	end
	
	user_data_start_code: action Symbol:[next_bits] ==> CtrlBitstreamReader:[control]
	guard
		next_bits = USER_DATA_START_CODE
	do
		// Flush user_data start code
	    control := CTRL_FLUSH|32;	
	end
	
	check_user_data: action Symbol:[next_bits] ==> CtrlBitstreamReader:[control]
	do
		// Check user data
	    control := 24;	
	end
	
	user_data: action Symbol:[next_bits] ==> CtrlBitstreamReader:[control]
	guard
		next_bits != START_CODE_PREFIX
	do
		// Flush user data
	    control := CTRL_FLUSH|8;	
	end
	
	//
	// Actions scheduling management
	//
	schedule fsm start_sequence :
		start_sequence (resync_bitstream) --> next_sequence;
		next_sequence (next_start_code) --> start_sequence;
	  	next_sequence (sequence_header) --> seq_info;
	  	//seq_info (get_sequence_info) --> intra_quant;
	  	seq_info (get_sequence_info) --> check_non_intra_quant;
	  	intra_quant (load_intra_quantiser_matrix) --> store_intra_quant;
	  	store_intra_quant (store_intra_quantiser_matrix) --> check_non_intra_quant;
	  	check_non_intra_quant (check_non_intra_quantiser_matrix) --> non_intra_quant;
	  	non_intra_quant (load_non_intra_quantiser_matrix) --> store_non_intra_quant;
	  	store_non_intra_quant (store_non_intra_quantiser_matrix) --> resync;
	  	resync (resync_bitstream) --> search_start_code;
	  	search_start_code (next_start_code) --> resync;
	  	search_start_code (extension_and_user_data) --> ext_id;
	  	search_start_code (extension_and_user_data) --> udata_start_code;
	  	search_start_code (extension_and_user_data) --> resync;
	  	ext_id (extension_id) --> seq_ext;
	  	ext_id (extension_id) --> seq_display;
	  	seq_ext (sequence_extension) --> resync;
	  	seq_display (sequence_display_extension) --> colour_desc;
	  	seq_display (sequence_display_extension) --> display_param;
	  	colour_desc (colour_description) --> display_param;
	  	display_param (display_parameters) --> resync;
	  	udata_start_code (user_data_start_code) --> check_udata;
	  	check_udata (check_user_data) --> udata;
	  	check_udata (check_user_data) --> resync;
	  	udata (user_data) --> check_udata;
	end
	
	priority
		load_intra_quantiser_matrix > check_non_intra_quantiser_matrix;
		colour_description > display_parameters;
		extension_id > resync_bitstream;
		user_data_start_code > resync_bitstream;
		user_data > resync_bitstream;
	end
end
