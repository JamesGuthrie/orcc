actor Parser() uint(size=8) I ==> :

  // to save next bits when needed
  uint(size=32) next_bits;
  uint(size=5) next_shift; // from 0 to 31
  uint(size=2) i_want_a_refill;

  // this is the maximum size of a chunk
  int MAX_CHUNK_SIZE = 1 << 16;
  List(type:int(size=32), size=MAX_CHUNK_SIZE) chunk;
  int chunk_ptr;

  // sequence characteristics
  uint(size=12) horizontal_size;
  uint(size=12) vertical_size;
  
  uint(size=4) aspect_ratio;
  int frame_rate; // TODO: use float
  
  uint(size=30) bit_rate;
  uint(size=18) vbv_buffer_size;
  bool load_intra_quantiser_matrix;
  
  /////////////////////////////////////////////////////////////////////////////
  // sequence extension stuff
  bool escape_bit;
  uint(size=3) profile;

  /////////////////////////////////////////////////////////////////////////////
  // GOP data

  /////////////////////////////////////////////////////////////////////////////
  // picture header
  uint(size=10) temporal_reference;
  uint(size=3) picture_coding_type;
  uint(size=16) vbv_delay;
  
  /////////////////////////////////////////////////////////////////////////////
  // picture coding extension
  List(type:List(type:uint(size=4), size=2), size=2) f_code := [[0, 0], [0, 0]];

  uint(size=2) intra_dc_precision;
  uint(size=2) picture_structure;
  
  bool top_field_first;
  bool frame_pred_frame_dct;
  bool concealment_motion_vectors;
  bool q_scale_type;
  bool intra_vlc_format;
  bool alternate_scan;
  bool repeat_first_field;
  bool chroma_420_type;
  bool progressive_frame;
  bool composite_display_flag;
  
  /////////////////////////////////////////////////////////////////////////////
  // slice
  uint(size=3) slice_vertical_position_extension;
  uint(size=5) quantiser_scale_code;

  /////////////////////////////////////////////////////////////////////////////
  // constants

  // start code values
  uint(size=8) PICTURE_START_CODE = 0x00;
  uint(size=8) SLICE_BEGIN_START_CODE = 0x01;
  uint(size=8) SLICE_END_START_CODE = 0xAF;
  uint(size=8) USER_DATA_START_CODE = 0xB2;
  uint(size=8) SEQUENCE_HEADER_CODE = 0xB3;
  uint(size=8) EXTENSION_START_CODE = 0xB5;
  uint(size=8) GROUP_START_CODE = 0xB8;
  
  // extension identifiers
  uint(size=4) SEQUENCE_EXTENSION = 0x01;
  uint(size=4) PICTURE_CODING_EXTENSION = 0x08;
    
  // TODO: use float
  List(type:int, size=16) FRAME_RATE_CODE =
    [ -1, 23 /*.976*/, 24, 25, 29 /*.97*/, 30, 50, 59 /*.94*/, 60,
    -1, -1, -1, -1, -1, -1, -1 ];

  // picture coding type
  uint(size=3) INTRA = 1;
  uint(size=3) PRED = 2;
  uint(size=3) BIPRED = 3;

  /////////////////////////////////////////////////////////////////////////////
  // start code detection

  chunk_b1: action I:[ b ] ==>
  do
    chunk[chunk_ptr] := b;
    chunk_ptr := chunk_ptr + 1;
  end

  /** detect next start code, or execute zero_byte_stuffing */
  next_start_code: action I:[ b0, b1, b2 ] ==>
  guard
    b0 = 0 and b1 = 0 and b2 = 0x01
  end
  
  byte_stuffing.zero: action I:[ b ] ==>
  guard
    b = 0
  end
  
  byte_stuffing.whatever: action I:[ b ] ==>
  end
  
  // when expected start code value not there
  other_start_code: action I:[ byte ] ==>
  end
  
  
  initialize ==>
  do
    chunk := [ 0 : for int i in Integers(0, MAX_CHUNK_SIZE - 1) ];
  end

  ///////////////////////////////////////////////////////////////////////////
  /** sequence header */
  sequence_header: action I:[ bytes ] repeat 9 ==>
  guard
    bytes[0] = SEQUENCE_HEADER_CODE
  var
    uint(size=8) byte, uint(size=24) size,
    uint(size=4) frame_rate_code, uint(size=1) constrained_parameters_flag
  do
    size := bytes[1] << 16 | bytes[2] << 8 | bytes[3];
    horizontal_size := size >> 12;
    vertical_size := size & 0x0fff;
    
    byte := bytes[4];
    aspect_ratio := byte >> 4;
    frame_rate_code := byte & 0x0f;

    frame_rate := FRAME_RATE_CODE[frame_rate_code];
    // TODO: check frame rate when println are implemented
    /* if frame_rate = -1 then
    println("exit");
    end */
    
    bit_rate := bytes[5] << 10 | bytes[6] << 2 | bytes[7] >> 6;
    
     // TODO: check bit rate when println are implemented
    /* if bit_rate = 0 then
    println("exit");
    end */
    
    // TODO: check marker bit when println are implemented
    /* if byte & 0x20 = 0 then
    println("exit");
    end */
    
    vbv_buffer_size := (bytes[7] & 0x1F) << 5 | bytes[8] >> 3;
    
    constrained_parameters_flag := bytes[8] & 0x04;
    // TODO: check constrained_parameters_flag when println are implemented
    /* if constrained_parameters_flag != 0 then
    println("exit");
    end */
    
    load_intra_quantiser_matrix := (bytes[8] & 0x02) != 0;
    next_bits := bytes[8] & 0x01;
  end
  
  /** sequence header with load_intra_quantiser_matrix */
  load_intra_quantiser_matrix.yes: action I:[ matrix ] repeat 64 ==>
  do
    // TODO: copy quant matrix

    // set next_bit 
    next_bits := matrix[8 * 64 - 1] & 0x01;
  end
  
  load_intra_quantiser_matrix.no: action ==>
  guard
    not load_intra_quantiser_matrix
  end
  
  /** sequence header with load_non_intra_quantiser_matrix */
  load_non_intra_quantiser_matrix.yes: action I:[ matrix ] repeat 64 ==>
    // TODO: copy quant matrix

    // Note: we are byte-aligned after this
  end
  
  load_non_intra_quantiser_matrix.no: action ==>
  guard
    next_bits = 0
  end

  ///////////////////////////////////////////////////////////////////////////
  /** extension_start_code */
  sequence_extension: action I:[ bytes ] repeat 7 ==>
  guard
    bytes[0] = EXTENSION_START_CODE and bytes[1] >> 4 = SEQUENCE_EXTENSION
  var
    uint(size=8) profile_and_level_indication
  do
    profile_and_level_indication := (bytes[1] & 0x0F) << 4 | bytes[2] >> 4;
    escape_bit := (profile_and_level_indication >> 7) != 0;
    profile := (profile_and_level_indication & 0x78) >> 4;
  end

  /** user_data */
  user_data: action I:[ start_code ] ==>
  guard
    start_code = USER_DATA_START_CODE
  end

  ///////////////////////////////////////////////////////////////////////////
  /** gop_header */
  gop_header: action I:[ bytes ] repeat 5 ==>
  guard
    bytes[0] = GROUP_START_CODE
  end

  ///////////////////////////////////////////////////////////////////////////
  /** picture_header */
  picture_header: action I:[ bytes ] repeat 5 ==>
  guard
    bytes[0] = PICTURE_START_CODE
  do
    temporal_reference := bytes[1] << 2 | bytes[2] & 0xC0;
    picture_coding_type := (bytes[2] & 0x38) >> 3;
    vbv_delay := (bytes[2] & 0x07) << 13 | bytes[3] | bytes[4] >> 3;
    next_bits := bytes[4] & 0x07;
  end

  picture.intra: action ==>
  guard
    picture_coding_type = INTRA
  end
  
  picture.pred.P: action I:[ byte ] ==>
  guard
    picture_coding_type = PRED
  do
    // not used in MPEG-2
    // full_pel_forward_vector := next_bits >> 2;
    // forward_f_code := next_bits & 0x03 | byte >> 7;
    next_bits := byte & 0x7F;
  end

  picture.pred.B: action I:[ byte ] ==>
  guard
    picture_coding_type = BIPRED
  do
    // not used in MPEG-2
    // full_pel_forward_vector := next_bits >> 2;
    // forward_f_code := next_bits & 0x03 | byte >> 7;
    // full_pel_backward_vector := (byte & 0x40) >> 6;
    // backward_f_code := (byte & 0x38) >> 3;
    next_bits := byte & 0x07;
  end
  
  ///////////////////////////////////////////////////////////////////////////
  /** picture_coding_extension */
  picture_coding_extension: action I:[ bytes ] repeat 6 ==>
  guard
    bytes[0] = EXTENSION_START_CODE and bytes[1] >> 4 = PICTURE_CODING_EXTENSION
  var
    uint(size=8) byte
  do
    f_code[0, 0] := bytes[1] & 0x0F;
    f_code[0, 1] := bytes[2] >> 4;
    f_code[1, 0] := bytes[2] & 0x0F;
    f_code[1, 1] := bytes[3] >> 4;
    
    intra_dc_precision := (bytes[3] >> 2) & 0x03;
    picture_structure := bytes[3] & 0x03;

    byte := bytes[4];

    top_field_first := (byte & 0x80) != 0;
    frame_pred_frame_dct := (byte & 0x40) != 0;
    concealment_motion_vectors := (byte & 0x20) != 0;
    q_scale_type := (byte & 0x10) != 0;
    intra_vlc_format := (byte & 0x08) != 0;
    alternate_scan := (byte & 0x04) != 0;
    repeat_first_field := (byte & 0x02) != 0;
    chroma_420_type := (byte & 0x01) != 0;

    next_bits := bytes[5];

    progressive_frame := (next_bits & 0x80) != 0;
    composite_display_flag := (next_bits & 0x40) != 0;
  end

  // TODO: decode information here
  composite_flag.yes: action I:[ bytes ] repeat 2 ==>
  do
    next_bits := 0;
  end

  composite_flag.no: action ==>
  guard
    not composite_display_flag
  end
  
  ///////////////////////////////////////////////////////////////////////////
  /** slice */
  slice: action I:[ bytes ] repeat 2 ==>
  guard
    bytes[0] >= SLICE_BEGIN_START_CODE and bytes[0] <= SLICE_END_START_CODE
  do
    next_bits := bytes[1];
    if vertical_size > 2800 then
      // somehow, I think it is quite unlikely, but... who knows? 
      slice_vertical_position_extension := next_bits >> 5; // 3 highest bits
      quantiser_scale_code := next_bits & 0x1F; // 5 lowest bits
      next_bits := bytes[2];
      next_shift := 7;
    else
      quantiser_scale_code := next_bits >> 3; // 5 highest bits
      next_bits := ((next_bits & 0x07) << 8) | bytes[2];
      next_shift := 10;
    end

    // TODO: scalable extension
  end
  
  slice_intra_flag.yes: action I:[ byte ] ==>
  end
  
  slice_intra_flag.no: action ==>
  guard
    ((next_bits >> next_shift) & 0x01) = 0
  do
    next_shift := next_shift - 1;
  end
  
  ///////////////////////////////////////////////////////////////////////////
  /** macroblock */
  mb: action I:[ byte ] ==>
  end

  ///////////////////////////////////////////////////////////////////////////
  // priorities
  priority
    next_start_code > byte_stuffing.zero > byte_stuffing.whatever;
    
    sequence_header > other_start_code;
    load_intra_quantiser_matrix.no > load_intra_quantiser_matrix.yes;
    load_non_intra_quantiser_matrix.no > load_non_intra_quantiser_matrix.yes;

    sequence_extension > other_start_code;
    user_data > other_start_code;
    gop_header > other_start_code;
    picture_header > other_start_code;
    slice > other_start_code;
    
    composite_flag.no > composite_flag.yes;
    slice_intra_flag.no > slice_intra_flag.yes;
  end
  
  ///////////////////////////////////////////////////////////////////////////
  // FSM
  // state "oops" is dead-end state when encountering an invalid sequence or when parser is lost
  schedule fsm video_sequence_start:
    video_sequence_start (byte_stuffing.zero) --> video_sequence_start;
    video_sequence_start (byte_stuffing.whatever) --> oops;
    video_sequence_start (next_start_code) --> sequence_header;

	// sequence_header
    sequence_header (sequence_header) --> sequence_header_intra_matrix_or_not;
    sequence_header (other_start_code) --> oops;

    sequence_header_intra_matrix_or_not (load_intra_quantiser_matrix) --> sequence_header_non_intra_matrix_or_not;
    sequence_header_non_intra_matrix_or_not (load_non_intra_quantiser_matrix) --> sequence_body;

	// sequence_body: if ( nextbits() == extension_start_code ) { sequence_extension; sequence_loop }
    sequence_body (byte_stuffing.zero) --> sequence_body;
    sequence_body (byte_stuffing.whatever) --> oops;
    sequence_body (next_start_code) --> sequence_body_after_SC;

    sequence_body_after_SC (sequence_extension) --> sequence_loop;
    sequence_body_after_SC (other_start_code) --> oops;

    // sequence_loop: do { ... } while ( nextbits() != sequence_end_code )
    sequence_loop (byte_stuffing.zero) --> sequence_loop;
    sequence_loop (byte_stuffing.whatever) --> oops;
    sequence_loop (next_start_code) --> extension_user_data_0;

    // extension data
    extension_user_data_0 (sequence_extension) --> extension_user_data_0;

	// user data
	extension_user_data_0 (user_data) --> user_data_0;
	user_data_0 (byte_stuffing.whatever) --> user_data_0;
	user_data_0 (next_start_code) --> extension_user_data_0;

    // GOP, or picture, or OOPS!
    extension_user_data_0 (gop_header) --> gop;
    extension_user_data_0 (picture_header) --> picture_header;
    extension_user_data_0 (other_start_code) --> oops;

    ///////////////////////////////////////////////////////////////////////////
	// we got a GOP, look for the next start code
    gop (byte_stuffing.zero) --> gop;
    gop (byte_stuffing.whatever) --> oops;
    gop (next_start_code) --> extension_user_data_1;

    // extension data
    extension_user_data_1 (sequence_extension) --> extension_user_data_1;

    // user data
    extension_user_data_1 (user_data) --> user_data_1;
    user_data_1 (byte_stuffing.whatever) --> user_data_1;
    user_data_1 (next_start_code) --> extension_user_data_1;
    
    // picture header
    extension_user_data_1 (picture_header) --> picture_header;
    
    ///////////////////////////////////////////////////////////////////////////
	// picture_header extra info, not used in MPEG-2
	picture_header (picture.pred) --> picture_header_extra;
	picture_header (picture.intra) --> picture_header_no_extra;
	
	picture_header_no_extra (byte_stuffing.zero) --> picture_header_no_extra;
	picture_header_no_extra (byte_stuffing.whatever) --> oops;
	picture_header_no_extra (next_start_code) --> picture_header_done;

	// ok bit of an optimization here, because this information is not used anyway
	// so we just look for the next start code (I know this is not strictly compliant,
	// but who cares?)
    picture_header_extra (byte_stuffing.whatever) --> picture_header_extra;
    picture_header_extra (next_start_code) --> picture_header_done;
    
    ///////////////////////////////////////////////////////////////////////////
	// picture_coding_extension
	picture_header_done (picture_coding_extension) --> composite_or_not;
	picture_header_done (other_start_code) --> oops;

	composite_or_not (composite_flag) --> picture_extension_done;
	
    picture_extension_done (byte_stuffing.zero) --> picture_extension_done;
    picture_extension_done (byte_stuffing.whatever) --> oops;
    picture_extension_done (next_start_code) --> extension_user_data_2;

    ///////////////////////////////////////////////////////////////////////////
	// extension_user_data_2

    // extension data
    extension_user_data_2 (sequence_extension) --> extension_user_data_2;

    // user data
    extension_user_data_2 (user_data) --> user_data_2;
    user_data_2 (byte_stuffing.whatever) --> user_data_2;
    user_data_2 (next_start_code) --> extension_user_data_2;
    
    // slice
    extension_user_data_2 (slice) --> slice_start;
    extension_user_data_2 (other_start_code) --> oops;
    
    ///////////////////////////////////////////////////////////////////////////
	// slice
	slice_start (slice_intra_flag.yes) --> oops; // TODO
	slice_start (slice_intra_flag.no) --> MB;

    // just so we do not have warnings
    oops (oops) --> oops;
  end

end
