// Interpolation for motion compensation, frame buffer and add motion and texture to produce pixels
//
// Authors: Ghislain Roquier(ghislain.roquier@epfl.ch), Matthieu Wipliez <mwipliez@insa-rennes.fr>

import all caltrop.lib.BitOps;

actor Framebuf_interp_add(
  int ADDR_SZ, int BTYPE_SZ, int BUF_SZ, int FLAG_SZ, int MB_COORD_SZ, int PIX_SZ,

  // Command flags from parser
  int NEWVOP,
  int INTRA,
  int ACCODED)

  int(size=FLAG_SZ) halfpel, // from MPEG4_algo_Interpolation_halfpel
  int(size=ADDR_SZ) RA, int(size=ADDR_SZ) WA, // from MPEG4_mgnt_Framebuf
  int(size=PIX_SZ) TEX, int(size=BTYPE_SZ) BTYPE ==> // from MPEG4_algo_Add
    
  int(size=PIX_SZ) VID : // from MPEG4_algo_Add
  
  /////////////////////////////////////////////////////////////////////////////
  // buffer
  List( type:int(size=PIX_SZ), size=BUF_SZ ) buf := [ 0 : for int i in Integers(1,BUF_SZ) ];
    
  /////////////////////////////////////////////////////////////////////////////
  // interpolation

  int(size=3) flags;
  int(size=2) round;
  
  // compensation function
  function compensate( int p00, int p10, int p01, int p11 ) --> int :
    if flags = 0 then p00 else
      if flags = 1 then
        // interpolate y only
        rshift( (p00 + p01 + 1) - round, 1 )
      else
        if flags = 2 then
          // interpolate x only
          rshift( (p00 + p10 + 1) - round, 1 )
        else
          // interpolate x and y
          rshift( ( p00 + p10 + p01 + p11 + 2) - round, 2 )
        end
      end
    end
  end

  /////////////////////////////////////////////////////////////////////////////
  // Ignore new VOP command
  cmd.newVop: action BTYPE:[ cmd ] ==>
  guard
    bitand( cmd, NEWVOP ) != 0
  end

  // Pure texture
  cmd.textureOnly: action BTYPE:[ cmd ] ==>
  guard
    bitand( cmd, INTRA ) != 0
  end

  // Pure motion
  cmd.motionOnly: action BTYPE:[ cmd ] ==>
  guard
    bitand( cmd, ACCODED ) = 0
  end

  // Mixed texture and motion
  // (Also used to skip vop w,h)
  cmd.other: action BTYPE:[ cmd ] ==>
  end

  texture: action TEX:[ tex ] repeat 64, WA:[ a ] repeat 64 ==> VID:[ tex ] repeat 64
  do
    foreach int i in Integers(0, 63) do
      buf[a[i]] := tex[i];
    end
  end
  
  // compensation action
  motion: action halfpel:[ f ], RA:[ d ] repeat 81, WA:[ a ] repeat 64 ==> VID:[ mot ] repeat 64
  var
    List(type:int, size=64) mot = [0 : for int n in Integers(0, 63)]
  do
    flags := rshift(f,1);
    round := bitand(f,1);
	
    foreach int i in Integers(0, 7) do
       foreach int j in Integers(0, 7) do
          mot[ 8*i + j ] :=
            compensate(buf[ d[9*i + j] ], buf[ d[9*i + j + 1] ],
            buf[ d[9*(i+1) + j] ], buf[ d[9*(i+1) + j + 1] ]);
       end
    end
    
    foreach int i in Integers(0, 63) do
      buf[a[i]] := mot[i];
    end
  end

  combine: action
    halfpel:[ f ], RA:[ d ] repeat 81, WA:[ a ] repeat 64, TEX:[ tex ] repeat 64 ==>
    VID:[ vid ] repeat 64
  var
    int output,
    List(type:int, size=64) mot = [0 : for int n1 in Integers(0, 63)],
    List(type:int, size=64) vid = [0 : for int n2 in Integers(0, 63)]
  do
    flags := rshift(f,1);
    round := bitand(f,1);
	
    foreach int i in Integers(0, 7) do
       foreach int j in Integers(0, 7) do
          mot[ 8*i + j ] :=
            compensate(buf[ d[9*i + j] ], buf[ d[9*i + j + 1] ],
            buf[ d[9*(i+1) + j] ], buf[ d[9*(i+1) + j + 1] ]);
       end
    end
    
    foreach int i in Integers(0, 63) do
      output := tex[i] + mot[i];
      vid[i] := 
        if output < 0 then
          0 
  		else
  		  if output > 255 then 255 else output end
  		end;
    end
    
    foreach int i in Integers(0, 63) do
      buf[a[i]] := vid[i];
    end
  end

  schedule fsm cmd:
    cmd          ( cmd.newVop        ) --> skipw;
    cmd          ( cmd.textureOnly   ) --> texture;
    cmd          ( cmd.motionOnly    ) --> motion;
    cmd          ( cmd.other         ) --> combine;

    texture      ( texture           ) --> cmd;
    motion       ( motion            ) --> cmd;
    combine      ( combine           ) --> cmd;

    skipw        ( cmd.other         ) --> skiph;
    skiph        ( cmd.other         ) --> cmd;
  end

  priority
    cmd.newVop > cmd.textureOnly > cmd.motionOnly > cmd.other;
  end

end