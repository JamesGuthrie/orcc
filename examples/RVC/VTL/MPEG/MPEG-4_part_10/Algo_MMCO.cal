/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/

//Modified by Mederic Blestel and Endri Bezati IETR/INSA of Rennes
//Modified by Mickael Raulet IETR/INSA of Rennes


actor Algo_MMCO () 
	uint(size=31) MMCO,
	uint(size=31) FraNum,
	uint(size=31) MaxFrameNum,
	uint(size=5)  NumReferenceFrame
		==>
	int (size=32) DelList,
	uint(size=31) ShortTermList,
	uint(size=5)  SzSTList,
	uint(size=31) LongTermList,
	uint(size=5)  NbLTFrame
		:

	List(type:uint(size=31), size=16) STList              := [0     : for int s in Integers(0,15)];
	List(type:bool         , size=16) ShortTermFalseFrame := [false : for int s in Integers(0,15)];
	List(type:int (size=32), size=16) LTList              := [-1    : for int s in Integers(0,15)];
	List(type:uint(size=31), size=16) DelListTab          := [0     : for int s in Integers(0,15)];

	int (size=6)  NbFrameDel       := 0;
	uint(size=31) FrameNum         := 0;
	uint(size=31) LastFrameNum     := 0;
	uint(size=31) ValMaxFrameNum   := 0;
	uint(size=5)  NumRefFrame      := 0;
	uint(size=5)  ShortTermCount   := 0;
	uint(size=5)  LongTermCount    := 0;
	uint(size=5)  NbShortTermSent  := 0;
	uint(size=5)  NbLongTermSent   := 0;
	uint(size=1)  FlagLongTerm     := 0;
	uint(size=4)  LongTermFrameIdx := 0;


	read_num_ref_frames: action
			NumReferenceFrame :[ValNumRefFrame],
			FraNum            :[ValFrame_Num],
			MaxFrameNum       :[MaxFrNu]
				==>
		do
			NumRefFrame    := ValNumRefFrame;
			ValMaxFrameNum := MaxFrNu;
			LastFrameNum   := FrameNum;
			FrameNum       := ValFrame_Num;
			NbFrameDel     := 0;
		end


	FillFalseRefFrame : action ==>
		guard
			FrameNum != (LastFrameNum + 1) mod ValMaxFrameNum
		var
			uint(size=31) false_frame_num := (LastFrameNum + 1) mod ValMaxFrameNum
		do
				while(false_frame_num != FrameNum)
				do
					if(LongTermCount + ShortTermCount = NumRefFrame) then
						if(NbFrameDel  >  15) then
							NbFrameDel := 15;
						end
						if (ShortTermFalseFrame[ShortTermCount - 1] = false) then
							DelListTab[NbFrameDel] := STList[ShortTermCount - 1];
							NbFrameDel             := NbFrameDel + 1;
						end
						ShortTermCount := ShortTermCount - 1;
					end
					foreach int i in Integers(0,ShortTermCount - 1)
					do
						STList             [ShortTermCount - i] := STList             [ShortTermCount - i - 1];
						ShortTermFalseFrame[ShortTermCount - i] := ShortTermFalseFrame[ShortTermCount - i - 1];
					end
					STList[0]              := false_frame_num;
					ShortTermFalseFrame[0] := true;
					ShortTermCount         := ShortTermCount + 1;
					false_frame_num        := (false_frame_num + 1) mod ValMaxFrameNum;
				end
		end


	FillFalseRefFrame_done : action ==>
		guard
			FrameNum = (LastFrameNum + 1) mod ValMaxFrameNum
		end


	SendSizeLists: action 
				==>
			SzSTList  :[ShortTermCount],
			NbLTFrame :[LongTermCount]
		do
			NbShortTermSent := 0;
			NbLongTermSent  := 0;
		end


	SendShortTermList: action
				==>
			ShortTermList :[ValShortTermList]
		guard
			NbShortTermSent < ShortTermCount
		var
			uint(size=31) ValShortTermList
		do
			ValShortTermList := STList[NbShortTermSent];
			NbShortTermSent  := NbShortTermSent + 1;
		end


	SendLongTermList: action
				==>
			LongTermList :[ValLongTermList]
		guard
			NbLongTermSent < 16
		var
			uint(size=31) ValLongTermList
		do
			ValLongTermList := LTList[NbLongTermSent];
			NbLongTermSent  := NbLongTermSent + 1;
		end

	
	SendLists_Done: action ==>
		end


	read_IDR: action
			MMCO :[NotIdr , is_long_term]
				==>
		guard 
			NotIdr = 0
		do
			FlagLongTerm     := is_long_term;
			LongTermFrameIdx := 0;
			ShortTermCount   := 0;
			LongTermCount    := 0;
			LTList           := [-1 :for int s in Integers(0,15)];
			NbFrameDel       := -1;
		end


	read_not_IDR_not_MMCO: action
			MMCO :[NotIdr , adaptive_ref_pic_marking_mode_flag]
				==>
		guard
			(NotIdr = 1) and (adaptive_ref_pic_marking_mode_flag = 0)
		do
			FlagLongTerm := 0;
		end


	read_not_IDR_MMCO: action
			MMCO :[NotIdr , adaptive_ref_pic_marking_mode_flag]
				==>
		guard 
			(NotIdr = 1) and (adaptive_ref_pic_marking_mode_flag = 1)
		do
			FlagLongTerm := 0;
		end


	MMCO_opcode_IsEqualTo0: action
			MMCO :[opcode]
				==>
		guard 
			opcode = 0
		end


	// Mark a short term reference picture as "unused for reference "
	MMCO_opcode.IsEqualTo1: action
			MMCO :[opcode, difference_of_pic_nums_minus1]
				==>
		guard 
			opcode = 1
		var 
			int(size=5)  idx := -1,
			int(size=32) FrameNumST
		do
			FrameNumST := FrameNum - difference_of_pic_nums_minus1 - 1;
			if(FrameNumST < 0) then
				FrameNumST := FrameNumST + ValMaxFrameNum;
			end
			foreach int i in Integers( 0, ShortTermCount - 1 )
			do
				if (STList[i] = FrameNumST) then 
					idx := i;
				end
			end
			if(idx != -1) then
				foreach int i in Integers(idx, ShortTermCount - 2)
				do
					STList[i]              := STList[i+1];
					ShortTermFalseFrame[i] := ShortTermFalseFrame[i+1];
				end
				ShortTermCount         := ShortTermCount - 1;
				DelListTab[NbFrameDel] := FrameNumST;
				NbFrameDel             := NbFrameDel + 1;
			end
		end


	// Mark a long term reference picture as "unused for reference "
	MMCO_opcode.IsEqualTo2: action
			MMCO:[opcode, IdxLTFrame ]
				==>
		guard 
			opcode = 2
		do
			if(LTList[IdxLTFrame]  != -1) then
				DelListTab[NbFrameDel] := LTList[IdxLTFrame];
				NbFrameDel             := NbFrameDel + 1;
				LTList[IdxLTFrame]     := -1;
				LongTermCount          := LongTermCount - 1;
			end
		end


	// Mark a short term reference picture as long term
	MMCO_opcode.IsEqualTo3: action
			MMCO:[opcode, difference_of_pic_nums_minus1, IdxLTFrame]
				==>
		guard 
			opcode = 3
		var
			int(size=5) idx := -1,
			int(size=32)FrameNumST
		do
			FrameNumST := FrameNum - difference_of_pic_nums_minus1 - 1; 
			if(FrameNumST < 0) then
				FrameNumST := FrameNumST + ValMaxFrameNum;
			end
			foreach int i in Integers(0, ShortTermCount-1)
			do
				if (STList[i] = FrameNumST) then
					idx := i;
				end
			end
			if(idx != -1) then
				foreach int i in Integers(idx, ShortTermCount - 2)
				do
						STList[i]              := STList[i + 1];
						ShortTermFalseFrame[i] := ShortTermFalseFrame[i + 1];
				end
				ShortTermCount := ShortTermCount - 1;
				
				if (LTList[IdxLTFrame] = -1) then
					LongTermCount := LongTermCount + 1;
				else
					DelListTab[NbFrameDel] := LTList[IdxLTFrame];
					NbFrameDel             := NbFrameDel + 1;
				end
				LTList[IdxLTFrame] := FrameNumST;
			end
		end


	// Specify the maximum long term frame index
	MMCO_opcode.IsEqualTo4: action
			MMCO:[opcode, long_term_max_idx]
				==>
		guard 
			opcode = 4
		do
			foreach int i in Integers(long_term_max_idx, 15)
			do
				if (LTList[i] != -1) then
					DelListTab[NbFrameDel] := LTList[i];
					NbFrameDel             := NbFrameDel + 1;
					LTList[i]              := -1;
					LongTermCount          := LongTermCount - 1;
				end
			end
		end


	// Mark all reference picture as "unused for reference "
	MMCO_opcode.IsEqualTo5: action
			MMCO:[opcode]
				==>
		guard 
			opcode = 5
		do
			FrameNum       := 0;
			ShortTermCount := 0;
			STList         := [-1 :for int s in Integers(0,16-1)];
			LongTermCount  := 0;
			LTList         := [-1 :for int s in Integers(0,16-1)];
			NbFrameDel     := -1;
		end


	// Mark the current picture as long term reference picture
	MMCO_opcode.IsEqualTo6: action
			MMCO:[opcode, IdxLTFrame]
				==>
		guard 
			opcode = 6
		do
			LongTermFrameIdx := IdxLTFrame;
			FlagLongTerm     := 1;
		end


	AddFrameInLTList: action ==>
		guard
			FlagLongTerm = 1
		do

			if (LTList[LongTermFrameIdx] != -1) then
				DelListTab[NbFrameDel] := LTList[LongTermFrameIdx];
				NbFrameDel             := NbFrameDel + 1;
			else 
				LongTermCount          := LongTermCount +1;
			end
			LTList[LongTermFrameIdx]   := FrameNum;

			if (LongTermCount + ShortTermCount > NumRefFrame) then
				ShortTermCount := ShortTermCount - 1;
				if(ShortTermFalseFrame[ShortTermCount] = false) then
					DelListTab[NbFrameDel] := STList[ShortTermCount];
					NbFrameDel             := NbFrameDel + 1;
				end
			end
		end


	AddFrameInSTList: action ==>
		guard
			FlagLongTerm = 0
		do
			if (LongTermCount + ShortTermCount = NumRefFrame) then
				ShortTermCount := ShortTermCount - 1;
				if(ShortTermFalseFrame[ShortTermCount] = false) then
					DelListTab[NbFrameDel] := STList[ShortTermCount];
					NbFrameDel             := NbFrameDel + 1;
				end
			end
			foreach int i in Integers (0, ShortTermCount - 1)
			do
				STList             [ShortTermCount - i] := STList             [ShortTermCount - i - 1];
				ShortTermFalseFrame[ShortTermCount - i] := ShortTermFalseFrame[ShortTermCount - i - 1];
			end
			STList[0]              := FrameNum;
			ShortTermFalseFrame[0] := false;
			ShortTermCount         := ShortTermCount +1;
		end


	SendSizeDelList: action
				==>
			DelList:[NbFrameDel]
		end


	SendDelList : action
				==>
			DelList:[ValDelFrame]
		guard
			NbFrameDel > 0
		var
			int(size=32) ValDelFrame
		do
			NbFrameDel  := NbFrameDel - 1;
			ValDelFrame := DelListTab[NbFrameDel];
		end


	SendDelListDone : action ==>
		end


	schedule fsm  read_num_ref_frames:
		read_num_ref_frames (read_num_ref_frames    )--> FillFalseRefFrame;

		FillFalseRefFrame   (FillFalseRefFrame      )--> SendSizeLists;
		FillFalseRefFrame   (FillFalseRefFrame_done )--> SendSizeLists;

		SendSizeLists       (SendSizeLists          )--> SendLists;
		SendLists           (SendShortTermList      )--> SendLists;
		SendLists           (SendLongTermList       )--> SendLists;
		SendLists           (SendLists_Done         )--> check_IDR;

		/* Get values about memory_management_control_operation */
		check_IDR           (read_IDR               )--> AddFrameInList;
		check_IDR           (read_not_IDR_not_MMCO  )--> AddFrameInList;
		check_IDR           (read_not_IDR_MMCO      )--> MMCO_opcode;
		MMCO_opcode         (MMCO_opcode            )--> MMCO_opcode;
		MMCO_opcode         (MMCO_opcode_IsEqualTo0 )--> AddFrameInList;

		AddFrameInList      (AddFrameInLTList       )--> SendSizeDelList;
		AddFrameInList      (AddFrameInSTList       )--> SendSizeDelList;

		SendSizeDelList     (SendSizeDelList        )--> SendDelList;
		SendDelList         (SendDelList            )--> SendDelList;
		SendDelList         (SendDelListDone        )--> read_num_ref_frames;
	end

	priority
		SendDelList       > SendDelListDone;
		SendShortTermList > SendLists_Done;
		SendLongTermList  > SendLists_Done;
	end

end
