/**
 * Copyright (c) 2009, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
 
// Author: Pierre-Laurent Lagalaye

/******************************************************************************
 * BitstreamReader_UT : Unitary test of the bitstream parser                  *
 ******************************************************************************/
actor BitstreamReader_UT() uint(size=32) Result ==> uint(size=8) Data,
uint(size=8) CtrlBitstreamReader, String Check :

	// Constants
	uint(size=8) CTRL_RESYNC = 0x80;
	uint(size=8) CTRL_FLUSH  = 0x40;

	// Tester state
	bool testing := true;

	// Input stimulus :
	List(type:uint(size=8), size=16) test_data :=
		[0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
		 0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10];

	test_data: action ==> Data:[test_data] repeat 16
	end

	test_flush: action ==> CtrlBitstreamReader:[CTRL_FLUSH|3]
	end
	
	test_show: action ==> CtrlBitstreamReader:[5]
	end
	
	test_byte_resync: action ==> CtrlBitstreamReader:[CTRL_RESYNC|0]
	end
	
	// BitstreamReader control commands
	List(type:uint(size=8), size=8) bits_ctrl :=
		[CTRL_FLUSH+16, CTRL_FLUSH+16, CTRL_FLUSH+16, CTRL_FLUSH+16,
		 CTRL_FLUSH+32, CTRL_FLUSH+5, CTRL_FLUSH+19, CTRL_FLUSH+8];
	test_multi_word: action ==> CtrlBitstreamReader:[bits_ctrl] repeat 8
	end
	
	// Output Result :
	List(type:uint(size=32), size=11) expected := 
		[0x0,0x1,0x1,0x0203,0x0405,0x0607,0x0809,0x0A0B0C0D,0x1,0x60F10,0x01];
	List(type:String, size=11) check;
	test_result: action Result:[symbol] repeat 11 ==> Check:[check] repeat 11
	guard
	  testing
	do
	 	foreach int i in Integers(0,10) do
			if symbol[i] = expected[i] then
				check[i]:="Test OK";
			else
				check[i]:="Test ERROR";
			end
		end
	  	testing := false;
	end
	
	// FSM scheduling the input stimuli
	schedule fsm init_data1 :
		init_data1 (test_data) --> init_data2;
		init_data2 (test_data) --> flush;
		flush (test_flush) --> show;
		show (test_show) --> resync;
		resync (test_byte_resync) --> multi_word;
		multi_word (test_multi_word) --> init_data1;
	end
end
