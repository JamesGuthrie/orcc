/********************************************************************************

This software module was originally developed by Florian Decologne IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.


This FU remove emulation_prevention_three_byte, send the RBSP bytes and the number of rbsp bytes between 2 NAL.

*****************************************************************************/



actor Algo_NALU (int Buffer_Size) 
	int(size=8) bits8 
	==> 
	int(size=8) bits_rbsp8, 
	uint nb_rbsp_bytes
	:
 
  uint(size=8) byte0;
  uint(size=8) byte1; 
  uint(size=8) byte_moins1;
  uint(size=2) byte_count := 0;
  uint(size=2) start_code := 0;
  uint(size=2) start_code_found := 0;
  uint(size=2) start_code_trunk_3 := 0;
  uint num_bytes_in_RBSP:=0;
  List (type : int , size = Buffer_Size ) Input_Bitstream := [ 0 : for int l in Integers ( 0 , Buffer_Size-1)];
  int i:=0;
  int a :=0;

  
  get_byte: action bits8:[ b ] ==>
  guard 
    byte_count < 2
  do
    if byte_count = 1 then
      byte0 := byte1;
    end 
    byte1:=b;
    byte_count := byte_count+1;
  end
  
/*  read : action bits8:[current_byte]==>
  guard
  	i < Buffer_Size,
  	start_code_found < 2
  do
  	if i <3 then
  		Input_Bitstream[i] := current_byte;
  	else
  		Input_Bitstream[i] := current_byte;
  		if Input_Bitstream[i-2] = 0 and Input_Bitstream[i-1] = 0 and Input_Bitstream[i] = 1 then
  			start_code_found := start_code_found + 1;
  		end 
  		if Input_Bitstream[i-2] = 0 and Input_Bitstream[i-1] = 0 and Input_Bitstream[i] = 3 then
  			num_bytes_in_RBSP := num_bytes_in_RBSP-2;
  			i := i-2;
  		end
  		num_bytes_in_RBSP := num_bytes_in_RBSP+1;
  	end
  	i := i+1;
  end
  
  send_stream : action ==>  bits_rbsp8:[Input_Bitstream] repeat Buffer_Size, nb_rbsp_bytes:[b]
  guard
  	i < Buffer_Size,
  	start_code_found = 2
  do
  		i := i -1;
		// case where SC is of 3 bytes instead of 4
  		if Input_Bitstream[i-3] != 0 and Input_Bitstream[i-2] = 0 and Input_Bitstream[i-1] = 0 and Input_Bitstream[i] = 1 then
  			num_bytes_in_RBSP := num_bytes_in_RBSP-1;
  		end 
		b := num_bytes_in_RBSP;
		start_code_found := 1;
		num_bytes_in_RBSP := 0;
		i := 0;
		
  end
 */
 
  emul: action bits8:[ b ] ==> bits_rbsp8:[ 0 , 0 ]
  guard 
    byte_count = 2,
    byte0 = 0 and byte1 = 0 and b = 3
   do
    byte_count := 0;
    num_bytes_in_RBSP := num_bytes_in_RBSP+2;
  end
  
  send: action bits8:[ b ] ==> bits_rbsp8:[v]
  guard 
    byte_count = 2
  var 
    uint(size=8) v
  do
    if start_code = 1 then
      num_bytes_in_RBSP := num_bytes_in_RBSP+1;
    end

    if byte0 = 0 and byte1 = 0 and b = 1 then 
      start_code := start_code+1;
      if byte_moins1 != 0 then // case video bitstreams where start code do not start with 00 00 00 01 but by 00 00 01 see file in AVCBS-5 folder
      	start_code_trunk_3 := 1;
      end
	end

    byte_moins1 := byte0;
    v := byte0;
    byte0 := byte1; 
    byte1 := b;
  
  end
  
// Modifications done by J DELORME the 12.03.10 for management of start code in video bitstreams which do not start with 4 bytes but 3 bytes 
// usually it is 00 00 00 01 then data and in certain cases (video in AVCBS-5 folder) start code begin as 00 00 01
  
  send_nb_rbsp_bytes: action  ==> nb_rbsp_bytes:[ v ]
  guard 
    start_code = 2
  var 
    uint v
  do
    if start_code_trunk_3 = 0 then 	// start codes are 00 00 01
		v := num_bytes_in_RBSP - 4; // 3 for start_code + 1 for NAL Unit header
	else							// start codes are 00 00 00 01
		v := num_bytes_in_RBSP - 3; // 2 for start_code + 1 for NAL Unit header
		start_code_trunk_3 := 0;
	end	  	
    num_bytes_in_RBSP :=0;
    start_code := 1;
  end

  priority
    send_nb_rbsp_bytes > emul > send;
//    read> send_stream;
  end
end

