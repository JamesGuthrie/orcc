/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
//Modified by Endri Bezati IETR/INSA Rennes
//Added FSM to the actor

actor Algo_IntraPred_Split (int PREDTYPE_SIZE)
		uint(size=1)  MbIntraFlag,
		uint(size=4)  IntraPredMode, 
		uint(size=13) CurrMbAddr,
		uint(size=7)  PicWidthInMb,
		uint(size=13) FirstMBInSlice,
		bool          ConstrainedIFlag
				==>
				int(size=PREDTYPE_SIZE) IntraDCflag,
				uint(size=4)  PredMode,
				uint (size=8) MbType,
				uint (size=8) MbTypeC : 
 
  //FIXME! number of MB per line of picture
  int PICWIDTH=1280/16; //number of MB per lines

  uint( size=2 ) mb_intra_type  := 0; // Intra4x4 1, Intra8x8 2, Intra16x16 3
  uint( size=3 ) mb_intra_flag; 
  uint( size=5 ) count := 0;
  uint mb_x:= 0;
  uint pic_width_in_mb;
  uint(size=13) curr_mb_addr;
  uint(size=13) first_mb_in_slice;
  
  List ( type: List (type:int(size=5), size=16), size= PICWIDTH) intra4x4predmode;
  List ( type: uint(size=4), size=16) InverseScan4x4Tab := [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];
  
  //FIXME! Maximum size of a line in macroclock
  List( type:bool, size=PICWIDTH) is_constrained_i_flag := [false : for int i in Integers( 0, PICWIDTH-1)];
  
  
  // initialize intra4x4predmode to a huge list of 2's
  initialize ==>
  do
    intra4x4predmode := [[ 2 : for int j in Integers(0,15)]: for int i in Integers( 0, PICWIDTH - 1)];
  end
  
  Get_MbType: action MbIntraFlag : [ Mb_Intra_Flag ] ==>
  do
  	mb_intra_flag := Mb_Intra_Flag;	
  end
  
    
  get_inter: action 
  					CurrMbAddr: [Curr_Mb_Addr],
  					PicWidthInMb: [Pic_Width_In_Mb],
  					FirstMBInSlice:[First_MB_In_Slice], 
  					ConstrainedIFlag:[Constrained_I_Flag] 
  						==> 
  						IntraDCflag:[0],
  						MbType:[2],
  						MbTypeC:[2]
  guard
    mb_intra_flag = 0
  do
    pic_width_in_mb   := Pic_Width_In_Mb; 
    curr_mb_addr      := Curr_Mb_Addr;
    first_mb_in_slice := First_MB_In_Slice;
    mb_x := curr_mb_addr mod pic_width_in_mb;
    intra4x4predmode[mb_x] := [ 2 : for int j in Integers(0,15)];
    is_constrained_i_flag[mb_x]:=not(Constrained_I_Flag);
  end
    
  get_intratype: action 
  					IntraPredMode:[Mb_Type], 
  					CurrMbAddr: [Curr_Mb_Addr],
  					PicWidthInMb: [Pic_Width_In_Mb],
  					FirstMBInSlice:[First_MB_In_Slice]
  					==> 
  guard
    mb_intra_flag = 1 
  do
    mb_intra_type     := Mb_Type;
    pic_width_in_mb   := Pic_Width_In_Mb; 
    first_mb_in_slice := First_MB_In_Slice;
    curr_mb_addr      := Curr_Mb_Addr;
    mb_x := curr_mb_addr mod pic_width_in_mb;
  end
  
  get_intra4x4: action IntraPredMode:[Intra_Pred_Mode] 
  										==> 
  											PredMode : [ pred_mode ]
  guard
    mb_intra_type = 1 and count < 16
  var 
    int(size=5) top, 
	int(size=5) left, 
	int(size=5) predicted, 
	int(size=5) pred_mode
  do
    if curr_mb_addr < first_mb_in_slice + pic_width_in_mb and InverseScan4x4Tab[count]<4 then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
         top:= -1;
    else
         if InverseScan4x4Tab[count]<4 then
         	if (is_constrained_i_flag[mb_x]) then
         		top := intra4x4predmode[mb_x, 12 + InverseScan4x4Tab[count]];
         	else
         		top:=-1;
         	end
         else
         	top := intra4x4predmode[mb_x, InverseScan4x4Tab[count]-4];
         end
    end
    if (curr_mb_addr = first_mb_in_slice or mb_x = 0) and InverseScan4x4Tab[count] mod 4 = 0 then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
       left:= -1;
    else
    	if InverseScan4x4Tab[count] mod 4 = 0 then
    		if (is_constrained_i_flag[mb_x-1]) then
    			left := intra4x4predmode[mb_x - 1, 3 + InverseScan4x4Tab[count]];
    		else
    			left :=-1;
    		end
    	else
    		left := intra4x4predmode[mb_x, InverseScan4x4Tab[count]- 1];
    	end
    end
    if left < top then predicted := left; else predicted := top; end
    if predicted < 0 then predicted := 2; end //INTRA_4x4_DC
    if Intra_Pred_Mode < predicted then pred_mode := Intra_Pred_Mode; else pred_mode := Intra_Pred_Mode+1; end
    if Intra_Pred_Mode = 15 then pred_mode := predicted; end
    intra4x4predmode[mb_x, InverseScan4x4Tab[count]] := pred_mode;
    count := count + 1;
  end
  
  get_intra4x4_done: action 
  					ConstrainedIFlag:[Constrained_I_Flag]
  					==>
  								IntraDCflag : [  0  ],
  								MbType      : [  0  ],
  								MbTypeC     : [  1  ]
  								
  guard
  	mb_intra_type = 1 and count = 16
  do
  	count := 0;
    is_constrained_i_flag[mb_x]:=true;
  end
  
/*  get_intra8x8: action IntraPredMode:[a] ==> PredMode:[val] // Not yet tested
  guard
    intratype = 2 and count <16
  var 
    uint CurrMb4x4Addr := y * lshift( picW,4) + lshift(x,2) + InverseScan4x4(count,lshift( picW,2)),
    uint CurrMb8x8Addr :=0,
    int(size=5) top, 
	int(size=5) left, 
	int(size=5) predicted, 
	int(size=5) val    
  do
    if (CurrMb4x4Addr / lshift( picW,2)) = 0 then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
         top:= -1;
    else
         top := intra4x4predmode[CurrMb4x4Addr - lshift(picW,2)];
    end
    if (CurrMb4x4Addr mod lshift( picW,2)) = 0 then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
       left:= -1;
    else
       left := intra4x4predmode[CurrMb4x4Addr - 1];
    end
    if left < top then predicted := left; else predicted := top; end
    if predicted < 0 then predicted := 2; end //INTRA_4x4_DC
    if a < predicted then val := a+1; else val := a; end
    if a = 15 then val := predicted; end
    println("Prediction : Intra8x8 "+CurrMb4x4Addr+" get "+a+" pred "+predicted+" --> val = "+val);
    foreach int i in Integers(0,3) do
      CurrMb8x8Addr := y * lshift( picW,4) + lshift(x,2) + InverseScan4x4(count+i,lshift( picW,2));
      intra4x4predmode[CurrMb8x8Addr] := val;
    end
    count := count +4;
  end */
  
  get_intra16x16: action 
  						ConstrainedIFlag:[Constrained_I_Flag],
  						IntraPredMode : [ Mode_16x16 ] 
  										==> 
  											IntraDCflag : [ 1 ],
  											PredMode    : [ Mode_16x16 ],
  											MbType      : [ 1 ],
  										    MbTypeC     : [ 1 ] 
  guard
    mb_intra_type = 3 
  do
    intra4x4predmode[ mb_x ] := [ 2 : for int j in Integers(0,15) ];
    is_constrained_i_flag[mb_x]:=true;
  end
  
 
  
  get_i_pcm: action
				ConstrainedIFlag:[cflag]
					==>
					MbType       : [ 4 ],
					MbTypeC      : [ 4 ]  										
  guard
  	mb_intra_type = 4
  do
    intra4x4predmode[ mb_x ] := [ 2 : for int j in Integers(0,15) ];
    is_constrained_i_flag[mb_x]:=true;
  end 
 
 schedule fsm GetType:
  	GetType		  ( Get_MbType        )		--> MbType;
  	//Decode Mb Inter
  	MbType		  ( get_inter         )	    --> GetType;
  	MbType		  ( get_intratype     )		--> IntraType;
  	//Decode Mb Intra 4x4
  	IntraType	  ( get_intra4x4      )		--> IntraType;
  	IntraType     ( get_intra4x4_done )		--> GetType;
  	//Decode Mb Intra 16x16
  	IntraType	  ( get_intra16x16    )		--> GetType;
  	//Decode Mb I PCM
  	IntraType	  ( get_i_pcm         )		--> GetType;      
  end
  
end