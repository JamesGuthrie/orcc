/********************************************************************************

This software module was originally developed by Florian Decologne IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.

 
Manager of the intra 4x4 Prediction
Jérôme GORIN IETR/ARTEMIS
gorinje@gmail.com
*****************************************************************************/

actor Mgnt_Intra_4x4 ( int SAMPLE_SZ, int MB_WIDTH )
	uint (size=8) Mb_Type,
	uint(size=13) FirstMbInSlice,
	uint(size=7) PicWidthInMb,
	uint(size=13) CurrMbAddr,
	uint(size=4) PredMode,
	uint(size=SAMPLE_SZ) EDGE,
	int(size=9) MB_4X4,
	int(size=SAMPLE_SZ) Coef_ACR,
	bool ConstrainedIFlag 
		==> 
		uint(size=1) Avail,
		uint(size=4) PredMode4x4,
		int(size=SAMPLE_SZ) Coef_ACR_4X4,
		int(size=SAMPLE_SZ) Y_Left4,
		int(size=SAMPLE_SZ) Y_Up4,
		int(size=SAMPLE_SZ) Y_UpLeft4
		:  
  	
	//Token counter
	int (size = 6) mb_counter := 0;
	
	// Raster scan order : Indicate the position number of the current 4x4 block in the 16x16 macroblock
	// The position number is raised from left to right and from top to bottom
    List ( type:uint(size=4), size=16 )  t_scan2_Index = [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15];

	//List that contains the neighbouring pixel of the current 16x16 Mb, from bottom to top then left to right 
	List( type:uint(size=SAMPLE_SZ), size=MB_WIDTH ) left_16x16_edge := [ 0 : for int i in Integers( 0, MB_WIDTH-1)];
  	List( type:uint(size=SAMPLE_SZ), size=MB_WIDTH+4 ) top_16x16_edge := [ 0 : for int i in Integers( 0, MB_WIDTH+3)];
  	uint(size=SAMPLE_SZ) topLeft_16x16_edge := 0;
  
    //List that contains the edge of the previous 4x4 Mb predicted 
	List( type:uint(size=SAMPLE_SZ), size=MB_WIDTH) bottom_4x4_edge := [0 : for int i in Integers( 0, MB_WIDTH-1)];
	List( type:uint(size=SAMPLE_SZ), size=4 ) right_4x4_edge := [ 0 : for int i in Integers( 0, 3)];
	uint(size=SAMPLE_SZ) bottomRight_4x4_edge := 0;
	
	// Available 4x4 edge for prediction [left, top, top left, top right]
	List( type:uint(size=1), size=4 ) avail := [ 0 : for int i in Integers( 0, 3) ];
	
	// Available 16x16 edge for prediction
	uint(size=1) left_16x16_avail := 0;
	uint(size=1) top_16x16_avail := 0;
	uint(size=1) topLeft_16x16_avail := 0;
	uint(size=1) topRight_16x16_avail := 0;
	List( type:uint(size=1), size=MB_WIDTH) topLeft_4x4_avail := [0 : for int i in Integers( 0, MB_WIDTH-1)];
	List( type:uint(size=1), size=MB_WIDTH) topRight_4x4_avail := [0 : for int i in Integers( 0, MB_WIDTH-1)];

  	//FIXME! Maximum size of a line in macroclock
  	uint(size=7) PICWIDTH =720/16;
	List( type:bool, size=PICWIDTH) is_intra := [false : for int i in Integers( 0, PICWIDTH-1)];
	uint(size=13) curr_pos:=0;
	bool intra_top_left:=false;
	
  //******************************* Enable or not Prediction management ********************************************
  
	//Mb_Type_NOK : Consume the token from full mb intra-prediction
	MbTypeIntra:action 
		Mb_Type:[a], 
		FirstMbInSlice:[b], 
		PicWidthInMb:[c], 
		CurrMbAddr:[d], 
		Coef_ACR:[e] repeat MB_WIDTH*MB_WIDTH,
		ConstrainedIFlag:[c_intra_flag],
		PredMode:[f]==>
	guard
		a = 1
	do
		curr_pos:=d mod c;
		intra_top_left:=is_intra[curr_pos];
		is_intra[curr_pos]:=true;
	end
  
	//Mb_Type_NOK : Consume the token from inter prediction 
	MbTypeInter:action 
		Mb_Type:[a], 
		PicWidthInMb:[c], 
		CurrMbAddr:[d], 
		Coef_ACR:[e] repeat MB_WIDTH*MB_WIDTH,
		ConstrainedIFlag:[c_intra_flag],
		FirstMbInSlice:[f] ==>
	guard
		a = 2
	do
		curr_pos:=d mod c;
		intra_top_left:=is_intra[curr_pos];
		is_intra[curr_pos]:=false;
	end
   
    //Mb_Type_NOK : Consume the token from I_PCM  
  	MbTypeI_PCM: action
  		Mb_Type:[a], 
		PicWidthInMb:[c], 
		CurrMbAddr:[d], 
		ConstrainedIFlag:[c_intra_flag],
		FirstMbInSlice:[f] ==>
	guard
		a = 4
	do
		curr_pos:=d mod c;
		intra_top_left:=is_intra[curr_pos];
		is_intra[curr_pos]:=true;
	end
  
	//Mb_Type_OK : Enable the prediction 
	MbTypeOK:action 
	  	Mb_Type:[a], 
	  	FirstMbInSlice:[b], 
	  	PicWidthInMb:[c], 
	  	CurrMbAddr:[d], 
		ConstrainedIFlag:[c_intra_flag],
		Coef_ACR:[coef_ac] repeat MB_WIDTH * MB_WIDTH, 
	  	PredMode:[v] repeat MB_WIDTH 
	  		==>
		  	Coef_ACR_4X4:[coef_ac] repeat MB_WIDTH * MB_WIDTH,
		  	PredMode4x4:[[v[t_scan2_Index[s]]:for int s in Integers(0,15)] ] repeat MB_WIDTH
	guard
		a = 0
	var
		uint(size=13) mbcurr,
		uint(size=13) first_mb_in_slice,
		uint(size=7) picwidth
	do
		//Store token value
		mbcurr := d;
		first_mb_in_slice := b;
		picwidth := c;

		curr_pos:=d mod c;
		
		//Initialize counter
		mb_counter := 0;
		 		 
		//Set 16x16 the available edge
		left_16x16_avail := if (mbcurr = first_mb_in_slice) or ((mbcurr mod picwidth) = 0) then 0 else 
								if (is_intra[curr_pos-1] or not(c_intra_flag)) then 1 else 0 end   
							end;
		top_16x16_avail := if (mbcurr < picwidth + first_mb_in_slice) then 0 else  
								if (is_intra[curr_pos] or not(c_intra_flag)) then 1 else 0 end   
							end;
		topRight_16x16_avail := if (mbcurr < picwidth + first_mb_in_slice) or (curr_pos+1=picwidth)  then 0 else   
									if (is_intra[curr_pos+1] or not(c_intra_flag)) then 1 else 0 end   
								end;
		topLeft_16x16_avail :=  if top_16x16_avail=0 and top_16x16_avail=0 then 0 else    
									if (intra_top_left or not(c_intra_flag)) then 1 else 0 end   
								end;
		 
		 
		//Set available edge for each 4x4 mb
		topLeft_4x4_avail := [ topLeft_16x16_avail, top_16x16_avail, top_16x16_avail, top_16x16_avail, 
		 						left_16x16_avail   , 1			    , 1				 , 1			  ,
		 						left_16x16_avail   , 1				, 1				 , 1			  , 
		 						left_16x16_avail   , 1			    , 1				 , 1			  ];
	     
		topRight_4x4_avail := [ top_16x16_avail   , top_16x16_avail, top_16x16_avail , topRight_16x16_avail,
	     						 1                 , 0              , 1              , 0			  ,
	     						 1				   , 1              , 1				 , 0              ,
	     						 1	               , 0	            , 1              , 0			  ];
		intra_top_left:=is_intra[curr_pos];
		is_intra[curr_pos]:=true;
	end

	//******************************* Receiving required token ********************************************
  
	//Receive the value of the 16x16 Mb neighbouring pixel from bottom to top, then corner, then left to right 
	EdgeNeighbour:action EDGE:[v] repeat 2*MB_WIDTH+5 ==> 
	do
		//Store left, top and top left border
		left_16x16_edge := [v[s]:for int s in Integers(0,MB_WIDTH-1)];
		topLeft_16x16_edge := v[MB_WIDTH];
		top_16x16_edge := [v[s]:for int s in Integers(MB_WIDTH+1,2*MB_WIDTH+4)];
	end
  
	//Receive pixel value from the previous 4x4 Mb Predicted and store its edge
	StoreEdge:action MB_4X4:[v] repeat 4*4==> 
	guard
		avail[0] = 0,
		avail[1] = 0,
		avail[2] = 0,
		avail[3] = 0
	do
		//Store bottom , right and bottom right edge
		bottomRight_4x4_edge := bottom_4x4_edge[3+ (mb_counter mod 4)*4];
		foreach int s in Integers(0,3)
		do
			bottom_4x4_edge[s+ (mb_counter mod 4)*4]:= v[s+3*4];
		end
		right_4x4_edge :=  [v[s*4-1]:for int s in Integers(1,4)];
		mb_counter := mb_counter +1;  
	end
  
	//******************************* Processing ********************************************
 
	//**** Select and send available edge ****
	AvailEdge:action ==> Avail:[ avail ] repeat 3
	guard
		mb_counter< MB_WIDTH
	do
		 	
		//4x4 edge available for left
		avail[0] := if (mb_counter mod 4) = 0 then left_16x16_avail else 1 end;
		//4x4 edge available for top
		avail[1] := if mb_counter < 4 then top_16x16_avail else 1 end;
		//4x4 edge available for top left
		avail[2] := topLeft_4x4_avail[mb_counter];
		//4x4 edge available for top right
		avail[3] := topRight_4x4_avail[mb_counter];    
	end
  
	//**** Send neighbouring pixel value ****
  
	//Left neighbour from 16x16 edge
	SendEdge.LeftEdge16:action ==> Y_Left4:[ [left_16x16_edge[s+mb_counter]: for int s in Integers(0,3)]]repeat 4
	guard 
	  	avail[0] = 1,
	  	mb_counter mod rshift(MB_WIDTH, 2) = 0
	do
		avail[0] := 0;
	end 
  
	//Left neighbour from 4x4 edge
	SendEdge.LeftEdge4:action ==> Y_Left4:[ [right_4x4_edge[s]: for int s in Integers(0,3)] ]repeat 4
	guard 
		avail[0] = 1,
		mb_counter mod rshift(MB_WIDTH, 2) != 0
	do
		avail[0] := 0;
	end 
  
	//Top and right neighbour from 16x16 edge
	SendEdge.TopRightEdge16:action ==> Y_Up4:[ [top_16x16_edge[mb_counter*4 + s]: for int s in Integers(0,7)]]repeat 8
	guard 
	  	avail[1] = 1,
	  	avail[3] = 1,
	  	mb_counter < MB_WIDTH / 4
	do
		avail[1] := 0;
		avail[3] := 0;
	end
  
	//Top and right neighbour from 4x4 edge
	SendEdge.TopRightEdge4:action ==> Y_Up4:[ [bottom_4x4_edge[(mb_counter mod 4)*4+s]: for int s in Integers(0,7)] ]repeat 8
	guard 
		avail[1] = 1,
		avail[3] = 1,
		mb_counter >= MB_WIDTH / 4
	do
		avail[1] := 0;
		avail[3] := 0;
	end
  
	//Only top neighbour from 16x16 edge
	SendEdge.TopEdge16:action ==> Y_Up4:[buff] repeat 8
	guard 
	  	avail[1] = 1,
	  	avail[3] = 0,
	  	mb_counter < MB_WIDTH / 4
  	
	var
		List (type: int(size=SAMPLE_SZ), size=64) buff := [ 0 : for int t in Integers( 0, 63) ]
	do
		avail[1] := 0;
		foreach int s in Integers(0, 3) do
			buff[s] := top_16x16_edge[mb_counter*4 + s];
		end
		foreach int i in Integers(0, 3) do
			buff[4 + i] := top_16x16_edge[mb_counter*4 + 3];
		end
	end
     
	//Only top neighbour from 4x4 edge
	SendEdge.TopEdge4:action ==> Y_Up4:[buff]repeat 8
	guard 
		avail[1] = 1,
		avail[3] = 0,
		mb_counter >= MB_WIDTH / 4
	var
		List (type: int(size=SAMPLE_SZ), size=16) buff := [ 0 : for int t in Integers( 0, 15) ]
	  
	do
		avail[1] := 0;
		foreach int s in Integers(0, 3) do
			buff[s] := bottom_4x4_edge[(mb_counter mod 4)*4 + s];
		end
		foreach int i in Integers(0, 3) do
			buff[4 + i] := bottom_4x4_edge[(mb_counter mod 4)*4 + 3];
		end
	end
  
  
	//Up Left neighbour
	SendEdge.TopLeftEdge4:action ==> Y_UpLeft4:[v]
	guard 
		avail[2] = 1
	var
		uint (size=SAMPLE_SZ) v
	do
 		v :=if mb_counter = 0 then
  				topLeft_16x16_edge
  			else 
  				if  mb_counter < 4 then
					top_16x16_edge[mb_counter*4 - 1]
				else 
					if mb_counter  mod 4 = 0 then
						left_16x16_edge[mb_counter-1]
  					else
  		 				bottomRight_4x4_edge
  		 			end
  		 		end
  		 	end;
		avail[2] := 0;
	end
 
	//******************************* End of processing ********************************************
 
	//End of every process, wait for the next mb_type
	EndEdge:action ==>
	guard
		mb_counter = MB_WIDTH,
		avail[0] = 0,
		avail[1] = 0,
		avail[2] = 0,
		avail[3] = 0
	end

	schedule fsm Mb_Type:
		Mb_Type     	(MbTypeIntra	)--> Mb_Type;
		Mb_Type     	(MbTypeInter	)--> Mb_Type;
		Mb_Type     	(MbTypeI_PCM	)--> Mb_Type;
		Mb_Type     	(MbTypeOK		)--> EdgeNeighbour;
		EdgeNeighbour	(EdgeNeighbour	)--> AvailEdge;
		AvailEdge		(AvailEdge		)--> Process;
		Process    		(SendEdge		)--> Process;
		Process      	(StoreEdge		)--> AvailEdge;
		
		AvailEdge		(EndEdge		)--> Mb_Type;
	end
	
	priority
		EndEdge > StoreEdge > SendEdge;
		SendEdge.LeftEdge16>SendEdge.TopRightEdge16>SendEdge.LeftEdge4>SendEdge.TopRightEdge4>SendEdge.TopEdge16>SendEdge.TopEdge4>SendEdge.TopLeftEdge4;
	end  
end