// A Mgnt_FBAddr_Chroma_MxN.cal
//
// Author: He-Yuan Lin
//
// Chroma frame buffer generator for AVC inter prediction
//Modified By Endri Bezati <endri.bezati@insa-rennes.fr>IETR/INSA

import all caltrop.lib.BitOps;


// BTYPE
// refID  MB position (x,y)
actor Mgnt_FBAddr_Chroma_MxN ( int ADDR_SZ,   int loca_SZ,    int ref_SZ,
    						   int frac_SZ,   int PartSZ_SZ, int PicS_SZ,int PicW_SZ,
    						   int MB_WIDTH ) 
   							
   							 int (size=SAMPLE_SZ) Coef_ACR, 
   							 uint(size=8)         Mb_Type, 
   							 int (size=MV_SZ)     MV, 
   							 uint(size=Idx_SZ)    RefIdx, 
  							 uint(size=loca_SZ)   Location , 
  							 uint(size=PartSZ_SZ) PartSZ, 
  							 uint(size=PicS_SZ)   PicSizeInMb, 
  							 uint(size=PicW_SZ)   PicWidthInMb,
  							 uint(size=3)         MbPartIdx,
  							 uint(size=13)        CurrMbAddr,
   							 bool                 Write_Done
  															   ==> 
  												 				  int (size=SAMPLE_SZ) Coef_ACR_P, 
   																  uint(size=21) 	   RA, 
   																  uint(size=11)        RA_Width, 
   																  uint(size=11)        RA_Height, 
   																  uint(size=ref_SZ)    refbuf, 
   			
   																  int (size=frac_SZ)   Frac :
   																  
   // Port size declaration
  int MV_SZ = 16;
  int SAMPLE_SZ = 16;
  int Idx_SZ = 3;
  
	/* ***
		Global Variables
							*** */
							
   //_CAL_tokenMonitor := true;
  int x_index ;
  int y_index ;
 // int x_frac ;
 // int y_frac ;
 // int MV_x ;
  //int MV_y ;
  int x;
  int y;
  int o_x;
  int o_y;
  int addr_x;
  int addr_y;
  int temp_mode; 
  int width;
  int height;
  int temp;
  int w_x;
  int w_y;
  int ID;
  
  int Picheight_c := 1;
  int Picwidth_c  := 1;
  int ref;
  
  int count    := 0;
  int currMB   := 0;
  int pic_size := 0;
  
  
  //Mb_Type_NOK_and_IPCM : Consume the token, nothing else to do 
  Mb_Type_NOK_and_IPCM: action Mb_Type      :[a],
  		              PicWidthInMb :[ b ], 
  		              PicSizeInMb  :[ c ],
  		              CurrMbAddr   :[ valCurrMbAddr ] ==> 
  guard
  	a = 4
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end

  //Mb_Type_NOK : Consume the token, nothing else to do 
  Mb_Type_NOK: action Mb_Type      :[a],
  		              PicWidthInMb :[ b ], 
  		              PicSizeInMb  :[ c ], 
  		              Coef_ACR     :[ d ] repeat MB_WIDTH*MB_WIDTH,
  		              CurrMbAddr   :[ valCurrMbAddr ] ==> 
  guard
  	a = 0 or a = 1
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end
  
  
  
  
  //Mb_Type_OK : Enable the prediction 
  Mb_Type_OK: action Mb_Type      :[a],
  	                 PicWidthInMb :[ b ], 
  	                 PicSizeInMb  :[ c ], 
  	                 Coef_ACR     :[d] repeat MB_WIDTH*MB_WIDTH,
  	                 CurrMbAddr   :[valCurrMbAddr]              ==> 
  	     										                   Coef_ACR_P:[d] repeat MB_WIDTH*MB_WIDTH
  guard
  	a = 2
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end
  
  
  
  get_pos: action MbPartIdx : [ idx  ], 
  			      Location  : [ a, b ], 
  			      PartSZ    : [ c, d ], 
  			      RefIdx    : [ e    ] ==>			      
  do
  	x      := a/2;
    y      := b/2;
    width  := c/2;
    height := d/2;
    ID     := e;
  
  	if ( ( width = 2 ) and ( height = 4 ) ) then
      count := count + 1 + lshift(idx,1);
    else 
      if ( ( width = 4 ) and  ( height = 8 ) )   then
         
        if ( idx = 0)  then 
        	count := 4;
       	else 
       		count := 16; 
       	end
      else
        
        count := count + rshift(width,1) * rshift(height,1);
      end
    
    end
    
  end
   

  get_mv_send_frac: action MV : [ mx, my ] ==>
  											   Frac : [ frac_x, frac_y ]
  var
  	uint frac_x, 
    uint frac_y
  do
  	x_index := rshift (mx, 3);        
    y_index := rshift (my, 3);
    o_x     := x + x_index;
    o_y     := y + y_index;
    frac_x  := ( mx - lshift (x_index, 3) );
    frac_y  := ( my - lshift (y_index, 3) ); 		
  end
  
  
  done: action ==>
  guard
    o_y = ( y + y_index + height + 1 )
  end

  MB_done: action ==>
  guard
  	count = 16
  do
  	count := 0;
  end
  
  MB_Ndone: action ==>
  end
  
  PIC_done: action Write_Done:[ w_done ] ==>
  guard
  	currMB = pic_size - 1
  end

  PIC_Ndone: action ==>
  guard 
  	currMB < ( pic_size - 1 )
  end

  // read_address
  read_address: action ==> RA        : [ r_addr ], 
  						   RA_Width  : [ 1 ], 
  						   RA_Height : [ 1 ], 
  						   refbuf    : [ ID ]
  
  var int r_addr,
      int temp3
  do
 
    addr_x := o_x;
    addr_y := o_y;
    
    if( o_x < 0) then
    	addr_x := 0 ;
    end   
   
   	if( o_x >= Picwidth_c - 1 ) then
   		addr_x := Picwidth_c-1 ;
   	end
   
   	if( o_y < 0) then
   		addr_y := 0 ;
   	end   
   
   	if( o_y >=Picheight_c-1) then
    	addr_y := Picheight_c-1 ;
   	end
    
   	r_addr := (addr_x + Picwidth_c * addr_y);
     
   	o_x := o_x + 1;

   	if o_x >=  (x + x_index+ width+ 1) then
      	o_x := x + x_index;
      	o_y := o_y + 1;
   	end
    
  end
 
  schedule fsm get_MB:
    get_MB      		( Mb_Type_NOK_and_IPCM       ) 	--> get_pic_done;
    get_MB      		( Mb_Type_NOK       ) 	--> get_pic_done;
    get_pic_done   		( PIC_done       	) 	--> get_MB;
    get_pic_done   		( PIC_Ndone       	) 	--> get_MB;
    get_MB      		( Mb_Type_OK        ) 	--> get_pos;
    get_pos        		( get_pos        	) 	--> get_mv_send_frac;
    get_mv_send_frac    ( get_mv_send_frac 	) 	--> address;
    address      		( read_address		) 	--> address;
    address      		( done         		) 	--> MB_done;
    MB_done      		( MB_done         	) 	--> get_pic_done;
    MB_done      		( MB_Ndone         	) 	--> get_pos;
   end

  priority
     PIC_done > MB_done       > MB_Ndone ;
     done     > read_address;
     PIC_done > PIC_Ndone;
  end

end