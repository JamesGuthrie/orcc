/*
This FU is part of a CAL implementation of AES (Rijndael).

To support parallel processing of multiple blocks, 
 the output of each FU is expanded to include the round number.
That is, each 16-byte block is expanded to 17-byte block,
 whose first byte is the current round index of the block. 

FU ID: AddRoundKey
Function: This FU performs AddRoundKey process in each round of the encipher and the decipher.
Note: The key is also read from an input port because it is possible that key is dynamically changed.
      Currently the key is read only once, so it is fixed for the whole encryption/decryption process.
      Support to dynamically updated keys are to be added when necessary.

Naming convention of input and output ports:
1) IP = Input Port, OP = Output Port, FD = Feedback;
2) when there is a single port, named as "IP_abc" or "OP_abc";
3) when there is multiple ports, named as "IPx_abc" or "OPx_abc", 
   where "x" is a number to inform graphiti about the location of the port;
4) when the meaning of the input/output ports are obvious, "_abc" is omitted from the port names.  

Shujun Li, Junaid Jameel Ahmad @ Uni-Konstanz 2010 
*/

import all caltrop.lib.BitOps;

actor AddRoundKey (bool bEncipher=true) uint(size=8) IP1_Text, uint(size=8) IP2_Key, uint(size=8) IP3_FD ==> 
		uint(size=8) OP1_Text, uint(size=8) OP2_FD :

	// The following variables are values for AES-256.
	// They will be updated later according to the key received from the source.
	int KeySize := 32;
	int Nk := rshift(KeySize,2); // = KeySize/4 = Nk @ FIPS 197
	List(type:uint(size=8), size=32) Key := [0 : for int i in Integers(1,32)];
	int Nr := 6 + Nk; // Keysize = [16, 24, 32] => Nr = [10, 12, 14] (Nr = number of rounds)
	int Nr16 := lshift(Nr+1,4); // = 16*(Nr+1)
	int Nr4 := rshift(Nr16,2); // = 4*(Nr+1) = Nb * (Nr+1) @ FIPS 197
	// A list for storing expanded keys for all rounds.
	List(type:uint(size=8), size=240) KeyEx := [0 : for int i in Integers(1,240)]; // Nr16 = 240

/*	int BlockSize = 16;
	List(type:String, size=16) hexdigits = [
		"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"
	];
	function byte2hex (uint(size=8) x) --> String:
		"0x"+hexdigits[rshift(x,4)]+hexdigits[bitand(x,0x0f)]
	end
	function list2hex (List(type:uint(size=8), size=BlockSize) x, int x_size) --> List(type:String, size=BlockSize):
		[byte2hex(x[i]) : for int i in Integers(0,x_size-1)]
	end
	// A procedure for printing expanded keys for debugging.
	procedure printKeyEx ()
	begin
		foreach int i in Integers(0,Nr) do
			println("Expanded Key " + i + " = " + list2hex([KeyEx[(lshift(i,4))+j] : for int j in Integers(0,15)],16));
		end
	end */

	// The S-box used in SubBytes.
	List(type:uint(size=8), size=256) SBox = 
	[
		0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
		0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
		0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
		0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
		0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
		0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
		0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
		0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
		0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
		0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
		0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
		0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
		0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
		0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
		0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
		0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
	];
	// The following list stores 2^{i-1} over GF(2^8), i.e., the non-zero Rcon bytes.
	List(type:uint(size=8), size=14) Rcon1 = 
	[
		0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36, // 10: for AES-128
		0x6c,0xc3, // 12: for AES-192
		0x9d,0x3a // 14: for AES-256
	];
	
	// KeyExpansion procedure defined in Fig. 11 of FIPS 197.
	procedure KeyExpansion ()
	var
		int i_word_mod_Nk,
		int i_byte,
		uint(size=8) byte,
		int index,
		int index2
	begin
		foreach int i in Integers(0,KeySize-1) do
			// println("i = " + i + ", Key[i] = " + Key[i]);
			KeyEx[i] := Key[i];
		end
		i_byte := KeySize; // 4*Nk
		foreach int i_word in Integers(Nk, Nr4-1) do
			i_word_mod_Nk := i_word mod Nk;
			// println("i_byte = " + i_byte);
			if i_word_mod_Nk=0 then
				// SubByte(RotWord(...))
				KeyEx[i_byte] := SBox[KeyEx[i_byte-3]];
				KeyEx[i_byte] := bitxor(KeyEx[i_byte],Rcon1[i_word/Nk-1]);
				KeyEx[i_byte+1] := SBox[KeyEx[i_byte-2]];
				KeyEx[i_byte+2] := SBox[KeyEx[i_byte-1]];
				KeyEx[i_byte+3] := SBox[KeyEx[i_byte-4]];
				// println("RotWord(W_{" + (i_word-1) + "}) = " + byte2hex(KeyEx[i_byte-3]) + " " + byte2hex(KeyEx[i_byte-2]) + " " + byte2hex(KeyEx[i_byte-1]) + " " + byte2hex(KeyEx[i_byte-4]));
				// println("Rcon = " + list2hex([Rcon1[i_word/Nk-1],0,0,0],4));
				// println("SubBytes(RotWord(W_{" + (i_word-1) + "})) XOR Rcon = " + list2hex([KeyEx[i_byte+j] : for int j in Integers(0,3)],4));
			else
				if (Nk>6 and i_word_mod_Nk=4) then
					// SubBytes(...)
					KeyEx[i_byte] := SBox[KeyEx[i_byte-4]];
					KeyEx[i_byte+1] := SBox[KeyEx[i_byte-3]];
					KeyEx[i_byte+2] := SBox[KeyEx[i_byte-2]];
					KeyEx[i_byte+3] := SBox[KeyEx[i_byte-1]];
				else
					KeyEx[i_byte] := KeyEx[i_byte-4];
					KeyEx[i_byte+1] := KeyEx[i_byte-3];
					KeyEx[i_byte+2] := KeyEx[i_byte-2];
					KeyEx[i_byte+3] := KeyEx[i_byte-1];
				end
				// println("W_{" + (i_word-1) + "} = " + list2hex([KeyEx[i_byte+j] : for int j in Integers(0,3)],4));
			end
			// println("W_{" + (i_word-4) + "} = " + list2hex([KeyEx[i_byte+j] : for int j in Integers(-16,-13)],4));
			KeyEx[i_byte] := bitxor(KeyEx[i_byte],KeyEx[i_byte-KeySize]);
			KeyEx[i_byte+1] := bitxor(KeyEx[i_byte+1],KeyEx[i_byte-KeySize+1]);
			KeyEx[i_byte+2] := bitxor(KeyEx[i_byte+2],KeyEx[i_byte-KeySize+2]);
			KeyEx[i_byte+3] := bitxor(KeyEx[i_byte+3],KeyEx[i_byte-KeySize+3]);
			i_byte := i_byte + 4;
			// println("Expanded key = " + list2hex([KeyEx[i_byte+j] : for int j in Integers(0,3)],4));
		end
		// printKeyEx();
		// Reverse the expanded key round by round for decipher.
		// This will allow us not to change the other actions in this actor.
	 	if not bEncipher then
			index := 0;
			index2 := lshift(Nr,4);
			foreach int r in Integers(0,Nr/2) do
				foreach int i in Integers(0,15) do
					byte := KeyEx[index+i];
					KeyEx[index+i] := KeyEx[index2+i];
					KeyEx[index2+i] := byte;
				end
				index := index + 16;
				index2 := index2 - 16;
			end
		end
	end
	
	bool KeyInfoUpdated := false;
	int ReadKeyCounter := 0;
	bool KeyExpanded := false;

	UpdateKeyInfo: // Read the key size and update other parameters.
	action IP2_Key:[K] ==>
	guard not KeyInfoUpdated
	do
		// println("KeySize = " + KeySize + ", Nk = " + Nk + ", Nr4 = " + Nr4 + ", Nr16 = " + Nr16);
		KeySize := K;
		Nk := rshift(KeySize,2);
		Nr := 6 + rshift(KeySize,2);
		Nr16 := lshift(Nr+1,4);
		Nr4 := rshift(Nr16,2);
		KeyInfoUpdated := true;
		// println("KeySize = " + KeySize + ", Nk = " + Nk + ", Nr4 = " + Nr4 + ", Nr16 = " + Nr16);
	end
	
	ReadKey: // Read the key according to the value of KeySize.
	action IP2_Key:[K] ==>
	guard KeyInfoUpdated and ReadKeyCounter<KeySize
	do
		Key[ReadKeyCounter] := K;
		ReadKeyCounter := ReadKeyCounter + 1;
		if ReadKeyCounter>=KeySize then // Expand the key if all bytes have been read.
			KeyExpansion();
			KeyExpanded := true;
		end
	end

	// y is used to assemble a 17-byte output due to the lack of support of list concatenation by ORCC.
	List(type:uint(size=8), size=17) y := [0 : for int i in Integers(1,17)];

	// A common procedure for performing AddRoundKey.
	// Because ORCC does not support #, we have to send a second argument for this value.
	procedure AddRoundKey (List(type:uint(size=8), size=17) x, int x_size)
	var
		int index
	begin
		if x_size=16 then
			y[0] := 0;
			foreach int i in Integers(0,15) do
				y[i+1] := bitxor(x[i], KeyEx[i]);
			end
		else
			y[0] := x[0];
			index := lshift(x[0],4); // x[0]*16;
			foreach int i in Integers(0,15) do
				y[i+1] := bitxor(x[i+1], KeyEx[index+i]);
			end
		end
	end
	
	// For the initial round, output the round number 0 and a 16-byte block to OP2_FD.
	initial_round:
	action IP1_Text:[x] repeat 16 ==> OP2_FD:[y] repeat 17
	guard KeyExpanded
	do
		AddRoundKey(x,16);
		// println("AddRoundKey0 action has been executed.");
		// println(list2hex([x[i]: for int i in Integers(0,15)], 16));
		// println(list2hex([KeyEx[i]: for int i in Integers(0,15)], 16));
		// println(list2hex([y[i]: for int i in Integers(1,16)], 16));
	end

	// For a normal round, output the round number x[0] and a 16-byte block to OP2_FD.
	normal_round:
	action IP3_FD:[x] repeat 17 ==> OP2_FD:[y] repeat 17
	guard KeyExpanded and x[0]<Nr
	do
		AddRoundKey(x,17);
		// println("AddRoundKey " + x[0] + " action has been executed.");
		// println(list2hex([KeyEx[(lshift(x[0],4))+i]: for int i in Integers(0,15)], 16));
		// println(list2hex([y[i]: for int i in Integers(1,16)], 16));
	end
	
	// For the last round, output a 16-byte ciphertext block to OP1_CT.
	last_round:
	action IP3_FD:[x] repeat 17 ==> OP1_Text:[ [y[i] : for int i in Integers(1,16)] ] repeat 16
	guard KeyExpanded and x[0]=Nr
	do
		AddRoundKey(x,17);
		// println("AddRoundKey " + x[0] + " action has been executed.");
		// println(list2hex([KeyEx[(lshift(x[0],4))+i]: for int i in Integers(0,15)], 16));
		// println(list2hex([y[i]: for int i in Integers(1,16)], 16));
	end
	
	priority
		// last_round helps reduce the waiting queue, so it has the highest priority.
		// initial_round can increase the waiting queue, so it has the lowest priority. 
		last_round > normal_round > initial_round;
	end
end
