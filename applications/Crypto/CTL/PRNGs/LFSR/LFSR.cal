/**
 * This FU is CAL implementation of Linear Forward Shift Register (LFSR).
 * It supports upto 63-order mask polynomials. The implementation follows the LFSR's Galois configuration given at [1].  
 * Test polynomial masks are taken from [2] and the output stream of this FU has been verified with [3].
 * [1] http://en.wikipedia.org/wiki/LFSR. 
 * [2] BRUCE SCHNEIER "Applied Cryptography: Protocols, Algorithms, and Source Code in C," 2nd Edition, ISBN: 0471128457, 
 *     John Wiley & Sons, Inc., 1996. 
 * [3] LFSR's matlab implementation available at
       http://www.mathworks.com/matlabcentral/fileexchange/22716-kasami-sequences-m-sequences-linear-feedback-shift-registers 
 *
 * FU ID: LFSR (Galois configuration)
 * One input ports:
 *   1) uint(size=64) IP: the input to receive initial parametrs in the order: mask polynomial (mask), input seed, 
 *          and opTokens (number of tokens required to be generated by LFSR). Each of these paramesters can be upto 63-bits.           
 *          Note: Initializing opTokens with a value <= 0 will make this FU to generate numbers indefinately.
 *      Notes about Mask:
 *      -- Mask variable represents the mask polynomial with tap bits marked as '1'.
 *      -- Mask value is assumed to be in Big-Endian. That is, the MSb (left most) bit of mask will represent 
 *         the highest order term of the mask polynomial.
 *      -- The mask value assume not to include the tap bit for the 0th coefficient (x^0) of the mask polynomial. 
 *         This is because in LFSR's Galois configuration, the right most (least significant) cell of the shift register
 *         will be updated by coefficient x^1 and this x^0 coefficient will not be used. However, if mistakenly included, 
 *         this FU will assume mask polynomial of order x^n to be a polynomial of order x^(n+1). 
 *      -- Mask is applied to the shifted value using the XOR operator.
 *
 * One output port:
 *   1) uint(size=1) Bit: the output bit
 * 
 * Developer: Junaid Jameel Ahmad, Shujun Li @ Uni-Konstanz 2010 
 */
 
 package PRNGs.LFSR;

actor LFSR () uint(size=64) IP ==> uint(size=1) Bit:
	// Two flags controlling firings of different actions.
	bool runInit := true;
	bool runGenerator := false;
	
	int MAX_MASK_ORDER = 64; // Maximum order (degree) of the mask polynomial.
	uint(size=MAX_MASK_ORDER) shiftRegister; // Shift Register.
	uint(size=MAX_MASK_ORDER) mask; // Polynomial mask containing the tap bits.
	int maskOrder; // Order (degree) of current mask polynomial.
	uint opTokens; // Number of tokens required to be generated.
	// uint startState := 0; // State variable to calculate the period.

	// Initialize parameters.
	init:
	action IP:[params] repeat 3 ==>
	guard runInit
	var
		uint(size=MAX_MASK_ORDER) tempMask
	do
		mask := params[0]; // Initialize mask		
		// Extract maskOrder from mask.
		tempMask := mask;
		maskOrder := 0;
		while tempMask > 0 do
			tempMask := tempMask >> 1;
			maskOrder := maskOrder + 1;
		end

		// Initialize shiftRegister with input seed.
		if params[1] = 0 then // Make sure input shift register is not initialized with 0.
			shiftRegister := 1;
		else
			// Make sure input seed is not greater than 2^maskOrder.
			shiftRegister := params[1] mod (1<<maskOrder);
		end
		// Save initial state of shift register to calculate period.
		// startState := shiftRegister;
		
		// Number of of output tokens required.
		opTokens := params[2];
		
		// Enable generator.
		runInit := false;
		runGenerator := true;
	end
	
	// LFSR bits generator.
	int counter := 0; // Counter to track number of generated bits in this session.
	uint(size=1) b; // Temporary bit.
	generator:
	action ==> Bit:[b]
	guard runGenerator
	do
		// Check the period of the used polynomial (mask).
		/*if counter > 0 and shiftRegister = startState then
			print("Period after "+counter+": bits\n");
		end*/

		// Save right most bit (LSB) of shift register for output.
		b := shiftRegister & 1;
		// Shift right to drop LSB.
		shiftRegister := shiftRegister >> 1;
		// Update shift register
		if b = 1 then
			shiftRegister := shiftRegister ^ mask;
		end
		counter := counter + 1;
		
		// If the desired number of output tokens has been generated then reset.
		if counter = opTokens then
			runInit := true;
			runGenerator := false;
			counter := 0; // Reset counter.
		end
	end
end
