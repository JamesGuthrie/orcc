/**
 * This FU gives implementation of OFB (Output Feedback)) mode of block ciphers in RVC-CAL.
 * 
 * FU ID: OFB
 * One actor parameter:
 *   1) BLOCK_SIZE: Block size in bytes of the underlying block cipher (default: 16 = 128 bits)
 * Three inputs ports:
 *   1) IP1_IV: Initialization Vector
 *   2) IP2_IT: Input text block (plaintext or cipher text)
 *   3) IP3_OB: Output block of the block encipher sent back to the OFB FU
 * Two output ports:
 *   1) OP1_OT: Output text (ciphertext or plaintext) block.
 *   2) OP2_IB: Input block of the block encipher
 *
 * How this FU should be connected with a block encipher to form a stream cipher:
 * OFB.OP2_IB ==> BlockEncipher.Plaintext
 * BlockEncipher.Ciphertext ==> OFB.IP3_OB 
 * Plaintext/Ciphertext (Text to be encrypted/decrypted) ==> OFB.IP2_IT 
 * OFB.OP1_OT ==> Ciphertext/Plaintext (Text encrypted/decrypted)
 * 
 * Developers: Shujun Li, Junaid Jameel Ahmad @ Uni-Konstanz 2010 
 */

actor OFB(uint BLOCK_SIZE=16) uint(size=8) IP1_IV, uint(size=8) IP2_IT, uint(size=8) IP3_OB
	==>  uint(size=8) OP1_OT, uint(size=8) OP2_IB:
	
	uint BLOCK_SIZE_MAX = 32; // Maximum block size in bytes

	// An index to indicate the current step running.
	// The scheduling of the steps are as follows: 0 --> 1; 1 <--> 2.
	int step_index := 0; // 0 = readIV, 1 = readOB, 2 = handleIT

	// Read the initial vector and forward it to the block encipher.
	int ivCounter := 0;
	readIV: // Step 0 (Initialization)
	action IP1_IV:[byte] ==> OP2_IB:[byte]
	guard step_index=0
	do
		ivCounter := ivCounter + 1;
		if (ivCounter = BLOCK_SIZE) then
			step_index := 1;
		end
	end

	List(type:uint(size=8), size=BLOCK_SIZE_MAX) outputBlock := [0: for int i in 1 .. BLOCK_SIZE_MAX];

	// Read the output block from the block encipher and save it in the state variable outputBlock.
	// This action also forwards outputBlock back to the block encipher as the next block for encryption. 
	int obCounter := 0;
	readOB: // Step 1
	action IP3_OB:[byte] ==> OP2_IB:[byte]
	guard step_index=1
	do
		outputBlock[obCounter] := byte;
		obCounter := obCounter + 1;
		if (obCounter = BLOCK_SIZE) then
			obCounter := 0;
			step_index := 2;
		end
	end

	// Read the next plaintext/ciphertext block and encrypt/decrypt it by XORing it with outputBlock.
	int itCounter := 0;
	handleIT: // Step 2
	action IP2_IT:[byte] ==> OP1_OT:[byte]
	guard step_index=2
	do
		byte := bitxor(byte, outputBlock[itCounter]);
		itCounter := itCounter + 1;
		if (itCounter = BLOCK_SIZE) then
			itCounter := 0;
			step_index := 1;
		end
	end

end
