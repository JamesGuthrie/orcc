package gzip;

import std.util.BitOps.selectbit;
import std.util.BitOps.selectbits;
import gzip.Constants.*;

actor Inflate() int(size=8) C ==> int(size=8) D:

	// the bits of the byte read
	uint(size=16) bits := 0;
	
	// number of bits remaining in value
	uint(size=4) num_bits := 0;
	
	// true when this block is the last block
	bool bfinal := false;
	
	// compression type
	uint(size=2) btype;

	List(type:int, size=16) bl_count;
	List(type:int, size=16) next_code;
	List(type:int, size=288) tree_len;
	List(type:int, size=288) tree_code;
	List(type:int, size=512) invtree_code := [ 0 : for int i in 0 .. 511 ];
	
	procedure set_len(int from, int to, int bitlen)
	var
		int n := from
	begin
		while n <= to do
    		tree_len[n] := bitlen;
    		bl_count[bitlen] := bl_count[bitlen] + 1;
			n := n + 1;
		end
	end
	
	procedure step1()
	begin
		bl_count := [ 0 : for int bits in 0 .. MAX_BITS ];
		
		set_len(0, 143, 8);
		set_len(144, 255, 9);
		set_len(256, 279, 7);
		set_len(280, 287, 8);
	end
	
	procedure step2()
	var
		int code := 0
	begin
		bl_count[0] := 0;
		foreach int bits in 1 .. MAX_BITS do
			code := (code + bl_count[bits - 1]) << 1;
			next_code[bits] := code;
		end
	end
	
	procedure print_bin(int number, int numbits)
	var
		int bit
	begin
		foreach int i in 1 .. numbits do
			bit := selectbit(number, numbits - i);
			if bit != 0 then
				print(1);
			else
				print(0);
			end
		end
		println();
	end
	
	procedure step3(int max_code)
	var
		int len := 0
	begin
		foreach int n in 0 .. max_code do
			len := tree_len[n];
			if len != 0 then
				tree_code[n] := next_code[len];
				invtree_code[tree_code[n]] := n;
				next_code[len] := next_code[len] + 1;
			end
		end
	end
	
	initialize ==>
	do
		step1();
		step2();
		step3(287);
	end
	
	///////////////////////////////////////////////////////////////////////////
	procedure bits_read(int(size=5) n)
	begin
		num_bits := num_bits - n;
		bits := bits >> n;
		println("bits_read: " + n + " bits requested, " + num_bits + " remaining");
	end
	
	function need_bits(int n) --> bool :
		num_bits >= n
	end
	
	///////////////////////////////////////////////////////////////////////////
	// test final block
	is_final: action ==> guard bfinal end
	other: action ==> end
	
	///////////////////////////////////////////////////////////////////////////
	load: action C:[ byte ] ==>
	do
		println("loaded 8 bits");
		bits := (byte << num_bits) | bits;
		num_bits := num_bits + 8;
	end

	///////////////////////////////////////////////////////////////////////////
	// read block header

	read.header: action ==>
	guard
		need_bits(3)
	do
		bfinal := selectbit(bits, 0) = 1;
		btype := selectbits(bits, 1, 2) >> 1;
		println("block_header: bfinal=" + bfinal + ", btype=" + btype);
		bits_read(3);
	end

	///////////////////////////////////////////////////////////////////////////
	// uncompressed data
	uncompressed: action ==>
	guard
		btype = STORED_BLOCK
	end

	uint(size=16) len;
	uint(size=16) count;
	uint(size=16) nlen;

	read_uc_len: action C:[ len1, len2, nlen1, nlen2 ] ==>
	do
		len := (len2 << 8) | len1;
		nlen := (nlen2 << 8) | nlen1;
		count := 0;
	end

	loop.uc: action C:[ byte ] ==> D:[ byte ]
	do
		count := count + 1;
	end
	
	done.uc: action ==>
	guard
		count = len
	end
	
	///////////////////////////////////////////////////////////////////////////
	// fixed Huffman coding
	bool done_decoding;
	int(size=8) value_len;
	int(size=9) value;
	
	fixed_huffman: action ==>
	guard
		btype = STATIC_TREES
	do
		done_decoding := false;
		value := 0;
		value_len := 0;
		println();
	end
	
	done.fixed: action ==>
	guard done_decoding
	end
	
	loop.fixed: action ==>
	guard
		need_bits(1)
	var
		uint(size=1) bit = selectbit(bits, 0)
	do
		value := (value << 1) | bit;
		value_len := value_len + 1;
		
		print("code_len = " + value_len + ", bit read = " + bit + ", code = ");
		print_bin(value, 9);
		
		println("invtree_code[" + value + "] = " + invtree_code[value]);
		println("tree_len[" + invtree_code[value] + "] = " + tree_len[invtree_code[value]]);
		
		done_decoding := (value_len = tree_len[invtree_code[value]]);
		bits_read(1);
	end
	
	output_value: action ==> D:[0]
	end

	///////////////////////////////////////////////////////////////////////////
	// FSM

	schedule fsm start:
		start (is_final) --> done;
		start (other) --> new_block;

		new_block (read.header) --> body;
		new_block (load) --> new_block;
		
		body (uncompressed) --> uncompressed;
		body (fixed_huffman) --> fixed;

		uncompressed (read_uc_len) --> uncompressed_loop;
		uncompressed_loop (loop.uc) --> uncompressed_loop;
		uncompressed_loop (done.uc) --> start;

		fixed (done.fixed) --> fixed_decoded;
		fixed (loop.fixed) --> fixed;
		fixed (load) --> fixed;

		fixed_decoded (fixed_huffman) --> fixed;
	end
	
	priority
		is_final > other;
		done > loop > read > load;
	end

end