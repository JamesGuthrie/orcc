
/**
 * This software module was originally developed by 
 * Paul Schumacher (Xilinx Inc.), 
 * in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
 * for reference purposes and its performance may not have been optimized. 
 * This software module is an implementation of one or more tools as 
 * specified by the ISO/IEC 23002-4.
 * 
 * ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
 * license to copy, distribute, and make derivative works of this software 
 * module or modifications thereof for use in implementations of the 
 * ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 
 * 
 * Those intending to use this software module in products are advised that 
 * its use may infringe existing patents. ISO/IEC have no liability for use 
 * of this software module or modifications thereof.
 * 
 * Copyright is not released for products that do not conform to audiovisual 
 * and image-coding related ITU Recommendations and/or ISO/IEC International 
 * Standards. 
 * 
 * Assurance that the originally developed software module can be used 
 * (1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
 * (2) to develop the ISO/IEC 23002-4: 
 *
 *
 * Xilinx Inc. grants ISO/IEC all rights necessary to 
 * include the originally developed software module or modifications thereof 
 * in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
 * worldwide, non-exclusive, copyright license to copy, distribute, and make 
 * derivative works for use in implementations of the ISO/IEC 23002-4 in 
 * products that satisfy conformance criteria (if any), and to the extent 
 * that such originally developed software module or portions of it are 
 * included in the ISO/IEC 23002-4.  To the extent that NCKU
 * owns patent rights that would be required to make, use, or 
 * sell the originally developed software module or portions thereof 
 * included in the ISO/IEC 23002-4 in a conforming product, NCKU will assure the ISO/IEC that it is willing to 
 * negotiate licenses under reasonable and non-discriminatory terms and 
 * conditions with applicants throughout the world.
 *
 * ISO/IEC gives You a free license to this software module or modifications 
 * thereof for the sole  purpose of developing the ISO/IEC 23002-4.
 * 
 * NCKU retains full right to modify and use the 
 * code for its own purpose, assign or donate the code to a third party and 
 * to inhibit third parties from using the code for products that do not 
 * conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
 * Standards. 
 * 
 * This copyright notice must be included in all copies or derivative works. 
 * Copyright (c) ISO/IEC 2006-2010.
 */
/*
* Author: Paul Schumacher, Xilinx Research Labs 
*         (Email: paul.schumacher@xilinx.com)
*
*
*
* Description:
*   This design performs the in-loop deblocking filter for an AVC video 
*   coder.  Tokens on the inputs and outputs of this block contain maps 
*   (similar to structures) for easier interfacing.  One token on 'mbIn' is 
*   assumed to contain the contents of a single macroblock (MB) including the 
*   input YUV values as well as the MB parameters.  This design assumes raster 
*   order of MBs (see below).  One token on 'imgParams' contains a map of 
*   parameters for one frame or field.
*
*   The 'mbDataOut' and 'StrengthOut' outputs each produce one token per MB.
*   One token on 'mbDataOut' is a map containing the (x,y) position (in MB
*   coordinates) as well as arrays of YUV 4:2:0 output data.  'StrengthOut'
*   should be used for debug only and produces a map of strength values and
*   important parameters for debug purposes.
*
*   Note that the following modes are not supported by this revision of the 
*   design:
*     * MBAFF (Macroblock Adaptive Field/Frame mode)
*     * only 4:2:0 format is supported
*     * > 8-bit video
*/
/* Revised:
*  Author: Jia-Wei Liang, MSOC Lab, NCKU
*  (E-mail: n2697181@mail.ncku.edu.tw)
*  This loop filter has a bug and is fixed.
*  The bug is that the loop filter does not perform deblocking on the right and
*  bottom boundaries of a macroblock before outputting it out.
*  The codes have been modified to output macroblocks at correct time.

*  Algo_DBF.cal
*  Description: The algorithm part of deblocking filter without mbaff
* Last modification RVC-CAL compliancy:
* Micka‘l Raulet (INSA/Rennes)
*/
package MPEG.MPEG4.part10;

import std.util.BitOps.* ;

actor Algo_DBF_Luma (int LUMA_CHROMA) uint(size=8) DB_I,
	uint(size=6) BS
	==> uint(size=8) DB_O :
	/*
	 * LUMA_CHROMA luma:=0, chroma:=1
	 */
/*
	 * Constants 
	 */
	int SAMPLE_SZ = 8;

	int MAXVAL_LUMA = 255;

	/*
	* State Variables
	*/
	List(type: List(type: uint(size=SAMPLE_SZ), size=20), size=20) curr_mb := [ [
	0 : for int i in 0 .. 20 - 1 ] : for int j in 0 .. 20 - 1 ];

	List(type: uint(size=6), size=3) Alist := [ 0 : for int i in 0 .. 3 - 1 ];

	List(type: uint(size=6), size=3) Blist := [ 0 : for int i in 0 .. 3 - 1 ];

	uint(size=1) StrengthNotZero := 0;

	uint(size=1) useLeft := 0;

	uint(size=1) useUp := 0;

	uint(size=3) edge_curr := 0;

	int xQ := 0;

	int yQ := 0;

	int xP := 0;

	int yP := 0;

	List(type: uint(size=3), size=32) Strength := [ 0 : for int i in 0 .. 32 - 1
	];
	/*
	 * ROM Tables
	 * 
	 * NOTE: In principle, the alpha and beta tables are calculated with the formulas below
	 *       Alpha( qp ) := 0.8 * (2^(qp/6)  -  1)
	 *       Beta ( qp ) := 0.5 * qp  -  7
	 * The tables actually used have been "hand optimized" though (by Anthony Joch). So, the
	 * table values might be a little different to formula-generated values. Also, the first
	 * few values of both tables is set to zero to force the filter off at low QPs
	 * ALPHA table (52 x 8-bit ROM)
	 */
	List(type: uint(size=9), size=52) ALPHA_TABLE = [ 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 7, 8, 9, 10, 12, 13, 15, 17, 20, 22, 25, 28,
	32, 36, 40, 45, 50, 56, 63, 71, 80, 90, 101, 113, 127, 144, 162, 182, 203,
	226, 255, 255 ];

	List(type: uint(size=9), size=52) ALPHA_TABLE_DIV4_PLUS2 = [ 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 7, 7, 8, 9,
	10, 11, 12, 13, 14, 16, 17, 19, 22, 24, 27, 30, 33, 38, 42, 47, 52, 58, 65, 65
	];
	/*
	 * BETA table (52 x 5-bit ROM)
	 */
	List(type: uint(size=6), size=52) BETA_TABLE = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9, 10,
	10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18 ];
	/*
	 * CLIP table (260 x 5-bit ROM)
	 */
	List(type: uint(size=6), size=52 * 5) CLIP_TABLE = [ 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0,
	1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1,
	2, 2, 0, 1, 1, 2, 2, 0, 1, 1, 2, 2, 0, 1, 1, 2, 2, 0, 1, 2, 3, 3, 0, 1, 2, 3,
	3, 0, 2, 2, 3, 3, 0, 2, 2, 4, 4, 0, 2, 3, 4, 4, 0, 2, 3, 4, 4, 0, 3, 3, 5, 5,
	0, 3, 4, 6, 6, 0, 3, 4, 6, 6, 0, 4, 5, 7, 7, 0, 4, 5, 8, 8, 0, 4, 6, 9, 9, 0,
	5, 7, 10, 10, 0, 6, 8, 11, 11, 0, 6, 8, 13, 13, 0, 7, 10, 14, 14, 0, 8, 11,
	16, 16, 0, 9, 12, 18, 18, 0, 10, 13, 20, 20, 0, 11, 15, 23, 23, 0, 13, 17, 25,
	25 ];
	/*
	 * Arithmetic functions
	 */
	function abs(int val) --> int :
		if (val < 0) then
			-val
		else
			val
		end
	end

	function Clip(int Min, int Max, int Val) --> int :
		if (Val < Min) then
			Min
		else
			if (Val > Max) then
				Max
			else
				Val
			end
		end
	end //
	// Memory interface functions
	//
	function ClipTab(int index, int strength) --> int :
		CLIP_TABLE[index * 5 + strength]
	end

	/*
	 * Get the X position in the current MB (0 to 15)
	 */
	function getPixelPosX(int pel, int dir) --> int :
		if (dir = 1) then
			pel
		else
			4 * edge_curr
		end
	end
	/*
	* Get the Y position in the current MB (0 to 15)
	*/
	function getPixelPosY(int pel, int dir) --> int :
		if (dir = 1) then
			if (edge_curr < 4) then
				4 * edge_curr
			else
				1
			end
		else
			pel
		end
	end

	function getLeftPixel(int i, int dir) --> int :
		curr_mb[yP + 4 - i * dir][xP + 4 - i * (1 - dir)]
	end

	function getRightPixel(int i, int dir) --> int :
		curr_mb[yQ + 4 + i * dir][xQ + 4 + i * (1 - dir)]
	end

	procedure setLeftPixel(int i, int val, int dir)
	var
		int xmod = xP - i * (1 - dir),
		int ymod = yP - i * dir
	begin
		curr_mb[ymod + 4][xmod + 4] := val;
	end

	procedure setRightPixel(int i, int val, int dir)
	var
		int xmod = xQ + i * (1 - dir),
		int ymod = yQ + i * dir
	begin
		curr_mb[ymod + 4][xmod + 4] := val;
	end
	/*
	 * Set the neighbour (used in GetStrengths)
	 * NOTE: only options are: within current MB, use left MB,
	 * or use up/top MB
	 */
	procedure setNeighbour(int xN, int yN)
	begin
		xP := xN;
		yP := yN;
		useLeft := 0;
		useUp := 0;
		if (xN < 0) then
			useLeft := 1;
		else
			if (yN < 0) then
				useUp := 1;
			end
		end
	end
	/*
	*  Deblocking Filter: Actions 
	*/
	StartMB: action DB_I:[ v ] repeat (16 + 4) * (16 + 4), BS:[ u ] repeat 38 ==>
	do
		foreach int y in 0 .. 20 - 1 do
			foreach int x in 0 .. 20 - 1 do
				curr_mb[y][x] := v[20 * y + x];
			end
		end
		StrengthNotZero := 0;
		foreach int i in 0 .. 31 do
			Strength[i] := u[i];
			if (Strength[i] != 0) then
				StrengthNotZero := 1;
			end
		end
		Alist := [ u[i] : for int i in 32 .. 34 ];
		Blist := [ u[i] : for int i in 35 .. 37 ];
	end

	ZeroStrengths: action ==>
	guard
		(StrengthNotZero = 0)
	end

	EdgeLoops.Luma: action ==>
	var
		int indexA,
		int indexB,
		int StrengthIdx,
		int pel,
		int PelNum := LUMA_CHROMA,
		int ap := 0,
		int aq := 0,
		int small_gap := 0,
		int L3,
		int L2,
		int L1,
		int L0,
		int R3,
		int R2,
		int R1,
		int R0,
		int RL0,
		int C0,
		int dif,
		int Delta,
		int AbsDelta,
		int Alpha := 0,
		int Beta := 0
	do
		foreach int dir in 0 .. 1 do
			foreach int edge in 0 .. 3 do
				edge_curr := edge;
				if (edge_curr < 4 and edge_curr >= 0) then
					pel := 0;
					while (pel < PelNum) do
						xQ := getPixelPosX(pel, dir);
						yQ := getPixelPosY(pel, dir);
						setNeighbour(xQ - 1 + dir, yQ - dir);
						StrengthIdx := bitand(pel, 12);
						StrengthIdx := StrengthIdx + lshift(dir, 4) + edge;
						if useLeft = 1 then
							indexA := Alist[1];
							indexB := Blist[1];
						else
							if useUp = 1 then
								indexA := Alist[2];
								indexB := Blist[2];
							else
								indexA := Alist[0];
								indexB := Blist[0];
							end
						end
						Alpha := ALPHA_TABLE[indexA];
						Beta := BETA_TABLE[indexB];
						if (Strength[StrengthIdx] > 0) then
							L3 := getLeftPixel(3, dir);
							L2 := getLeftPixel(2, dir);
							L1 := getLeftPixel(1, dir);
							L0 := getLeftPixel(0, dir);
							R0 := getRightPixel(0, dir);
							R1 := getRightPixel(1, dir);
							R2 := getRightPixel(2, dir);
							R3 := getRightPixel(3, dir);
							RL0 := L0 + R0;
							Delta := R0 - L0;
							AbsDelta := abs(Delta);
							if (AbsDelta < Alpha) then
								C0 := ClipTab(indexA, Strength[StrengthIdx]);
								if (bitand((abs(R0 - R1) - Beta), (abs(L0 - L1) - Beta)) < 0) then
									if ((abs(R0 - R2) - Beta) < 0) then
										aq := 1;
									else
										aq := 0;
									end
									if ((abs(L0 - L2) - Beta) < 0) then
										ap := 1;
									else
										ap := 0;
									end
									if (Strength[StrengthIdx] = 4) then // INTRA strong filtering
										if (AbsDelta < ALPHA_TABLE_DIV4_PLUS2[indexA]) then
											small_gap := 1;
										else
											small_gap := 0;
										end
										ap := bitand(ap, small_gap);
										aq := bitand(aq, small_gap);
										if (aq = 1) then
											setRightPixel(0, rshift(L1 + lshift(R1 + RL0, 1) + R2 + 4, 3), dir);
											setRightPixel(1, rshift(R2 + R0 + R1 + L0 + 2, 2), dir);
											setRightPixel(2, rshift(lshift(R3 + R2, 1) + R2 + R1 + RL0 + 4, 3),
											dir);
										else
											setRightPixel(0, rshift(lshift(R1, 1) + R0 + L1 + 2, 2), dir);
											setRightPixel(1, R1, dir);
											setRightPixel(2, R2, dir);
										end
										if (ap = 1) then
											setLeftPixel(0, rshift(R1 + lshift((L1 + RL0), 1) + L2 + 4, 3),
											dir);
											setLeftPixel(1, rshift(L2 + L1 + L0 + R0 + 2, 2), dir);
											setLeftPixel(2, rshift(lshift(L3 + L2, 1) + L2 + L1 + RL0 + 4, 3),
											dir);
										else
											setLeftPixel(0, rshift(lshift(L1, 1) + L0 + R1 + 2, 2), dir);
											setLeftPixel(1, L1, dir);
											setLeftPixel(2, L2, dir);
										end
									else // normal filtering
										dif := Clip(-C0 - ap - aq, (C0 + ap + aq), rshift(lshift(Delta, 2) +
										(L1 - R1) + 4, 3));
										setLeftPixel(0, Clip(0, MAXVAL_LUMA, L0 + dif), dir);
										setRightPixel(0, Clip(0, MAXVAL_LUMA, R0 - dif), dir);
										if (ap = 1) then
											setLeftPixel(1, L1 + Clip(-C0, C0, rshift(L2 + rshift(RL0 + 1, 1) -
											lshift(L1, 1), 1)), dir);
										end
										if (aq = 1) then
											setRightPixel(1, R1 + Clip(-C0, C0, rshift(R2 + rshift(RL0 + 1, 1) -
											lshift(R1, 1), 1)), dir);
										end
									end //if (Strength[StrengthIdx] = 4)
								end //if ( bitand((abs(R0 - R1) - Beta), (abs(L0 - L1) - Beta)) < 0 ) then 
							end //if ( AbsDelta < Alpha ) then
						end //if ( AbsDelta < Alpha )		          
						pel := pel + 1;
					end // while (pel<PelNum)
				end // if-then
			end // while (edge<4)
		end // while (dir<2)

	end

	OutMB: action ==> DB_O:[ buff ] repeat (16 + 4) * (16 + 4)
	var
		List(type: uint(size=SAMPLE_SZ), size=(16 + 4) * (16 + 4)) buff
	do
		foreach int y in 0 .. 20 - 1 do
			foreach int x in 0 .. 20 - 1 do
				buff[y * 20 + x] := curr_mb[y][x];
			end
		end
	end
	/*
	* Schedule/Priority
	*/
	schedule fsm S0 :
		S0 ( StartMB ) --> S1;
		S1 ( ZeroStrengths ) --> S2;
		S1 ( EdgeLoops ) --> S2;
		S2 ( OutMB ) --> S0;
	end

	priority
		ZeroStrengths > EdgeLoops;
	end

end