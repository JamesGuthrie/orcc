/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
//Modified by Endri Bezati IETR/INSA Rennes

//Added FSM to the actor

//Delete me!!!
package MPEG.MPEG4.part10.Common;

import MPEG.Common.Imp_PictureInfo.*;

actor Algo_IntraPred_Split()
	uint(size=1)  MbIntraFlag,
	uint(size=4)  IntraPredMode,
	uint(size=7)  MbLocation,
	bool          NeighbourAvail,
	bool          ConstrainedIFlag
		==>
	uint(size=4)  PredMode,
	uint(size=8)  MbType,
	//uint(size=2)  BlocksSize_Luma,
	uint(size=8)  MbTypeC
		:


	uint(size=4) INTRA_4x4   = 1;
//	uint(size=4) INTRA_8x8   = 2;	
	uint(size=4) INTRA_16x16 = 3;	
	uint(size=4) I_PCM       = 4;

//Should be the same values !!!
	uint(size=4) MB_TYPE_INTRA_4x4   = 0;
	uint(size=4) MB_TYPE_INTRA_16x16 = 1;	
	uint(size=4) MB_TYPE_INTER       = 2;
	uint(size=4) MB_TYPE_I_PCM       = 4;
//	uint(size=4) MB_TYPE_INTRA_8x8   = ??;
	uint(size=2) BLOCK_4x4   = 0;
//	uint(size=2) BLOCK_8x8   = 1;
	uint(size=2) BLOCK_16x16 = 2;

	//number of MB per lines
	uint(size=4) mb_intra_type    := 0;
	// Intra4x4 1, Intra8x8 2, Intra16x16 3
	uint(size=3)  mb_intra_flag;
	uint(size=5)  count            := 0;
	uint          MbLocationxInPic := 0;
	bool Is_MbA_Avail;
	bool Is_MbB_Avail;


	List(type: List(type: int(size=5), size=16), size=MAX_PICWIDTH_BLK) intra4x4predmode:=
		[ [ 2 : for int j in 0 .. 15 ] : for int i in 0 .. MAX_PICWIDTH_BLK - 1 ];
	List(type: uint(size=4) , size=16)   InverseScan4x4Tab := [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];
	//FIXME! Maximum size of a line in macroclock
	List(type: bool, size=MAX_PICWIDTH_BLK) is_constrained_i_flag := [ false : for int i in 0 .. MAX_PICWIDTH_BLK - 1 ];


	Get_MbType: action
			MbIntraFlag :[ Mb_Intra_Flag ]
				==>
		do
			mb_intra_flag := Mb_Intra_Flag;
		end


	get_inter: action
			MbLocation       :[MbLocxInPic , MbLocyInPic],
			NeighbourAvail   :[NeighbourA_Avail , NeighbourB_Avail , NeighbourC_Avail , NeighbourD_Avail],
			ConstrainedIFlag :[ Constrained_I_Flag ]
				==>
			MbType      :[MB_TYPE_INTER],
			//BlocksSize_Luma  :[BLOCK_4x4],
			MbTypeC     :[2]
		guard
			mb_intra_flag = 0
		do
			MbLocationxInPic   := MbLocxInPic;
			Is_MbA_Avail := NeighbourA_Avail;
			Is_MbB_Avail := NeighbourB_Avail;
			intra4x4predmode[MbLocationxInPic]      := [ 2 : for int j in 0 .. 15 ];
			is_constrained_i_flag[MbLocationxInPic] := not (Constrained_I_Flag);
		end


	get_intratype: action
			IntraPredMode  :[ Mb_Type ],
			NeighbourAvail :[NeighbourA_Avail , NeighbourB_Avail , NeighbourC_Avail , NeighbourD_Avail],
			MbLocation     :[MbLocxInPic , MbLocyInPic]
				==>
		guard
			mb_intra_flag = 1
		do
			mb_intra_type     := Mb_Type;
			MbLocationxInPic  := MbLocxInPic;
			Is_MbA_Avail := NeighbourA_Avail;
			Is_MbB_Avail := NeighbourB_Avail;
		end


	get_intra4x4: action
			IntraPredMode :[ Intra_Pred_Mode ]
				==>
			PredMode :[ pred_mode ]
		guard
			mb_intra_type = INTRA_4x4 and count < 16
		var
			int(size=5) top , int(size=5) left , int(size=5) predicted ,
			int(size=5) pred_mode
		do
			if not Is_MbB_Avail and
			InverseScan4x4Tab[count] < 4 then
			// MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
				top := -1;
			else
				if InverseScan4x4Tab[count] < 4 then
					if (is_constrained_i_flag[MbLocationxInPic]) then
						top := intra4x4predmode[MbLocationxInPic][12 + InverseScan4x4Tab[count]];
					else
						top := -1;
					end
				else
					top := intra4x4predmode[MbLocationxInPic][InverseScan4x4Tab[count] - 4];
				end
			end
			if not Is_MbA_Avail and
			InverseScan4x4Tab[count] mod 4 = 0 then
			// MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
				left := -1;
			else
				if InverseScan4x4Tab[count] mod 4 = 0 then
					if (is_constrained_i_flag[MbLocationxInPic - 1]) then
						left := intra4x4predmode[MbLocationxInPic - 1][3 + InverseScan4x4Tab[count]];
					else
						left := -1;
					end
				else
					left := intra4x4predmode[MbLocationxInPic][InverseScan4x4Tab[count] - 1];
				end
			end
			if left < top then
				predicted := left;
			else
				predicted := top;
			end
			if predicted < 0 then
				predicted := 2;
			end
			//INTRA_4x4_DC
			if Intra_Pred_Mode < predicted then
				pred_mode := Intra_Pred_Mode;
			else
				pred_mode := Intra_Pred_Mode + 1;
			end
			if Intra_Pred_Mode = 15 then
				pred_mode := predicted;
			end
			intra4x4predmode[MbLocationxInPic][InverseScan4x4Tab[count]] := pred_mode;
			count := count + 1;
		end


	get_intra4x4_done: action 
			ConstrainedIFlag :[ Constrained_I_Flag ]
				==>
			MbType      :[ MB_TYPE_INTRA_4x4 ],
			//BlocksSize_Luma  :[BLOCK_4x4],
			MbTypeC     :[ 1 ]
		guard
			mb_intra_type = INTRA_4x4 and count = 16
		do
			count := 0;
			is_constrained_i_flag[MbLocationxInPic] := true;
		end


	get_intra16x16: action
			ConstrainedIFlag :[ Constrained_I_Flag ],
			IntraPredMode    :[ Mode_16x16 ]
				==>
			PredMode    :[ Mode_16x16 ],
			MbType      :[ MB_TYPE_INTRA_16x16 ],
			//BlocksSize_Luma  :[BLOCK_16x16],
			MbTypeC     :[ 1 ]
		guard
			mb_intra_type = INTRA_16x16
		do
			intra4x4predmode[MbLocationxInPic]      := [ 2 : for int j in 0 .. 15 ];
			is_constrained_i_flag[MbLocationxInPic] := true;
		end


	get_i_pcm: action
			ConstrainedIFlag :[ cflag ]
				==>
		guard
			mb_intra_type = I_PCM
		do
			intra4x4predmode[MbLocationxInPic]      := [ 2 : for int j in 0 .. 15 ];
			is_constrained_i_flag[MbLocationxInPic] := true;
		end


	schedule fsm GetType :
		GetType ( Get_MbType          ) --> MbType;

		//Decode Mb Inter
		MbType ( get_inter            ) --> GetType;
		MbType ( get_intratype        ) --> IntraType;
		//Decode Mb Intra 4x4
		IntraType ( get_intra4x4      ) --> IntraType;
		IntraType ( get_intra4x4_done ) --> GetType;
		//Decode Mb Intra 16x16
		IntraType ( get_intra16x16    ) --> GetType;
		//Decode Mb I PCM
		IntraType ( get_i_pcm         ) --> GetType;
	end

end