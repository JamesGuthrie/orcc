actor Controller () int(size=9) In, int InReconstructed_16, int
InReconstructed_4, int Sel_16_4 ==> int OutMB_16, int OutPredictor_16, int
MBType_16, int BlockType_4, int OutBlock_4, int OutPredictor_4, int MBType_4 :

	int width = 176;

	int height = 144;

	int frameSize = width * height;

	int rowSize = width * 16;

	List(type: int, size=rowSize) frameRow := [ 0 : for int t in Integers(1,
	rowSize) ];

	List(type: int, size=width) top := [ 128 : for int t in Integers(1, width) ];

	List(type: int, size=16) left := [ 128 : for int t in Integers(0, 15) ];

	List(type: int, size=4) M := [ 128 : for int t in Integers(0, 3) ];

	int i := 0;

	int origin := 0;

	int count := 0;

	int nmbs := 0;

	int topIndex := 0;

	int leftIndex := 0;

	int bType := 0;

	int nrows := 0;

	//There is no actual use of this state variable. Just used for debugging
	int nblocks := 0;

	int offset := 0;

	//Read one row of MBs  
	Read_In: action In:[ inValue ] ==>
	guard
		i < rowSize
	do
		frameRow[i] := inValue;
		i := i + 1;
	end

	//Prepare for the processing
	FinishIn: action ==>
	guard
		i = rowSize
	do
		i := 0;
		//println("FinishIn");
	end

	MBType: action ==> MBType_16:[ bType ]
	do
		if (nmbs > 0 and nmbs < width / 16) then
		//Upper border MB
			bType := 1;
		else
			if (nmbs > 0 and nmbs mod (width / 16) = 0) then
			//first MB in a row that is not an upper border	
				bType := 2;
			else
				bType := 0;
				// An internal MB (including the right-boundaries)
			end
		end
		i := origin;
		//println("MB Number = "+nmbs);
		//println("");	

	end

	//Output the 64 Y samples of the MB to the module "MB"
	OutMB: action ==> OutMB_16:[ out ]
	guard
		count < 16 * 16
	var
		int out
	do
		out := frameRow[i];
		//Ihab
		//out:=nmbs*256+count;
		count := count + 1;
		if (count mod 16 = 0) then
		//If a row of 16 samples have been read, then move to the beginning of the next row of samples within the same MB
			i := i + width - 15;
		else
			i := i + 1;
		end
	end

	//Fired by the end of each MB
	FinishOutMB: action ==>
	guard
		count = 16 * 16
	do
		count := 0;
		i := 0;
	end

	//Output the required neighbors of the current MB to be used in the prediction process
	OutPredictor: action ==> OutPredictor_16:[ out ] //bType = 0 --> Normal internal MB
		//bType != 0 --> Upper or left MB

	guard
		(i < 32 and bType = 0) or (i < 16 and bType != 0)
	var
		int out
	do
		if (bType = 0) then
			if (i < 16) then
				out := top[topIndex];
				topIndex := topIndex + 1;
			else
				out := left[leftIndex];
				leftIndex := leftIndex + 1;
			end
		else
			if (bType = 1) then
				out := left[leftIndex];
				leftIndex := leftIndex + 1;
			else
				out := top[topIndex];
				topIndex := topIndex + 1;
			end
		end
		i := i + 1;
	end

	FinishOutPredictor: action ==> //bType = 0 --> Normal internal MB
		//bType != 0 --> Upper or left MB

	guard
		(i = 32 and bType = 0) or (i = 16 and bType != 0)
	do
		i := 0;
		leftIndex := 0;
		if (bType != 1) then
			topIndex := topIndex - 16;
		end
		//Ihab//println("Reconstructed MB# " +nmbs);
		//Ihab//println("---------------------------");

	end

	BlockType: action ==> BlockType_4:[ bType ]
	do
	//I will use the convention that was used in the old code
		//Beware the ambiguity with the naming convention for the 16x16 mode
		//E.g. types 1 and 2 are kind of opposite
		//Figure is in the PDF "Intra_Calculations.PDF"
		if (nmbs = 0 and nblocks = 0) then
			bType := 3;
			//The first block in the frame
		else
			if ((nmbs < width / 16) and (nblocks = 0 or nblocks = 1 or nblocks = 4 or
			nblocks = 5)) then
			//Upper border block excluding the first block
				bType := 2;
			else
				if ((nmbs mod (width / 16) = 0) and (nblocks = 0 or nblocks = 2 or nblocks
				= 8 or nblocks = 10)) then
				//first block in a row that is not an upper border	
					bType := 1;
				else
					if (nblocks = 3 or nblocks = 7 or nblocks = 11 or nblocks = 13 or nblocks
					= 15 or (((nmbs + 1) mod (width / 16) = 0) and (nblocks = 5))) then
					//last block in a row + special cases						
						bType := 4;
					else
						bType := 0;
					end
				end
			end
		end
		i := origin;
		//println("Block Number = "+nblocks);

	end

	//Output the 16 Y samples of the the block to the module "Block" in z-shape
	OutBlock: action ==> OutBlock_4:[ out ]
	guard
		count < 4 * 4
	var
		int out
	do
		out := frameRow[i];
		//out:=nmbs*256 + nblocks*16 + count;
		//Ihab
		count := count + 1;
		if (count mod 4 = 0) then
		//If a row of 4 samples have been read, then move to the beginning of the next row of samples within the same block
			i := i + width - 3;
		else
			i := i + 1;
		end
	end

	//Fired by the end of each block
	FinishOutBlock: action ==>
	guard
		count = 4 * 4
	do
		count := 0;
		i := 0;
		offset := 0;
	end

	//Output the required neighbors of the current block to be used in the prediction process
	OutPredictor4: action ==> OutPredictor_4:[ out ]
	guard
		(i < 13 and bType = 0) or (i < 8 and bType = 1) or (i < 4 and bType = 2) or (
		i < 4 and bType = 3) or (i < 9 and bType = 4)
	var
		int out
	do
		if (bType = 0) then
		//Internal block
			if (i < 4) then
				out := top[topIndex];
				topIndex := topIndex + 1;
			else
				if (i < 8) then
					out := left[leftIndex];
					leftIndex := leftIndex + 1;
				else
					if (i < 12) then
						out := top[topIndex + offset];
						offset := offset + 1;
					else
					//output the M predictor (upper left corner)						
						if (nblocks = 0 or nblocks = 1 or nblocks = 4 or nblocks = 5) then
							out := M[0];
						else
							if (nblocks = 2 or nblocks = 3 or nblocks = 6 or nblocks = 7) then
								out := M[1];
							else
								if (nblocks = 8 or nblocks = 9 or nblocks = 12 or nblocks = 13) then
									out := M[2];
								else
								//(nblocks=10 or nblocks=11 or nblocks=14 or nblocks=15)
									out := M[3];
								end
							end
						end
					end
				end
			end
		else
			if (bType = 1) then
			//Left Block
				if (i < 4) then
					out := top[topIndex];
					topIndex := topIndex + 1;
				else
					out := top[topIndex + offset];
					offset := offset + 1;
				end
			else
				if (bType = 2) then
				//Upper Block
					out := left[leftIndex];
					leftIndex := leftIndex + 1;
				else
					if (bType = 3) then
					//Upper Left Block
						out := top[topIndex];
						topIndex := topIndex + 1;
					else
					//bType = 4 --> Right block	or special cases	
						if (i < 4) then
							out := top[topIndex];
							topIndex := topIndex + 1;
						else
							if (i < 8) then
								out := left[leftIndex];
								leftIndex := leftIndex + 1;
							else
							//output the M predictor (upper left corner)								
								if (nblocks = 0 or nblocks = 1 or nblocks = 4 or nblocks = 5) then
									out := M[0];
								else
									if (nblocks = 2 or nblocks = 3 or nblocks = 6 or nblocks = 7) then
										out := M[1];
									else
										if (nblocks = 8 or nblocks = 9 or nblocks = 12 or nblocks = 13) then
											out := M[2];
										else
										//(nblocks=10 or nblocks=11 or nblocks=14 or nblocks=15)
											out := M[3];
										end
									end
								end
							end
						end
					end
				end
			end
		end
		i := i + 1;
	end

	FinishOutPredictor4: action ==>
	guard
		(i = 13 and bType = 0) or (i = 8 and bType = 1) or (i = 4 and bType = 2) or (
		i = 4 and bType = 3) or (i = 9 and bType = 4)
	do
		i := 0;
		if (bType != 2) then
			topIndex := topIndex - 4;
		end
		if (bType = 0 or bType = 2 or bType = 4) then
			leftIndex := leftIndex - 4;
		end
	end

	InReconstructed4: action InReconstructed_4:[ inR ] ==>
	guard
		i < 4 * 4
	do
		if ((i + 1) mod 4 = 0) then
			left[leftIndex] := inR;
			//Ihab//println("4x4: left["+leftIndex+"] = "+inR);
			leftIndex := leftIndex + 1;
		end
		if ((i + 1) > 4 * 3) then
			if (i = 15) then
				if (nblocks = 0 or nblocks = 1 or nblocks = 4 or nblocks = 5) then
					M[0] := top[topIndex];
				else
					if (nblocks = 2 or nblocks = 3 or nblocks = 6 or nblocks = 7) then
						M[1] := top[topIndex];
					else
						if (nblocks = 8 or nblocks = 9 or nblocks = 12 or nblocks = 13) then
							M[2] := top[topIndex];
						else
						//(nblocks=10 or nblocks=11 or nblocks=14 or nblocks=15)
							M[3] := top[topIndex];
						end
					end
				end
			end
			top[topIndex] := inR;
			//Ihab//println("4x4: top["+topIndex+"] = "+inR);
			topIndex := topIndex + 1;
		end
		i := i + 1;
	end

	FinishInReconstructed4: action ==>
	guard
		i = 4 * 4 and nblocks < 15
	do
		origin := origin + 4;
		if (nblocks = 1 or nblocks = 5 or nblocks = 9 or nblocks = 13) then
			origin := origin - 8 + 4 * width;
			topIndex := topIndex - 8;
		else
			if (nblocks = 3 or nblocks = 11) then
				origin := origin - 4 * width;
			else
				if (nblocks = 7) then
					origin := origin - 16 + 4 * width;
					topIndex := topIndex - 16;
				end
			end
		end
		//i:=origin;
		nblocks := nblocks + 1;
		//if (nblocks=0 or nblocks=1 or nblocks=4 or nblocks=5) then
		if (nblocks = 1 or nblocks = 4 or nblocks = 5) then
			leftIndex := 0;
		else
			if (nblocks = 2 or nblocks = 3 or nblocks = 6 or nblocks = 7) then
				leftIndex := 4;
			else
				if (nblocks = 8 or nblocks = 9 or nblocks = 12 or nblocks = 13) then
					leftIndex := 8;
				else
					leftIndex := 12;
				end
			end
		end
	end

	MBFinishInReconstructed4: action ==>
	guard
		i = 4 * 4 and nblocks = 15
	do
		leftIndex := 0;
		nblocks := 0;
		origin := origin + 4 - 12 * width;
		//i:=origin;
		nmbs := nmbs + 1;
	end

	Selected_4: action Sel_16_4:[ s ] ==>
	guard
		s = 0
	end

	Selected_16: action Sel_16_4:[ s ] ==>
	guard
		s = 1
	do
		nmbs := nmbs - 1;
		topIndex := topIndex - 16;
		origin := origin - 16;
		i := 0;
	end

	Flush_16: action InReconstructed_16:[ inR ] ==>
	guard
		count < 16 * 16
	do
		count := count + 1;
	end

	FinishFlush_16: action ==>
	guard
		count = 16 * 16
	do
		count := 0;
	end

	NotFinishRow: action ==>
	guard
		(nmbs mod (rowSize / 256)) != 0
	end

	MBFinishRow: action ==>
	guard
		(nmbs mod (rowSize / 256)) = 0
	do
		nrows := nrows + 1;
		i := 0;
		leftIndex := 0;
		topIndex := 0;
		origin := 0;
		count := 0;
		nblocks := 0;
		//println("*******************");
		//println("MB Finished Row # " +nrows);	

	end

	MBFinishFrame: action ==>
	guard
		nmbs = (frameSize / 256)
	do
		nrows := nrows + 1;
		nmbs := 0;
		i := 0;
		leftIndex := 0;
		topIndex := 0;
		origin := 0;
		count := 0;
		nblocks := 0;
		//println("===============================================");
		//println("MB Finished Row # " +nrows);
		//println("MB Frame Finished!");
		nrows := 0;
	end

	InReconstructed: action InReconstructed_16:[ inR ] ==>
	guard
		i < 16 * 16
	do
		if ((i + 1) mod 16 = 0) then
			left[leftIndex] := inR;
			//Ihab//println("16x16: left["+leftIndex+"] = "+inR);
			leftIndex := leftIndex + 1;
		end
		if ((i + 1) > 16 * 15) then
			top[topIndex] := inR;
			//Ihab//println("16x16: top["+topIndex+"] = "+inR);
			topIndex := topIndex + 1;
		end
		i := i + 1;
	end

	FinishInReconstructed: action ==>
	guard
		i = 16 * 16 and ((nmbs mod (rowSize / 256)) < (rowSize / 256) - 1)
	do
		leftIndex := 0;
		nmbs := nmbs + 1;
		origin := origin + 16;
		//i:=origin;
	end

	FinishRow: action ==>
	guard
		i = 16 * 16 and ((nmbs + 1) mod (rowSize / 256) = 0)
	do
		nrows := nrows + 1;
		nmbs := nmbs + 1;
		i := 0;
		leftIndex := 0;
		topIndex := 0;
		origin := 0;
		count := 0;
		//println("*******************");
		//println("Finished Row # " +nrows);

	end

	FinishFrame: action ==>
	guard
		i = 16 * 16 and (nmbs + 1) = (frameSize / 256)
	do
		nrows := nrows + 1;
		nmbs := 0;
		i := 0;
		leftIndex := 0;
		topIndex := 0;
		origin := 0;
		count := 0;
		//println("===============================================");
		//println("Finished Row # " +nrows);
		//println("Frame Finished!");
		nrows := 0;
	end

	schedule fsm ReadMBRow :
		ReadMBRow ( Read_In ) --> ReadMBRow;
		ReadMBRow ( FinishIn ) --> ReadMBType_16x16;
		ReadMBType_16x16 ( MBType ) --> PassMB_16x16;
		PassMB_16x16 ( OutMB ) --> PassMB_16x16;
		PassMB_16x16 ( FinishOutMB ) --> PassSamplesForPrediction_16x16;
		PassSamplesForPrediction_16x16 ( OutPredictor ) -->
		PassSamplesForPrediction_16x16;
		PassSamplesForPrediction_16x16 ( FinishOutPredictor ) --> ReadBlockType_4x4;
		ReadBlockType_4x4 ( BlockType ) --> PassBlock_4x4;
		PassBlock_4x4 ( OutBlock ) --> PassBlock_4x4;
		PassBlock_4x4 ( FinishOutBlock ) --> PassSamplesForPrediction_4x4;
		PassSamplesForPrediction_4x4 ( OutPredictor4 ) -->
		PassSamplesForPrediction_4x4;
		PassSamplesForPrediction_4x4 ( FinishOutPredictor4 ) --> ReconstructBlock_4x4
		;
		ReconstructBlock_4x4 ( InReconstructed4 ) --> ReconstructBlock_4x4;
		ReconstructBlock_4x4 ( FinishInReconstructed4 ) --> ReadBlockType_4x4;
		ReconstructBlock_4x4 ( MBFinishInReconstructed4 ) -->
		CheckModeDecision_16x16_Vs_4x4;
		CheckModeDecision_16x16_Vs_4x4 ( Selected_4 ) --> FlushExtraTokensOf16x16;
		FlushExtraTokensOf16x16 ( Flush_16 ) --> FlushExtraTokensOf16x16;
		FlushExtraTokensOf16x16 ( FinishFlush_16 ) --> CheckFinish_4x4;
		CheckFinish_4x4 ( NotFinishRow ) --> ReadMBType_16x16;
		CheckFinish_4x4 ( MBFinishRow ) --> ReadMBRow;
		CheckFinish_4x4 ( MBFinishFrame ) --> ReadMBRow;
		CheckModeDecision_16x16_Vs_4x4 ( Selected_16 ) --> ReconstructMB_16x16;
		ReconstructMB_16x16 ( InReconstructed ) --> ReconstructMB_16x16;
		ReconstructMB_16x16 ( FinishInReconstructed ) --> ReadMBType_16x16;
		ReconstructMB_16x16 ( FinishRow ) --> ReadMBRow;
		ReconstructMB_16x16 ( FinishFrame ) --> ReadMBRow;
	end

	priority
		FinishFrame > FinishRow;
		MBFinishFrame > MBFinishRow;
	end

end