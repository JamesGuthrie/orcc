// Mgnt_FBAddr_Luma_MxN.cal
//
// Author: He-Yuan Lin
//
// Luma frame buffer generator for AVC inter prediction

//Modified by Florian DECOLOGNE (IETR) : 15/09/08 : 
//Mgnt_FBAddr_Luma_MxN --> Mgnt_Interp_FBAddr_Luma_MxN

//Modified by Endri Bezati <endri.bezati@insa-rennes.fr>
//Modified the "size" correctly to work with orcc

actor Mgnt_Interp_FBAddr_Luma_MxN ()
		uint(size=13) CurrMbAddr,
		uint(size=3) MbPartIdx,
		uint (size=8) Mb_Type,
		uint(size=7) PicWidthInMb,
		uint(size=13) PicSizeInMb,
		int(size=16) MV,
		uint(size=11) Location,
		uint(size=6) PartSZ
		==>
		uint(size=21) RA,
		uint(size=11) RA_Width,
		uint(size=11) RA_Height,
//		uint(size=16) Frac,
		uint(size=2)  RefIdx2PocControl,
		bool          NewMb
	:

	uint(size=2) GETNEWLIST  = 0;
	uint(size=2) GETNEWIDX   = 1;
	uint(size=2) SENDLASTIDX = 2;

	bool DEBUG_INPUT = false;

  int(size=32) x_index ;
  int(size=32) y_index ;
  uint(size=11) Picheight_l := 1;
  uint(size=11) Picwidth_l  := 1;
  int(size=32) x;
  int(size=32) y;
  int(size=32) o_x;
  int(size=32) o_y;
  int width;
  int addr_x;
  int addr_y;
  int height;
  int count:=0;
  int currMB                := 0;
  int pic_size              := 0;
  
  //Mb_Type_NOK : Consume the token, nothing else to do 
  Mb_Type_NOK_and_IPCM :action Mb_Type:[a], PicSizeInMb:[ c ], CurrMbAddr:[valCurrMbAddr] ==> 
  guard
  	a = 4
  do
	if(DEBUG_INPUT)then
		println("Input InterpFBAddrLuma Mb_Type:"+a);	
		println("Input InterpFBAddrLuma PicSizeInMb:"+c);	
		println("Input InterpFBAddrLuma CurrMbAddr:"+valCurrMbAddr);	
	end
  	currMB:=valCurrMbAddr;
  	pic_size:=c;
  end

  //Mb_Type_NOK : Consume the token, nothing else to do 
  Mb_Type_NOK :action Mb_Type:[a], PicSizeInMb:[ c ], CurrMbAddr:[valCurrMbAddr] ==> 
  guard
  	a = 0 or a = 1
  do
	if(DEBUG_INPUT)then
		println("Input InterpFBAddrLuma Mb_Type:"+a);
		println("Input InterpFBAddrLuma PicSizeInMb:"+c);	
		println("Input InterpFBAddrLuma CurrMbAddr:"+valCurrMbAddr);
	end
  	currMB:=valCurrMbAddr;
  	pic_size:=c;
  end
  
  //Mb_Type_OK : Enable the prediction 
  Mb_Type_OK :action Mb_Type:[a], PicWidthInMb:[b], PicSizeInMb:[ c ], CurrMbAddr:[valCurrMbAddr]  ==>
  guard
  	a = 2
  do 
	if(DEBUG_INPUT)then
		println("Input InterpFBAddrLuma Mb_Type:"+a);	
		println("Input InterpFBAddrLuma PicWidthInMb:"+b);	
		println("Input InterpFBAddrLuma PicSizeInMb:"+c);	
		println("Input InterpFBAddrLuma CurrMbAddr:"+valCurrMbAddr);
	end
    Picwidth_l := lshift(b,4);
    Picheight_l := lshift(c/b,4);
  	currMB:=valCurrMbAddr;
  	pic_size:=c;
  end
  
  get_pos: action MbPartIdx:[idx], Location:[ a, b ], PartSZ:[ c, d ] ==> RefIdx2PocControl :[GETNEWIDX], NewMb:[true]
  do
	if(DEBUG_INPUT)then
		println("Input InterpFBAddrLuma MbPartIdx:"+idx);	
		println("Input InterpFBAddrLuma Location:"+a+" ; "+b);	
		println("Input InterpFBAddrLuma PartSZ:"+c+" ; "+d);
	end
    x := a;
    y := b;
    width := c;
    height :=d;
    count := if width=16 and height=16 then
       count+rshift(width,2)*rshift(height,2)
    else 
    if height = 16 and width = 8 then //mode16x8
   	  if idx = 0 then 4 else 16 end 
    else 
    if height = 8 and width = 16 then //mode 8x16
      count+rshift(width,2)*rshift(height,2)
    else 
    if height = 8 and width = 8 then // mode8x8
      count+rshift(width,2)*rshift(height,2)
    else 
    if height = 8 and width = 4 then //mode 8x4
      count+1+lshift(idx,1)
    else 
    if height = 4 and width = 8 then //mode 4x8
      count+rshift(width,2)*rshift(height,2)
    else // if mbpart_h = 4 and mbpart_w = 4 then mode4x4 
      count+rshift(width,2)*rshift(height,2)
    end end end end end end;
    
    
  end
  
  get_mv_send_frac: action MV:[ mx, my ] ==> /*Frac: [frac_x, frac_y]*/
//  var
//    uint(size=16) frac_x, uint(size=16) frac_y
  do
	if(DEBUG_INPUT)then
		println("Input InterpFBAddrLuma MV:"+mx+" ; "+my);
	end
    x_index :=rshift (mx, 2);        
    y_index :=rshift (my, 2);
    o_x := x + x_index-2;
    o_y := y + y_index-2;
 //   frac_x := (mx - lshift (x_index, 2));
 //   frac_y := (my - lshift (y_index, 2));
  end
  
  RA_not_border: action ==>  RA:[ o_x + Picwidth_l * o_y ], RA_Width:[ width + 5 ], RA_Height:[ height + 5 ], RefIdx2PocControl :[ SENDLASTIDX ],NewMb:[false]
  guard
    x + x_index-2 >= 0 and (x + x_index + width + 3) <= (Picwidth_l-1) and
    y + y_index-2 >= 0 and (y + y_index + height + 3) <= (Picheight_l-1)
  end
  
  // read_address
  RA_border: action ==>  RA:[ r_addr ], RA_Width:[ 1 ], RA_Height:[ 1 ], RefIdx2PocControl :[ SENDLASTIDX ],NewMb:[false]
  var uint r_addr
  do
   addr_x := o_x;
   addr_y := o_y;
   if( o_x < 0) then
     addr_x := 0 ;
   end   
   if( o_x > Picwidth_l - 1) then
     addr_x := Picwidth_l - 1 ;
   end
   if( o_y < 0) then
     addr_y := 0 ;
   end   
   if( o_y > Picheight_l - 1) then
     addr_y := Picheight_l - 1 ;
   end

   r_addr := (addr_x + Picwidth_l * addr_y);
   o_x := o_x + 1;
   if o_x =  (x + x_index + width + 3) then
     o_x := x + x_index - 2;
     o_y := o_y + 1;
   end
  end 
  
  done: action ==>
  guard
    o_y =  (y + y_index+ height+ 3)
  end

  MB_done: action ==>
  guard
    count = 16
  do
  	count:=0;
  end
  
  MB_Ndone: action ==>
  end

  PIC_done: action
  		==>
  	RefIdx2PocControl :[ GETNEWLIST ]
  guard
  	currMB = pic_size-1
  end

  PIC_Ndone: action ==>
  guard currMB<pic_size-1
  end

  schedule fsm get_MB:
    get_MB      		( Mb_Type_NOK_and_IPCM 	) --> get_pic_done;
    get_MB      		( Mb_Type_NOK       	) --> get_pic_done;
    get_MB      		( Mb_Type_OK        	) --> get_pos;

    get_pic_done   		( PIC_done       		) --> get_MB;
    get_pic_done   		( PIC_Ndone       		) --> get_MB;
 
    get_pos        		( get_pos        		) --> get_mv_send_frac;
 
    get_mv_send_frac    ( get_mv_send_frac 		) --> address;
 
    address      		( RA_border				) --> address;
    address      		( RA_not_border			) --> MB_done;
    address      		( done         			) --> MB_done;
 
    MB_done      		( MB_done         		) --> get_pic_done;
    MB_done      		( MB_Ndone         		) --> get_pos;
   end

  priority
     PIC_done > MB_done       > MB_Ndone ;
     done     > RA_not_border > RA_border;
     PIC_done > PIC_Ndone;
  end

end