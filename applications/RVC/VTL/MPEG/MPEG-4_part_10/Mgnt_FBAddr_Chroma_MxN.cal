// A Mgnt_FBAddr_Chroma_MxN.cal
//
// Author: He-Yuan Lin
//
// Chroma frame buffer generator for AVC inter prediction
//Modified By Endri Bezati <endri.bezati@insa-rennes.fr>IETR/INSA




// BTYPE
// refID  MB position (x,y)
actor Mgnt_FBAddr_Chroma_MxN () 

   							 uint(size=8)         Mb_Type, 
   							 int (size=16)     MV, 
   							 uint(size=3)    RefIdx, 
  							 uint(size=11)   Location , 
  							 uint(size=6) PartSZ, 
  							 uint(size=13)   PicSizeInMb, 
  							 uint(size=7)   PicWidthInMb,
  							 uint(size=3)         MbPartIdx,
  							 uint(size=13)        CurrMbAddr
  															   ==> 
   																  uint(size=21) 	   RA, 
   																  uint(size=11)        RA_Width, 
   																  uint(size=11)        RA_Height, 
   																  uint(size=4)    refbuf, 
   																  int (size=4)   Frac, 
   																  uint (size=1)  PicID :

	/* ***
		Global Variables
							*** */

  int x_index ;
  int y_index ;
  int x;
  int y;
  int o_x;
  int o_y;
  int addr_x;
  int addr_y;
  int width;
  int height;
  int ID;
  
  int Picheight_c := 1;
  int Picwidth_c  := 1;
  
  int count    := 0;
  int currMB   := 0;
  int pic_size := 0;
  
  uint(size=1) ValPicID := 0;
  
  //Mb_Type_NOK_and_IPCM : Consume the token, nothing else to do 
  Mb_Type_NOK_and_IPCM: action Mb_Type      :[a],
  		              PicWidthInMb :[ b ], 
  		              PicSizeInMb  :[ c ],
  		              CurrMbAddr   :[ valCurrMbAddr ] ==> 
  guard
  	a = 4
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end

  //Mb_Type_NOK : Consume the token, nothing else to do 
  Mb_Type_NOK: action Mb_Type      :[a],
  		              PicWidthInMb :[ b ], 
  		              PicSizeInMb  :[ c ], 
 // 		              Coef_ACR     :[ d ] repeat 8*8,
  		              CurrMbAddr   :[ valCurrMbAddr ] ==> 
  guard
  	a = 0 or a = 1
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end
  
  
  
  
  //Mb_Type_OK : Enable the prediction 
  Mb_Type_OK: action Mb_Type      :[a],
  	                 PicWidthInMb :[ b ], 
  	                 PicSizeInMb  :[ c ], 
//  	                 Coef_ACR     :[d] repeat 8*8,
  	                 CurrMbAddr   :[valCurrMbAddr]              ==> 
//  	     										                   Coef_ACR_P:[d] repeat 8*8
  guard
  	a = 2
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end
  
  
  
  get_pos: action MbPartIdx : [ idx  ], 
  			      Location  : [ a, b ], 
  			      PartSZ    : [ c, d ], 
  			      RefIdx    : [ e    ] ==>			      
  do
  	x      := a/2;
    y      := b/2;
    width  := c/2;
    height := d/2;
    ID     := e;
  
  	if ( ( width = 2 ) and ( height = 4 ) ) then
      count := count + 1 + lshift(idx,1);
    else 
      if ( ( width = 4 ) and  ( height = 8 ) )   then
         
        if ( idx = 0)  then 
        	count := 4;
       	else 
       		count := 16; 
       	end
      else
        
        count := count + rshift(width,1) * rshift(height,1);
      end
    
    end
    
  end
   

  get_mv_send_frac: action MV : [ mx, my ] ==>
  											   Frac : [ frac_x, frac_y ]
  var
  	uint frac_x, 
    uint frac_y
  do
  	x_index := rshift (mx, 3);        
    y_index := rshift (my, 3);
    o_x     := x + x_index;
    o_y     := y + y_index;
    frac_x  := ( mx - lshift (x_index, 3) );
    frac_y  := ( my - lshift (y_index, 3) ); 		
  end
  
  
  done: action ==>
  guard
    o_y = ( y + y_index + height + 1 )
  end

  MB_done: action ==>
  guard
  	count = 16
  do
  	count := 0;
  end
  
  MB_Ndone: action ==>
  end
  
  PIC_done: action ==> PicID     : [ValPicID]
  guard
  	currMB = pic_size - 1
  do
  	ValPicID := ValPicID + 1;
  end

  PIC_Ndone: action ==>
  guard 
  	currMB < ( pic_size - 1 )
  end

  // read_address
  read_address: action ==> RA        : [ r_addr ], 
  						   RA_Width  : [ 1 ], 
  						   RA_Height : [ 1 ], 
  						   refbuf    : [ ID ],
  						   PicID     : [ValPicID]
  
  var int r_addr
  do
 
    addr_x := o_x;
    addr_y := o_y;
    
    if( o_x < 0) then
    	addr_x := 0 ;
    end   
   
   	if( o_x >= Picwidth_c - 1 ) then
   		addr_x := Picwidth_c-1 ;
   	end
   
   	if( o_y < 0) then
   		addr_y := 0 ;
   	end   
   
   	if( o_y >=Picheight_c-1) then
    	addr_y := Picheight_c-1 ;
   	end
    
   	r_addr := (addr_x + Picwidth_c * addr_y);
     
   	o_x := o_x + 1;

   	if o_x >=  (x + x_index+ width+ 1) then
      	o_x := x + x_index;
      	o_y := o_y + 1;
   	end
    
  end
 
  schedule fsm get_MB:
    get_MB      		( Mb_Type_NOK_and_IPCM       ) 	--> get_pic_done;
    get_MB      		( Mb_Type_NOK       ) 	--> get_pic_done;
    get_pic_done   		( PIC_done       	) 	--> get_MB;
    get_pic_done   		( PIC_Ndone       	) 	--> get_MB;
    get_MB      		( Mb_Type_OK        ) 	--> get_pos;
    get_pos        		( get_pos        	) 	--> get_mv_send_frac;
    get_mv_send_frac    ( get_mv_send_frac 	) 	--> address;
    address      		( read_address		) 	--> address;
    address      		( done         		) 	--> MB_done;
    MB_done      		( MB_done         	) 	--> get_pic_done;
    MB_done      		( MB_Ndone         	) 	--> get_pos;
   end

  priority
     PIC_done > MB_done       > MB_Ndone ;
     done     > read_address;
     PIC_done > PIC_Ndone;
  end

end