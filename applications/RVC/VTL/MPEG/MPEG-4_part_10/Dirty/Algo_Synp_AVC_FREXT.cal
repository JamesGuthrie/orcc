/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes) for CAVLC and 
Endri Bezati (IETR/INSA of Rennes and EPFL) for CABAC entropy decoding, 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
 
FU realizing Syntax Parsing for AVC
*****************************************************************************/

// This FU has been modified by Mickael Raulet (INSA of Rennes) July 2009

actor Algo_Synp_AVC_FREXT()
		uint(size=1) bits, 
		uint nb_rbsp_bytes 
		==> int(size=9) pix_I_PCM,
			uint(size=4) IntraPredMode,
			uint(size=4) IntraPredModeC, 
			uint(size=4) RUN, 
			int(size=12) VALUE,
			bool         LAST,
			int(size = 2) ENTROPY_TYPE,
			int(size=8) ScalingList, 
			int(size=8) QP,
			int(size=8) QP_Cb, 
			int(size=8) QP_Cr, 
			uint(size=13) CurrMbAddr, 
			uint(size=7) PicWidthInMb, 
			uint(size=13) PicSizeInMb, 
			uint(size=13) FirstMbInSlice, 
			uint POC, 
			uint(size=3) MbPartIdx, 
			uint(size=3) RefIdx, 
			uint(size=5) MbPartWidth, 
			uint(size=5) MbPartHeigth, 
			int(size=16) MvRes, 
			uint(size=1) MbIntraFlag, 
			uint(size=31) RefReordering_l0,
			uint(size=31) RefReordering_l1,
			uint(size=5)  Nb_RefFrame_l0,
			uint(size=5)  Nb_RefFrame_l1,
			uint(size=31) MMCO,
			uint(size=5)  NumRefFrame,
			uint(size=31) FramNumCurrPic,
			uint(size=2)  RefList0Type,
			uint(size=2)  RefList1Type,
			uint(size=31) MaxFrameNum,
			uint(size=16) cbp_blk,
			int(size=6) slice_alpha_c0_offset, 
			int(size=6) slice_beta_offset,
			uint(size=2) LFDisable,
			bool ConstrainedIFlag,
			int(size=16) WIDTH, 
			int(size=16) HEIGHT,
			uint(size=5) SizeDPBMax,
			bool ReadNextByte
		:
  	// FIXME! Maximum size of a line in macroclock
  	uint(size=7) PICWIDTH =1280/16;
	uint(size=7) PICHEIGHT=720/16;


	uint(size=2) REFLIST0_PRED    = 0;
	uint(size=2) REFLIST0_BI_PRED = 1;
	uint(size=2) REFLIST1_BI_PRED = 2;

	// ********** Read bits ********** //  
	int(size=9) bits_to_read_count := -1;
	bool        bit_read_cnt_finish := true;
	int(size=41) read_result_in_progress; 
	uint bit_count := 0;
	uint val_nb_rbsp_bytes := 0;
	// ********** Read VLD ********** //
	bool NewVLD := false;
	int VLD_Counter;
	bool First_part := false;
	int Codeword;
	int CodeLen;
	int Bbits := 0;
	bool TRACE := false;//true;
	bool TRACE_POC := false;
	bool TRACE_MRL := false;//true;
	bool TRACE_BIARI := false;

	// ********** Read CAVLC ********** //
	bool NewCoeff := false;
	uint(size=2) CAVLC_type;// 0 coeff_token, 1 total_zeros, 2 run_before
	uint(size=7) coeff_token;
	uint(size=4) total_zeros;
	uint(size=4) run_before :=0;
	
	// ********** read CABAC ********* //
	
	// ********** CABAC Constants ********* //
	
	//Cabac State variables
	int preCtxState;
	List ( type : int (size = 6), size = 640 ) pStateIdx;
	List ( type : int (size = 1), size = 640 ) valMPS;
	int ctxIdxInc := 0;
	int ctxIdx := 0;
	int binIdx := -1;
	int qCodIRangeIdx;
	int codIRangeLPS;
	uint binVal;
	
	bool SEARCH_MB_TYPE := false;
	bool StartNewCabacParsing := false;
	
	/* Cabac intialisation process for the arithmetic decoding engine */
	bool Cabac_Arithmetic_Decoding_Engine_Start := false;
	/* CABAC I_PCM decoding conditions */
	bool PcmAlignementZeroBitDone := false;
	bool PcmSampleLumaDone := false;
	bool PcmSampleChromaDone := false;
	
	
	bool SentChromaZeros := false;
	bool SentLumaDCZeros := false;
	
	//CABAC SE
	uint (size = 1) coded_block_flag;
	
	int SearchForMbType := 0;
	
	//CABAC Binarisation
	
	bool SentMbSkipZeros :=false;
	bool bypassFlag := false;
	
	//CABAC Decoding Process
	int ctxIdxOffset;
	int ctxBlockCat;
	
	//Arithmetic Decoding
	int ( size = 16 ) codIRange := 0;
	int ( size = 16 ) codIOffset;
	
	
	//CBP
	uint (size=6) cbp_cabac;
	int bk_cbp := 0;
	
	//CABAC Process Conditions 
	bool FirstSEinSlice					:= true;
	bool FoundSE		       			:= false;
	bool StartRenormD					:= false;
	bool StartInitializationDecoding	:= false;
	bool StartCabacInit					:= false;
	bool binValDecoded					:= false;
	bool StartDecodeTerminate			:= false;
	bool StartDecodeDecision			:= false;
	bool StartDecodeBypass				:= false;
	bool NextBitToDecode				:= true;
	bool StartRenormDRead				:= false;
	bool StartDecodeBypassStart			:= false;
	
	bool cbp_done := false;
	
	/* Coeff abs level minus 1 parsing*/
	int numDecodAbsLevelEq1 := 1;
	int numDecodAbsLevelGt1 := 0;
	int coeff_abs := 0;
	int Coeff_J := 0;
	bool StartPrefix := true;
	bool StartSuffix := false;
	bool GetSign := false;
	bool StopCoeff := true;
	bool StartCoeffSignAbs := false;
	bool StartCoeff_J_Dec := false;
	
	/* CABAC Mb type parsing */
	bool SuffixMbTypeP := true;
	bool SuffixMbTypeB := true;
	int compIdx;
	int binIdxMb := 0;
	//CABAC Decode Variables
	/* Defines the Final Value of the Cabac Decoding Process and the Index of the Cabac Compare Tbale SynElVal */
	int CabacValue;
	int binIdxOffset := 0;
	int PreviousCtxIdx := 0;
	
	bool IS_L0 := false;
	int mvd_temp :=0;
	int ctx_temp :=0;
	/* CABAC Neighbouring contstants */
	uint NeighMbAddr;
	bool NeighMbAvail;
	uint NeighMb_xW;
	uint NeighMb_yW;
	
	/* P_Skip and B_Skip MB type values */
	uint P_Skip = 254;
	uint B_Skip = 255;
	
	int tempCoeff;
	/* MVD and REF CABAC Neighbouring */
	int mbPartIdxN;
	int subMbPartIdxN;
	
	int blCabacIdx := 0;
	uint(size=5) numCoeff := 0;
	
	/* Syntax Element Enumeration */
	
	int CABAC_SEARCH_SYNTAX_ELEMENT				:= -1;
	
	int CABAC_MB_TYPE_SI    	 				:= 0;
	int CABAC_MB_TYPE_I     	 				:= 1;
	int CABAC_MB_TYPE_P_SP  	 				:= 2;
	int CABAC_MB_TYPE_B      	 				:= 3;
	int CABAC_MB_SKIP_FLAG	    				:= 5;
	int CABAC_SUB_MB_TYPE_P_SP   				:= 6;
	int CABAC_SUB_MB_TYPE_B	     				:= 7; 
	int CABAC_MVD_L0_0_0	     				:= 8;
	int CABAC_REF_IDX_L0_L1						:= 10;
	int CABAC_MB_QP_DELTA						:= 11;
	int CABAC_INTRA_CHROMA_PRED_MODE			:= 12;
	int CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG	:= 13;
	int CABAC_REM_INTRA4x4_8x8_PRED_MODE 		:= 14;
	//int CABAC_MB_FIELD_DECODING_FLAG 			:= 15;
	int CABAC_CODED_BLOCK_PATERN_LUMA 			:= 16;
	int CABAC_CODED_BLOCK_PATERN_CHROMA			:= 17;		
	int CABAC_CODED_BLOCK_FLAG 					:= 18;
	int CABAC_SIGNIFICANT_COEFF_FLAG 			:= 19;
	int CABAC_LAST_SIGNIFICANT_COEFF_FLAG 		:= 20;
	int CABAC_COEFF_ABS_LEVEL_MINUS1 			:= 21;
	int CABAC_END_OF_SLICE_FLAG 				:= 23;
	int CABAC_TRANSFORM_SIZE_8x8_FLAG 			:= 24;
	
		// ********** CABAC Functions ********* //
	
	// SLICE TYPES
	function IS_I16x16(int SliceType, int Mbtype) --> bool : (Mbtype >= 1 and Mbtype <= 24 ) and (SliceType = SLICE_TYPE_I) end
	function IS_INxN(int SliceType, int Mbtype) --> bool : (Mbtype = 0) and (SliceType = SLICE_TYPE_I) end
	function IS_SI(int SliceType) --> bool : SliceType = SLICE_TYPE_SI end
	
	/* P and B Images */
	function ABS(int x) --> int: if x < 0 then -x else x end end
	function IS_P_8x8() --> bool: slice_type = SLICE_TYPE_P and mb_type = 3 end
	function IS_B_8x8() --> bool: slice_type = SLICE_TYPE_B and mb_type = 22 end
	function IS_B_Direct_8x8() --> bool: slice_type = SLICE_TYPE_B and sub_mb_type[mbPartIdx] = 0 end
	function IS_B_Direct_16x16_CABAC(int mbAddr) --> bool: slice_type = SLICE_TYPE_B and mbTab[mbAddr][2] = 0 end
	function IS_IPCM_Tab(int Addr, int MbType) -->bool: if Addr < 0 then false else mbTab[Addr][MbType] = 25 end end
	function TestSignificantCoeffFlag(int Addr, int Val) --> bool: if Addr < 0 then false else significant_coeff_flag[Addr] = Val end end
	//Entropie decoding
	function IS_CAVLC() --> bool: entropy_coding_mode_flag[pps_id] = 0 end
	function IS_CABAC() --> bool: entropy_coding_mode_flag[pps_id] = 1 end
	
	/* CABAC Neighbourhood Prediction Functions */
	function IS_P_8x8_CABAC(int mbAddr) --> bool: mbTab[mbAddr][mbSliceType] = SLICE_TYPE_P and mbTab[mbAddr][mbTabMbtype] = 3 end
	function IS_B_8x8_CABAC(int mbAddr) --> bool:  mbTab[mbAddr][mbSliceType] = SLICE_TYPE_B and mbTab[mbAddr][mbTabMbtype] = 22 end
	function IS_P_8x8ref0_CABAC(int mbAddr) --> bool : mbTab[mbAddr][mbSliceType] = SLICE_TYPE_P and mbTab[mbAddr][mbTabMbtype] = 4 end
	function IS_MB_Type_P8X8(int mbAdd) --> bool: mbTab[mbAdd][1] = SLICE_TYPE_P and mbTab[mbAdd][2] = 3 end
	function IS_MB_Type_B8X8(int mbAdd) --> bool: mbTab[mbAdd][1] = SLICE_TYPE_B and mbTab[mbAdd][2] = 22 end
	function IS_P_Skip_CABAC(int mbAddr) --> bool: mbTab[mbAddr][1] = SLICE_TYPE_P and mbTab[mbAddr][2] = P_Skip end
	function IS_B_Skip_CABAC(int mbAddr) --> bool: mbTab[mbAddr][1] = SLICE_TYPE_B and mbTab[mbAddr][2] = B_Skip end
	function IS_Intra_Pred_CABAC(int mbAddr) --> bool : ( mbTab[mbAddr][1] = SLICE_TYPE_P and mbTab[mbAddr][2] > 4) or (mbTab[mbAddr][1] = SLICE_TYPE_B and mbTab[mbAddr][2] > 22) end
	function IS_Intra(int mbAddr) --> bool: mbTab[mbAddr][TypePred] = 0 end
	function IS_Inter(int mbAddr) --> bool: mbTab[mbAddr][TypePred] = 1 end
	/* Save Memory function */
	function CabacCurrMbAddr() --> int: 
		if val_CurrMbAddr >= PicWidthInMbs + 1 then 
			PicWidthInMbs 
		else 
			val_CurrMbAddr 
		end 
	end
	
	// ********** CABAC Arrays ********* //
	
	
	//CABAC Neighbouring
	
	List ( type: List ( type: int, size = 10) , size = PICWIDTH + 1 ) mbTab := [[ 0 : for int i in 0 .. 9] : for int j in 0 .. PICWIDTH];
	
	int TypePred				:= 0; //0:Intra 1:Inter 2: B, used for ctx prediction
	int mbSliceType				:= 1;
	int mbTabMbtype				:= 2;
	int mbIntraChromaPredMode	:= 3;
	int mbQpDelta				:= 4;
	int mbCBPLuma				:= 5;
	int mbCBPChroma				:= 6;
	int mbTransSize8x8Flag		:= 7;
	int mbCBF					:= 8;
	int mbSkipFlag				:= 9;
	
	
	 /* CABAC Coded Block Flag Lists */
	 
	List ( type: List ( type: int(size = 2), size = 16) , size = PICWIDTH + 1 ) transblock_cbf	:=  [ [ 0 : for int i in 0 .. 15 ]: for int j in 0 .. PICWIDTH ];
	List ( type: List ( type: int(size = 2), size = 4)  , size = PICWIDTH + 1 ) transblock_cbf_cr	:=  [ [ 0 : for int i in 0 .. 3  ]: for int j in 0 .. PICWIDTH ];
	List ( type: List ( type: int(size = 2), size = 4)  , size = PICWIDTH + 1 ) transblock_cbf_cb	:=  [ [ 0 : for int i in 0 .. 3  ]: for int j in 0 .. PICWIDTH ];
	List ( type: List ( type: int(size = 2), size = 2)  , size = PICWIDTH + 1 ) transblock_cbf_dc_cr_cb	:=  [ [ 0 : for int i in 0 .. 1  ]: for int j in 0 .. PICWIDTH ];
	
	/* CABAC MVD and REF Lists */
														  /*val_CurrMbAddr, mbPartIdx, subMbPartIdx,compIdx*/
	List ( type: List ( type : List (type: List ( type: int, size = 2), size  = 4), size = 4 ), size = PICWIDTH + 1 ) Mvd_L0 :=  [ [ [ [ 0:for int i in 0 .. 1 ]: for int j in 0 .. 3 ]: for int l in 0 .. 3 ]: for int m in 0 .. PICWIDTH ];
	List ( type: List ( type : List (type: List ( type: int, size = 2), size  = 4), size = 4 ), size = PICWIDTH + 1 ) Mvd_L1 :=  [ [ [ [ 0:for int i in 0 .. 1 ]: for int j in 0 .. 3 ]: for int l in 0 .. 3 ]: for int m in 0 .. PICWIDTH ];
	
	List ( type: List ( type: int, size = 4)  , size = PICWIDTH + 1 ) Ref_Idx_L0	:=  [ [ 0 : for int i in 0 .. 3  ]: for int j in 0 .. PICWIDTH ];
	List ( type: List ( type: int, size = 4)  , size = PICWIDTH + 1 ) Ref_Idx_L1	:=  [ [ 0 : for int i in 0 .. 3  ]: for int j in 0 .. PICWIDTH ];
	/* CABAC sub_mb_type */
	List ( type: List ( type: int, size = 4) , size = PICWIDTH + 1 ) cabac_sub_mb_type :=  [ [ 0 : for int i in 0 .. 3 ]: for int j in 0 .. PICWIDTH ];
	
	/* Residual Block arrays used in Cabac */
	List (type: int(size = 8), size = 256) significant_coeff_flag 		:= [0: for int i in 0 .. 255] ;
	List (type: int(size = 8), size = 256) last_significant_coeff_flag	:= [0: for int i in 0 .. 255] ;
	List (type: int(size = 16), size = 16) coeff_abs_level_minus1		:= [0: for int i in 0 .. 15] ;
	List (type: int(size = 2), size = 4)   prior_decoded_bin_cbp		:= [0: for int i in 0 .. 3] ;
	
	
		
	// ******** End of CABAC variables declaration ******
	/*************************************************************
	*************************************************************
	********              NAL Unit HEADER                ********
	*************************************************************
	*************************************************************/
	int NAL_UNIT_HEADER_LENGTH := 8; //forbidden_zero_bit | nal_ref_idc | nal_unit_type

	uint(size=2) nal_ref_idc :=0;
	uint(size=5) nal_unit_type :=0;

	/*************************************************************
	*************************************************************
	********        Sequence Parameter Set HEADER        ********
	*************************************************************
	*************************************************************/

	uint Sps_inc;
	List (type: uint(size=8), size=32) profile_idc := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=4), size=32) constraint_set_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=8), size=32) level_idc := [ 0 : for int i in 0 .. 31 ];
	uint(size=5) sps_id ;
	// High Profile
	List (type:uint(size=2), size=32 ) chroma_format_idc := [ 1 : for int i in 0 .. 31 ];
	List (type:uint(size=1), size=32 ) separate_colour_plane_flag := [ 0 : for int i in 0 .. 31 ];
	List (type:uint(size=3), size=32 ) bit_depth_luma_minus8 := [ 0 : for int i in 0 .. 31 ];
	List (type:uint(size=3), size=32 ) bit_depth_chroma_minus8 := [ 0 : for int i in 0 .. 31 ];

	List (type: uint(size=4), size=32) log2_max_frame_num_minus4 := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=2), size=32) pic_order_cnt_type := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=4), size=32) log2_max_pic_order_cnt_lsb_minus4 := [ 0 : for int i in 0 .. 31 ];
  
	List (type: uint(size=1), size=32) delta_pic_order_always_zero_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: int, size=32) offset_for_non_ref_pic := [ 0 : for int i in 0 .. 31 ];
	List (type: int, size=32) offset_for_top_to_bottom_field := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=8), size=32) num_ref_frames_in_pic_order_cnt_cycle := [ 0 : for int i in 0 .. 31 ];
	List (type: List ( type: int, size=255), size=32 ) offset_for_ref_frame := [[ 0 : for int i in 0 .. 254 ]: for int j in 0 .. 31 ];

	List (type: uint, size=32) num_ref_frames := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) gaps_in_frame_num_value_allowed_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) pic_width_in_mbs_minus1 := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) pic_height_in_map_units_minus1 := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) frame_mbs_only_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) mb_adaptive_frame_field_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) direct_8x8_interference_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) frame_cropping_flag := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) frame_crop_left_offset := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) frame_crop_right_offset := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) frame_crop_top_offset := [ 0 : for int i in 0 .. 31 ];
	List (type: uint, size=32) frame_crop_bottom_offset := [ 0 : for int i in 0 .. 31 ];
	List (type: uint(size=1), size=32) vui_parameters_present_flag := [ 0 : for int i in 0 .. 31 ];

	List (type: uint(size=5), size=32) MaxDPBSz := [16 : for int i in 0 .. 31];

	/*************************************************************
	*************************************************************
	********        Picture Parameter Set HEADER        *********
	*************************************************************
	*************************************************************/

	uint(size=8) pps_id;
	List (type:uint(size=5),size=255) sequence_parameter_set_id := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) entropy_coding_mode_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) pic_order_present_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=3),size=255) num_slice_groups_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=3),size=255) slice_group_map_type := [ 0 : for int i in 0 .. 254];

	uint Pps_inc;
	List (type:List (type:uint,size=7),size=255) run_length_minus1 := [[ 0 : for int i in 1 .. 7] :for int j in 0 .. 254];
	List (type:List (type:uint,size=7),size=255) top_left := [[ 0 : for int i in 1 .. 7] : for int j in 0 .. 254];
	List (type:List (type:uint,size=7),size=255) bottom_right := [[ 0 : for int i in 1 .. 7] : for int j in 0 .. 254];	
	List (type:uint(size=1),size=255) slice_group_change_direction_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint,size=255) slice_group_change_rate_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint,size=255) pic_size_in_map_units_minus1 := [ 0 : for int i in 0 .. 254];

	List (type:uint(size=5),size=255) num_ref_idx_l0_active_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=5),size=255) num_ref_idx_l1_active_minus1 := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) weighted_pred_flag := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=2),size=255) weighted_bipred_idc := [ 0 : for int i in 0 .. 254];
	List (type:int(size=6),size=255) pic_init_qp_minus26 := [ 0 : for int i in 0 .. 254];
	List (type:int(size=6),size=255) pic_init_qs_minus26 := [ 0 : for int i in 0 .. 254];
	List (type:int(size=5),size=255) chroma_qp_index_offset := [ 0 : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) deblocking_filter_control_present_flag := [ 0 : for int i in 0 .. 254];
	List (type:bool,size=255) constrained_intra_pred_flag := [ false : for int i in 0 .. 254];
	List (type:uint(size=1),size=255) redundant_pic_cnt_present_flag := [ 0 : for int i in 0 .. 254];

	//High profile 
	List (type:uint(size=1),size=255) transform_8x8_mode_flag := [ 0 : for int i in 0 .. 254];
	List (type:int(size=5),size=255) second_chroma_qp_index_offset := [ 0 : for int i in 0 .. 254];

	/*************************************************************
	*************************************************************
	********       		Slice HEADER  	  		    *********
	*************************************************************
	*************************************************************/
	uint first_mb_in_slice ;
	uint(size=4) slice_type ;
	uint(size=2) colour_plane_id := 0;
	uint frame_num;
	uint(size=1) field_pic_flag := 0;
	uint(size=1) bottom_field_flag := 0;
	uint(size=16) idr_pic_id := 0;
	int pic_order_cnt_lsb := 0;
	int delta_pic_order_cnt_bottom := 0;
	List (type:int,size=2)delta_pic_order_cnt  := [ 0 : for int i in 0 .. 1];
	uint(size=7) redundant_pic_cnt := 0;
	uint(size=1) direct_spatial_mv_pred_flag := 0;
	uint(size=1) num_ref_idx_active_override_flag := 0;
	uint(size=5) slice_num_ref_idx_l0_active_minus1 := 0;
	uint(size=5) slice_num_ref_idx_l1_active_minus1 := 0;
	uint(size=2) cabac_init_idc := 0;
	int slice_qp_delta;
	uint(size=1) sp_for_switch_flag := 0;
	uint(size=6) slice_qs_delta;
	uint(size=2) disable_deblocking_filter_idc := 0;
	int(size=5) slice_alpha_c0_offset_div2 := 0;
	int(size=5) slice_beta_offset_div2 := 0;
	int(size=6) val_slice_alpha_c0_offset := 0;
	int(size=6) val_slice_beta_offset := 0;
	uint slice_group_change_cycle := 0;

	uint(size=6) val_QP;
	uint(size=6) val_QP_Cb;
	uint(size=6) val_QP_Cr;
	List (type:uint(size=6),size=58) qP_tab := 
		[
			0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
			17,18,19,20,21,22,23,24,25,26,27,28,29,29,
			30,31,32,32,33,34,34,35,35,36,36,37,37,37,
			38,38,38,39,39,39,39,39,39,39,39,39,39
		];

	uint(size=3) SLICE_TYPE_P := 0;
	uint(size=3) SLICE_TYPE_B := 1;
	uint(size=3) SLICE_TYPE_I := 2;
	uint(size=3) SLICE_TYPE_SP := 3;
	uint(size=3) SLICE_TYPE_SI := 4;

	// MMO
	int prevPicOrderCntMsb := 0;
	int prevPicOrderCntLsb := 0;
	uint prev_frame_num := 0;
	uint prev_frame_num_offset := 0;
	//*****************************************************************

	//*******  ref_pic_list_reordering  ********/
	uint(size=1) ref_pic_list_reordering_flag;
	uint(size=2) reordering_of_pic_nums_idc;

	/*************************************************************
	*************************************************************
	********       		Slice DATA 	  	  		    *********
	*************************************************************
	*************************************************************/
	uint val_CurrMbAddr;
	uint(size=1) moreDataFlag;
	uint prevMbSkipped;
	uint(size=1) MbaffFrameFlag;
	uint mb_skip_run;
	uint(size=1) mb_skip_flag := 0;
	uint(size=1) mb_field_decoding_flag := 0;

	uint Mb_x;
	uint Mb_y;
	uint PicWidthInMbs;
	uint PicSizeInMbs;
	//*************************************************************/

	/*************************************************************
	*************************************************************
	********       		Macroblock layer    	    *********
	*************************************************************
	*************************************************************/
	uint(size=6) mb_type;
	uint(size=1) mb_intra_flag; // INTER 0, INTRA 1
	uint MB_inc;
	uint(size=1) noSubMbPartSizeLessThan8x8Flag;
	uint(size=1) transform_size_8x8_flag := 0;
	uint(size=6) val_CodedBlockPatternLuma := 0;
	uint(size=6) CodedBlockPatternChroma := 0;
	int mb_qp_delta;
	bool start_pcm_chroma := false;
	List ( type: List ( type: uint(size=4), size=3), size=25 ) Intra_16x16_tab = //[mb_type][Intra16x16PredMode / CBPChroma / CBPLuma]
		[ 
			[0,0,0], [0,0,0], [1,0,0], [2,0,0], [3,0,0], [0,1,0], [1,1,0], [2,1,0], 
			[3,1,0], [0,2,0], [1,2,0], [2,2,0], [3,2,0], [0,0,15], [1,0,15], [2,0,15], 
			[3,0,15], [0,1,15], [1,1,15], [2,1,15], [3,1,15], [0,2,15], [1,2,15], [2,2,15], [3,2,15]  
		];

	List ( type: List ( type: uint(size=5), size=5), size=6 ) P_tab = //[mb_type][NumMbPart / MbPartWidth / MbPartHeight /MbPartPredMode,0 / MbPartPredMode,1]
		[ [1,16,16,0,7], [2,16,8,0,0], [2,8,16,0,0], [4,8,8,7,7], [4,8,8,7,7], [1,16,16,0,7] ];

	List ( type: List ( type: uint(size=5), size=5), size=24 ) B_tab = //[mb_type][NumMbPart / MbPartWidth / MbPartHeight /MbPartPredMode,0 / MbPartPredMode,1]
		[ 
			[0,8,8,3,0], [1,16,16,0,7], [1,16,16,1,7], [1,16,16,2,7], 
			[2,16,8,0,0], [2,8,16,0,0], [2,16,8,1,1], [2,8,16,1,1],
			[2,16,8,0,1], [2,8,16,0,1], [2,16,8,1,0], [2,8,16,1,0],
			[2,16,8,0,2], [2,8,16,0,2], [2,16,8,1,2], [2,8,16,1,2],
			[2,16,8,2,0], [2,8,16,2,0], [2,16,8,2,1], [2,8,16,2,1], 
			[2,16,8,2,2], [2,8,16,2,2], [4,8,8,7,7],[0,8,8,3,7] 
		];

	List ( type: List ( type: uint(size=6), size=2), size=64 ) CBP_Table = // [codeNum][CBP Intra_4x4,Intra_8x8 / CBP Inter]
		[ // chroma_format_idc is equal to 0
			[15,0],[0,1], [7,2], [11,4],[13,8],[14,3], [3,5],[5,10],
			[10,12],[12,15], [1,7], [2,11],[4,13],[8,14], [6,6], [9,9],
			// chroma_format_idc is not equal to 0
			[47,0],[31,16],[15,1],[0,2],[23,4],[27,8],[29,32],[30,3],
			[7, 5],[11,10],[13,12],[14,15],[39,47],[43,7],[45,11],[46,13],
			[16,14], [3,6],[5,9],[10,31],[12,35],[19,37],[21,42],[26,44],
			[28,33],[35,34],[37,36],[42,40],[44,39],[1,43],[2,45],[4,46],
			[8,17],[17,18],[18,20],[20,24],[24,19],[6,21],[9,26],[22,28],
			[25,23],[32,27],[33,29],[34,30],[36,22],[40,25],[38,38],[41,41]    
		];

	/*************************************************************
	*************************************************************
	********       			Sub Mb Pred    	    		*********
	*************************************************************
	*************************************************************/

	uint(size=3) mbPartIdx;
	uint(size=3) subMbPartIdx;
	List (type:uint,size=5) sub_mb_type := [ 0 : for int i in 0 .. 4];
	List (type:int,size=4) ref_idx_l0 := [ 0 : for int i in 0 .. 3];
	List (type:int,size=4) ref_idx_l1 := [ 0 : for int i in 0 .. 3];
	int mvd_l0 := 0;
	int mvd_l1 := 0;

	/*************************************************************
	*************************************************************
	********       			Mb Pred    	    		*********
	*************************************************************
	*************************************************************/

	uint(size=5) luma4x4BlkIdx;
	uint(size=1) prev_intra4x4_pred_mode_flag := 0;
	List (type:uint(size=4),size=16) rem_intra4x4_pred_mode := [ 0 : for int i in 1 .. 16];
	uint(size=2) intra_chroma_pred_mode;
	//*************************************************************/


	//******* dec_ref_pic_marking  ********/
	uint(size=1) no_output_of_prior_pics_flag;
	uint(size=1) long_term_reference_flag;
	uint(size=1) adaptative_ref_pic_marking_mode_flag;
	uint(size=3) memory_management_control_operation;
	uint(size=5) difference_of_pic_nums_minus1;
	uint(size=5) long_term_pic_num;
	uint(size=5) long_term_frame_idx;
	uint(size=5) max_long_term_frame_idx_plus1;

	/*************************************************************
	*************************************************************
	********       		Residual Block CAVLC   	    *********
	*************************************************************
	*************************************************************/
	int(size=6) nc;
	List ( type: List(type: uint(size=4), size=16), size = PICHEIGHT*PICWIDTH) NonZeroCount; // FIXME those numbers should be independent of the size
	List ( type: List(type: uint(size=4), size=4), size=PICHEIGHT*PICWIDTH) NonZeroCountCb; // FIXME those numbers should be independent of the size
	List ( type: List(type: uint(size=4), size=4), size=PICHEIGHT*PICWIDTH) NonZeroCountCr; // FIXME those numbers should be independent of the size
	uint(size=3) suffixLength;
	uint(size=5) inc_nb_coeff;
	uint level_prefix;
	uint(size=16) val_cbp_blk:=0;
	uint levelCode;
	uint(size=4) zerosLeft;
	int(size=16) coeff_sent := 0;

	List (type:int(size=16),size=16) level := [ 0 : for int i in 1 .. 16];
	List (type:uint(size=4),size=16) run := [ 0 : for int i in 1 .. 16];
	List ( type: uint(size=4), size=16) InverseScan4x4Tab := [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];

	List ( type: List ( type: uint(size=7), size=3), size=62 ) VLC_nC_0to2 = //[n][coef_length / coef_val / coef_token]
		[ 
			[1,1,0], [6,5,4], [2,1,5], [8,7,8], [6,4,9], [3,1,10], [9,7,12], [8,6,13], 
			[7,5,14], [5,3,15], [10,7,16], [9,6,17], [8,5,18], [6,3,19], [11,7,20], [10,6,21],
			[9,5,22], [7,4,23], [13,15,24], [11,6,25], [10,5,26], [8,4,27], [13,11,28], [13,14,29],
			[11,5,30], [9,4,31], [13,8,32], [13,10,33], [13,13,34], [10,4,35], [14,15,36], [14,14,37],
			[13,9,38], [11,4,39], [14,11,40], [14,10,41], [14,13,42], [13,12,43], [15,15,44], [15,14,45],
			[14,9,46], [14,12,47], [15,11,48], [15,10,49], [15,13,50], [14,8,51], [16,15,52], 
			[15,1,53], [15,9,54], [15,12,55], [16,11,56], [16,14,57], [16,13,58], [15,8,59], [16,7,60],
			[16,10,61], [16,9,62], [16,12,63], [16,4,64], [16,6,65], [16,5,66], [16,8,67] 
		];
	List ( type: List ( type: uint(size=7), size=3), size=62 ) VLC_nC_2to4 = //[n][coef_length / coef_val / coef_token]
		[
			[2,3,0], [6,11,4], [2,2,5], [6,7,8], [5,7,9], [3,3,10], [7,7,12], 
			[6,10,13], [6,9,14], [4,5,15], [8,7,16], [6,6,17], [6,5,18], [4,4,19], [8,4,20], [7,6,21],
			[7,5,22], [5,6,23], [9,7,24], [8,6,25], [8,5,26], [6,8,27], [11,15,28], [9,6,29], [9,5,30],
			[6,4,31], [11,11,32], [11,14,33], [11,13,34], [7,4,35], [12,15,36], [11,10,37],
			[11,9,38], [9,4,39], [12,11,40], [12,14,41], [12,13,42], [11,12,43], [12,8,44],
			[12,10,45], [12,9,46], [11,8,47], [13,15,48], [13,14,49], [13,13,50], [12,12,51], [13,11,52], 
			[13,10,53], [13,9,54], [13,12,55], [13,7,56], [14,11,57], [13,6,58], [13,8,59], [14,9,60],
			[14,8,61], [14,10,62], [13,1,63], [14,7,64], [14,6,65], [14,5,66], [14,4,67] 
		];
	List ( type: List ( type: uint(size=7), size=3), size=62 ) VLC_nC_4to8 = //[n][coef_length / coef_val / coef_token]
		[ 
			[4,15,0], [6,15,4], [4,14,5], [6,11,8], [5,15,9], [4,13,10], [6,8,12], 
			[5,12,13], [5,14,14], [4,12,15], [7,15,16], [5,10,17], [5,11,18], [4,11,19], [7,11,20], [5,8,21],
			[5,9,22], [4,10,23], [7,9,24], [6,14,25], [6,13,26], [4,9,27], [7,8,28], [6,10,29],
			[6,9,30], [4,8,31], [8,15,32], [7,14,33], [7,13,34], [5,13,35], [8,11,36], [8,14,37],
			[7,10,38], [6,12,39], [9,15,40], [8,10,41], [8,13,42], [7,12,43], [9,11,44], 
			[9,14,45], [8,9,46], [8,12,47], [9,8,48], [9,10,49], [9,13,50], [8,8,51], [10,13,52], 
			[9,7,53], [9,9,54], [9,12,55], [10,9,56], [10,12,57], [10,11,58], [10,10,59], 
			[10,5,60], [10,8,61], [10,7,62], [10,6,63], [10,1,64], [10,4,65], [10,3,66], [10,2,67] 
		];
	List ( type: List ( type: uint(size=7), size=3), size=62 ) VLC_nC_8 = //[n][coef_length / coef_val / coef_token]
		[ 
			[6,3,0], [6,0,4], [6,1,5], [6,4,8], [6,5,9], [6,6,10], [6,8,12], [6,9,13], [6,10,14],
			[6,11,15], [6,12,16], [6,13,17], [6,14,18], [6,15,19], [6,16,20], [6,17,21],
			[6,18,22], [6,19,23], [6,20,24], [6,21,25], [6,22,26], [6,23,27], [6,24,28], 
			[6,25,29], [6,26,30], [6,27,31], [6,28,32], [6,29,33], [6,30,34], [6,31,35], [6,32,36], [6,33,37],
			[6,34,38], [6,35,39], [6,36,40], [6,37,41], [6,38,42], [6,39,43], [6,40,44], [6,41,45], 
			[6,42,46], [6,43,47], [6,44,48], [6,45,49], [6,46,50], [6,47,51], [6,48,52], 
			[6,49,53], [6,50,54], [6,51,55], [6,52,56], [6,53,57], [6,54,58], [6,55,59], [6,56,60],
			[6,57,61], [6,58,62], [6,59,63], [6,60,64], [6,61,65], [6,62,66], [6,63,67] 
		];
	List ( type: List ( type: uint(size=7), size=3), size=14 ) VLC_nC_1 = //[n][coef_length / coef_val / coef_token]
		[ [2,1,0], [6,7,4], [1,1,5], [6,4,8], [6,6,9], [3,1,10], [6,3,12], [7,3,13], [7,2,14], [6,5,15], [6,2,16], [8,3,17], [8,2,18], [7,0,19] ];
	List ( type: List ( type: uint(size=7), size=3), size=30 ) VLC_nC_2 = //[n][coef_length / coef_val / coef_token]
		[ [1,1,0], [7,15,4], [2,1,5], [8,14,8], [8,13,9], [3,1,10], [9,7,12], [7,12,13], [7,13,14], [5,1,15], [9,6,16], [9,5,17], [7,10,18], [6,1,19], [10,7,20], [10,6,21],
		[9,4,22], [7,9,23], [11,7,24], [11,6,25], [10,5,26], [7,8,27], [12,7,28], [12,6,29], [11,5,30], [10,4,31], [13,7,32], [12,5,33], [12,4,34], [11,4,35]
		];
	List ( type:List ( type: List ( type: uint(size=4), size=3), size=16 ), size=15) VLC_total0 = //[TotalCoeff()-1][n][coef_length / coef_val / total_zeros]
		[ [ [1,1,0], [3,3,1], [3,2,2], [4,3,3], [4,2,4], [5,3,5], [5,2,6], [6,3,7], [6,2,8], [7,3,9], [7,2,10], [8,3,11], [8,2,12], [9,3,13], [9,2,14], [9,1,15] ],//tzVlcIndex = 1
		[ [3,7,0], [3,6,1], [3,5,2], [3,4,3], [3,3,4], [4,5,5], [4,4,6], [4,3,7], [4,2,8], [5,3,9], [5,2,10], [6,3,11], [6,2,12], [6,1,13], [6,0,14] ],//tzVlcIndex = 2
		[ [4,5,0], [3,7,1], [3,6,2], [3,5,3], [4,4,4], [4,3,5], [3,4,6], [3,3,7], [4,2,8], [5,3,9], [5,2,10], [6,1,11], [5,1,12], [6,0,13] ],//tzVlcIndex = 3
		[ [5,3,0], [3,7,1], [4,5,2], [4,4,3], [3,6,4], [3,5,5], [3,4,6], [4,3,7], [3,3,8], [4,2,9], [5,2,10], [5,1,11], [5,0,12] ],//tzVlcIndex = 4
		[ [4,5,0], [4,4,1], [4,3,2], [3,7,3], [3,6,4], [3,5,5], [3,4,6], [3,3,7], [4,2,8], [5,1,9], [4,1,10], [5,0,11] ],//tzVlcIndex = 5
		[ [6,1,0], [5,1,1], [3,7,2], [3,6,3], [3,5,4], [3,4,5], [3,3,6], [3,2,7], [4,1,8], [3,1,9], [6,0,10] ],//tzVlcIndex = 6
		[ [6,1,0], [5,1,1], [3,5,2], [3,4,3], [3,3,4], [2,3,5], [3,2,6], [4,1,7], [3,1,8], [6,0,9] ],//tzVlcIndex = 7
		[ [6,1,0], [4,1,1], [5,1,2], [3,3,3], [2,3,4], [2,2,5], [3,2,6], [3,1,7], [6,0,8] ],//tzVlcIndex = 8
		[ [6,1,0], [6,0,1], [4,1,2], [2,3,3], [2,2,4], [3,1,5], [2,1,6], [5,1,7] ],//tzVlcIndex = 9
		[ [5,1,0], [5,0,1], [3,1,2], [2,3,3], [2,2,4], [2,1,5], [4,1,6] ],//tzVlcIndex = 10
		[ [4,0,0], [4,1,1], [3,1,2], [3,2,3], [1,1,4], [3,3,5] ],//tzVlcIndex = 11
		[ [4,0,0], [4,1,1], [2,1,2], [1,1,3], [3,1,4]  ],//tzVlcIndex = 12
		[ [3,0,0], [3,1,1], [1,1,2], [2,1,3]  ],//tzVlcIndex = 13
		[ [2,0,0], [2,1,1], [1,1,2]  ],//tzVlcIndex = 14
		[ [1,0,0], [1,1,1]  ]//tzVlcIndex = 15
		]; 
	List ( type:List ( type: List ( type: uint(size=4), size=3), size=4 ), size=3) VLC_total0_Cr_DC2x2 = //[TotalCoeff()-1][n][coef_length / coef_val / total_zeros]
		[ [ [1,1,0], [2,1,1], [3,1,2], [3,0,3]  ],//tzVlcIndex = 1
		[ [1,1,0], [2,1,1], [2,0,2]  ],//tzVlcIndex = 2
		[ [1,1,0], [1,0,1]  ]//tzVlcIndex = 3
		]; 
	List ( type:List ( type: List ( type: uint(size=7), size=3), size=15 ), size=7) VLC_run_before = //[TotalCoeff()-1][n][coef_length / coef_val / total_zeros]
		[ [ [1,1,0], [1,0,1]  ], //zerosLeft = 1
		[ [1,1,0], [2,1,1], [2,0,2]  ], //zerosLeft = 2
		[ [2,3,0], [2,2,1], [2,1,2], [2,0,3]  ], //zerosLeft = 3
		[ [2,3,0], [2,2,1], [2,1,2], [3,1,3], [3,0,4]  ], //zerosLeft = 4
		[ [2,3,0], [2,2,1], [3,3,2], [3,2,3], [3,1,4], [3,0,5]  ], //zerosLeft = 5
		[ [2,3,0], [3,0,1], [3,1,2], [3,3,3], [3,2,4], [3,5,5], [3,4,6]  ], //zerosLeft = 6
		[ [3,7,0], [3,6,1], [3,5,2], [3,4,3], [3,3,4], [3,2,5], [3,1,6], [4,1,7], [5,1,8], [6,1,9], [7,1,10], [8,1,11], [9,1,12], [10,1,13], [11,1,14] ] //zerosLeft > 6
		];
	
	//*************************************************************
	/*************************************************************
	********       		Context Index Lists - CABAC   	 *********
	*************************************************************
	*************************************************************/
	
	List ( type: List ( type: int(size = 9), size = 2) , size = 467 ) Cabac_Context_Init_I = 
	[
		/* 0 - 10 */
		[ 20, -15 ], [  2, 54 ],  [  3,  74 ], [ 20, -15 ],
		[  2,  54 ], [  3, 74 ],  [ -28,127 ], [ -23, 104 ],
		[ -6,  53 ], [ -1, 54 ],  [  7,  51 ],
	
		/* 11 - 23 unsused for I */
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],
	
		/* 24- 39 */
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
	
		/* 40 - 53 */
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],
	
		/* 54 - 59 */
		[ 0, 0 ],    [ 0, 0 ],    [ 0, 0 ],      [ 0, 0 ],
		[ 0, 0 ],    [ 0, 0 ],
	
		/* 60 - 69 */
		[ 0, 41 ],   [ 0, 63 ],   [ 0, 63 ],     [ 0, 63 ],
		[ -9, 83 ],  [ 4, 86 ],   [ 0, 97 ],     [ -7, 72 ],
		[ 13, 41 ],  [ 3, 62 ],
	
		/* 70 -> 87 */
		[ 0, 11 ],   [ 1, 55 ],   [ 0, 69 ],     [ -17, 127 ],
		[ -13, 102 ],[ 0, 82 ],   [ -7, 74 ],    [ -21, 107 ],
		[ -27, 127 ],[ -31, 127 ],[ -24, 127 ],  [ -18, 95 ],
		[ -27, 127 ],[ -21, 114 ],[ -30, 127 ],  [ -17, 123 ],
		[ -12, 115 ],[ -16, 122 ],
	
		/* 88 -> 104 */
		[ -11, 115 ],[ -12, 63 ], [ -2, 68 ],    [ -15, 84 ],
		[ -13, 104 ],[ -3, 70 ],  [ -8, 93 ],    [ -10, 90 ],
		[ -30, 127 ],[ -1, 74 ],  [ -6, 97 ],    [ -7, 91 ],
		[ -20, 127 ],[ -4, 56 ],  [ -5, 82 ],    [ -7, 76 ],
		[ -22, 125 ],
	
		/* 105 -> 135 */
		[ -7, 93 ],  [ -11, 87 ], [ -3, 77 ],    [ -5, 71 ],
		[ -4, 63 ],  [ -4, 68 ],  [ -12, 84 ],   [ -7, 62 ],
		[ -7, 65 ],  [ 8, 61 ],   [ 5, 56 ],     [ -2, 66 ],
		[ 1, 64 ],   [ 0, 61 ],   [ -2, 78 ],    [ 1, 50 ],
		[ 7, 52 ],   [ 10, 35 ],  [ 0, 44 ],     [ 11, 38 ],
		[ 1, 45 ],   [ 0, 46 ],   [ 5, 44 ],     [ 31, 17 ],
		[ 1, 51 ],   [ 7, 50 ],   [ 28, 19 ],    [ 16, 33 ],
		[ 14, 62 ],  [ -13, 108 ],[ -15, 100 ],
	
		/* 136 -> 165 */
		[ -13, 101 ],[ -13, 91 ], [ -12, 94 ],   [ -10, 88 ],
		[ -16, 84 ], [ -10, 86 ], [ -7, 83 ],    [ -13, 87 ],
		[ -19, 94 ], [ 1, 70 ],   [ 0, 72 ],     [ -5, 74 ],
		[ 18, 59 ],  [ -8, 102 ], [ -15, 100 ],  [ 0, 95 ],
		[ -4, 75 ],  [ 2, 72 ],   [ -11, 75 ],   [ -3, 71 ],
		[ 15, 46 ],  [ -13, 69 ], [ 0, 62 ],     [ 0, 65 ],
		[ 21, 37 ],  [ -15, 72 ], [ 9, 57 ],     [ 16, 54 ],
		[ 0, 62 ],   [ 12, 72 ],
	
		/* 166 -> 196 */
		[ 24, 0 ],   [ 15, 9 ],   [ 8, 25 ],     [ 13, 18 ],
		[ 15, 9 ],   [ 13, 19 ],  [ 10, 37 ],    [ 12, 18 ],
		[ 6, 29 ],   [ 20, 33 ],  [ 15, 30 ],    [ 4, 45 ],
		[ 1, 58 ],   [ 0, 62 ],   [ 7, 61 ],     [ 12, 38 ],
		[ 11, 45 ],  [ 15, 39 ],  [ 11, 42 ],    [ 13, 44 ],
		[ 16, 45 ],  [ 12, 41 ],  [ 10, 49 ],    [ 30, 34 ],
		[ 18, 42 ],  [ 10, 55 ],  [ 17, 51 ],    [ 17, 46 ],
		[ 0, 89 ],   [ 26, -19 ], [ 22, -17 ],
	
		/* 197 -> 226 */
		[ 26, -17 ], [ 30, -25 ], [ 28, -20 ],   [ 33, -23 ],
		[ 37, -27 ], [ 33, -23 ], [ 40, -28 ],   [ 38, -17 ],
		[ 33, -11 ], [ 40, -15 ], [ 41, -6 ],    [ 38, 1 ],
		[ 41, 17 ],  [ 30, -6 ],  [ 27, 3 ],     [ 26, 22 ],
		[ 37, -16 ], [ 35, -4 ],  [ 38, -8 ],    [ 38, -3 ],
		[ 37, 3 ],   [ 38, 5 ],   [ 42, 0 ],     [ 35, 16 ],
		[ 39, 22 ],  [ 14, 48 ],  [ 27, 37 ],    [ 21, 60 ],
		[ 12, 68 ],  [ 2, 97 ],
	
		/* 227 -> 251 */
		[ -3, 71 ],  [ -6, 42 ],  [ -5, 50 ],    [ -3, 54 ],
		[ -2, 62 ],  [ 0, 58 ],   [ 1, 63 ],     [ -2, 72 ],
		[ -1, 74 ],  [ -9, 91 ],  [ -5, 67 ],    [ -5, 27 ],
		[ -3, 39 ],  [ -2, 44 ],  [ 0, 46 ],     [ -16, 64 ],
		[ -8, 68 ],  [ -10, 78 ], [ -6, 77 ],    [ -10, 86 ],
		[ -12, 92 ], [ -15, 55 ], [ -10, 60 ],   [ -6, 62 ],
		[ -4, 65 ],
	
		/* 252 -> 275 */
		[ -12, 73 ], [ -8, 76 ],  [ -7, 80 ],    [ -9, 88 ],
		[ -17, 110 ],[ -11, 97 ], [ -20, 84 ],   [ -11, 79 ],
		[ -6, 73 ],  [ -4, 74 ],  [ -13, 86 ],   [ -13, 96 ],
		[ -11, 97 ], [ -19, 117 ],[ -8, 78 ],    [ -5, 33 ],
		[ -4, 48 ],  [ -2, 53 ],  [ -3, 62 ],    [ -13, 71 ],
		[ -10, 79 ], [ -12, 86 ], [ -13, 90 ],   [ -14, 97 ],
	
		/* 276 a bit special (not used, bypass is used instead) */
		[ 0, 0 ],
	
		/* 277 -> 307 */
		[ -6, 93 ],  [ -6, 84 ],  [ -8, 79 ],    [ 0, 66 ],
		[ -1, 71 ],  [ 0, 62 ],   [ -2, 60 ],    [ -2, 59 ],
		[ -5, 75 ],  [ -3, 62 ],  [ -4, 58 ],    [ -9, 66 ],
		[ -1, 79 ],  [ 0, 71 ],   [ 3, 68 ],     [ 10, 44 ],
		[ -7, 62 ],  [ 15, 36 ],  [ 14, 40 ],    [ 16, 27 ],
		[ 12, 29 ],  [ 1, 44 ],   [ 20, 36 ],    [ 18, 32 ],
		[ 5, 42 ],   [ 1, 48 ],   [ 10, 62 ],    [ 17, 46 ],
		[ 9, 64 ],   [ -12, 104 ],[ -11, 97 ],
	
		/* 308 -> 337 */
		[ -16, 96 ], [ -7, 88 ],  [ -8, 85 ],    [ -7, 85 ],
		[ -9, 85 ],  [ -13, 88 ], [ 4, 66 ],     [ -3, 77 ],
		[ -3, 76 ],  [ -6, 76 ],  [ 10, 58 ],    [ -1, 76 ],
		[ -1, 83 ],  [ -7, 99 ],  [ -14, 95 ],   [ 2, 95 ],
		[ 0, 76 ],   [ -5, 74 ],  [ 0, 70 ],     [ -11, 75 ],
		[ 1, 68 ],   [ 0, 65 ],   [ -14, 73 ],   [ 3, 62 ],
		[ 4, 62 ],   [ -1, 68 ],  [ -13, 75 ],   [ 11, 55 ],
		[ 5, 64 ],   [ 12, 70 ],
	
		/* 338 -> 368 */
		[ 15, 6 ],   [ 6, 19 ],   [ 7, 16 ],     [ 12, 14 ],
		[ 18, 13 ],  [ 13, 11 ],  [ 13, 15 ],    [ 15, 16 ],
		[ 12, 23 ],  [ 13, 23 ],  [ 15, 20 ],    [ 14, 26 ],
		[ 14, 44 ],  [ 17, 40 ],  [ 17, 47 ],    [ 24, 17 ],
		[ 21, 21 ],  [ 25, 22 ],  [ 31, 27 ],    [ 22, 29 ],
		[ 19, 35 ],  [ 14, 50 ],  [ 10, 57 ],    [ 7, 63 ],
		[ -2, 77 ],  [ -4, 82 ],  [ -3, 94 ],    [ 9, 69 ],
		[ -12, 109 ],[ 36, -35 ], [ 36, -34 ],
	
		/* 369 -> 398 */
		[ 32, -26 ], [ 37, -30 ], [ 44, -32 ],   [ 34, -18 ],
		[ 34, -15 ], [ 40, -15 ], [ 33, -7 ],    [ 35, -5 ],
		[ 33, 0 ],   [ 38, 2 ],   [ 33, 13 ],    [ 23, 35 ],
		[ 13, 58 ],  [ 29, -3 ],  [ 26, 0 ],     [ 22, 30 ],
		[ 31, -7 ],  [ 35, -15 ], [ 34, -3 ],    [ 34, 3 ],
		[ 36, -1 ],  [ 34, 5 ],   [ 32, 11 ],    [ 35, 5 ],
		[ 34, 12 ],  [ 39, 11 ],  [ 30, 29 ],    [ 34, 26 ],
		[ 29, 39 ],  [ 19, 66 ],
	
		/* 399 -> 435 */
		[  31,  21 ], [  31,  31 ], [  25,  50 ],
		[ -17, 120 ], [ -20, 112 ], [ -18, 114 ], [ -11,  85 ],
		[ -15,  92 ], [ -14,  89 ], [ -26,  71 ], [ -15,  81 ],
		[ -14,  80 ], [   0,  68 ], [ -14,  70 ], [ -24,  56 ],
		[ -23,  68 ], [ -24,  50 ], [ -11,  74 ], [  23, -13 ],
		[  26, -13 ], [  40, -15 ], [  49, -14 ], [  44,   3 ],
		[  45,   6 ], [  44,  34 ], [  33,  54 ], [  19,  82 ],
		[  -3,  75 ], [  -1,  23 ], [   1,  34 ], [   1,  43 ],
		[   0,  54 ], [  -2,  55 ], [   0,  61 ], [   1,  64 ],
		[   0,  68 ], [  -9,  92 ],
	
		/* 436 -> 459 */
		[ -14, 106 ], [ -13,  97 ], [ -15,  90 ], [ -12,  90 ],
		[ -18,  88 ], [ -10,  73 ], [  -9,  79 ], [ -14,  86 ],
		[ -10,  73 ], [ -10,  70 ], [ -10,  69 ], [  -5,  66 ],
		[  -9,  64 ], [  -5,  58 ], [   2,  59 ], [  21, -10 ],
		[  24, -11 ], [  28,  -8 ], [  28,  -1 ], [  29,   3 ],
		[  29,   9 ], [  35,  20 ], [  29,  36 ], [  14,  67 ],
	
	
		//Svc Stuff
		//Be carefull, should be a ctxIdx == 1024 to 1029
		/* 460 -> 466 */
		[ -14, 138 ], [ -22, 140 ], [ -11,  99],
		[  -6,  67 ], [  -6,  67 ], [ -23, 104 ], [ -35, 106]
	];	
	
	List ( type: List ( type: List (type: int(size=2), size = 2) , size = 467), size = 3 ) Cabac_Context_Init_PB = 
	
	[
		/* i_cabac_init_idc == 0 */
		[
			/* 0 - 10 */
			[  20, -15 ], [   2,  54 ], [   3,  74 ], [  20, -15 ],
			[   2,  54 ], [   3,  74 ], [ -28, 127 ], [ -23, 104 ],
			[  -6,  53 ], [  -1,  54 ], [   7,  51 ],
	
			/* 11 - 23 */
			[  23,  33 ], [  23,   2 ], [  21,   0 ], [   1,   9 ],
			[   0,  49 ], [ -37, 118 ], [   5,  57 ], [ -13,  78 ],
			[ -11,  65 ], [   1,  62 ], [  12,  49 ], [  -4,  73 ],
			[  17,  50 ],
	
			/* 24 - 39 */
			[  18,  64 ], [   9,  43 ], [  29,   0 ], [  26,  67 ],
			[  16,  90 ], [   9, 104 ], [ -46, 127 ], [ -20, 104 ],
			[   1,  67 ], [ -13,  78 ], [ -11,  65 ], [   1,  62 ],
			[  -6,  86 ], [ -17,  95 ], [  -6,  61 ], [   9,  45 ],
	
			/* 40 - 53 */
			[  -3,  69 ], [  -6,  81 ], [ -11,  96 ], [   6,  55 ],
			[   7,  67 ], [  -5,  86 ], [   2,  88 ], [   0,  58 ],
			[  -3,  76 ], [ -10,  94 ], [   5,  54 ], [   4,  69 ],
			[  -3,  81 ], [   0,  88 ],
	
			/* 54 - 59 */
			[  -7,  67 ], [  -5,  74 ], [  -4,  74 ], [  -5,  80 ],
			[  -7,  72 ], [   1,  58 ],
	
			/* 60 - 69 */
			[   0,  41 ], [   0,  63 ], [   0,  63 ], [ 0, 63 ],
			[  -9,  83 ], [   4,  86 ], [   0,  97 ], [ -7, 72 ],
			[  13,  41 ], [   3,  62 ],
	
			/* 70 - 87 */
			[   0,  45 ], [  -4,  78 ], [  -3,  96 ], [ -27,  126 ],
			[ -28,  98 ], [ -25, 101 ], [ -23,  67 ], [ -28,  82 ],
			[ -20,  94 ], [ -16,  83 ], [ -22, 110 ], [ -21,  91 ],
			[ -18, 102 ], [ -13,  93 ], [ -29, 127 ], [  -7,  92 ],
			[  -5,  89 ], [  -7,  96 ], [ -13, 108 ], [  -3,  46 ],
			[  -1,  65 ], [  -1,  57 ], [  -9,  93 ], [  -3,  74 ],
			[  -9,  92 ], [  -8,  87 ], [ -23, 126 ], [   5,  54 ],
			[   6,  60 ], [   6,  59 ], [   6,  69 ], [  -1,  48 ],
			[   0,  68 ], [  -4,  69 ], [  -8,  88 ],
	
			/* 105 -> 165 */
			[  -2,  85 ], [  -6,  78 ], [  -1,  75 ], [  -7,  77 ],
			[   2,  54 ], [   5,  50 ], [  -3,  68 ], [   1,  50 ],
			[   6,  42 ], [  -4,  81 ], [   1,  63 ], [  -4,  70 ],
			[   0,  67 ], [   2,  57 ], [  -2,  76 ], [  11,  35 ],
			[   4,  64 ], [   1,  61 ], [  11,  35 ], [  18,  25 ],
			[  12,  24 ], [  13,  29 ], [  13,  36 ], [ -10,  93 ],
			[  -7,  73 ], [  -2,  73 ], [  13,  46 ], [   9,  49 ],
			[  -7, 100 ], [   9,  53 ], [   2,  53 ], [   5,  53 ],
			[  -2,  61 ], [   0,  56 ], [   0,  56 ], [ -13,  63 ],
			[  -5,  60 ], [  -1,  62 ], [   4,  57 ], [  -6,  69 ],
			[   4,  57 ], [  14,  39 ], [   4,  51 ], [  13,  68 ],
			[   3,  64 ], [   1,  61 ], [   9,  63 ], [   7,  50 ],
			[  16,  39 ], [   5,  44 ], [   4,  52 ], [  11,  48 ],
			[  -5,  60 ], [  -1,  59 ], [   0,  59 ], [  22,  33 ],
			[   5,  44 ], [  14,  43 ], [  -1,  78 ], [   0,  60 ],
			[   9,  69 ],
	
			/* 166 - 226 */
			[  11,  28 ], [   2,  40 ], [   3,  44 ], [   0,  49 ],
			[   0,  46 ], [   2,  44 ], [   2,  51 ], [   0,  47 ],
			[   4,  39 ], [   2,  62 ], [   6,  46 ], [   0,  54 ],
			[   3,  54 ], [   2,  58 ], [   4,  63 ], [   6,  51 ],
			[   6,  57 ], [   7,  53 ], [   6,  52 ], [   6,  55 ],
			[  11,  45 ], [  14,  36 ], [   8,  53 ], [  -1,  82 ],
			[   7,  55 ], [  -3,  78 ], [  15,  46 ], [  22,  31 ],
			[  -1,  84 ], [  25,   7 ], [  30,  -7 ], [  28,   3 ],
			[  28,   4 ], [  32,   0 ], [  34,  -1 ], [  30,   6 ],
			[  30,   6 ], [  32,   9 ], [  31,  19 ], [  26,  27 ],
			[  26,  30 ], [  37,  20 ], [  28,  34 ], [  17,  70 ],
			[   1,  67 ], [   5,  59 ], [   9,  67 ], [  16,  30 ],
			[  18,  32 ], [  18,  35 ], [  22,  29 ], [  24,  31 ],
			[  23,  38 ], [  18,  43 ], [  20,  41 ], [  11,  63 ],
			[   9,  59 ], [   9,  64 ], [  -1,  94 ], [  -2,  89 ],
			[  -9, 108 ],
	
			/* 227 - 275 */
			[  -6,  76 ], [  -2,  44 ], [   0,  45 ], [   0,  52 ],
			[  -3,  64 ], [  -2,  59 ], [  -4,  70 ], [  -4,  75 ],
			[  -8,  82 ], [ -17, 102 ], [  -9,  77 ], [   3,  24 ],
			[   0,  42 ], [   0,  48 ], [   0,  55 ], [  -6,  59 ],
			[  -7,  71 ], [ -12,  83 ], [ -11,  87 ], [ -30, 119 ],
			[   1,  58 ], [  -3,  29 ], [  -1,  36 ], [   1,  38 ],
			[   2,  43 ], [  -6,  55 ], [   0,  58 ], [   0,  64 ],
			[  -3,  74 ], [ -10,  90 ], [   0,  70 ], [  -4,  29 ],
			[   5,  31 ], [   7,  42 ], [   1,  59 ], [  -2,  58 ],
			[  -3,  72 ], [  -3,  81 ], [ -11,  97 ], [   0,  58 ],
			[   8,   5 ], [  10,  14 ], [  14,  18 ], [  13,  27 ],
			[   2,  40 ], [   0,  58 ], [  -3,  70 ], [  -6,  79 ],
			[  -8,  85 ],
	
			/* 276 a bit special (not used, bypass is used instead) */
			[ 0, 0 ],
	
			/* 277 - 337 */
			[ -13, 106 ], [ -16, 106 ], [ -10,  87 ], [ -21, 114 ],
			[ -18, 110 ], [ -14,  98 ], [ -22, 110 ], [ -21, 106 ],
			[ -18, 103 ], [ -21, 107 ], [ -23, 108 ], [ -26, 112 ],
			[ -10,  96 ], [ -12,  95 ], [  -5,  91 ], [  -9,  93 ],
			[ -22,  94 ], [  -5,  86 ], [   9,  67 ], [  -4,  80 ],
			[ -10,  85 ], [  -1,  70 ], [   7,  60 ], [   9,  58 ],
			[   5,  61 ], [  12,  50 ], [  15,  50 ], [  18,  49 ],
			[  17,  54 ], [  10,  41 ], [   7,  46 ], [  -1,  51 ],
			[   7,  49 ], [   8,  52 ], [   9,  41 ], [   6,  47 ],
			[   2,  55 ], [  13,  41 ], [  10,  44 ], [   6,  50 ],
			[   5,  53 ], [  13,  49 ], [   4,  63 ], [   6,  64 ],
			[  -2,  69 ], [  -2,  59 ], [   6,  70 ], [  10,  44 ],
			[   9,  31 ], [  12,  43 ], [   3,  53 ], [  14,  34 ],
			[  10,  38 ], [  -3,  52 ], [  13,  40 ], [  17,  32 ],
			[   7,  44 ], [   7,  38 ], [  13,  50 ], [  10,  57 ],
			[  26,  43 ],
	
			/* 338 - 398 */
			[  14,  11 ], [  11,  14 ], [   9,  11 ], [  18,  11 ],
			[  21,   9 ], [  23,  -2 ], [  32, -15 ], [  32, -15 ],
			[  34, -21 ], [  39, -23 ], [  42, -33 ], [  41, -31 ],
			[  46, -28 ], [  38, -12 ], [  21,  29 ], [  45, -24 ],
			[  53, -45 ], [  48, -26 ], [  65, -43 ], [  43, -19 ],
			[  39, -10 ], [  30,   9 ], [  18,  26 ], [  20,  27 ],
			[   0,  57 ], [ -14,  82 ], [  -5,  75 ], [ -19,  97 ],
			[ -35, 125 ], [  27,   0 ], [  28,   0 ], [  31,  -4 ],
			[  27,   6 ], [  34,   8 ], [  30,  10 ], [  24,  22 ],
			[  33,  19 ], [  22,  32 ], [  26,  31 ], [  21,  41 ],
			[  26,  44 ], [  23,  47 ], [  16,  65 ], [  14,  71 ],
			[   8,  60 ], [   6,  63 ], [  17,  65 ], [  21,  24 ],
			[  23,  20 ], [  26,  23 ], [  27,  32 ], [  28,  23 ],
			[  28,  24 ], [  23,  40 ], [  24,  32 ], [  28,  29 ],
			[  23,  42 ], [  19,  57 ], [  22,  53 ], [  22,  61 ],
			[  11,  86 ],
	
			/* 399 - 435 */
			[  12,  40 ], [  11,  51 ], [  14,  59 ],
			[  -4,  79 ], [  -7,  71 ], [  -5,  69 ], [  -9,  70 ],
			[  -8,  66 ], [ -10,  68 ], [ -19,  73 ], [ -12,  69 ],
			[ -16,  70 ], [ -15,  67 ], [ -20,  62 ], [ -19,  70 ],
			[ -16,  66 ], [ -22,  65 ], [ -20,  63 ], [   9,  -2 ],
			[  26,  -9 ], [  33,  -9 ], [  39,  -7 ], [  41,  -2 ],
			[  45,   3 ], [  49,   9 ], [  45,  27 ], [  36,  59 ],
			[  -6,  66 ], [  -7,  35 ], [  -7,  42 ], [  -8,  45 ],
			[  -5,  48 ], [ -12,  56 ], [  -6,  60 ], [  -5,  62 ],
			[  -8,  66 ], [  -8,  76 ],
	
			/* 436 - 459 */
			[  -5,  85 ], [  -6,  81 ], [ -10,  77 ], [  -7,  81 ],
			[ -17,  80 ], [ -18,  73 ], [  -4,  74 ], [ -10,  83 ],
			[  -9,  71 ], [  -9,  67 ], [  -1,  61 ], [  -8,  66 ],
			[ -14,  66 ], [   0,  59 ], [   2,  59 ], [  21, -13 ],
			[  33, -14 ], [  39,  -7 ], [  46,  -2 ], [  51,   2 ],
			[  60,   6 ], [  61,  17 ], [  55,  34 ], [  42,  62 ],
	
			//Svc Stuff
			//Be carefull, should be a ctxIdx == 1024 to 1029
			/* 460 -> 467 */
			[  0,   75 ], [   2,  65 ], [   2,  59],
			[  -6,  67 ], [  -6,  67 ], [ -23, 104 ], [ -35, 106]
		],
	
			/* i_cabac_init_idc == 1 */
		[
			/* 0 - 10 */
			[  20, -15 ], [   2,  54 ], [   3,  74 ], [  20, -15 ],
			[   2,  54 ], [   3,  74 ], [ -28, 127 ], [ -23, 104 ],
			[  -6,  53 ], [  -1,  54 ], [   7,  51 ],
	
			/* 11 - 23 */
			[  22,  25 ], [  34,   0 ], [  16,   0 ], [  -2,   9 ],
			[   4,  41 ], [ -29, 118 ], [   2,  65 ], [  -6,  71 ],
			[ -13,  79 ], [   5,  52 ], [   9,  50 ], [  -3,  70 ],
			[  10,  54 ],
	
			/* 24 - 39 */
			[  26,  34 ], [  19,  22 ], [  40,   0 ], [  57,   2 ],
			[  41,  36 ], [  26,  69 ], [ -45, 127 ], [ -15, 101 ],
			[  -4,  76 ], [  -6,  71 ], [ -13,  79 ], [   5,  52 ],
			[   6,  69 ], [ -13,  90 ], [   0,  52 ], [   8,  43 ],
	
			/* 40 - 53 */
			[  -2,  69 ],[  -5,  82 ],[ -10,  96 ],[   2,  59 ],
			[   2,  75 ],[  -3,  87 ],[  -3,  100 ],[   1,  56 ],
			[  -3,  74 ],[  -6,  85 ],[   0,  59 ],[  -3,  81 ],
			[  -7,  86 ],[  -5,  95 ],
	
			/* 54 - 59 */
			[  -1,  66 ],[  -1,  77 ],[   1,  70 ],[  -2,  86 ],
			[  -5,  72 ],[   0,  61 ],
	
			/* 60 - 69 */
			[ 0, 41 ],   [ 0, 63 ],   [ 0, 63 ],     [ 0, 63 ],
			[ -9, 83 ],  [ 4, 86 ],   [ 0, 97 ],     [ -7, 72 ],
			[ 13, 41 ],  [ 3, 62 ],
	
			/* 70 - 104 */
			[  13,  15 ], [   7,  51 ], [   2,  80 ], [ -39, 127 ],
			[ -18,  91 ], [ -17,  96 ], [ -26,  81 ], [ -35,  98 ],
			[ -24, 102 ], [ -23,  97 ], [ -27, 119 ], [ -24,  99 ],
			[ -21, 110 ], [ -18, 102 ], [ -36, 127 ], [   0,  80 ],
			[  -5,  89 ], [  -7,  94 ], [  -4,  92 ], [   0,  39 ],
			[   0,  65 ], [ -15,  84 ], [ -35, 127 ], [  -2,  73 ],
			[ -12, 104 ], [  -9,  91 ], [ -31, 127 ], [   3,  55 ],
			[   7,  56 ], [   7,  55 ], [   8,  61 ], [  -3,  53 ],
			[   0,  68 ], [  -7,  74 ], [  -9,  88 ],
	
			/* 105 -> 165 */
			[ -13, 103 ], [ -13,  91 ], [  -9,  89 ], [ -14,  92 ],
			[  -8,  76 ], [ -12,  87 ], [ -23, 110 ], [ -24, 105 ],
			[ -10,  78 ], [ -20, 112 ], [ -17,  99 ], [ -78, 127 ],
			[ -70, 127 ], [ -50, 127 ], [ -46, 127 ], [  -4,  66 ],
			[  -5,  78 ], [  -4,  71 ], [  -8,  72 ], [   2,  59 ],
			[  -1,  55 ], [  -7,  70 ], [  -6,  75 ], [  -8,  89 ],
			[ -34, 119 ], [  -3,  75 ], [  32,  20 ], [  30,  22 ],
			[ -44, 127 ], [   0,  54 ], [  -5,  61 ], [   0,  58 ],
			[  -1,  60 ], [  -3,  61 ], [  -8,  67 ], [ -25,  84 ],
			[ -14,  74 ], [  -5,  65 ], [   5,  52 ], [   2,  57 ],
			[   0,  61 ], [  -9,  69 ], [ -11,  70 ], [  18,  55 ],
			[  -4,  71 ], [   0,  58 ], [   7,  61 ], [   9,  41 ],
			[  18,  25 ], [   9,  32 ], [   5,  43 ], [   9,  47 ],
			[   0,  44 ], [   0,  51 ], [   2,  46 ], [  19,  38 ],
			[  -4,  66 ], [  15,  38 ], [  12,  42 ], [   9,  34 ],
			[   0,  89 ],
	
			/* 166 - 226 */
			[   4,  45 ], [  10,  28 ], [  10,  31 ], [  33, -11 ],
			[  52, -43 ], [  18,  15 ], [  28,   0 ], [  35, -22 ],
			[  38, -25 ], [  34,   0 ], [  39, -18 ], [  32, -12 ],
			[ 102, -94 ], [   0,   0 ], [  56, -15 ], [  33,  -4 ],
			[  29,  10 ], [  37,  -5 ], [  51, -29 ], [  39,  -9 ],
			[  52, -34 ], [  69, -58 ], [  67, -63 ], [  44,  -5 ],
			[  32,   7 ], [  55, -29 ], [  32,   1 ], [   0,   0 ],
			[  27,  36 ], [  33, -25 ], [  34, -30 ], [  36, -28 ],
			[  38, -28 ], [  38, -27 ], [  34, -18 ], [  35, -16 ],
			[  34, -14 ], [  32,  -8 ], [  37,  -6 ], [  35,   0 ],
			[  30,  10 ], [  28,  18 ], [  26,  25 ], [  29,  41 ],
			[   0,  75 ], [   2,  72 ], [   8,  77 ], [  14,  35 ],
			[  18,  31 ], [  17,  35 ], [  21,  30 ], [  17,  45 ],
			[  20,  42 ], [  18,  45 ], [  27,  26 ], [  16,  54 ],
			[   7,  66 ], [  16,  56 ], [  11,  73 ], [  10,  67 ],
			[ -10, 116 ],
	
			/* 227 - 275 */
			[ -23, 112 ], [ -15,  71 ], [  -7,  61 ], [   0,  53 ],
			[  -5,  66 ], [ -11,  77 ], [  -9,  80 ], [  -9,  84 ],
			[ -10,  87 ], [ -34, 127 ], [ -21, 101 ], [  -3,  39 ],
			[  -5,  53 ], [  -7,  61 ], [ -11,  75 ], [ -15,  77 ],
			[ -17,  91 ], [ -25, 107 ], [ -25, 111 ], [ -28, 122 ],
			[ -11,  76 ], [ -10,  44 ], [ -10,  52 ], [ -10,  57 ],
			[  -9,  58 ], [ -16,  72 ], [  -7,  69 ], [  -4,  69 ],
			[  -5,  74 ], [  -9,  86 ], [   2,  66 ], [  -9,  34 ],
			[   1,  32 ], [  11,  31 ], [   5,  52 ], [  -2,  55 ],
			[  -2,  67 ], [   0,  73 ], [  -8,  89 ], [   3,  52 ],
			[   7,   4 ], [  10,   8 ], [  17,   8 ], [  16,  19 ],
			[   3,  37 ], [  -1,  61 ], [  -5,  73 ], [  -1,  70 ],
			[  -4,  78 ],
	
			/* 276 a bit special (not used, bypass is used instead) */
			[ 0, 0 ],
	
			/* 277 - 337 */
			[ -21, 126 ], [ -23, 124 ], [ -20, 110 ], [ -26, 126 ],
			[ -25, 124 ], [ -17, 105 ], [ -27, 121 ], [ -27, 117 ],
			[ -17, 102 ], [ -26, 117 ], [ -27, 116 ], [ -33, 122 ],
			[ -10,  95 ], [ -14, 100 ], [  -8,  95 ], [ -17, 111 ],
			[ -28, 114 ], [  -6,  89 ], [  -2,  80 ], [  -4,  82 ],
			[  -9,  85 ], [  -8,  81 ], [  -1,  72 ], [   5,  64 ],
			[   1,  67 ], [   9,  56 ], [   0,  69 ], [   1,  69 ],
			[   7,  69 ], [  -7,  69 ], [  -6,  67 ], [ -16,  77 ],
			[  -2,  64 ], [   2,  61 ], [  -6,  67 ], [  -3,  64 ],
			[   2,  57 ], [  -3,  65 ], [  -3,  66 ], [   0,  62 ],
			[   9,  51 ], [  -1,  66 ], [  -2,  71 ], [  -2,  75 ],
			[  -1,  70 ], [  -9,  72 ], [  14,  60 ], [  16,  37 ],
			[   0,  47 ], [  18,  35 ], [  11,  37 ], [  12,  41 ],
			[  10,  41 ], [   2,  48 ], [  12,  41 ], [  13,  41 ],
			[   0,  59 ], [   3,  50 ], [  19,  40 ], [   3,  66 ],
			[  18,  50 ],
	
			/* 338 - 398 */
			[  19,  -6 ], [  18,  -6 ], [  14,   0 ], [  26, -12 ],
			[  31, -16 ], [  33, -25 ], [  33, -22 ], [  37, -28 ],
			[  39, -30 ], [  42, -30 ], [  47, -42 ], [  45, -36 ],
			[  49, -34 ], [  41, -17 ], [  32,   9 ], [  69, -71 ],
			[  63, -63 ], [  66, -64 ], [  77, -74 ], [  54, -39 ],
			[  52, -35 ], [  41, -10 ], [  36,   0 ], [  40,  -1 ],
			[  30,  14 ], [  28,  26 ], [  23,  37 ], [  12,  55 ],
			[  11,  65 ], [  37, -33 ], [  39, -36 ], [  40, -37 ],
			[  38, -30 ], [  46, -33 ], [  42, -30 ], [  40, -24 ],
			[  49, -29 ], [  38, -12 ], [  40, -10 ], [  38,  -3 ],
			[  46,  -5 ], [  31,  20 ], [  29,  30 ], [  25,  44 ],
			[  12,  48 ], [  11,  49 ], [  26,  45 ], [  22,  22 ],
			[  23,  22 ], [  27,  21 ], [  33,  20 ], [  26,  28 ],
			[  30,  24 ], [  27,  34 ], [  18,  42 ], [  25,  39 ],
			[  18,  50 ], [  12,  70 ], [  21,  54 ], [  14,  71 ],
			[  11,  83 ],
	
			/* 399 - 435 */
			[  25,  32 ], [  21,  49 ], [  21,  54 ],
			[  -5,  85 ], [  -6,  81 ], [ -10,  77 ], [  -7,  81 ],
			[ -17,  80 ], [ -18,  73 ], [  -4,  74 ], [ -10,  83 ],
			[  -9,  71 ], [  -9,  67 ], [  -1,  61 ], [  -8,  66 ],
			[ -14,  66 ], [   0,  59 ], [   2,  59 ], [  17, -10 ],
			[  32, -13 ], [  42,  -9 ], [  49,  -5 ], [  53,   0 ],
			[  64,   3 ], [  68,  10 ], [  66,  27 ], [  47,  57 ],
			[  -5,  71 ], [   0,  24 ], [  -1,  36 ], [  -2,  42 ],
			[  -2,  52 ], [  -9,  57 ], [  -6,  63 ], [  -4,  65 ],
			[  -4,  67 ], [  -7,  82 ],
	
			/* 436 - 459 */
			[  -3,  81 ], [  -3,  76 ], [  -7,  72 ], [  -6,  78 ],
			[ -12,  72 ], [ -14,  68 ], [  -3,  70 ], [  -6,  76 ],
			[  -5,  66 ], [  -5,  62 ], [   0,  57 ], [  -4,  61 ],
			[  -9,  60 ], [   1,  54 ], [   2,  58 ], [  17, -10 ],
			[  32, -13 ], [  42,  -9 ], [  49,  -5 ], [  53,   0 ],
			[  64,   3 ], [  68,  10 ], [  66,  27 ], [  47,  57 ],
	
			//Svc Stuff
			//Be carefull, should be a ctxIdx == 1024 to 1029
			/* 460 -> 466 */
			[  0,   75 ], [   2,  65 ], [   2,  59],
			[  -6,  67 ], [  -6,  67 ], [ -23, 104 ], [ -35, 106]
		],
	
			/* i_cabac_init_idc == 2 */
		[
			/* 0 - 10 */
			[  20, -15 ], [   2,  54 ], [   3,  74 ], [  20, -15 ],
			[   2,  54 ], [   3,  74 ], [ -28, 127 ], [ -23, 104 ],
			[  -6,  53 ], [  -1,  54 ], [   7,  51 ],
	
			/* 11 - 23 */
			[  29,  16 ], [  25,   0 ], [  14,   0 ], [ -10,  51 ],
			[  -3,  62 ], [ -27,  99 ], [  26,  16 ], [  -4,  85 ],
			[ -24, 102 ], [   5,  57 ], [   6,  57 ], [ -17,  73 ],
			[  14,  57 ],
	
			/* 24 - 39 */
			[  20,  40 ], [  20,  10 ], [  29,   0 ], [  54,   0 ],
			[  37,  42 ], [  12,  97 ], [ -32, 127 ], [ -22, 117 ],
			[  -2,  74 ], [  -4,  85 ], [ -24, 102 ], [   5,  57 ],
			[  -6,  93 ], [ -14,  88 ], [  -6,  44 ], [   4,  55 ],
	
			/* 40 - 53 */
			[ -11,  89 ],[ -15,  103 ],[ -21,  116 ],[  19,  57 ],
			[  20,  58 ],[   4,  84 ],[   6,  96 ],[   1,  63 ],
			[  -5,  85 ],[ -13,  106 ],[   5,  63 ],[   6,  75 ],
			[  -3,  90 ],[  -1,  101 ],
	
			/* 54 - 59 */
			[   3,  55 ],[  -4,  79 ],[  -2,  75 ],[ -12,  97 ],
			[  -7,  50 ],[   1,  60 ],
	
			/* 60 - 69 */
			[ 0, 41 ],   [ 0, 63 ],   [ 0, 63 ],     [ 0, 63 ],
			[ -9, 83 ],  [ 4, 86 ],   [ 0, 97 ],     [ -7, 72 ],
			[ 13, 41 ],  [ 3, 62 ],
	
			/* 70 - 104 */
			[   7,  34 ], [  -9,  88 ], [ -20, 127 ], [ -36, 127 ],
			[ -17,  91 ], [ -14,  95 ], [ -25,  84 ], [ -25,  86 ],
			[ -12,  89 ], [ -17,  91 ], [ -31, 127 ], [ -14,  76 ],
			[ -18, 103 ], [ -13,  90 ], [ -37, 127 ], [  11,  80 ],
			[   5,  76 ], [   2,  84 ], [   5,  78 ], [  -6,  55 ],
			[   4,  61 ], [ -14,  83 ], [ -37, 127 ], [  -5,  79 ],
			[ -11, 104 ], [ -11,  91 ], [ -30, 127 ], [   0,  65 ],
			[  -2,  79 ], [   0,  72 ], [  -4,  92 ], [  -6,  56 ],
			[   3,  68 ], [  -8,  71 ], [ -13,  98 ],
	
			/* 105 -> 165 */
			[  -4,  86 ], [ -12,  88 ], [  -5,  82 ], [  -3,  72 ],
			[  -4,  67 ], [  -8,  72 ], [ -16,  89 ], [  -9,  69 ],
			[  -1,  59 ], [   5,  66 ], [   4,  57 ], [  -4,  71 ],
			[  -2,  71 ], [   2,  58 ], [  -1,  74 ], [  -4,  44 ],
			[  -1,  69 ], [   0,  62 ], [  -7,  51 ], [  -4,  47 ],
			[  -6,  42 ], [  -3,  41 ], [  -6,  53 ], [   8,  76 ],
			[  -9,  78 ], [ -11,  83 ], [   9,  52 ], [   0,  67 ],
			[  -5,  90 ], [   1,  67 ], [ -15,  72 ], [  -5,  75 ],
			[  -8,  80 ], [ -21,  83 ], [ -21,  64 ], [ -13,  31 ],
			[ -25,  64 ], [ -29,  94 ], [   9,  75 ], [  17,  63 ],
			[  -8,  74 ], [  -5,  35 ], [  -2,  27 ], [  13,  91 ],
			[   3,  65 ], [  -7,  69 ], [   8,  77 ], [ -10,  66 ],
			[   3,  62 ], [  -3,  68 ], [ -20,  81 ], [   0,  30 ],
			[   1,   7 ], [  -3,  23 ], [ -21,  74 ], [  16,  66 ],
			[ -23, 124 ], [  17,  37 ], [  44, -18 ], [  50, -34 ],
			[ -22, 127 ],
	
			/* 166 - 226 */
			[   4,  39 ], [   0,  42 ], [   7,  34 ], [  11,  29 ],
			[   8,  31 ], [   6,  37 ], [   7,  42 ], [   3,  40 ],
			[   8,  33 ], [  13,  43 ], [  13,  36 ], [   4,  47 ],
			[   3,  55 ], [   2,  58 ], [   6,  60 ], [   8,  44 ],
			[  11,  44 ], [  14,  42 ], [   7,  48 ], [   4,  56 ],
			[   4,  52 ], [  13,  37 ], [   9,  49 ], [  19,  58 ],
			[  10,  48 ], [  12,  45 ], [   0,  69 ], [  20,  33 ],
			[   8,  63 ], [  35, -18 ], [  33, -25 ], [  28,  -3 ],
			[  24,  10 ], [  27,   0 ], [  34, -14 ], [  52, -44 ],
			[  39, -24 ], [  19,  17 ], [  31,  25 ], [  36,  29 ],
			[  24,  33 ], [  34,  15 ], [  30,  20 ], [  22,  73 ],
			[  20,  34 ], [  19,  31 ], [  27,  44 ], [  19,  16 ],
			[  15,  36 ], [  15,  36 ], [  21,  28 ], [  25,  21 ],
			[  30,  20 ], [  31,  12 ], [  27,  16 ], [  24,  42 ],
			[   0,  93 ], [  14,  56 ], [  15,  57 ], [  26,  38 ],
			[ -24, 127 ],
	
			/* 227 - 275 */
			[ -24, 115 ], [ -22,  82 ], [  -9,  62 ], [   0,  53 ],
			[   0,  59 ], [ -14,  85 ], [ -13,  89 ], [ -13,  94 ],
			[ -11,  92 ], [ -29, 127 ], [ -21, 100 ], [ -14,  57 ],
			[ -12,  67 ], [ -11,  71 ], [ -10,  77 ], [ -21,  85 ],
			[ -16,  88 ], [ -23, 104 ], [ -15,  98 ], [ -37, 127 ],
			[ -10,  82 ], [  -8,  48 ], [  -8,  61 ], [  -8,  66 ],
			[  -7,  70 ], [ -14,  75 ], [ -10,  79 ], [  -9,  83 ],
			[ -12,  92 ], [ -18, 108 ], [  -4,  79 ], [ -22,  69 ],
			[ -16,  75 ], [  -2,  58 ], [   1,  58 ], [ -13,  78 ],
			[  -9,  83 ], [  -4,  81 ], [ -13,  99 ], [ -13,  81 ],
			[  -6,  38 ], [ -13,  62 ], [  -6,  58 ], [  -2,  59 ],
			[ -16,  73 ], [ -10,  76 ], [ -13,  86 ], [  -9,  83 ],
			[ -10,  87 ],
	
			/* 276 a bit special (not used, bypass is used instead) */
			[ 0, 0 ],
	
			/* 277 - 337 */
			[ -22, 127 ], [ -25, 127 ], [ -25, 120 ], [ -27, 127 ],
			[ -19, 114 ], [ -23, 117 ], [ -25, 118 ], [ -26, 117 ],
			[ -24, 113 ], [ -28, 118 ], [ -31, 120 ], [ -37, 124 ],
			[ -10,  94 ], [ -15, 102 ], [ -10,  99 ], [ -13, 106 ],
			[ -50, 127 ], [  -5,  92 ], [  17,  57 ], [  -5,  86 ],
			[ -13,  94 ], [ -12,  91 ], [  -2,  77 ], [   0,  71 ],
			[  -1,  73 ], [   4,  64 ], [  -7,  81 ], [   5,  64 ],
			[  15,  57 ], [   1,  67 ], [   0,  68 ], [ -10,  67 ],
			[   1,  68 ], [   0,  77 ], [   2,  64 ], [   0,  68 ],
			[  -5,  78 ], [   7,  55 ], [   5,  59 ], [   2,  65 ],
			[  14,  54 ], [  15,  44 ], [   5,  60 ], [   2,  70 ],
			[  -2,  76 ], [ -18,  86 ], [  12,  70 ], [   5,  64 ],
			[ -12,  70 ], [  11,  55 ], [   5,  56 ], [   0,  69 ],
			[   2,  65 ], [  -6,  74 ], [   5,  54 ], [   7,  54 ],
			[  -6,  76 ], [ -11,  82 ], [  -2,  77 ], [  -2,  77 ],
			[  25,  42 ],
	
			/* 338 - 398 */
			[  17, -13 ], [  16,  -9 ], [  17, -12 ], [  27, -21 ],
			[  37, -30 ], [  41, -40 ], [  42, -41 ], [  48, -47 ],
			[  39, -32 ], [  46, -40 ], [  52, -51 ], [  46, -41 ],
			[  52, -39 ], [  43, -19 ], [  32,  11 ], [  61, -55 ],
			[  56, -46 ], [  62, -50 ], [  81, -67 ], [  45, -20 ],
			[  35,  -2 ], [  28,  15 ], [  34,   1 ], [  39,   1 ],
			[  30,  17 ], [  20,  38 ], [  18,  45 ], [  15,  54 ],
			[   0,  79 ], [  36, -16 ], [  37, -14 ], [  37, -17 ],
			[  32,   1 ], [  34,  15 ], [  29,  15 ], [  24,  25 ],
			[  34,  22 ], [  31,  16 ], [  35,  18 ], [  31,  28 ],
			[  33,  41 ], [  36,  28 ], [  27,  47 ], [  21,  62 ],
			[  18,  31 ], [  19,  26 ], [  36,  24 ], [  24,  23 ],
			[  27,  16 ], [  24,  30 ], [  31,  29 ], [  22,  41 ],
			[  22,  42 ], [  16,  60 ], [  15,  52 ], [  14,  60 ],
			[   3,  78 ], [ -16, 123 ], [  21,  53 ], [  22,  56 ],
			[  25,  61 ],
	
			/* 399 - 435 */
			[  21,  33 ], [  19,  50 ], [  17,  61 ],
			[  -3,  78 ], [  -8,  74 ], [  -9,  72 ], [ -10,  72 ],
			[ -18,  75 ], [ -12,  71 ], [ -11,  63 ], [  -5,  70 ],
			[ -17,  75 ], [ -14,  72 ], [ -16,  67 ], [  -8,  53 ],
			[ -14,  59 ], [  -9,  52 ], [ -11,  68 ], [   9,  -2 ],
			[  30, -10 ], [  31,  -4 ], [  33,  -1 ], [  33,   7 ],
			[  31,  12 ], [  37,  23 ], [  31,  38 ], [  20,  64 ],
			[  -9,  71 ], [  -7,  37 ], [  -8,  44 ], [ -11,  49 ],
			[ -10,  56 ], [ -12,  59 ], [  -8,  63 ], [  -9,  67 ],
			[  -6,  68 ], [ -10,  79 ],
	
			/* 436 - 459 */
			[  -3,  78 ], [  -8,  74 ], [  -9,  72 ], [ -10,  72 ],
			[ -18,  75 ], [ -12,  71 ], [ -11,  63 ], [  -5,  70 ],
			[ -17,  75 ], [ -14,  72 ], [ -16,  67 ], [  -8,  53 ],
			[ -14,  59 ], [  -9,  52 ], [ -11,  68 ], [   9,  -2 ],
			[  30, -10 ], [  31,  -4 ], [  33,  -1 ], [  33,   7 ],
			[  31,  12 ], [  37,  23 ], [  31,  38 ], [  20,  64 ],
	
			//Svc Stuff
			//Be carefull, should be a ctxIdx == 1024 to 1029
			/* 460 -> 466 */
			[  0,   75 ], [   2,  65 ], [   2,  59],
			[  -6,  67 ], [  -6,  67 ], [ -23, 104 ], [ -35, 106 ]
		]
	];
	
	//
	List ( type: List ( type: int , size = 14), size = 3 ) ctxIdxBlockCatOffset_tab = 
	[
		[ 0,  4,  8, 12, 16, 0, 0,  4,  8, 4, 0,  4,  8, 8 ],
		[ 0, 15, 29, 44, 47, 0, 0, 15, 29, 0, 0, 15, 29, 0 ], //significant_coeff_flag values equal to last_significant_coeff_flag values
		[ 0, 10, 20, 30, 39, 0, 0, 10, 20, 0, 0, 10, 20, 0 ]
	];
	//
	/* CABAC Arithmetic Decoding qCodIRangeIdx */
	List ( type:uint, size = 64 ) transIdxMPS = 
	[
		1, 2, 3, 4, 5, 6, 7, 8,
		9,10,11,12,13,14,15,16,
		17,18,19,20,21,22,23,24,
		25,26,27,28,29,30,31,32,
		33,34,35,36,37,38,39,40,
		41,42,43,44,45,46,47,48,
		49,50,51,52,53,54,55,56,
		57,58,59,60,61,62,62,63
	];
	//
	List ( type:uint, size = 64 ) transIdxLPS = 
	[
		0, 0, 1, 2, 2, 4, 4, 5,
		6, 7, 8, 9, 9,11,11,12,
		13,13,15,15,16,16,18,18,
		19,19,21,21,22,22,23,24,
		24,25,26,26,27,27,28,29,
		29,30,30,30,31,32,32,33,
		33,33,34,34,35,35,35,36,
		36,36,37,37,37,38,38,63
	];
	
	//
	List ( type: List ( type: uint , size = 4), size = 64 ) rangeTabLPS = 
	
	[
		[128,176,208,240], [128,167,197,227], [128,158,187,216], [123,150,178,205],
		[116,142,169,195], [111,135,160,185], [105,128,152,175], [100,122,144,166],
		[ 95,116,137,158], [ 90,110,130,150], [ 85,104,123,142], [ 81, 99,117,135],
		[ 77, 94,111,128], [ 73, 89,105,122], [ 69, 85,100,116], [ 66, 80, 95,110],
		[ 62, 76, 90,104], [ 59, 72, 86, 99], [ 56, 69, 81, 94], [ 53, 65, 77, 89],
		[ 51, 62, 73, 85], [ 48, 59, 69, 80], [ 46, 56, 66, 76], [ 43, 53, 63, 72],
		[ 41, 50, 59, 69], [ 39, 48, 56, 65], [ 37, 45, 54, 62], [ 35, 43, 51, 59],
		[ 33, 41, 48, 56], [ 32, 39, 46, 53], [ 30, 37, 43, 50], [ 29, 35, 41, 48],
		[ 27, 33, 39, 45], [ 26, 31, 37, 43], [ 24, 30, 35, 41], [ 23, 28, 33, 39],
		[ 22, 27, 32, 37], [ 21, 26, 30, 35], [ 20, 24, 29, 33], [ 19, 23, 27, 31],
		[ 18, 22, 26, 30], [ 17, 21, 25, 28], [ 16, 20, 23, 27], [ 15, 19, 22, 25],
		[ 14, 18, 21, 24], [ 14, 17, 20, 23], [ 13, 16, 19, 22], [ 12, 15, 18, 21],
		[ 12, 14, 17, 20], [ 11, 14, 16, 19], [ 11, 13, 15, 18], [ 10, 12, 15, 17],
		[ 10, 12, 14, 16], [  9, 11, 13, 15], [  9, 11, 12, 14], [  8, 10, 12, 14],
		[  8,  9, 11, 13], [  7,  9, 11, 12], [  7,  9, 10, 12], [  7,  8, 10, 11],
		[  6,  8,  9, 11], [  6,  7,  9, 10], [  6,  7,  8,  9], [  2,  2,  2,  2]
	];
	
	//*************************************************************/
	/*************************************************************
	*************************************************************
	********       		Residual		    	    *********
	*************************************************************
	*************************************************************/
	bool DEBUG_NEW_PARSER = true;
	uint(size=1) bmFlag;
	uint(size=4) startIdx;
	uint(size=4) endIdx;
	uint(size=4) block_startIdx;
	uint(size=6) block_endIdx;
	uint(size=7) maxNumCoeff;

	uint(size=3) i8x8;
	uint(size=3) i4x4;
	uint(size=3) NumC8x8;
	uint(size=2) iCbCr;
	uint(size=2) leveltype := 0; // Intra16x16DCLevel 0, Intra16x16ACLevel / LumaLevel 1, ChromaDCLevel 2, ChromaACLevel 3

	// ********** Read VLD ********** //

	procedure start_vld()
	begin
		NewVLD := true;
		VLD_Counter := 0;
		First_part := true;
		Codeword := 0;
		CodeLen := 0;
	end
 
	function IS_Intra_4x4() --> bool : mb_intra_flag = 1 and mb_type = 0 and transform_size_8x8_flag = 0 end
	function IS_Intra_8x8() --> bool : mb_intra_flag = 1 and mb_type = 0 and transform_size_8x8_flag = 1 end
	function IS_Intra_16x16() --> bool : mb_intra_flag = 1 and mb_type > 0 and mb_type <25 end
	function IS_I_PCM() --> bool : mb_intra_flag = 1 and mb_type = 25 end
	function IS_P_8x8ref0() --> bool : slice_type = SLICE_TYPE_P and mb_type = 4 end
	//function IS_B_Direct_8x8() --> bool : slice_type = SLICE_TYPE_B and sub_mb_type[ mbPartIdx ] = 0 end
	

	function vld_end() --> bool : not NewVLD end
	function vld_ue() --> int : lshift(1, CodeLen)+Codeword-1 end
	function vld_se() --> int : if (vld_ue() mod 2) = 0 then - (vld_ue() / 2) else (vld_ue() / 2) + 1 end end
	function vld_me() --> int : 
		if chroma_format_idc[sps_id] = 0 then 
			CBP_Table[vld_ue()] [if IS_Intra_4x4() or IS_Intra_8x8()  then 0 else 1 end] 
		else 
			CBP_Table[16 + vld_ue()] [if IS_Intra_4x4() or IS_Intra_8x8() then 0 else 1 end] 
		end 
	end

	procedure set_bits_to_read( int count )
	begin
		bits_to_read_count := count - 1;
		read_result_in_progress := 0;
	end

	function done_reading_bits() --> bool : (bits_to_read_count < 0) and (bit_read_cnt_finish) end
	function read_result() --> int : read_result_in_progress end
	function more_rbsp_data() --> uint(size=1) : 
		if (bit_count + 8)/ 8  < val_nb_rbsp_bytes
			then 1 
			else 
				if (8 - (bit_count mod 8) = 8) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false) and (bit_read[(bit_count+2) mod 8]=false) and (bit_read[(bit_count+3) mod 8]=false)
						and (bit_read[(bit_count+4) mod 8]=false) and (bit_read[(bit_count+5) mod 8]=false) and (bit_read[(bit_count+6) mod 8]=false)
						and (bit_read[(bit_count+7) mod 8]=false)) then 0 else 1 end
				else
				if (8 - (bit_count mod 8) = 7) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false) and (bit_read[(bit_count+2) mod 8]=false) and (bit_read[(bit_count+3) mod 8]=false)
						and (bit_read[(bit_count+4) mod 8]=false) and (bit_read[(bit_count+5) mod 8]=false) and (bit_read[(bit_count+6) mod 8]=false)) 
						then 0 else 1 end
				else
				if (8 - (bit_count mod 8) = 6) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false) and (bit_read[(bit_count+2) mod 8]=false) and (bit_read[(bit_count+3) mod 8]=false)
						and (bit_read[(bit_count+4) mod 8]=false) and (bit_read[(bit_count+5) mod 8]=false)) then 0 else 1 end
				else
				if (8 - (bit_count mod 8) = 5) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false) and (bit_read[(bit_count+2) mod 8]=false) and (bit_read[(bit_count+3) mod 8]=false)
						and (bit_read[(bit_count+4) mod 8]=false)) then 0 else 1 end
				else
				if (8 - (bit_count mod 8) = 4) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false) and (bit_read[(bit_count+2) mod 8]=false) and (bit_read[(bit_count+3) mod 8]=false))
						then 0 else 1 end
				else
				if (8 - (bit_count mod 8) = 3) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false) and (bit_read[(bit_count+2) mod 8]=false))
						then 0 else 1 end
				else			
				if (8 -(bit_count mod 8) = 2) then
					if ((bit_read[(bit_count) mod 8]=true) and (bit_read[(bit_count+1) mod 8]=false))
						then 0 else 1 end
				else 0 end end end end end end
				end
			end
		end
	
  
	function mask_bits( int(size=41)v, int(size=41)n ) --> int :
		bitand( v, lshift(1,n)-1 )
	end

	List (type:bool, size=8 ) bit_read:=[false: for int i in 0 .. 7];
	int bit_read_cnt:=8;

	action bits:[ b ] repeat 8==>
	guard
		bit_read_cnt_finish = false
	do
		bit_read_cnt_finish := true;
		bit_read:=[(b[i]=1):for int i in 0 .. 7];
	//	println("new value read:");
	//	foreach int i in  0 .. 7
	//	do
	//		println(bit_read[i]+ ";"+b[i]);
	//	end
	end
  
	action /*bits:[ b ]*/ ==>
	guard 
		not done_reading_bits(), bit_read_cnt!=8
	do
		read_result_in_progress := bitor( lshift( read_result_in_progress, 1), if bit_read[bit_read_cnt] = true then 1 else 0 end );
		bits_to_read_count := bits_to_read_count - 1;
		bit_count := bit_count + 1;
		bit_read_cnt := bit_read_cnt + 1;
	end

	action /*bits:[ b ]*/ ==>
	guard
		NewVLD,
		First_part,
		bit_read_cnt!=8
	do
		if bit_read[bit_read_cnt] = true then
			First_part := false;
			CodeLen := VLD_Counter;
			if CodeLen = 0 then NewVLD := false; end
		else
			VLD_Counter := VLD_Counter + 1;
		end
		bit_count := bit_count + 1;
		bit_read_cnt := bit_read_cnt + 1;
	end
  
	action /*bits:[ b ]*/ ==>
	guard
		NewVLD,
		not First_part,
		bit_read_cnt!=8
	do
		VLD_Counter := VLD_Counter - 1;
		Codeword := bitor( lshift( Codeword, 1), if bit_read[bit_read_cnt] = true then 1 else 0 end);
		bit_count := bit_count + 1;
		if   VLD_Counter = 0 then NewVLD := false; end
		bit_read_cnt := bit_read_cnt + 1;
	end  

	// ********** Read CAVLC ********** //

	function CAVLC_end() --> bool : not NewCoeff end

	procedure start_CAVLC(uint(size=2) x)
	begin
		NewCoeff := true;
		VLD_Counter := 0;
		Codeword := 0;
		CAVLC_type := x;
	end
      
	function TotalCoeff() --> uint(size=7) : rshift(coeff_token,2) end
	function TrailingOnes() --> uint(size=2) : mask_bits(coeff_token,2) end
	function Abs(int x) --> uint : if x >= 0 then x else -x end end

	action /*bits:[ b ]*/ ==>
	guard
	NewCoeff,
	bit_read_cnt!=8
	do
		VLD_Counter := VLD_Counter + 1;
		Codeword := bitor( lshift( Codeword, 1), if bit_read[bit_read_cnt] = true then 1 else 0 end);
		if CAVLC_type =0 then // coeff_token
			foreach int i in 0 .. 61 do
				if nc >=0 and nc < 2 then
					if VLD_Counter = VLC_nC_0to2[i][0] and Codeword = VLC_nC_0to2[i][1] then
						coeff_token := VLC_nC_0to2[i][2];
						NewCoeff := false;
						if(DEBUG_NEW_PARSER) then
							println("Cavlc; Idx_nc :" + 0 + " ; NbBitsRead : "+VLD_Counter+ " ; coeff_token : "+Codeword);
						end
					end
				else
					if nc >=2 and nc < 4 then
						if VLD_Counter = VLC_nC_2to4[i][0] and Codeword = VLC_nC_2to4[i][1] then
							coeff_token := VLC_nC_2to4[i][2];
							NewCoeff := false;
							if(DEBUG_NEW_PARSER) then
								println("Cavlc; Idx_nc :" + 1 + " ; NbBitsRead : "+VLD_Counter+ " ; coeff_token : "+Codeword);
							end
						end
					else
						if nc >=4 and nc < 8 then
							if VLD_Counter = VLC_nC_4to8[i][0] and Codeword = VLC_nC_4to8[i][1] then
								coeff_token := VLC_nC_4to8[i][2];
								NewCoeff := false;
								if(DEBUG_NEW_PARSER) then
									println("Cavlc; Idx_nc :" + 2 + " ; NbBitsRead : "+VLD_Counter+ " ; coeff_token : "+Codeword);
								end
							end
						else
							if nc >=8 then
								if VLD_Counter = VLC_nC_8[i][0] and Codeword = VLC_nC_8[i][1] then
									coeff_token := VLC_nC_8[i][2];
									NewCoeff := false;
									if(DEBUG_NEW_PARSER) then
										println("Cavlc; Idx_nc :" + 3 + " ; NbBitsRead : "+VLD_Counter+ " ; coeff_token : "+Codeword);
									end
								end 
							else
								if nc = -1 and i <14 then
									if VLD_Counter = VLC_nC_1[i][0] and Codeword = VLC_nC_1[i][1] then
										coeff_token := VLC_nC_1[i][2];
										NewCoeff := false;
										if(DEBUG_NEW_PARSER) then
											println("Cavlc; Idx_nc :" + 4 + " ; NbBitsRead : "+VLD_Counter+ " ; coeff_token : "+Codeword);
										end
									end
								else
									if nc = -2 and i <30 then
										if VLD_Counter = VLC_nC_2[i][0] and Codeword = VLC_nC_2[i][1] then
											coeff_token := VLC_nC_2[i][2];
											NewCoeff := false;
											if(DEBUG_NEW_PARSER) then
													println("Cavlc; Idx_nc :" + 5 + " ; NbBitsRead : "+VLD_Counter+ " ; coeff_token : "+Codeword);
											end
										end  
									end
								end
							end
						end
					end
				end
			end
		else
			if CAVLC_type = 1 then // total_zeros
				foreach int i in 0 .. (maxNumCoeff - TotalCoeff() ) do
					if maxNumCoeff != 4 and maxNumCoeff !=8 then 
						if VLD_Counter = VLC_total0[TotalCoeff()-1][i][0] and Codeword = VLC_total0[TotalCoeff()-1][i][1] then 
							total_zeros := VLC_total0[TotalCoeff()-1][i][2]; NewCoeff := false; 
						end
					else 
						if maxNumCoeff = 4 then
							if VLD_Counter = VLC_total0_Cr_DC2x2[TotalCoeff()-1][i][0] and Codeword = VLC_total0_Cr_DC2x2[TotalCoeff()-1][i][1] then 
								total_zeros := VLC_total0_Cr_DC2x2[TotalCoeff()-1][i][2]; NewCoeff := false; 
							end
						else //maxNumCoeff = 8
							////println("Chroma DC 2x4 block not implemented");
						end
					end
				end
			else //run_before
				foreach int i in 0 .. zerosLeft do
					if zerosLeft > 6 then
						if VLD_Counter = VLC_run_before[6][i][0] and Codeword = VLC_run_before[6][i][1] then 
							run_before := VLC_run_before[6][i][2]; NewCoeff := false; 
						end
					else
						if VLD_Counter = VLC_run_before[zerosLeft-1][i][0] and Codeword = VLC_run_before[zerosLeft-1][i][1] then
							run_before := VLC_run_before[zerosLeft-1][i][2]; NewCoeff := false; 
						end         
					end
				end
			end
		end
		bit_count := bit_count + 1;
		bit_read_cnt:=bit_read_cnt + 1;
	end
  
	//*************************************************************/
	/*************************************************************
	*************************************************************
	********       		Read CABAC      		    	*********
	*************************************************************
	*************************************************************/
	
	
	procedure StartCabacProcess() 
	begin
		FoundSE := false;
		StartNewCabacParsing := true;
	end 
	
	procedure StopCabacProcess() 
	begin
		StartNewCabacParsing := false;
	end 
	
	function cabac_value() --> int:
		CabacValue
	end	
	
	function cabac_end() --> bool:
		FoundSE
	end
		
	function Clip3( int Min, int Max, int Val  ) --> int :  if (Val < Min) then Min else if (Val > Max) then Max else Val end end end
	
	procedure preCtxState_pro(int QPy, int m, int n)
	begin
		preCtxState := Clip3( 1, 126, ( ( m * Clip3( 0, 51, QPy ) ) >> 4 ) + n );
	end
	
	procedure GetCabacMbTypeSyntaxElement()
	begin
		
		if slice_type = SLICE_TYPE_I then
			CABAC_SEARCH_SYNTAX_ELEMENT := CABAC_MB_TYPE_I;
			SearchForMbType := 0;
		else if  slice_type = SLICE_TYPE_SI then
				CABAC_SEARCH_SYNTAX_ELEMENT := CABAC_MB_TYPE_SI;
				SearchForMbType := 0;
		else if  slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then
			CABAC_SEARCH_SYNTAX_ELEMENT := CABAC_MB_TYPE_P_SP;
			SearchForMbType := 1;
		else if  slice_type = SLICE_TYPE_B then
				CABAC_SEARCH_SYNTAX_ELEMENT := CABAC_MB_TYPE_B;
				SearchForMbType := 2;
		end end end end	
	end
	
	procedure GetCabacSubMbTypeSyntaxElement()
	begin
		
		if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then
			CABAC_SEARCH_SYNTAX_ELEMENT := CABAC_SUB_MB_TYPE_P_SP;
			SearchForMbType := 0;
		else 
			if  slice_type = SLICE_TYPE_B then
				CABAC_SEARCH_SYNTAX_ELEMENT := CABAC_SUB_MB_TYPE_B;
				SearchForMbType := 1;	
			end 
		end	
	end
	
	procedure GetCabacSyntaxElement(int SyntaxElement)
	begin
		CABAC_SEARCH_SYNTAX_ELEMENT := SyntaxElement;
	end
	
	//*************************************************************/
	/*************************************************************
	*************************************************************
	********      MB Neighbouring                    	*********
	*************************************************************
	*************************************************************/
		
	function InverseRasterScan(int a, int b, int c, int d, int e ) --> uint :
		if e = 0 then
			( a mod ( d/b ) ) * b
		else 
			( a / ( d / b ) ) * c
		end
	end
	
	function GetMb4x4_X() --> int:
	  InverseRasterScan( ( luma4x4BlkIdx / 4 ), 8, 8, 16, 0 ) + InverseRasterScan( ( luma4x4BlkIdx mod 4 ), 4, 4, 8, 0 )
	end
	
	function GetMb4x4_Y() --> int:
	  InverseRasterScan( ( luma4x4BlkIdx / 4 ), 8, 8, 16, 1 ) + InverseRasterScan( ( luma4x4BlkIdx mod 4 ), 4, 4, 8, 1 )
	end
	
	function GetMb4x4_Chroma_X() --> int:
	  InverseRasterScan( luma4x4BlkIdx, 4, 4, 8, 0 )
	end
	
	function GetMb4x4_Chroma_Y() --> int:
	  InverseRasterScan( luma4x4BlkIdx, 4, 4, 8, 1 )
	end
	
	procedure getNeighbouring(int xN, int yN, int maxW, int maxH)
	begin
		if xN < 0 then
  			if yN < maxH - 1 then
				NeighMbAvail := mbAddrA_Avail();
				NeighMbAddr := GiveMbAddrA();
  			else
				NeighMbAvail := false;
  			end
 		else
			if xN < maxW - 1 then
  				if yN < 0 then
					NeighMbAvail := mbAddrB_Avail();
					NeighMbAddr := GiveMbAddrB();
  				else
    				if yN < maxH - 1 then
      					NeighMbAvail := true;
      					NeighMbAddr  := CabacCurrMbAddr();
    				end
			end
			else
				NeighMbAvail := false;
			end
		end
 
  
		//Give xW
		NeighMb_xW := ( xN + maxW ) mod maxW;
	  
		//Give yW
		NeighMb_yW := ( yN + maxH ) mod maxH;
	end
		
	// FIXME : Add the possibility to return false when the mbAddr belongs to another slice
	function mbAddrAvailable( int mbAddrX ) --> bool : 
		if ( ( mbAddrX < 0 ) or ( mbAddrX > PicSizeInMbs ) )then 
			false  //return 
		else 
			true  //return
		end 
	end
	
	function GiveMbAddrA( ) --> int :
		CabacCurrMbAddr() - 1
	end
	
	function mbAddrA_Avail() --> bool :
		if val_CurrMbAddr = 0 then
			false
		else 
			( val_CurrMbAddr mod PicWidthInMbs ) != 0
		end
	end
	
	function GiveMbAddrB( ) --> int :
		CabacCurrMbAddr() - PicWidthInMbs
	end
	
	
	function mbAddrB_Avail() --> bool :
		mbAddrAvailable( GiveMbAddrB() )
	end
	
	function GiveMbSliceType(bool MbAvail, int mbAdresse) --> int :
		if ( MbAvail ) then
			mbTab[ mbAdresse ][ mbSliceType ]
		else
			-1
		end		
	end
		
	
	function GiveMbType( bool MbAvail, int mbAdresse ) --> int :
		if ( MbAvail ) then
			mbTab[ mbAdresse ][ mbTabMbtype ]
		else
			-1
		end		
	end
	
	function GiveIntraChromaPredMode( bool MbAvail, int mbAdresse ) --> int :
		if ( MbAvail ) then
			mbTab[ mbAdresse ][ mbIntraChromaPredMode ]
		else
			-1
		end		
	end
	
	
	function GiveCBPLuma( bool MbAvail, int mbAdresse ) --> int :
		if( MbAvail ) then
			mbTab[ mbAdresse ][ mbCBPLuma ]
		else
			-1
		end
	end
	
	function GiveCBPChroma( bool MbAvail, int mbAdresse ) --> int :
		if( MbAvail ) then
			mbTab[ mbAdresse ][ mbCBPChroma ]
		else
			-1
		end
	end
	
	function GiveMbQpDelta( bool MbAvail, int mbAdresse ) -->  int:
		if( MbAvail ) then
			mbTab[ mbAdresse ][ mbQpDelta ]
		else
			-1
		end
	end
	//*************************************************************/
	/*************************************************************
	*************************************************************
	********      CABAC Decoding Process Flow       	*********
	*************************************************************
	*************************************************************/
		//Derivation process of ctxIdxInc for the syntax element mb_type
	
	//FIXME : Maybe add B_Direct_16x16 in the ctxIdxOffset = 27 and ( P_Skip_Flag or B_Skip_Flag ) ) then
	
	procedure ctxIdxincMbType() 
	var
		int  condTermFlagA,
		int  condTermFlagB,
		int  mbAddr,
		bool AvailMb
	begin
		//N = A
		getNeighbouring(-1, 0, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagA := 0;
		else
			if ( ( ctxIdxOffset = 0 and IS_SI(GiveMbSliceType(AvailMb,mbAddr))) or		  
			     ( ctxIdxOffset = 3  and IS_INxN( GiveMbSliceType(AvailMb,mbAddr), GiveMbType(AvailMb,mbAddr) ) ) or
			     ( ctxIdxOffset = 27 and ( IS_P_Skip_CABAC(mbAddr) or IS_B_Skip_CABAC(mbAddr) or IS_B_Direct_16x16_CABAC(mbAddr) ) ) )then
	
				 condTermFlagA := 0;
			else
				 condTermFlagA := 1;
			end	
		end
		
		//N = B
		getNeighbouring(0, -1, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagB := 0;
		else
			if ( ( ctxIdxOffset = 0 and IS_SI(GiveMbSliceType(AvailMb,mbAddr))) or		  
			     ( ctxIdxOffset = 3  and IS_INxN( GiveMbSliceType(AvailMb,mbAddr), GiveMbType(AvailMb,mbAddr) ) ) or
			     ( ctxIdxOffset = 27 and ( IS_P_Skip_CABAC(mbAddr) or IS_B_Skip_CABAC(mbAddr) or IS_B_Direct_16x16_CABAC(mbAddr) ) ) )then
	
				 condTermFlagB := 0;
			else
				 condTermFlagB := 1;
			end	
		end
		
		ctxIdxInc := condTermFlagA + condTermFlagB;
	end
	
	procedure ctxIdxincIntraChromaPredmode()
	var
		int condTermFlagA,
		int condTermFlagB,
		int  mbAddr,
		bool AvailMb
	begin
		//N = A
		getNeighbouring(-1, 0, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagA := 0;
		else	
			if ( IS_Inter(mbAddr) or
			     GiveMbType(AvailMb,mbAddr) = 25 or
			     GiveIntraChromaPredMode(AvailMb,mbAddr) = 0 ) then
			 
				 condTermFlagA := 0;
			else
				 condTermFlagA := 1;
			end
		end
		
		//N = B
		getNeighbouring(0, -1, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagB := 0;
		else	
			if ( IS_Inter(mbAddr)  or
			     GiveMbType(AvailMb,mbAddr) = 25 or
			     GiveIntraChromaPredMode(AvailMb,mbAddr) = 0 ) then
			 
				 condTermFlagB := 0;
			else
				 condTermFlagB := 1;
			end
		end
		
			
		ctxIdxInc := condTermFlagA + condTermFlagB;
	end
	
	procedure ctxIdxincMbQpDelta()
	var
		int  mbAddr,
		bool AvailMb
	begin
		//Assign Values
		mbAddr  := GiveMbAddrA();
		AvailMb := mbAddrA_Avail();
		
		//FIXME add P_Skip and B_Skip
		if not mbAddrA_Avail() then
			ctxIdxInc := 0;
		else
			if ( GiveMbSliceType(AvailMb,mbAddr) = SLICE_TYPE_I and GiveMbType(AvailMb,mbAddr) = 25 or IS_B_Skip_CABAC(mbAddr) or IS_B_Skip_CABAC(mbAddr) or
		             not IS_I16x16( GiveMbSliceType(AvailMb,mbAddr), GiveMbType(AvailMb,mbAddr)) and GiveCBPLuma(AvailMb,mbAddr) = 0 and GiveCBPChroma(AvailMb,mbAddr) = 0 or
			     GiveMbQpDelta(AvailMb,mbAddr)  = 0 )  then
				 
				 ctxIdxInc := 0;
			else
				ctxIdxInc := 1;
			end
		end
			 
	end
	
	procedure ctxIdxCodedBlockPatternLuma()
	var
		int condTermFlagA,
		int condTermFlagB,
		int xN,
		int yN,
		int mbAddr,
		bool AvailMb,
		int luma8x8BlkIdxN,
		bool slice
		
	begin
		//if ctxIdxOffset = 73 then
		//AvailMbA := false;
		//Neighbouring for A
		xN := ( binIdx mod 2 ) * 8 ;
		yN := ( binIdx  /  2 ) * 8; 
		
		getNeighbouring(xN - 1, yN, 16, 16);
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if  not AvailMb then
			condTermFlagA := 0;
		else
			if slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI then
				slice := true;
			else
				if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then
					slice := IS_P_Skip_CABAC(mbAddr) = false;
				else
					slice := IS_B_Skip_CABAC(mbAddr) = false;
				end
			end
			
			luma8x8BlkIdxN := 2*(NeighMb_yW >> 3) + (NeighMb_xW >> 3) ;
			if  ( GiveMbType(AvailMb,mbAddr) = 25  or 
			    ( slice and ( mbAddr != CabacCurrMbAddr()) and ( ( ( GiveCBPLuma(AvailMb, mbAddr) >> luma8x8BlkIdxN ) & 1)  != 0 ) ) or
			    (( mbAddr = CabacCurrMbAddr() ) and ( prior_decoded_bin_cbp[luma8x8BlkIdxN] != 0) ) ) then
				condTermFlagA := 0;
			else
				condTermFlagA := 1;
			end
		end
		
		getNeighbouring(xN, yN - 1, 16, 16);
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if  not AvailMb then
			condTermFlagB := 0;
		else
			if slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI then
				slice := true;
			else
				if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then
					slice := IS_P_Skip_CABAC(mbAddr) = false;
				else
					slice := IS_B_Skip_CABAC(mbAddr) = false;
				end
			end
			luma8x8BlkIdxN := 2*(NeighMb_yW >> 3) + (NeighMb_xW >> 3) ;
			if  ( GiveMbType(AvailMb,mbAddr) = 25  or 
			    ( slice and ( mbAddr != CabacCurrMbAddr()) and ( mbAddr != CabacCurrMbAddr()) and ( ( ( GiveCBPLuma(AvailMb, mbAddr) >> luma8x8BlkIdxN ) & 1)  != 0 ) ) or
			    (( mbAddr = CabacCurrMbAddr() ) and ( prior_decoded_bin_cbp[luma8x8BlkIdxN] != 0) ) ) then
			    condTermFlagB := 0;
			else
				condTermFlagB := 1;
			end
		end
		
		ctxIdxInc := condTermFlagA + 2*condTermFlagB;
	end
	

	procedure ctxIdxCodedBlockPatternChroma()
	var
		int condTermFlagA,
		int condTermFlagB,
		int mbAddr,
		bool AvailMb,
		int temp
	begin
		//if ctxIdxOffset = 77
		
		//N = A
		getNeighbouring(-1, 0, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagA := 0;
		else
			if ( GiveMbType(AvailMb,mbAddr) = 25 and GiveMbSliceType(AvailMb,mbAddr) = SLICE_TYPE_I ) then
				condTermFlagA := 1;
			end
			
			if ( binIdx = 0 and GiveCBPChroma(AvailMb,mbAddr) = 0) or
			   ( binIdx = 1 and GiveCBPChroma(AvailMb,mbAddr) != 2) or GiveMbType(AvailMb,mbAddr) = P_Skip or GiveMbType(AvailMb,mbAddr) = B_Skip then
				condTermFlagA := 0;
			else
				condTermFlagA := 1;
			end
		end
		
		//N = B
		getNeighbouring(0, -1, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagB := 0;
		else
			if ( GiveMbType(AvailMb,mbAddr) = 25 and GiveMbSliceType(AvailMb,mbAddr) = SLICE_TYPE_I ) then
				condTermFlagB := 1;
			end
			
			if ( binIdx = 0 and GiveCBPChroma(AvailMb,mbAddr) = 0) or
			   ( binIdx = 1 and GiveCBPChroma(AvailMb,mbAddr) != 2) or GiveMbType(AvailMb,mbAddr) = P_Skip or GiveMbType(AvailMb,mbAddr) = B_Skip then
				condTermFlagB := 0;
			else
				condTermFlagB := 1;
			end
		end
		
		if binIdx = 1 then
			temp := 4;
		else
			temp := 0;
		end
	
		ctxIdxInc := condTermFlagA + 2*condTermFlagB + temp;
	end
		
	procedure ctxIdxTransSize8x8Flag()
	var
		int condTermFlagA,
		int condTermFlagB,
		int mbAddr,
		bool AvailMb
	begin
		getNeighbouring(-1, 0, 8, 8);
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		
		if not AvailMb then
				condTermFlagA := 0;
		else
			if mbTab[mbAddr][mbTransSize8x8Flag] = 0 then
				condTermFlagA := 1;
			end
		end
		
		getNeighbouring(0, -1, 8, 8);
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if not AvailMb then
				condTermFlagB := 0;
		else
			if mbTab[mbAddr][mbTransSize8x8Flag] = 0 then
				condTermFlagB := 1;
			end
		end
		ctxIdxInc := condTermFlagA + 2*condTermFlagB;
	end
	
	procedure ctxIdxCodedBlockFlag()
	var
		int transBlockA,
		int transBlockB,
		int mbAddrA,
		int mbAddrB,
		bool AvailMbA,
		bool AvailMbB,
		int luma4x4BlkIdxA,
		int luma4x4BlkIdxB,
		int chroma4x4BlkIdxA,
		int chroma4x4BlkIdxB,
		int condTermFlagA,
		int condTermFlagB
	begin
		ctxIdxInc := 0;
		
		/* ************************************************************************************************
		    Luma 16x16 Block DC
		 ************************************************************************************************* */
		
		if ctxBlockCat = 0 then
			// N = A
			getNeighbouring(-1,0,16,16);
			//Assign Values
			mbAddrA  := NeighMbAddr;
			AvailMbA := NeighMbAvail;
			
			if AvailMbA then
			  if mbTab[mbAddrA][mbTabMbtype] > 0 and mbTab[mbAddrA][mbTabMbtype] < 25 then
				  transBlockA := mbAddrA; 
				end
			else
				transBlockA := 0;
			end
			
			// N = B
			getNeighbouring(0,-1,16,16);
			//Assign Values
			mbAddrB  := NeighMbAddr;
			AvailMbB := NeighMbAvail;
			
			if AvailMbB then
				if mbTab[mbAddrB][mbTabMbtype] > 0 and mbTab[mbAddrB][mbTabMbtype] < 25 then
				  transBlockB := mbAddrB; 
				end
			else
				transBlockB := 0;
			end
		end
		
		/* ************************************************************************************************
		    Luma 4x4 Block AC, luma4x4BlkIdx
		 ************************************************************************************************* */
		
		if ctxBlockCat = 1 or ctxBlockCat = 2 then
			
			//Get Neighbouring for MB A
			getNeighbouring( GetMb4x4_X() - 1, GetMb4x4_Y(), 16, 16);
			  
			//Associate Values
			mbAddrA  := NeighMbAddr;
			AvailMbA := NeighMbAvail;
			
			if AvailMbA then
				luma4x4BlkIdxA := ( (NeighMb_yW >> 2) * 4 ) + (NeighMb_xW >> 2);
				
				if ( (mbTab[mbAddrA][mbTabMbtype] != P_Skip) or 
				     (mbTab[mbAddrA][mbTabMbtype] != B_Skip) or 
				     (mbTab[mbAddrA][mbTabMbtype] != 25) or
				     ((mbTab[mbAddrA][mbCBPLuma] >> (luma4x4BlkIdxA >> 2)) & 1) != 0 or
				     (transform_size_8x8_flag = 0) ) then
					transBlockA := luma4x4BlkIdxA;
				else
					transBlockA := -1;
					
				end
			else
				luma4x4BlkIdxA := 0;
				transBlockA := -1;
			end
			
			//Get Neighbouring for MB B
			getNeighbouring( GetMb4x4_X(), GetMb4x4_Y() - 1, 16, 16);
			  
			//Associate Values
			mbAddrB  := NeighMbAddr;
			AvailMbB := NeighMbAvail;
			 
			if AvailMbB then
				luma4x4BlkIdxB := ( (NeighMb_yW >> 2) * 4 ) + (NeighMb_xW >> 2) ;
				
				if ( (mbTab[mbAddrB][mbTabMbtype] != P_Skip) or 
				     (mbTab[mbAddrB][mbTabMbtype] != B_Skip) or 
				     (mbTab[mbAddrB][mbTabMbtype] != 25) or
				     ((mbTab[mbAddrB][mbCBPLuma] >> (luma4x4BlkIdxB >> 2)) & 1) != 0 or
				     (transform_size_8x8_flag = 0) ) then
					transBlockB := luma4x4BlkIdxB;
				else
					transBlockB := -1;
				end
			else
				luma4x4BlkIdxB := 0;
				transBlockB := -1;
			end
		end
		
		/* ************************************************************************************************
		    Chroma DC, chroma component index iCbCr
		 ************************************************************************************************* */
		
		if ctxBlockCat = 3  then
			// N = A
			getNeighbouring(-1,0,4,4);
			//Assign Values
			mbAddrA  := NeighMbAddr;
			AvailMbA := NeighMbAvail;
			
			if AvailMbA then
				if mbTab[mbAddrA][mbTabMbtype] != 25 then
				  transBlockA := mbAddrA; 
				end
			else
				transBlockA := 0;
			end
			
			// N = B
			getNeighbouring(0,-1,4,4);
			//Assign Values
			mbAddrB  := NeighMbAddr;
			AvailMbB := NeighMbAvail;
			
			if AvailMbB then
				if mbTab[mbAddrB][mbTabMbtype] != 25 then
				  transBlockB := mbAddrB; 
				end
			else
				transBlockB := 0;
			end
		end
		
		/* ************************************************************************************************
		    Chroma AC, chroma component i ndex iCbCr
		 ************************************************************************************************* */
		
		if ctxBlockCat = 4  then
			// N = A
			//Get Neighbouring for MB A
			getNeighbouring( GetMb4x4_Chroma_X() - 1, GetMb4x4_Chroma_Y(), 8, 8);
			  
			//Associate Values
			mbAddrA  := NeighMbAddr;
			AvailMbA := NeighMbAvail;
			if AvailMbA then
				chroma4x4BlkIdxA := ( (NeighMb_yW >> 2) * 2 ) + (NeighMb_xW >> 2);
				if ( (mbTab[mbAddrA][mbTabMbtype]  != P_Skip) or 
				     (mbTab[mbAddrA][mbTabMbtype]  != B_Skip) or 
				     (mbTab[mbAddrA][mbTabMbtype]  != 25) or
				     (mbTab[mbAddrA][mbCBPChroma] = 2) ) then	     
					transBlockA := chroma4x4BlkIdxA;
				else
					transBlockA := -1;
				end
			else
			      chroma4x4BlkIdxA := 0;
			      transBlockA := -1;
			end
			
			// N = B
			//Get Neighbouring for MB A
			getNeighbouring( GetMb4x4_Chroma_X(), GetMb4x4_Chroma_Y() - 1, 8, 8);
			  
			//Associate ValuesL
			mbAddrB  := NeighMbAddr;
			AvailMbB := NeighMbAvail;
			if AvailMbB then
				chroma4x4BlkIdxB := ( (NeighMb_yW >> 2) * 2 ) + (NeighMb_xW >> 2);
				if ( (mbTab[mbAddrB][mbTabMbtype]  != P_Skip) or 
				     (mbTab[mbAddrB][mbTabMbtype]  != B_Skip) or 
				     (mbTab[mbAddrB][mbTabMbtype]  != 25) or
				     (mbTab[mbAddrB][mbCBPChroma] = 2) ) then
				     
					transBlockB := chroma4x4BlkIdxB;
				else
					transBlockB := -1;
				end
			else
			      chroma4x4BlkIdxB := 0;
			      transBlockB := -1;
			end
		end		
		
		/* ************************************************************************************************
		    CtxIdxInc
		 ************************************************************************************************* */
		
		
		// condTermFlagA
		
		if not AvailMbA and IS_Inter(CabacCurrMbAddr()) or
		   AvailMbA and transBlockA = -1 and IS_IPCM_Tab(mbAddrA,mbTabMbtype) = false then
			condTermFlagA := 0;
		else
			if not AvailMbA and IS_Intra(CabacCurrMbAddr()) or
			  IS_IPCM_Tab(mbAddrA,mbTabMbtype) then
				condTermFlagA := 1;
			else
				
				if ctxBlockCat = 0 then
					condTermFlagA := mbTab[mbAddrA][mbCBF];
				end
				
				if ctxBlockCat = 1 or ctxBlockCat = 2 then
					condTermFlagA := transblock_cbf[mbAddrA][InverseScan4x4Tab[luma4x4BlkIdxA]];
				end
				
				if ctxBlockCat = 3 then
					condTermFlagA := transblock_cbf_dc_cr_cb[transBlockA][iCbCr];
				end
				
				if ctxBlockCat = 4 then
					if iCbCr = 0 then
						condTermFlagA := transblock_cbf_cb[mbAddrA][chroma4x4BlkIdxA];
					else
						condTermFlagA := transblock_cbf_cr[mbAddrA][chroma4x4BlkIdxA];
					end
				end				
			end
		end
		
		// condTermFlagB

		if not AvailMbB and IS_Inter(CabacCurrMbAddr()) or
		   AvailMbB and transBlockB = -1 and IS_IPCM_Tab(mbAddrB,mbTabMbtype) = false then
			condTermFlagB := 0;
		else
			if not AvailMbB and IS_Intra(CabacCurrMbAddr()) or
			   IS_IPCM_Tab(mbAddrB,mbTabMbtype) then
				condTermFlagB := 1;
			else
				
				if ctxBlockCat = 0 then
					condTermFlagB := mbTab[mbAddrB][mbCBF];
				end
				
				if ctxBlockCat = 1 or ctxBlockCat = 2 then
					condTermFlagB := transblock_cbf[mbAddrB][InverseScan4x4Tab[luma4x4BlkIdxB]];
				end
				
				if ctxBlockCat = 3 then
					condTermFlagB := transblock_cbf_dc_cr_cb[transBlockB][iCbCr];
				end
				
				if ctxBlockCat = 4 then
					if iCbCr = 0 then
						condTermFlagB := transblock_cbf_cb[mbAddrB][chroma4x4BlkIdxB];
					else
						condTermFlagB := transblock_cbf_cr[mbAddrB][chroma4x4BlkIdxB];
					end
				end
			end
		end
		
		ctxIdxInc := condTermFlagA + 2*condTermFlagB;
	end
	
	procedure ctxIdxSignificantCoeffFlag()
	begin
		if ctxBlockCat != 3 or ctxBlockCat != 5 then
			ctxIdxInc := blCabacIdx;
		end
		
		if ctxBlockCat = 3 then
			ctxIdxInc := if ( ( blCabacIdx / NumC8x8 ) < 2 ) then blCabacIdx / NumC8x8 else 2 end;
		end
	end
	
	function Min(int a, int b) --> int:
		if a > b then
			b
		else
			a
		end
	end

	procedure ctxIdxCoeffAbsLevel()
	var
		int temp
	begin
		if ctxBlockCat < 5 then
			ctxIdxOffset := 227;
		end
		
		
		if binIdx = 0 then
			if numDecodAbsLevelGt1 !=0 then
				ctxIdxInc := 0;
			else
				ctxIdxInc := Min(numDecodAbsLevelEq1, 4);
			end
		else
			if ctxBlockCat = 3 then
				temp := 1;
			else
				temp := 0;
			end
			
			ctxIdxInc := 5 + Min(4 - temp, numDecodAbsLevelGt1);
		end
		
		ctxIdx := ctxIdxOffset + ctxIdxInc + ctxIdxBlockCatOffset_tab[2][ctxBlockCat];
	end
	
	procedure ctxIdxincMbSkipFlag() 
	var
		int  condTermFlagA,
		int  condTermFlagB,
		int  mbAddr,
		bool AvailMb
	begin
		//N = A
		getNeighbouring(-1, 0, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagA := 0;
		else
			if mbTab[mbAddr][mbSkipFlag] = 1 then
				 condTermFlagA := 0;
			else
				 condTermFlagA := 1;
			end	
		end
		
		//N = B
		getNeighbouring(0, -1, 16, 16);
		//Assign Values
		mbAddr  := NeighMbAddr;
		AvailMb := NeighMbAvail;
		
		if ( not AvailMb ) then
			condTermFlagB := 0;
		else
			if mbTab[mbAddr][mbSkipFlag] = 1 then
				 condTermFlagB := 0;
			else
				 condTermFlagB := 1;
			end	
		end
		
		ctxIdxInc := condTermFlagA + condTermFlagB;
	end
	
	procedure GiveMbPartIdx(int MBtype, int xW, int yW)
	begin
		if MBtype = 0 then
			mbPartIdxN := 0;
		else
			if MBtype = 1 or MBtype > 4 then
				if yW = 0 then
					mbPartIdxN := 0;
				else
					mbPartIdxN := 1;
				end
			else
				if MBtype = 2 then
					if xW = 0 then
						mbPartIdxN := 0;
					else
						mbPartIdxN := 1;
					end
				else
					if MBtype = 3 or MBtype = 4 then
						mbPartIdxN := ( yW * 2 ) + xW;
					end
				end
			end
		end
	end

	procedure GiveMbPartIdxB(int MBtype, int xW, int yW)
	begin
		if MBtype = 0 or MBtype = 1 or MBtype = 2 or MBtype = 3 or MBtype > 22 then
			mbPartIdxN := 0;
		else
			if MBtype = 4 or MBtype = 6 or MBtype = 8 or MBtype = 10 or MBtype = 12 or MBtype = 14 or MBtype = 16 or MBtype = 18 or MBtype = 20 then
				if yW = 0 then
					mbPartIdxN := 0;
				else
					mbPartIdxN := 1;
				end
			else
				if MBtype = 5 or MBtype = 7 or MBtype = 9 or MBtype = 11 or MBtype = 13 or MBtype = 15 or MBtype = 17 or MBtype = 19 or MBtype = 21 then
					if xW = 0 then
						mbPartIdxN := 0;
					else
						mbPartIdxN := 1;
					end
				else
					if MBtype = 22 then
						mbPartIdxN := ( yW * 2 ) + xW;
					end
				end
			end
		end
	end
	
	procedure GiveSubMbPartIdx(int currSubType, int xW,int yW, int mbPart)
	begin
		if currSubType = 0 then
			subMbPartIdxN := 0;		
		else
			if currSubType = 1 then
				if yW = 4 or yW = 7 or yW = 12 or yW = 15 then
					subMbPartIdxN := 1;
				else
					subMbPartIdxN := 0;
				end
			else
				if currSubType = 2 then
					if xW = 4 or xW = 7 or xW = 12 or xW = 15 then
						subMbPartIdxN := 1;
					else
						subMbPartIdxN := 0;
					end
				else
					if currSubType = 3 then
						if mbPart = 0 then
							subMbPartIdxN := (yW >> 2) * 2 + (xW >> 2);
						else
							if mbPart = 1 then
								subMbPartIdxN := (yW >> 2) * 2 + ((xW -1 - 7) >> 2);
							else	
								if mbPart = 2 then
									subMbPartIdxN := (((yW-1) - 7) >> 2) * 2 + (xW >> 2);
								else
									if mbPart = 3 then
										subMbPartIdxN :=  ((yW - 1 - 7) >> 2) * 2 + ((xW - 1 - 7) >> 2);
									end
								end
							end
						end			
					end
				end
			end
		end
	end
	
	procedure GiveSubMbPartIdxB(int currSubType, int xW,int yW, int mbPart)
	begin
		if currSubType = 0 or currSubType = 1 or currSubType = 2 or currSubType = 3 then
			subMbPartIdxN := 0;		
		else
			if currSubType = 4 or currSubType = 6 or currSubType = 8 then
				if yW = 4 or yW = 7 or yW = 12 or yW = 15 then
					subMbPartIdxN := 1;
				else
					subMbPartIdxN := 0;
				end
			else
				if currSubType = 5 or currSubType = 7 or currSubType = 9  then
					if xW = 4 or xW = 7 or xW = 12 or xW = 15 then
						subMbPartIdxN := 1;
					else
						subMbPartIdxN := 0;
					end
				else
					if currSubType > 9 then
						if mbPart = 0 then
							subMbPartIdxN := (yW >> 2) * 2 + (xW >> 2);
						else
							if mbPart = 1 then
								subMbPartIdxN := (yW >> 2) * 2 + ((xW -1 - 7) >> 2);
							else	
								if mbPart = 2 then
									subMbPartIdxN := (((yW-1) - 7) >> 2) * 2 + (xW >> 2);
								else
									if mbPart = 3 then
										subMbPartIdxN :=  ((yW - 1 - 7) >> 2) * 2 + ((xW - 1 - 7) >> 2);
									end
								end
							end
						end			
					end
				end
			end
		end
	end

	
	
	procedure GetCtxIdxMvd()
	var
		int predModeEqualFlagA,
		int predModeEqualFlagB,
		int currSubMbType,
		int absMvdCompA,
		int absMvdCompB,
		int x,
		int y,
		int xN,
		int yN,
		int xS,
		int yS
	begin
		
		currSubMbType := sub_mb_type[mbPartIdx];
		//Inverse sub-macroclock partiontion scanning process
				
		if slice_type = SLICE_TYPE_P then
			x := InverseRasterScan(mbPartIdx, P_tab[mb_type][1], P_tab[mb_type][2], 16, 0);
			y := InverseRasterScan(mbPartIdx, P_tab[mb_type][1], P_tab[mb_type][2], 16, 1);
		else
			x := InverseRasterScan(mbPartIdx, B_tab[mb_type][1], B_tab[mb_type][2], 16, 0);
			y := InverseRasterScan(mbPartIdx, B_tab[mb_type][1], B_tab[mb_type][2], 16, 1);
		end
		
		if IS_P_8x8() or IS_B_8x8() or IS_P_8x8ref0() then
			if slice_type = SLICE_TYPE_P then
				xS := InverseRasterScan(subMbPartIdx, P_tab_sub[currSubMbType][1], P_tab_sub[currSubMbType][2], 8, 0);
				yS := InverseRasterScan(subMbPartIdx, P_tab_sub[currSubMbType][1], P_tab_sub[currSubMbType][2], 8, 1);
			else
				xS := InverseRasterScan(subMbPartIdx, B_tab_sub[currSubMbType][1], B_tab_sub[currSubMbType][2], 8, 0);
				yS := InverseRasterScan(subMbPartIdx, B_tab_sub[currSubMbType][1], B_tab_sub[currSubMbType][2], 8, 1);
			end
		else
			xS := 0;
			yS := 0;
		end
		
		//N = A
		xN := x + xS - 1;
		yN := y + yS;
		
		getNeighbouring(xN , yN, 16, 16);
		
		if not NeighMbAvail then
			mbPartIdxN    := -1;
			subMbPartIdxN := -1;
			absMvdCompA := 0;
		else
			if slice_type = SLICE_TYPE_P then
				GiveMbPartIdx(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			else
				GiveMbPartIdxB(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			end
			
			if IS_P_8x8_CABAC(NeighMbAddr) or IS_B_8x8_CABAC(NeighMbAddr) or IS_P_8x8ref0_CABAC(NeighMbAddr) then
				if slice_type = SLICE_TYPE_P then
					GiveSubMbPartIdx(cabac_sub_mb_type[NeighMbAddr][mbPartIdxN], NeighMb_xW, NeighMb_yW, mbPartIdxN);
				else
					GiveSubMbPartIdxB(cabac_sub_mb_type[NeighMbAddr][mbPartIdxN], NeighMb_xW, NeighMb_yW, mbPartIdxN);
				end
			else
				subMbPartIdxN := 0;
			end
			
			if slice_type = SLICE_TYPE_P then
				if IS_MB_Type_P8X8(NeighMbAddr)then
					if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false then
						predModeEqualFlagA := 0;
					else
						predModeEqualFlagA := 1;
					end
				else
					if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false then
						predModeEqualFlagA := 0;
					else
						predModeEqualFlagA := 1;
					end
				end
			else
				if IS_MB_Type_P8X8(NeighMbAddr) or IS_MB_Type_B8X8(NeighMbAddr) then
					if IS_L0 then
						if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					else
						if IS_SubMBPred_L1_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					end
				else
					if IS_L0 then
						if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					else
						if IS_MBPred_L1_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					end
				end
			end
			
			if IS_Intra(NeighMbAddr) or IS_B_Skip_CABAC(NeighMbAddr) or IS_B_Skip_CABAC(NeighMbAddr) or predModeEqualFlagA = 0 then
				absMvdCompA := 0;
			else
				if IS_L0 then
					absMvdCompA := ABS(Mvd_L0[NeighMbAddr][mbPartIdxN][subMbPartIdxN][compIdx]);
				else
					absMvdCompA := ABS(Mvd_L1[NeighMbAddr][mbPartIdxN][subMbPartIdxN][compIdx]);
				end
			end
		end
			
		//N = B
		xN := x + xS;
		yN := y + yS - 1;
		
		getNeighbouring(xN , yN, 16, 16);
		
		if not NeighMbAvail then
			mbPartIdxN    := -1;
			subMbPartIdxN := -1;
			absMvdCompB := 0;
		else
			if slice_type = SLICE_TYPE_P then
				GiveMbPartIdx(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			else
				GiveMbPartIdxB(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			end
						
			if IS_P_8x8_CABAC(NeighMbAddr) or IS_B_8x8_CABAC(NeighMbAddr) or IS_P_8x8ref0_CABAC(NeighMbAddr) then
				if slice_type = SLICE_TYPE_P then
					GiveSubMbPartIdx(cabac_sub_mb_type[NeighMbAddr][mbPartIdxN], NeighMb_xW, NeighMb_yW, mbPartIdxN);
				else
					GiveSubMbPartIdxB(cabac_sub_mb_type[NeighMbAddr][mbPartIdxN], NeighMb_xW, NeighMb_yW, mbPartIdxN);
				end
			else
				subMbPartIdxN := 0;
			end
			
			if slice_type = SLICE_TYPE_P then
				if IS_MB_Type_P8X8(NeighMbAddr)then
					if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false then
						predModeEqualFlagB := 0;
					else
						predModeEqualFlagB := 1;
					end
				else
					if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false then
						predModeEqualFlagB := 0;
					else
						predModeEqualFlagB := 1;
					end
				end
			else
				if IS_MB_Type_P8X8(NeighMbAddr) or IS_MB_Type_B8X8(NeighMbAddr) then
					if IS_L0 then
						if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					else
						if IS_SubMBPred_L1_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					end
				else
					if IS_L0 then
						if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					else
						if IS_MBPred_L1_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					end
				end
			end
			
			if IS_Intra(NeighMbAddr) or IS_B_Skip_CABAC(NeighMbAddr) or IS_B_Skip_CABAC(NeighMbAddr) or predModeEqualFlagB = 0 then
				absMvdCompB := 0;
			else
				if IS_L0 then
					absMvdCompB := ABS(Mvd_L0[NeighMbAddr][mbPartIdxN][subMbPartIdxN][compIdx]);
				else
					absMvdCompB := ABS(Mvd_L1[NeighMbAddr][mbPartIdxN][subMbPartIdxN][compIdx]);
				end
			end
		end
					
		if absMvdCompA + absMvdCompB < 3 then
			  ctxIdxInc := 0;
		else
			  if absMvdCompA + absMvdCompB > 32 then
				ctxIdxInc := 2;
			  else
				ctxIdxInc := 1;
			  end
		end
	end
	
	procedure GetCtxIdxRefIdx()
	var
		int condTermFlagA,
		int condTermFlagB,
		int predModeEqualFlagA,
		int predModeEqualFlagB,
		int currSubMbType,
		int refIdxZeroFlagA,
		int refIdxZeroFlagB,
		int x,
		int y,
		int xN,
		int yN,
		int xS,
		int yS
	begin
		
		currSubMbType := sub_mb_type[mbPartIdx];
		//Inverse sub-macroclock partiontion scanning process
		if slice_type = SLICE_TYPE_P then
			x := InverseRasterScan(mbPartIdx, P_tab[mb_type][1], P_tab[mb_type][2], 16, 0);
			y := InverseRasterScan(mbPartIdx, P_tab[mb_type][1], P_tab[mb_type][2], 16, 1);
		else
			x := InverseRasterScan(mbPartIdx, B_tab[mb_type][1], B_tab[mb_type][2], 16, 0);
			y := InverseRasterScan(mbPartIdx, B_tab[mb_type][1], B_tab[mb_type][2], 16, 1);
		end
		
		if IS_P_8x8() or IS_B_8x8() or IS_P_8x8ref0() then
			if slice_type = SLICE_TYPE_P then
				xS := InverseRasterScan(0, P_tab_sub[currSubMbType][1], P_tab_sub[currSubMbType][2], 8, 0);
				yS := InverseRasterScan(0, P_tab_sub[currSubMbType][1], P_tab_sub[currSubMbType][2], 8, 1);
			else
				xS := InverseRasterScan(0, B_tab_sub[currSubMbType][1], B_tab_sub[currSubMbType][2], 8, 0);
				yS := InverseRasterScan(0, B_tab_sub[currSubMbType][1], B_tab_sub[currSubMbType][2], 8, 1);
			end
		else
			xS := 0;
			yS := 0;
		end
			
		//N = A
		xN := x + xS - 1;
		yN := y + yS;
		
		getNeighbouring(xN , yN, 16, 16);
		
		if not NeighMbAvail then
			mbPartIdxN    := -1;
			condTermFlagA := 0;
		else
			if slice_type = SLICE_TYPE_P then
				GiveMbPartIdx(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			else
				GiveMbPartIdxB(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			end
			//Give refIdxZeroFlagX value
			if IS_L0 then
				refIdxZeroFlagA := if Ref_Idx_L0[NeighMbAddr][mbPartIdxN] > 0 then 0 else 1 end;
			else
				refIdxZeroFlagA := if Ref_Idx_L1[NeighMbAddr][mbPartIdxN] > 0 then 0 else 1 end;
			end
					
			if IS_MB_Type_P8X8(NeighMbAddr) or IS_MB_Type_B8X8(NeighMbAddr) then
				if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
					predModeEqualFlagA := 0;
				else
					predModeEqualFlagA := 1;
				end
			else
				if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
					predModeEqualFlagA := 0;
				else
					predModeEqualFlagA := 1;
				end
			end
			
			if slice_type = SLICE_TYPE_P then
				if IS_MB_Type_P8X8(NeighMbAddr)then
					if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false then
						predModeEqualFlagA := 0;
					else
						predModeEqualFlagA := 1;
					end
				else
					if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false then
						predModeEqualFlagA := 0;
					else
						predModeEqualFlagA := 1;
					end
				end
			else
				if IS_MB_Type_P8X8(NeighMbAddr) or IS_MB_Type_B8X8(NeighMbAddr) then
					if IS_L0 then
						if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					else
						if IS_SubMBPred_L1_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					end
				else
					if IS_L0 then
						if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					else
						if IS_MBPred_L1_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagA := 0;
						else
							predModeEqualFlagA := 1;
						end
					end
				end
			end
			
			if IS_P_Skip_CABAC(NeighMbAddr) or IS_B_Skip_CABAC(NeighMbAddr) or 
			   IS_Intra_Pred_CABAC(NeighMbAddr) or predModeEqualFlagA = 0 or refIdxZeroFlagA = 1 then
				condTermFlagA := 0;
			else
				condTermFlagA := 1;
			end
		end
			
		//N = B
		xN := x + xS;
		yN := y + yS - 1;
		
		getNeighbouring(xN , yN, 16, 16);
		
		if not NeighMbAvail then
			mbPartIdxN    := -1;
			condTermFlagB := 0;
		else
			if slice_type = SLICE_TYPE_P then
				GiveMbPartIdx(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			else
				GiveMbPartIdxB(mbTab[NeighMbAddr][mbTabMbtype], NeighMb_xW >> 3, NeighMb_yW >> 3);
			end
			//Give refIdxZeroFlagX value
			if IS_L0 then
				refIdxZeroFlagB := if Ref_Idx_L0[NeighMbAddr][mbPartIdxN] > 0 then 0 else 1 end;
			else
				refIdxZeroFlagB := if Ref_Idx_L1[NeighMbAddr][mbPartIdxN] > 0 then 0 else 1 end;
			end
					
			if slice_type = SLICE_TYPE_P then
				if IS_MB_Type_P8X8(NeighMbAddr)then
					if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false then
						predModeEqualFlagB := 0;
					else
						predModeEqualFlagB := 1;
					end
				else
					if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false then
						predModeEqualFlagB := 0;
					else
						predModeEqualFlagB := 1;
					end
				end
			else
				if IS_MB_Type_P8X8(NeighMbAddr) or IS_MB_Type_B8X8(NeighMbAddr) then
					if IS_L0 then
						if IS_SubMBPred_L0_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					else
						if IS_SubMBPred_L1_CABAC(mbPartIdxN, NeighMbAddr) = false and IS_SubMBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					end
				else
					if IS_L0 then
						if IS_MBPred_L0_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					else
						if IS_MBPred_L1_CABAC(mbPartIdxN,NeighMbAddr) = false and IS_MBBiPred_CABAC(mbPartIdxN, NeighMbAddr) = false then
							predModeEqualFlagB := 0;
						else
							predModeEqualFlagB := 1;
						end
					end
				end
			end
			if IS_P_Skip_CABAC(NeighMbAddr) or IS_B_Skip_CABAC(NeighMbAddr) or 
			   IS_Intra_Pred_CABAC(NeighMbAddr) or predModeEqualFlagB = 0 or refIdxZeroFlagB = 1 then
				condTermFlagB := 0;
			else
				condTermFlagB := 1;
			end
		end
		
		ctxIdxInc := condTermFlagA + 2*condTermFlagB;
	end
	
	procedure CoeffAbsParsing()
	begin
		if StartPrefix then
			if binValDecoded = false then
				binIdx := binIdx + 1;
				//give the ctxIdx
				ctxIdxCoeffAbsLevel();
				//Get the bin Value
				StartDecodeDecision := true;
				//Do not give the hand to Coeff_Abs_Parsing
				StopCabacProcess();
				NextBitToDecode := false;
				// Init binIdx
				binIdx := 0;
			end

			if binValDecoded = true and GetSign = false then
				// Increment binIdx
				binIdx := binIdx + 1;
				if binVal = 0 then
					StartDecodeBypass := true;
					bypassFlag := true;
					StopCabacProcess();
					GetSign := true;
				else
					binValDecoded := false;
					StartSuffix := true;
					StartPrefix := false;
					coeff_abs := 2;
					StopCoeff := true;
					Coeff_J   := 0;
				end	
			end
			
			if binValDecoded = true and StartDecodeBypass = false then
				// Increment binIdx
				binIdx := binIdx + 1;
				if binVal = 1 then
					CabacValue := -1;
				else
					CabacValue := 1;
				end
				
				//Finishing the Prefix for a 0 binVal
				StartPrefix := false;
				numDecodAbsLevelEq1 := numDecodAbsLevelEq1 + 1;
				//Stop cabac process and give the value
				StopCabacProcess();
				FoundSE := true;
			end
			
		end
		
		if StartSuffix then
			
			if coeff_abs < 15 then
				if binValDecoded = false and StopCoeff then
					//Give the ctxIdx
					ctxIdxCoeffAbsLevel();
					StartDecodeDecision := true;	
					//Do not give the hand to Coeff_Abs_Parsing
					StopCabacProcess();
				else
					// Increment binIdx
					binIdx := binIdx + 1;
					if binVal = 1 then
						coeff_abs := coeff_abs + 1;
						if coeff_abs >= 15  then
							StopCoeff := false;
						end
					else
						StopCoeff := false;
						StartCoeffSignAbs := true;
						StartSuffix := false;
					end
					binValDecoded := false;
				end
			end
			
			if coeff_abs >= 15  then
				if StartCoeff_J_Dec = false then
						if binValDecoded = false and StopCoeff = false then
							StartDecodeBypass := true;
							bypassFlag := true;
							StopCabacProcess();
						else
							// Increment binIdx
							binIdx := binIdx + 1;
							if binVal = 1 then
								coeff_abs := coeff_abs + (1 << Coeff_J);
								Coeff_J := Coeff_J + 1;
							else
								StopCoeff := true;
								StartCoeff_J_Dec := true;
							end
							binValDecoded := false;
						end
				else
					if Coeff_J != 0  then
						if binValDecoded = false then
							StartDecodeBypass := true;
							bypassFlag := true;
							StopCabacProcess();
						else
							// Increment binIdx
							binIdx := binIdx + 1;
							if binVal = 1 then
								coeff_abs := coeff_abs + (1 << Coeff_J - 1);
								Coeff_J := Coeff_J - 1;
							else
								Coeff_J := Coeff_J - 1;
							end
							binValDecoded := false;
						end
					else
						StartCoeffSignAbs := true;
						StartSuffix := false;
						StartCoeff_J_Dec := false;
					end
				end
				
			end	
		end
		
		if StartCoeffSignAbs then
			if binValDecoded = false then
				StartDecodeBypass := true;
				bypassFlag := true;
				StopCabacProcess();
			else
				if binVal = 1 then
					CabacValue := coeff_abs * (-1);
				else
					CabacValue := coeff_abs;
				end
				numDecodAbsLevelGt1 := numDecodAbsLevelGt1 + 1;
				
			
				//Stop cabac process and give the value
				StopCabacProcess();
				FoundSE := true;
			end
		end
		
		if FoundSE then
			// Init Coeff_Abs_Parsing
			StartPrefix := true;
			StartSuffix := false;
			StartCoeffSignAbs := false;
			binValDecoded := false;
			binIdx := -1;
			GetSign := false;
			NextBitToDecode := true;
		end
	end
	
	
	procedure GetMbType_I()
	var
		int IS_Intra
	begin
	
		if slice_type = SLICE_TYPE_I then
			IS_Intra := 1;
		else
			IS_Intra := 0;
		end
		
		if binIdxMb = 0 then
			if binValDecoded = false then
				if slice_type = SLICE_TYPE_I then
					ctxIdxOffset := 3; 
					ctxIdxincMbType();
					ctxIdx := 3 + ctxIdxInc;
					PreviousCtxIdx := 3 + 2;
				else
					if slice_type = SLICE_TYPE_P then
						ctxIdx := 17;
						PreviousCtxIdx := 17;
					else
						/* SLICE TYPE B */
						ctxIdx := 32;
						PreviousCtxIdx := 32;
					end
				end
				
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 0 then
					FoundSE := true;
					CabacValue := 0; 	/* INTRA 4x4*/
				else
					CabacValue := 1;
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
		end
		
		if binIdxMb = 1 and FoundSE = false then
			if binValDecoded = false then
				ctxIdx := 276;
				StartDecodeTerminate := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					CabacValue := 25;	/*PCM*/
					FoundSE := true;
				else
					CabacValue := 1;
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
		end
		
		if binIdxMb = 2 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := PreviousCtxIdx + 1;
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					CabacValue := CabacValue + 12;	/* CBPLuma = 0 */ 
				end
				binValDecoded := false;
				binIdxMb := binIdxMb + 1;
			end
		end
		
		if binIdxMb = 3 and FoundSE = false then
			if binValDecoded = false then
				ctxIdx := PreviousCtxIdx + 2;
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					 binIdxOffset := 1;
				end
				binValDecoded := false;
				binIdxMb := binIdxMb + 1;
			end
		end
		
		if binIdxMb = 4 and FoundSE = false then
			if binIdxOffset = 1 then
				if binValDecoded = false then
					ctxIdx := PreviousCtxIdx + 2 + IS_Intra;
					StartDecodeDecision := true;
					StopCabacProcess();
					NextBitToDecode := false;
				else
					if binVal = 0 then
						CabacValue := CabacValue + 4*1; 	
					else
						CabacValue := CabacValue + 4*2;
					end
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			else
				if binValDecoded = false then
					ctxIdx := PreviousCtxIdx + 3 + IS_Intra;
					StartDecodeDecision := true;
					StopCabacProcess();
					NextBitToDecode := false;
				else
					if binVal = 1 then
						CabacValue := CabacValue + 2;
					end
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
		end
		
		if binIdxMb = 5 and FoundSE = false then
			if binIdxOffset = 1 then
				if binValDecoded = false then
					ctxIdx := PreviousCtxIdx + 3 + IS_Intra;
					StartDecodeDecision := true;
					StopCabacProcess();
					NextBitToDecode := false;
				else
					if binVal = 1 then
						CabacValue := CabacValue + 2;
					end
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			else
				if binValDecoded = false then
					ctxIdx := PreviousCtxIdx + 3 + 2*IS_Intra;
					StartDecodeDecision := true;
					StopCabacProcess();
					NextBitToDecode := false;
				else
					if binVal = 1 then
						CabacValue := CabacValue + 1;
					end
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
					FoundSE := true;
				end 
			end
		end
		
		if binIdxMb = 6 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := PreviousCtxIdx + 3 + 2*IS_Intra;
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					CabacValue := CabacValue + 1;
				end
				binValDecoded := false;
				binIdxMb := binIdxMb + 1;
				FoundSE := true;
			end 
		end
		
		
		if FoundSE = true then
			binValDecoded := false;
			binIdxMb := -1;
			NextBitToDecode := true;
			StopCabacProcess();
			binIdxOffset := 0;
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_I then
				/* Mb Type is I_PCM Start Initialization Deocding Engine*/
				if CabacValue = 25 and FoundSE = true then
					StartInitializationDecoding := true;
					set_bits_to_read(9);
				end
			end
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_P_SP then
				CabacValue := CabacValue + 5;
				SuffixMbTypeP := true;
			end
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_B then
				CabacValue := CabacValue + 23;
				SuffixMbTypeB := true;
			end
			//Give type prediction
			mbTab[CabacCurrMbAddr()][TypePred] := 0; 
		end
	end
	
	procedure GetMbType_P()
	begin
		if SuffixMbTypeP then
			/* IS P type */
			if binIdxMb = 0 then
				if binValDecoded = false then
					ctxIdx := 14;
					StartDecodeDecision := true;
					StopCabacProcess();
					NextBitToDecode := false;
				else
					if binVal = 1 then
						SuffixMbTypeP := false;
						binValDecoded := false;
						/* Get Intra Type Mb */
						SearchForMbType := 0;
					else
						binValDecoded := false;
						binIdxMb := binIdxMb + 1;
					end
				end
			end
			
			if binIdxMb = 1 and FoundSE = false then
				if binValDecoded = false then
					ctxIdx := 15;
					StartDecodeDecision := true;
					StopCabacProcess();
					NextBitToDecode := false;
				else
					if binVal = 0 then
						binIdxOffset := 0;
					else
						binIdxOffset := 1;
					end
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
			
			if binIdxMb = 2 and FoundSE = false then
				if binIdxOffset = 0 then
					if binValDecoded = false then
						ctxIdx := 16;
						StartDecodeDecision := true;
						StopCabacProcess();
						NextBitToDecode := false;
					else
						if binVal = 0 then
							CabacValue := 0;
						else
							CabacValue := 3;
						end
						FoundSE := true;
					end
				else
					if binValDecoded = false then
						ctxIdx := 17;
						StartDecodeDecision := true;
						StopCabacProcess();
						NextBitToDecode := false;
					else
						if binVal = 0 then
							CabacValue := 2;
						else
							CabacValue := 1;
						end
						FoundSE := true;
					end 
				end
			end
			
			if FoundSE then
				binValDecoded := false;
				binIdxMb := -1;
				NextBitToDecode := true;
				StopCabacProcess();
				binIdxOffset := 0;
				//Give type prediction
				mbTab[CabacCurrMbAddr()][TypePred] := 1; 
			end
		end
		
		if SearchForMbType = 0 then
			binValDecoded := false;
			binIdxMb := 0;
			NextBitToDecode := true;
			binIdxOffset := 0;
			GetMbType_I();
		end
	end
	
	procedure GetMbType_B()
	begin
		if SuffixMbTypeB then
			/* IS B type */

			if binIdxMb = 0 then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdxincMbType();
					ctxIdx := ctxIdxOffset + ctxIdxInc;
					StartDecodeDecision := true;
					StopCabacProcess();
					CabacValue := 0;
				else
					if binVal = 0 then
						CabacValue := 0;
						FoundSE := true;
					else
						binIdxMb := binIdxMb + 1;
					end
					binValDecoded := false;
				end
			end
			
			if binIdxMb = 1 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 3;
					StartDecodeDecision := true;
					StopCabacProcess();
				else
					if binVal = 0 then
						binIdxMb := binIdxMb + 1;
					else
						binIdxMb := binIdxMb + 2;
					end
					binValDecoded := false;
				end
			end
			
			if binIdxMb = 2 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 5;
					StartDecodeDecision := true;
					StopCabacProcess();
				else
					CabacValue := 1 + binVal;
					FoundSE := true;
					binValDecoded := false;
				end
			end
			
			if binIdxMb = 3 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 4;
					StartDecodeDecision := true;
					StopCabacProcess();

				else
					Bbits := binVal << 3;
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
		
			if binIdxMb = 4 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 5;
					StartDecodeDecision := true;
					StopCabacProcess();
				else
					Bbits := Bbits | (binVal << 2);
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
			
			if binIdxMb = 5 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 5;
					StartDecodeDecision := true;
					StopCabacProcess();
				else
					Bbits := Bbits | (binVal << 1);
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
			
			if binIdxMb = 6 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 5;
					StartDecodeDecision := true;
					StopCabacProcess();
				else
					Bbits := Bbits | binVal;
					binValDecoded := false;
					binIdxMb := binIdxMb + 1;
				end
			end
			
			if binIdxMb = 7 and FoundSE = false then
				if Bbits < 8 then
					CabacValue := Bbits + 3;
					FoundSE := true;
				else
					if Bbits = 13 then
						SuffixMbTypeB := false;
						binValDecoded := false;
						/* Get Intra Type Mb */
						SearchForMbType := 0;
					else
						if Bbits = 14 then
							CabacValue := 11;
							FoundSE := true;
						else
							if Bbits = 15 then
								CabacValue := 22;
								FoundSE := true;
							else
								binValDecoded := false;
								binIdxMb := binIdxMb + 1;
							end
						end
					end
				end
			end
			
			if binIdxMb = 8 and FoundSE = false then
				if binValDecoded = false then
					ctxIdxOffset := 27;
					ctxIdx := ctxIdxOffset + 5;
					StartDecodeDecision := true;
					StopCabacProcess();
				else
					Bbits := ( Bbits << 1) | binVal;
					CabacValue := Bbits - 4;
					binValDecoded := false;
					FoundSE := true;
				end
			end
			
			if FoundSE then
				binValDecoded := false;
				binIdxMb := -1;
				NextBitToDecode := true;
				StopCabacProcess();
				binIdxOffset := 0;
				//Give type prediction
				mbTab[CabacCurrMbAddr()][TypePred] := 2; 
			end
		end
		
		if SearchForMbType = 0 then
			binValDecoded := false;
			binIdxMb := 0;
			NextBitToDecode := true;
			binIdxOffset := 0;
			GetMbType_I();
		end
	
	end
	
	procedure GetSubMbType_P()
	begin
		
		if binIdxMb = 0 then
			if binValDecoded = false then
				ctxIdx := 21;
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					CabacValue := 0;
					FoundSE := true;
				else
					binIdxMb := binIdxMb + 1;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 1 and FoundSE = false then
			if binValDecoded = false then
				ctxIdx := 22;
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 0 then
					CabacValue := 1;
					FoundSE := true;
				else
					binIdxOffset := 1;
					binIdxMb := binIdxMb + 1;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 2 and FoundSE = false then
			if binValDecoded = false then
				ctxIdx := 23;
				StartDecodeDecision := true;
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					CabacValue := 2;
					FoundSE := true;
				else
					CabacValue := 3;
					FoundSE := true;
				end
				binValDecoded := false;
			end
		end
		
		if FoundSE then
			binValDecoded := false;
			binIdxMb := -1;
			NextBitToDecode := true;
			StopCabacProcess();
		end
	end
	
	procedure GetSubMbType_B()
	begin
		if binIdxMb = 0 then
			if binValDecoded = false then
				ctxIdx := 36;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 0 then
					CabacValue := 0;
					FoundSE := true;
				else
					binIdxMb := binIdxMb + 1;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 1 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 37;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 0 then
					binIdxMb := binIdxMb + 1;
				else
					binIdxMb := binIdxMb + 2;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 2 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 39;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := 1 + binVal;
				FoundSE := true;
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 3 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 38;
				StartDecodeDecision := true;
				StopCabacProcess();
				CabacValue := 3;
			else
				if binVal = 1 then
					binIdxMb := binIdxMb + 1;
					CabacValue := 7;
				else
					binIdxMb := binIdxMb + 3;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 4 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 39;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 1 then
					binIdxMb := binIdxMb + 1;
				else
					binIdxMb := binIdxMb + 2;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 5 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 39;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := 11 + binVal;
				FoundSE := true;
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 6 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 39;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := CabacValue + (binVal << 1);
				binValDecoded := false;
				binIdxMb := binIdxMb + 1;
			end
		end
		
		if binIdxMb = 7 and FoundSE = false  then
			if binValDecoded = false then
				ctxIdx := 39;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := CabacValue + binVal;
				binValDecoded := false;
				binIdxMb := binIdxMb + 1;
				FoundSE := true;
			end
		end
		
		if FoundSE then
			binValDecoded := false;
			binIdxMb := -1;
			NextBitToDecode := true;
			StopCabacProcess();
		end
	end
	
	procedure GetMbTypeParsing()
	begin
		if SearchForMbType = 0 then
			GetMbType_I();
		else
			if SearchForMbType = 1 then
				 GetMbType_P();
			else
				 GetMbType_B();
			end
		end
	end
	
	procedure GetSubMbTypeParsing()
	begin
		if SearchForMbType = 0 then
			GetSubMbType_P();
		else
			GetSubMbType_B();
		end
	end
	
	
	procedure GetMvD_Lx()
	begin
		if compIdx = 0 then
					ctxIdxOffset := 40;
				else
					ctxIdxOffset := 47;
		end
		
		if StartPrefix then
			if binValDecoded = false then
				//give the ctxIdx
				GetCtxIdxMvd();
				ctxIdx := ctxIdxInc + ctxIdxOffset;
				//Get the bin Value
				StartDecodeDecision := true;
				//Do not give the hand to Coeff_Abs_Parsing
				StopCabacProcess();
				NextBitToDecode := false;
			else
				if binVal = 1 then
					StartSuffix := true;
					StopCoeff := true;
					mvd_temp := 1;
					ctx_temp := 3;
				else
					CabacValue := 0;
					FoundSE := true;
				end
				StartPrefix := false;
				binValDecoded := false;
			end
			
		end
		
		if StartSuffix then
			
			if mvd_temp < 9 then
				if binValDecoded = false and StopCoeff then
					//Give the ctxIdx
					ctxIdx := ctxIdxOffset + ctx_temp;
					StartDecodeDecision := true;	
					//Do not give the hand to Coeff_Abs_Parsing
					StopCabacProcess();
				else
					// Increment binIdx
					if binVal = 1 then
						mvd_temp := mvd_temp + 1;
						if ctx_temp < 6 then
							ctx_temp := ctx_temp + 1;
						end
						if mvd_temp >= 9  then
							StopCoeff := false;
							Coeff_J := 3;
						end
					else
						StopCoeff := false;
						StartCoeffSignAbs := true;
						StartSuffix := false;
					end
					binValDecoded := false;
				end
			end
			
			if mvd_temp >= 9  then
				if StartCoeff_J_Dec = false then
						if binValDecoded = false and StopCoeff = false then
							StartDecodeBypass := true;
							bypassFlag := true;
							StopCabacProcess();
						else
							// Increment binIdx
							if binVal = 1 then
								mvd_temp := mvd_temp + (1 << Coeff_J);
								Coeff_J := Coeff_J + 1;
							else
								StopCoeff := true;
								StartCoeff_J_Dec := true;
							end
							binValDecoded := false;
						end
				else
					if Coeff_J != 0  then
						if binValDecoded = false then
							StartDecodeBypass := true;
							bypassFlag := true;
							StopCabacProcess();
						else
							// Increment binIdx
							if binVal = 1 then
								mvd_temp := mvd_temp + (1 << Coeff_J - 1);
								Coeff_J := Coeff_J - 1;
							else
								Coeff_J := Coeff_J - 1;
							end
							binValDecoded := false;
						end
					else
						StartCoeffSignAbs := true;
						StartSuffix := false;
						StartCoeff_J_Dec := false;
					end
				end
				
			end	
		end
		
		if StartCoeffSignAbs then
			if binValDecoded = false then
				StartDecodeBypass := true;
				bypassFlag := true;
				StopCabacProcess();
			else
				if binVal = 1 then
					CabacValue := mvd_temp * (-1);
				else
					CabacValue := mvd_temp;
				end
				numDecodAbsLevelGt1 := numDecodAbsLevelGt1 + 1;
				
			
				//Stop cabac process and give the value
				
				FoundSE := true;
			end
		end
		
		if FoundSE then
			// Init Coeff_Abs_Parsing
			StartPrefix := true;
			StartSuffix := false;
			StartCoeffSignAbs := false;
			binValDecoded := false;
			binIdx := -1;
			GetSign := false;
			NextBitToDecode := true;
			StopCabacProcess();
		end
	end
	
	procedure GetRefIdx_Lx()
	begin
			
		if StartPrefix then
			CabacValue := 0;
			GetCtxIdxRefIdx();
			ctxIdx := 54 + ctxIdxInc;
			StartPrefix := false;
			StartSuffix := true;
			StopCoeff := true;
		end
		
		if StartSuffix then	
			if binValDecoded = false and StopCoeff then
				StartDecodeDecision := true;	
				//Do not give the hand to GetRefIdx_Lx
				StopCabacProcess();
			else
				if binVal = 0 then
					FoundSE := true;
					StopCoeff := false;
				else
					CabacValue := CabacValue + 1;
					if ctxIdxInc < 4 then
						ctxIdxInc := 4;
					else
						ctxIdxInc := 5;
					end
					ctxIdx := 54 + ctxIdxInc;
					StopCoeff := true;
					binValDecoded := false;
				end
			end
		end
		
		if FoundSE then
			// Init GetRefIdx_Lx
			StartPrefix := true;
			StartSuffix := false;
			binValDecoded := false;
			binIdx := -1;
			NextBitToDecode := true;
			StopCabacProcess();
		end
		
	end
	
	procedure GetMbQpDelta()
	begin
			
		if StartPrefix then
			CabacValue := 0;
			ctxIdxincMbQpDelta();
			ctxIdx := 60 + ctxIdxInc;
			StartPrefix := false;
			StartSuffix := true;
			StopCoeff := true;
		end
		
		if StartSuffix then	
			if binValDecoded = false and StopCoeff then
				StartDecodeDecision := true;	
				//Do not give the hand to GetRefIdx_Lx
				StopCabacProcess();
			else
				if binVal = 0 then
					FoundSE := true;
					StopCoeff := false;
				else
					CabacValue := CabacValue + 1;
					if ctxIdxInc < 2 then
						ctxIdxInc := 2;
					else
						ctxIdxInc := 3;
					end
					ctxIdx := 60 + ctxIdxInc;
					StopCoeff := true;
					binValDecoded := false;
				end
			end
		end
		
		if FoundSE then
			// Init GetMbQpDelta
			StartPrefix := true;
			StartSuffix := false;
			binValDecoded := false;
			binIdx := -1;
			NextBitToDecode := true;
			StopCabacProcess();
		end
		
	end

	procedure GetFlagParsing()
	begin
		if binValDecoded = false then
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_SKIP_FLAG then
				if slice_type = SLICE_TYPE_P then
					ctxIdxOffset := 11;
				else	
					ctxIdxOffset := 24;
				end
				ctxIdxincMbSkipFlag();
			else
				if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_CODED_BLOCK_FLAG then
					ctxIdxOffset := 85 + ctxIdxBlockCatOffset_tab[0][ctxBlockCat];
					ctxIdxCodedBlockFlag();
				else
					if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_SIGNIFICANT_COEFF_FLAG then
						ctxIdxOffset := 105 + ctxIdxBlockCatOffset_tab[1][ctxBlockCat];
						ctxIdxSignificantCoeffFlag();
					else
						if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_LAST_SIGNIFICANT_COEFF_FLAG then
							ctxIdxOffset := 166 + ctxIdxBlockCatOffset_tab[1][ctxBlockCat];
							ctxIdxSignificantCoeffFlag();
						else
							if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG then
								ctxIdxOffset := 68;
								ctxIdxInc := 0;
							else
								if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_TRANSFORM_SIZE_8x8_FLAG then
									ctxIdxOffset := 399;
									ctxIdxTransSize8x8Flag();
								end
							end
						end
								
					end
				end
			end
			//calculate the value of the Context Index
			ctxIdx := ctxIdxInc + ctxIdxOffset;
			StartDecodeDecision := true;	
			//Do not give the hand to GetFlagParsing
			StopCabacProcess();
		else
			CabacValue := binVal;
			FoundSE := true;
		end
		
		
		if FoundSE then
			binValDecoded := false;
			StopCabacProcess();
			NextBitToDecode := true;
		end
	end
	
	procedure GetEndOfSliceParsing()
	begin
		if binValDecoded = false then
			//calculate the value of the Context Index
			ctxIdx := 276;
			StartDecodeTerminate := true;	
			//Do not give the hand to GetFlagParsing
			StopCabacProcess();
		else
			CabacValue := binVal;
			FoundSE := true;
		end
		
		if FoundSE then
			binValDecoded := false;
			StopCabacProcess();
			NextBitToDecode := true;
		end
	end
	
	procedure GetIntraChromaPredModeParsing()
	begin
		if binIdxMb = 0 then
			if binValDecoded = false then
				ctxIdxincIntraChromaPredmode();
				ctxIdx := 64 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 0 then
					CabacValue := 0;
					FoundSE := true;
				else
					binIdxMb := binIdxMb + 1;
				end
				binValDecoded := false;
			end
		end
		
		if binIdxMb = 1 and FoundSE = false then
			if binValDecoded = false then
				ctxIdx := 64 + 3;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 0 then
					CabacValue := 1;
					FoundSE := true;
				else
					binIdxMb := binIdxMb + 1;
				end
				binValDecoded := false;
				
			end
		end
		
		if binIdxMb = 2 and FoundSE = false then
			if binValDecoded = false then
				ctxIdx := 64 + 3;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 0 then
					CabacValue := 2;
					FoundSE := true;
				else
					CabacValue := 3;
					FoundSE := true;
				end
				binValDecoded := false;
			end
		end
		
		if FoundSE then
			binValDecoded := false;
			binIdxMb := -1;
			StopCabacProcess();
		end
	end
	
	procedure GetIntraREM_Mode_4X4_8X8Parsing()
	begin
		if binIdx = 0 then
			if binValDecoded = false then
				ctxIdx := 69;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := binVal;
				binIdx := binIdx + 1;
				binValDecoded := false;
			end
		end
		
		if binIdx = 1 then
			if binValDecoded = false then
				ctxIdx := 69;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := CabacValue + (binVal << 1);
				binIdx := binIdx + 1;
				binValDecoded := false;
			end
		end
		
		if binIdx = 2 then
			if binValDecoded = false then
				ctxIdx := 69;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := CabacValue + (binVal << 2);
				binValDecoded := false;
				FoundSE := true;
			end
		end
		
		if FoundSE then
			binValDecoded := false;
			binIdx := -1;
			StopCabacProcess();
		end
	end
	
	procedure GetCbpLumaParsing()
	begin
		if binIdx = 0 then
			if binValDecoded = false then
				ctxIdxCodedBlockPatternLuma();
				ctxIdx := 73 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
				CabacValue := 0;
			else
				if binVal = 1 then
					CabacValue := CabacValue + bitor(CabacValue, ( 1 << binIdx));
				end
				binIdx := binIdx + 1;
				binValDecoded := false;
			end
		end
		
		if binIdx = 1 then
			if binValDecoded = false then
				ctxIdxCodedBlockPatternLuma();
				ctxIdx := 73 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 1 then
					CabacValue := CabacValue | ( 1 << binIdx);
				end
				binIdx := binIdx + 1;
				binValDecoded := false;
			end
		end
		
		if binIdx = 2 then
			if binValDecoded = false then
				ctxIdxCodedBlockPatternLuma();
				ctxIdx := 73 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 1 then
					CabacValue := CabacValue | ( 1 << binIdx);
				end
				binIdx := binIdx + 1;
				binValDecoded := false;
			end
		end
		
		if binIdx = 3 then
			if binValDecoded = false then
				ctxIdxCodedBlockPatternLuma();
				ctxIdx := 73 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 1 then
					CabacValue := CabacValue | ( 1 << binIdx);
				end
				FoundSE := true;
				binValDecoded := false;
			end
		end
		
		if FoundSE then
			binValDecoded := false;
			binIdx := -1;
			StopCabacProcess();
		end
	end
	
	procedure GetCbpChromaParsing()
	begin
		if binIdx = 0 then
			if binValDecoded = false then
				ctxIdxCodedBlockPatternChroma();
				ctxIdx := 77 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				if binVal = 0 then
					CabacValue := 0;
					FoundSE := true;
				else
					binIdx := binIdx + 1;
				end
				binValDecoded := false;
			end
		end
		
		if binIdx = 1 and FoundSE = false then
			if binValDecoded = false then
				ctxIdxCodedBlockPatternChroma();
				ctxIdx := 77 + ctxIdxInc;
				StartDecodeDecision := true;
				StopCabacProcess();
			else
				CabacValue := 1 + binVal;
				FoundSE := true;
				binValDecoded := false;
			end
		end
		
		if FoundSE then
			binValDecoded := false;
			binIdx := -1;
			StopCabacProcess();
		end
	end
	
	
    //*************************************************************/
	/*************************************************************
	*************************************************************
	********      CABAC Parsing                     	*********
	*************************************************************
	*************************************************************/
	/* CabacParsing */
	action ==>
	guard
		StartNewCabacParsing
	do
		if ( FirstSEinSlice ) then
			StartCabacInit := true;
			// Do not give the hand to Cabac Parsing Process if the initialization has not finished
			StopCabacProcess();
			FirstSEinSlice := false;  
		else
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MVD_L0_0_0 then
				GetMvD_Lx();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_REF_IDX_L0_L1 then
				GetRefIdx_Lx();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_COEFF_ABS_LEVEL_MINUS1 then
			      CoeffAbsParsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_I or CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_P_SP or CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_B then	
				GetMbTypeParsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_SUB_MB_TYPE_P_SP or CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_SUB_MB_TYPE_B then
				GetSubMbTypeParsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_CODED_BLOCK_FLAG or 
			   CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_SKIP_FLAG or 
			   CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_SIGNIFICANT_COEFF_FLAG or 
			   CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_LAST_SIGNIFICANT_COEFF_FLAG or
			   CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_TRANSFORM_SIZE_8x8_FLAG or
			   CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG then
				GetFlagParsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_REM_INTRA4x4_8x8_PRED_MODE then
				GetIntraREM_Mode_4X4_8X8Parsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_CODED_BLOCK_PATERN_LUMA then
				GetCbpLumaParsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_CODED_BLOCK_PATERN_CHROMA then
				GetCbpChromaParsing();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_QP_DELTA then
				GetMbQpDelta();
			end
			
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_INTRA_CHROMA_PRED_MODE then
				GetIntraChromaPredModeParsing();
			end
				
			if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_END_OF_SLICE_FLAG then
				GetEndOfSliceParsing();
			end
		end
	end

	//*************************************************************/
	/*************************************************************
	*************************************************************
	********      CABAC Arithmetic Decoding           	*********
	*************************************************************
	*************************************************************/
	
	function intXOR(int value) --> int:
		if value = 0 then
			1
		else
			0
		end
	end
		
	/********************** RenormD actions **********************/
	/* RenormD_Read */
	action ==>
	guard
		StartRenormDRead and
		codIRange < 0x0100
	do
		set_bits_to_read(1);
		StartRenormD := true;
		StartRenormDRead := false;
	end
	
	/* RenormD_Start */
	action ==>
	guard
		StartRenormD and
		codIRange < 0x0100 and
		done_reading_bits()
	do
		codIRange  := codIRange  << 1;
		codIOffset := codIOffset << 1;
		codIOffset := codIOffset | read_result();
		if ( codIRange < 0x0100 ) then
			set_bits_to_read(1);
		end
	end
	
	/* RenormD_Done */
	action ==>
	guard
		StartRenormD and
		codIRange >= 0x0100
	do
		StartRenormD := false;
		if StartDecodeDecision = false then
			// Give the hand to CabacParsing
			StartCabacProcess();
		end
		// Decode Terminate done
		if ctxIdx = 276 then
			StartCabacProcess();
		end
		
	end	
	/********************** DecodeDecision action **********************/
	
	/* DecodeDecision */
	action ==>
	guard
		StartDecodeDecision
	do
		qCodIRangeIdx := ( codIRange >> 6 ) & 3;
		codIRangeLPS := rangeTabLPS[pStateIdx[ctxIdx]][qCodIRangeIdx];
		codIRange := codIRange - codIRangeLPS;
		
		if TRACE_BIARI then
			println("codIRange := " + codIRange + "codIOffset := " + codIOffset);
		end
		
		if codIOffset >= codIRange then
			binVal     := intXOR(valMPS[ctxIdx]);
			codIOffset := codIOffset - codIRange;
			codIRange  := codIRangeLPS;
			
			if pStateIdx[ctxIdx] = 0 then
				valMPS[ctxIdx] := 1 - valMPS[ctxIdx];
			end
			pStateIdx[ctxIdx] := transIdxLPS[pStateIdx[ctxIdx]];
		else
			binVal := valMPS[ctxIdx]; 
			pStateIdx[ctxIdx] := transIdxMPS[pStateIdx[ctxIdx]];
		end
		
		// Give the right to compare in CabacParsing
		binValDecoded := true;

		
		if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_CODED_BLOCK_PATERN_LUMA then
			prior_decoded_bin_cbp[binIdx] := binVal;
			bk_cbp := bk_cbp + 1;
		end
		
		if codIRange < 0x0100 then
			StartRenormDRead := true;
		else
			StartCabacProcess();
		end			
		// Do not call again DecodeDecision
		StartDecodeDecision := false;
	end
	/********************** DecodeBypass actions **********************/
	
	/* DecodeBypassRead*/ 
	action ==>
	guard
		StartDecodeBypass and
		bypassFlag 
	do
		set_bits_to_read(1);
		// Do not give the hand to CabacParsing
		StopCabacProcess();
		StartDecodeBypass := false;
		StartDecodeBypassStart := true;
	end
	
	/* DecodeBypassStart */ 
	action ==>
	guard
		StartDecodeBypassStart and bypassFlag and done_reading_bits()
	do
		codIOffset := codIOffset << 1;
		codIOffset := codIOffset | read_result();
		
		if codIOffset >= codIRange then
			binVal := 1;
			codIOffset := codIOffset - codIRange;
		else
			binVal := 0;
		end
		
		binValDecoded := true;
		bypassFlag := false;
		StartDecodeBypassStart := false;
		// Give the hand to CabacParsing
		StartCabacProcess();
	end
	
	/* DecodeTerminate */
	action ==>
	guard
		StartDecodeTerminate and
		ctxIdx = 276
	var 
		int tempOffest
	do
		if val_CurrMbAddr = PicSizeInMbs - 1 and SEARCH_MB_TYPE = false then 
			binVal := 1;
			binValDecoded := true;
			// Start Cabac Process
			StartCabacProcess();
			binValDecoded := true;
			// write the bit into the  ReadBinString
			StartDecodeTerminate := false;
		else
		
			codIRange  := codIRange - 2;
			tempOffest := codIOffset - codIRange;
			
			if tempOffest >= 0 then
				binVal := 1;
				binValDecoded := true;
				// Start Cabac Process
				StartCabacProcess();
				// Give the right write a bit into ReadBinString[]
				binValDecoded := true;
			else
				binVal := 0;
				binValDecoded := true;
				if codIRange < 0x100 then
					StartRenormDRead := true;
				else
					// Start Cabac Process
					StartCabacProcess();
					// Give the right write a bit into ReadBinString[]
					binValDecoded := true;
				end
			end
			// write the bit into the  ReadBinString
			StartDecodeTerminate := false;
		end

	end
	/********************** Cabac Initialization **********************/
	
	/* CabacInit */
	action ==>
	guard
		StartCabacInit
	do
		foreach int i in 0 .. 459 do
					if (slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI )then
						preCtxState_pro(val_QP, Cabac_Context_Init_I[i][0], Cabac_Context_Init_I[i][1]);
					else
						preCtxState_pro(val_QP, Cabac_Context_Init_PB[cabac_init_idc][i][0], Cabac_Context_Init_PB[cabac_init_idc][i][1]);
					end
									
					if ( preCtxState  <=  63 )  then
						pStateIdx[i]	:= 63 - preCtxState;
						valMPS[i]		:= 0 ;
					else 
						pStateIdx[i]	:= preCtxState - 64;
						valMPS[i]		:= 1;
					end
				end
		StartInitializationDecoding := true;
		set_bits_to_read(9);
		StartCabacInit := false;
		// Do not give the hand to CabacParsing
		StopCabacProcess();
	end	
	
	
	/* CabacInitDecoding_Done */
	action ==>
	guard
		( PcmAlignementZeroBitDone or PcmSampleLumaDone or PcmSampleChromaDone  or StartInitializationDecoding ) and
		done_reading_bits()
	do
		/* Initialisation of decoding engine */
				
				codIRange	:= 0x01FE;
				codIOffset	:= read_result();
				
		/* End of decoding engine initialisation*/
		
		Cabac_Arithmetic_Decoding_Engine_Start	:= false;
		PcmAlignementZeroBitDone 				:= false;
		PcmSampleLumaDone						:= false;
		PcmSampleChromaDone						:= false;
		
		if ( StartInitializationDecoding = true ) then
			StartInitializationDecoding := false;
			StartCabacInit := false;
		end
		
		
		if CABAC_SEARCH_SYNTAX_ELEMENT = CABAC_MB_TYPE_I and CabacValue = 25 and FoundSE = true then
			StopCabacProcess();
		else
			// Give the hand to CabacParsing
			StartCabacProcess();
		end
		
	end
	
	/*************************************************************
	*************************************************************
	********              NAL Unit HEADER                ********
	*************************************************************
	*************************************************************/
	read_next_byte : action ==> ReadNextByte:[true]
	guard
		bit_read_cnt = 8
	do
	//	println("read_next_byte");
		bit_read_cnt := 0;
		bit_read_cnt_finish := false;
	end

	look_for_Sequence_Header: action ==>
	end

	//FIXME this action is not used any more
	search_start_code: action ==>
	end

	read_Nal_unit_header: action nb_rbsp_bytes:[n] ==>
	guard
    	done_reading_bits()
	do
		//println("bouh");
		val_nb_rbsp_bytes := n;
		set_bits_to_read(NAL_UNIT_HEADER_LENGTH);
	end
  
  
	look_for_which_Header: action ==>
	guard
		done_reading_bits()
	do
		nal_unit_type := mask_bits(read_result(), 5);
		nal_ref_idc := mask_bits(rshift(read_result(), 5), 2);
		//println("look_for_which_Header");
		//println("nal_unit_type "+ nal_unit_type +" nal_ref_idc "+ nal_ref_idc);
		bit_count := 0;
	end
 
	look_for_other_header: action ==>
	guard
		nal_unit_type != 7 and nal_unit_type != 8 and nal_unit_type != 5 and nal_unit_type != 1
	do
		//println("look_for_other_header");
	end
 
	look_for_Sps_header: action ==>
	guard
		nal_unit_type = 7
	do
		//println("look_for_Sps_header");
		set_bits_to_read(24); //8 + 1+1+1+1 + 4 + 8
	end

	look_for_Pps_header: action ==>
	guard
		nal_unit_type = 8
	do
		//println("look_for_Pps_header");
		start_vld();
	end
 
	look_for_Slice_header: action ==>
	guard
		nal_unit_type = 5 or nal_unit_type = 1
	do
		//println("look_for_Slice_header");
		start_vld();
		//Initialisation process for the arithmetic decoding engine //FIXME
		Cabac_Arithmetic_Decoding_Engine_Start := true; 
	end

	/*************************************************************
	*************************************************************
	********        Sequence Parameter Set HEADER        ********
	*************************************************************
	*************************************************************/


	read_Sps_id: action ==>
	guard
		done_reading_bits()
	do
		//println("read Sps id");
		start_vld();
	end

	read_Sps_id_done: action ==>
	guard
		vld_end()
	do
		//println("read Sps id done");
		sps_id := vld_ue();
		level_idc[sps_id] := mask_bits(read_result(), 8);
		constraint_set_flag[sps_id] := mask_bits(rshift(read_result(),12), 4);
		profile_idc[sps_id] := mask_bits(rshift(read_result(),16), 8);
	end
 
	 // if profile is not Baseline or Main
	 read_Sps_chroma_format_idc: action ==>
	 guard
		(profile_idc[sps_id] = 110 
		or profile_idc[sps_id] = 122 
		or profile_idc[sps_id] = 244 
		or profile_idc[sps_id] = 44 
		or profile_idc[sps_id] = 83 
		or profile_idc[sps_id] = 86)
	 do
		//println("read_Sps_chroma_format_idc not yet implemented");
	 end
	 // end if
 
	read_Sps_log2_max_frame_num_minus4: action ==>
	do
		start_vld();
		//println("read_Sps_log2_max_frame_num_minus4");
	end
 
	read_Sps_pic_order_cnt_type: action ==>
	guard
		vld_end()
	do
		//println("read_Sps_pic_order_cnt_type");
		log2_max_frame_num_minus4[sps_id] := vld_ue();
		start_vld();
	end

	// if pic_order_cnt_type == 0
	read_Sps_log2_max_pic_order_cnt_lsb_minus4: action ==>
	guard
		vld_end(),
		vld_ue() = 0
	do
		//println("read_Sps_log2_max_pic_order_cnt_lsb_minus4");
		pic_order_cnt_type[sps_id] := 0;
		start_vld();
	end
 
	read_Sps_log2_max_pic_order_cnt_lsb_minus4_done: action ==>
	guard
		vld_end()
	do
		//println("read_Sps_log2_max_pic_order_cnt_lsb_minus4_done");
		log2_max_pic_order_cnt_lsb_minus4[sps_id] := vld_ue();
	end

	// else if pic_order_cnt_type == 1
	read_Sps_delta_pic_order_always_zero_flag: action ==>
	guard
		vld_end() and
		vld_ue() = 1
	do
		//println("read_Sps_delta_pic_order_always_zero_flag");
		pic_order_cnt_type[sps_id] := 1;
		set_bits_to_read(1);
	end

	read_Sps_offset_for_non_ref_pic: action ==>
	guard
		done_reading_bits()
	do
		//println("read_Sps_offset_for_non_ref_pic");
		delta_pic_order_always_zero_flag[sps_id] := read_result();
		start_vld();
	end

	read_Sps_offset_for_top_to_bottom_field: action ==>
	guard
		vld_end()
	do
		//println("read_Sps_offset_for_top_to_bottom_field");
		offset_for_non_ref_pic[sps_id] := vld_se();
		start_vld();
	end

	read_Sps_num_ref_frames_in_pic_order_cnt_cycle: action ==>
	guard
		vld_end()
	do
		//println("read_Sps_num_ref_frames_in_pic_order_cnt_cycle");
		offset_for_top_to_bottom_field[sps_id] := vld_se();
		start_vld();
	end

	// for (Sps_inc=0 ; Sps_inc<num_ref_frames_in_pic_order_cnt_cycle ; Sps_inc++) 
	read_Sps_offset_for_ref_frame0: action ==>
	guard
		vld_end()
	do
		//println("read_Sps_offset_for_ref_frame0");
		num_ref_frames_in_pic_order_cnt_cycle[sps_id] := vld_ue();
		if num_ref_frames_in_pic_order_cnt_cycle[sps_id] >0 then start_vld(); Sps_inc:=0; end
	end

	read_Sps_offset_for_ref_frame1: action ==>
	guard
		vld_end(),
		Sps_inc < num_ref_frames_in_pic_order_cnt_cycle[sps_id]
	do
		//println("read_Sps_offset_for_ref_frame1");
		offset_for_ref_frame[sps_id][Sps_inc] := vld_se();
		Sps_inc := Sps_inc + 1;
		if Sps_inc < num_ref_frames_in_pic_order_cnt_cycle[sps_id] then start_vld();  end
	end

	read_Sps_skip_offset_for_ref_frame1: action ==>
	guard
		Sps_inc = num_ref_frames_in_pic_order_cnt_cycle[sps_id]
	do
		//println("read_Sps_skip_offset_for_ref_frame1");
	end
	// end for

	// else (pic_order_cnt_type != 0 and !=1)
	read_Sps_pic_order_cnt_type_skip01: action ==>
	guard
		vld_end() and   vld_ue() = 2
	do
		pic_order_cnt_type[sps_id] := 2;
	end
	// end if

	read_Sps_num_ref_frames: action ==>
	do
		start_vld();
	end

	read_Sps_gaps_in_frame_num_value_allowed_flag: action ==>
	guard
		vld_end()
	do
		num_ref_frames[sps_id] := vld_ue();
		set_bits_to_read(1);
	end

	read_Sps_pic_width_in_mbs_minus1: action ==>
	guard
		done_reading_bits()
	do
		gaps_in_frame_num_value_allowed_flag[sps_id] := mask_bits(read_result(), 1);
		start_vld();
	end

	read_Sps_pic_height_in_map_units_minus1: action ==> WIDTH:[pic_width_in_mbs_minus1[sps_id] + 1]
	guard
		vld_end()
	do
		pic_width_in_mbs_minus1[sps_id] := vld_ue();
		start_vld();
	end

	read_Sps_frame_mbs_only_flag: action ==> HEIGHT:[pic_height_in_map_units_minus1[sps_id] + 1]
	guard
		vld_end()
	do
		pic_height_in_map_units_minus1[sps_id] := vld_ue();
		set_bits_to_read(1);
	end

	// if (!frame_mbs_only_flag)
	read_Sps_mb_adaptive_frame_field_flag: action ==>
	guard
		done_reading_bits(),
		read_result() = 0
	var
		uint(size=32) PicWidthInMacroBs,
		uint(size=32) FrameHeightInMacroBs,
		uint(size=8)  Val_Level_IDC,
		int(size=32)  MaxDPB_x_2,
		uint(size=32) MaxFS,
		uint(size=32) Sqrt_8MaxFS,
		uint(size=32) FrameHeight_x_PicWidth,
		uint(size=32) MaxDPBSize
	do
		frame_mbs_only_flag[sps_id] := 0;
		Val_Level_IDC := level_idc[sps_id];
		if(Val_Level_IDC < 31) then                          // 1 <= Level Number <= 3
			if(Val_Level_IDC < 12) then                           // 1 <= Level Number <= 1.1
				if(   Val_Level_IDC = 10 
				   or (bitand(level_idc[sps_id],0x10) = 0)) then            // Level Number = 1 or 1b
					MaxFS       := 99;
					Sqrt_8MaxFS := 28;
					MaxDPB_x_2  := 297;
				else                                                        // Level Number = 1.1
					MaxFS       := 396;
					Sqrt_8MaxFS := 56;
					MaxDPB_x_2  := 675;
				end
			else                                                  // 1.2 <= Level Number <= 3
				if(Val_Level_IDC < 21) then                                 // 1.2 <= Level Number <= 2
					MaxFS       := 396;
					Sqrt_8MaxFS := 56;
					MaxDPB_x_2  := 1782;
				else                                              // 2.1 <= Level Number <= 3
					if(Val_Level_IDC = 21) then                             // Level Number = 2.1
						MaxFS       := 792;
						Sqrt_8MaxFS := 80;//79.5989
						MaxDPB_x_2  := 3564;
					else                                                    // Level Number = 2.2 or 3
						MaxFS       := 1620;
						Sqrt_8MaxFS := 114;//113.8419
						MaxDPB_x_2  := 6075;
					end
				end
			end
		else                                                 // 3.1 <= Level Number <= 5.1
			if(Val_Level_IDC < 42) then                           // 3.1 <= Level Number <= 4.1
				if(Val_Level_IDC < 33) then                            // 3.1 <= Level Number <= 3.2
					if(Val_Level_IDC = 31) then                             // Level Number = 3.1
						MaxFS       := 3600;
						Sqrt_8MaxFS := 170;//169.7056
						MaxDPB_x_2  := 13500;
					else                                                    // Level Number = 3.2
						MaxFS       := 5120;
						Sqrt_8MaxFS := 202;//202.3858
						MaxDPB_x_2  := 15360;
					end
				else                                                        // Level Number = 4 or 4.1
					MaxFS       := 8192;
					Sqrt_8MaxFS := 256;//256
					MaxDPB_x_2  := 24576;
				end
			else                                                  // 4.2 <= Level Number <= 5.1
				if(Val_Level_IDC = 42) then                                 // Level Number = 4.2
					MaxFS       := 8704;
					Sqrt_8MaxFS := 264;//263.8788
					MaxDPB_x_2  := 26112;
				else
					if(Val_Level_IDC = 50) then                             // Level Number = 5
						MaxFS       := 22080;
						Sqrt_8MaxFS := 420;//420.2856
						MaxDPB_x_2  := 82800;
					else                                                    // Level Number = 5.1
						MaxFS       := 36864;
						Sqrt_8MaxFS := 543;//543.0580
						MaxDPB_x_2  := 138240;
					end
				end
			end
		end
		PicWidthInMacroBs    := pic_width_in_mbs_minus1[sps_id] + 1;
		FrameHeightInMacroBs := (2 - 0) * (pic_height_in_map_units_minus1[sps_id] + 1);
		if(PicWidthInMacroBs > Sqrt_8MaxFS) then
			PicWidthInMacroBs := Sqrt_8MaxFS;
		end
		if(FrameHeightInMacroBs > Sqrt_8MaxFS) then
			FrameHeightInMacroBs := Sqrt_8MaxFS;
		end
		FrameHeight_x_PicWidth := FrameHeightInMacroBs * PicWidthInMacroBs;
		if(FrameHeight_x_PicWidth > MaxFS) then
			FrameHeight_x_PicWidth := MaxFS;
		end
		MaxDPBSize := (512 * MaxDPB_x_2) / (FrameHeight_x_PicWidth * 384);
		if(MaxDPBSize >= 16) then
			MaxDPBSz[sps_id] := 16;
		else
			MaxDPBSz[sps_id] := MaxDPBSize;
		end
		set_bits_to_read(1);
	end

	read_Sps_mb_adaptive_frame_field_flag_done: action ==>
	guard
		done_reading_bits()
	do
		mb_adaptive_frame_field_flag[sps_id] := mask_bits(read_result(), 1);
	end
 
	//else (frame_mbs_only_flag)
	read_Sps_skip_mb_adaptive_frame_field_flag: action ==>
	guard
		done_reading_bits(),
		read_result() = 1
	var
		uint(size=32) PicWidthInMacroBs,
		uint(size=32) FrameHeightInMacroBs,
		uint(size=8)  Val_Level_IDC,
		int(size=32)  MaxDPB_x_2,
		uint(size=32) MaxFS,
		uint(size=32) Sqrt_8MaxFS,
		uint(size=32) FrameHeight_x_PicWidth,
		uint(size=32) MaxDPBSize
	do
		frame_mbs_only_flag[sps_id] := 1;
		Val_Level_IDC := level_idc[sps_id];
		if(Val_Level_IDC < 31) then                          // 1 <= Level Number <= 3
			if(Val_Level_IDC < 12) then                           // 1 <= Level Number <= 1.1
				if(   Val_Level_IDC = 10 
				   or (bitand(level_idc[sps_id],0x10) = 0)) then            // Level Number = 1 or 1b
					MaxFS       := 99;
					Sqrt_8MaxFS := 28;
					MaxDPB_x_2  := 297;
				else                                                        // Level Number = 1.1
					MaxFS       := 396;
					Sqrt_8MaxFS := 56;
					MaxDPB_x_2  := 675;
				end
			else                                                  // 1.2 <= Level Number <= 3
				if(Val_Level_IDC < 21) then                                 // 1.2 <= Level Number <= 2
					MaxFS       := 396;
					Sqrt_8MaxFS := 56;
					MaxDPB_x_2  := 1782;
				else                                              // 2.1 <= Level Number <= 3
					if(Val_Level_IDC = 21) then                             // Level Number = 2.1
						MaxFS       := 792;
						Sqrt_8MaxFS := 80;//79.5989
						MaxDPB_x_2  := 3564;
					else                                                    // Level Number = 2.2 or 3
						MaxFS       := 1620;
						Sqrt_8MaxFS := 114;//113.8419
						MaxDPB_x_2  := 6075;
					end
				end
			end
		else                                                 // 3.1 <= Level Number <= 5.1
			if(Val_Level_IDC < 42) then                           // 3.1 <= Level Number <= 4.1
				if(Val_Level_IDC < 33) then                            // 3.1 <= Level Number <= 3.2
					if(Val_Level_IDC = 31) then                             // Level Number = 3.1
						MaxFS       := 3600;
						Sqrt_8MaxFS := 170;//169.7056
						MaxDPB_x_2  := 13500;
					else                                                    // Level Number = 3.2
						MaxFS       := 5120;
						Sqrt_8MaxFS := 202;//202.3858
						MaxDPB_x_2  := 15360;
					end
				else                                                        // Level Number = 4 or 4.1
					MaxFS       := 8192;
					Sqrt_8MaxFS := 256;//256
					MaxDPB_x_2  := 24576;
				end
			else                                                  // 4.2 <= Level Number <= 5.1
				if(Val_Level_IDC = 42) then                                 // Level Number = 4.2
					MaxFS       := 8704;
					Sqrt_8MaxFS := 264;//263.8788
					MaxDPB_x_2  := 26112;
				else
					if(Val_Level_IDC = 50) then                             // Level Number = 5
						MaxFS       := 22080;
						Sqrt_8MaxFS := 420;//420.2856
						MaxDPB_x_2  := 82800;
					else                                                    // Level Number = 5.1
						MaxFS       := 36864;
						Sqrt_8MaxFS := 543;//543.0580
						MaxDPB_x_2  := 138240;
					end
				end
			end
		end
		PicWidthInMacroBs    := pic_width_in_mbs_minus1[sps_id] + 1;
		FrameHeightInMacroBs := (2 - 0) * (pic_height_in_map_units_minus1[sps_id] + 1);
		if(PicWidthInMacroBs > Sqrt_8MaxFS) then
			PicWidthInMacroBs := Sqrt_8MaxFS;
		end
		if(FrameHeightInMacroBs > Sqrt_8MaxFS) then
			FrameHeightInMacroBs := Sqrt_8MaxFS;
		end
		FrameHeight_x_PicWidth := FrameHeightInMacroBs * PicWidthInMacroBs;
		if(FrameHeight_x_PicWidth > MaxFS) then
			FrameHeight_x_PicWidth := MaxFS;
		end
		MaxDPBSize := (512 * MaxDPB_x_2) / (FrameHeight_x_PicWidth * 384);
		if(MaxDPBSize >= 16) then
			MaxDPBSz[sps_id] := 16;
		else
			MaxDPBSz[sps_id] := MaxDPBSize;
		end
	end	//end if

	read_Sps_direct_8x8_interference_flag: action ==>
	do
		set_bits_to_read(1);
	end

	read_Sps_frame_cropping_flag: action ==>
	guard
		done_reading_bits()
	do
		direct_8x8_interference_flag[sps_id] := mask_bits(read_result(), 1);
		set_bits_to_read(1);
	end

	// if (frame_cropping_flag)
	read_Sps_frame_crop_left_offset: action ==>
	guard
		done_reading_bits(),
		read_result() = 1
	do
		frame_cropping_flag[sps_id] := 1;
		start_vld();
	end

	read_Sps_frame_crop_right_offset: action ==>
	guard
		vld_end()
	do
		frame_crop_left_offset[sps_id] := vld_ue();
		start_vld();
	end

	read_Sps_frame_crop_top_offset: action ==>
	guard
		vld_end()
	do
		frame_crop_right_offset[sps_id] := vld_ue();
		start_vld();
	end

	read_Sps_frame_crop_bottom_offset: action ==>
	guard
		vld_end()
	do
		frame_crop_top_offset[sps_id] := vld_ue();
		start_vld();
	end

	read_Sps_frame_crop_bottom_offset_done: action ==>
	guard
		vld_end()
	do
		frame_crop_bottom_offset[sps_id] := vld_ue();
	end

	// else (!frame_cropping_flag)
	read_Sps_skip_frame_crop_left_offset: action ==>
	guard
		done_reading_bits(),
		read_result() = 0
	do
		frame_cropping_flag[sps_id] := 0;
	end
	//end if 

	read_Sps_vui_parameters_present_flag: action ==>
	guard
		done_reading_bits()
	do
		set_bits_to_read(1);
	end

	read_Sps_vui_parameters_present_flag_done: action ==>
	guard
		done_reading_bits()
	do
		vui_parameters_present_flag[sps_id] := mask_bits(read_result(), 1);
		set_bits_to_read(1); //to continue reading the bitstream
		////println("read Sps header done");
		////println("");
	end
	/******* End of Sequence Parameter Set HEADER  ********/
 


	/*************************************************************
	*************************************************************
	********        Picture Parameter Set HEADER        *********
	*************************************************************
	*************************************************************/


	//*************************************
	read_Pps_seq_parameter_set_id: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_seq_parameter_set_id");
		pps_id := vld_ue();
		start_vld();
	end

	read_Pps_entropy_coding_mode_pic_order_flag: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_entropy_coding_mode_pic_order_flag");
		sequence_parameter_set_id[pps_id] := vld_ue();
		set_bits_to_read(2);
	end

	read_Pps_num_slice_groups_minus1: action ==>
	guard
		done_reading_bits()
	do
		//println("read_Pps_num_slice_groups_minus1");
		pic_order_present_flag[pps_id] := mask_bits(read_result(), 1);
		entropy_coding_mode_flag[pps_id] := mask_bits(rshift(read_result(),1), 1);
		start_vld();
	end

	// if (num_slice_groups_minus1 <=0)
	read_Pps_slice_group_map_type_skip: action ==>
	guard
		vld_end(),
		vld_ue() <= 0
	do
		//println("read_Pps_slice_group_map_type_skip");
		num_slice_groups_minus1[pps_id] := vld_ue();
	end

	// if (num_slice_groups_minus1 >0)
	read_Pps_slice_group_map_type: action ==>
	guard
		vld_end(),
		vld_ue() > 0
	do
		//println("read_Pps_slice_group_map_type");
		num_slice_groups_minus1[pps_id] := vld_ue();
		start_vld();
		//println("num_slice_groups_minus1 > 0 not yet implemented");
	end

	read_Pps_check_slice_group_map_type: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_check_slice_group_map_type");
		slice_group_map_type[pps_id] := vld_ue();
		////println("read_Pps_check_slice_group_map_type : "+slice_group_map_type[pps_id]);
		if slice_group_map_type[pps_id] = 0 or slice_group_map_type[pps_id] = 2 or slice_group_map_type[pps_id] = 6 then start_vld(); end
		if slice_group_map_type[pps_id] = 3 or slice_group_map_type[pps_id] = 4 or slice_group_map_type[pps_id] =5 then set_bits_to_read(1); end
		Pps_inc :=0;
	end

	// if (slice_group_map_type == 0)
	//   for (Pps_inc =0 ; Pps_inc < num_slice_groups_minus1 ; Pps_inc++)
	read_Pps_run_length_minus1: action ==>
	guard
		vld_end(),
		slice_group_map_type[pps_id] = 0,
		Pps_inc < num_slice_groups_minus1[pps_id]
	do
		//println("read_Pps_run_length_minus1");
		run_length_minus1[pps_id][Pps_inc] := vld_ue();
		Pps_inc := Pps_inc +1;
		if Pps_inc < num_slice_groups_minus1[pps_id] then start_vld();end
	end
	// end for

	// else if (slice_group_map_type == 1)
	read_Pps_check_slice_group_map_type1: action ==>
	guard
		slice_group_map_type[pps_id] = 1
	do
		//println("read_Pps_check_slice_group_map_type1");
	end

	// else if (slice_group_map_type == 2)
	//   for (Pps_inc =0 ; Pps_inc < num_slice_groups_minus1 ; Pps_inc++)
	read_Pps_top_left: action ==>
	guard
		vld_end(),
		slice_group_map_type[pps_id] = 2,
		Pps_inc < num_slice_groups_minus1[pps_id]
	do
		//println("read_Pps_top_left");
		top_left[pps_id][Pps_inc] := vld_ue();
		start_vld();
	end

	read_Pps_bottom_right: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_bottom_right");
		bottom_right[pps_id][Pps_inc] := vld_ue();
		Pps_inc := Pps_inc +1;
		if Pps_inc < num_slice_groups_minus1[pps_id] then start_vld();end
	end
	//end for

	// else if (slice_group_map_type == 3 | 4 | 5)
	read_Pps_slice_group_change_direction_flag: action ==>
	guard
		done_reading_bits(),
		slice_group_map_type[pps_id] = 3 or slice_group_map_type[pps_id] = 4 or slice_group_map_type[pps_id] = 5
	do
		//println("read_Pps_slice_group_change_direction_flag");
		slice_group_change_direction_flag[pps_id] := read_result();
		start_vld();
	end

	read_Pps_slice_group_change_rate_minus1: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_slice_group_change_rate_minus1");
		slice_group_change_rate_minus1[pps_id] := vld_ue();
	end

	// else if (slice_group_map_type == 6)
	read_Pps_pic_size_in_map_units_minus1: action ==>
	guard
		vld_end(),
		slice_group_map_type[pps_id] = 6
	do
		//println("read_Pps_pic_size_in_map_units_minus1");
		pic_size_in_map_units_minus1[pps_id] := vld_ue();
		//println(" PB : slice_group_map_type = 6 -> search code_start"); 
	end
	// end if

	read_Pps_num_ref_idx_l0_active_minus1: action ==>
	do
		//println("read_Pps_num_ref_idx_l0_active_minus1");
		start_vld();
	end

	read_Pps_num_ref_idx_l1_active_minus1: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_num_ref_idx_l1_active_minus1");
		num_ref_idx_l0_active_minus1[pps_id] := vld_ue();
		start_vld();
	end

	read_Pps_weighted_pred_bipred: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_weighted_pred_bipred");
		num_ref_idx_l1_active_minus1[pps_id] := vld_ue();
		set_bits_to_read(3);
	end

	read_Pps_pic_init_qp_minus26: action ==>
	guard
		done_reading_bits()
	do
		//println("read_Pps_pic_init_qp_minus26");
		weighted_pred_flag[pps_id] := mask_bits(rshift(read_result(),2), 1);
		weighted_bipred_idc[pps_id] := mask_bits(read_result(), 2);
		start_vld();
	end

	read_Pps_pic_init_qs_minus26: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_pic_init_qs_minus26");
		pic_init_qp_minus26[pps_id] := vld_se();
		start_vld();
	end

	read_Pps_chroma_qp_index_offset: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_chroma_qp_index_offset");
		pic_init_qs_minus26[pps_id] := vld_se();
		start_vld();
	end

	read_Pps_flag_deblocking_constrained_redundant: action ==>
	guard
		vld_end()
	do
		//println("read_Pps_flag_deblocking_constrained_redundant");
		chroma_qp_index_offset[pps_id] := vld_se();
		second_chroma_qp_index_offset[pps_id] := vld_se();
		set_bits_to_read(3);
	end

	read_Pps_check_High_Profile: action ==>
	guard
		done_reading_bits()
	do
		//println("read_Pps_check_High_Profile");
		deblocking_filter_control_present_flag[pps_id] := mask_bits(rshift(read_result(),2), 1);
		constrained_intra_pred_flag[pps_id] := (mask_bits(rshift(read_result(),1), 1) = 1);
		redundant_pic_cnt_present_flag[pps_id] := mask_bits(read_result(), 1);
		set_bits_to_read(8 -  bit_count mod 8); //byte_alignment
	end 

	//if (!more_rbsp_data)
	read_Pps_not_High_Profile: action ==>
	guard
		done_reading_bits()
	do
		//println("read_Pps_not_High_Profile");
		////println("read Pps header done");
		//println("");
	end

	//Not implemented due to guard condition : more_rbsp_data 
	/* read_Pps_pic_scaling_matrix_present_flag: action ==>
	guard
	more_rbsp_data()=1
	do
		//println("read_Pps_pic_scaling_matrix_present_flag");
	////println("PPS High Profile not yet implemented !");
	//println("");
	end
	*/
	/******* End of Picture Parameter Set HEADER  ********/
  
  
  
	/*************************************************************
	*************************************************************
	********       Slice HEADER  	      *********
	*************************************************************
	*************************************************************/


	read_SliceH_slice_type: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_slice_type");
		//println("read_SliceH_slice_type");
		first_mb_in_slice := vld_ue();
		start_vld();
	end

	read_SliceH_pps_id: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_pps_id");
		slice_type := vld_ue();
		slice_type := slice_type mod 5;
		start_vld();
	end

	read_SliceH_check_separate_colour_plane_flag: action ==> 
	guard
		vld_end()
	do
		//println("read_SliceH_check_separate_colour_plane_flag");
		pps_id := vld_ue();
		sps_id := sequence_parameter_set_id[pps_id];
	end

	read_SliceH_separate_colour_plane_flag_done: action ==> 
	guard
		separate_colour_plane_flag[sps_id] = 1
	do
		//println("read_SliceH_separate_colour_plane_flag_done");
		set_bits_to_read(2);
	end

	// if(separate_colour_plane_flag ==1)
	read_SliceH_read_colour_plane_id: action ==>
	guard
		done_reading_bits()
	do
		//println("read_SliceH_read_colour_plane_id");
		colour_plane_id := read_result();
		set_bits_to_read(4+log2_max_frame_num_minus4[sps_id]);
	end
	//end if 

	read_SliceH_skip_separate_colour_plane_flag: action ==> 
	guard
		separate_colour_plane_flag[sps_id] != 1
	do
		//println("read_SliceH_skip_separate_colour_plane_flag");
		set_bits_to_read(4+log2_max_frame_num_minus4[sps_id]);
	end


	read_SliceH_frame_num: action ==> NumRefFrame:[num_ref_frames[sps_id] ],FramNumCurrPic:[frame_num], MaxFrameNum:[ValMaxFrameNum]
	guard
		done_reading_bits(),first_mb_in_slice=0
	var
		int(size=32) ValMaxFrameNum
	do
		//println("read_SliceH_frame_num");
		frame_num      := read_result();
		ValMaxFrameNum := 1 << (log2_max_frame_num_minus4[sps_id] + 4);
	end

	skip_read_SliceH_frame_num: action ==> 
	guard
		done_reading_bits(),first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_frame_num");
		frame_num := read_result();
	end

	//if (!frame_mbs_only_flag)
	read_SliceH_field_pic_flag: action ==>
	guard
		frame_mbs_only_flag[sps_id] = 0
	do
		//println("read_SliceH_field_pic_flag");
		set_bits_to_read(1);
	end

	//if (field_pic_flag)
	read_SliceH_bottom_field_flag: action ==>
	guard
		done_reading_bits(),
		read_result() = 1
	do
		//println("read_SliceH_bottom_field_flag");
		field_pic_flag := 1;
		set_bits_to_read(1);
	end


	read_SliceH_bottom_field_flag_done: action ==>
	guard
		done_reading_bits()
	do
		//println("read_SliceH_bottom_field_flag_done");
		bottom_field_flag := read_result();
	end

	//else (!field_flag)
	read_SliceH_skip_bottom_field_flag: action ==>
	guard
		done_reading_bits(),
		read_result() = 0
	do
		//println("read_SliceH_skip_bottom_field_flag");
		field_pic_flag := 0;
	end
	//end if

	// else (frame_mbs_only_flag)
	read_SliceH_skip_field_pic_flag: action ==>
	guard
		frame_mbs_only_flag[sps_id] = 1
	do
		//println("read_SliceH_skip_field_pic_flag");
	end
	//end if

	//if (nal_unit_type == 5)
	read_SliceH_idr_pic_id: action ==>
	guard
		nal_unit_type = 5
	do
		//println("read_SliceH_idr_pic_id");
		start_vld();
	end

	read_SliceH_idr_pic_id_done: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_idr_pic_id_done");
		idr_pic_id := vld_ue();
	end

	//else (nal_unit_type != 5)
	read_SliceH_skip_idr_pic_id: action ==>
	guard
		nal_unit_type != 5
	do
		//println("read_SliceH_skip_idr_pic_id");
	end
	//end if

	read_SliceH_pic_order_cnt_lsb: action ==>
	guard 
		pic_order_cnt_type[sps_id] = 0
	do
		//println("read_SliceH_pic_order_cnt_lsb");
		set_bits_to_read(log2_max_pic_order_cnt_lsb_minus4[sps_id] +4);
	end

	read_SliceH_skip_pic_order_cnt_lsb: action ==>
	guard 
		pic_order_cnt_type[sps_id] != 0
	do
		//println("read_SliceH_skip_pic_order_cnt_lsb");
	end

	//if (pic_order_cnt_type == 0)
	read_SliceH_pic_order_cnt_lsb_done: action ==>
	guard
		done_reading_bits(),
		pic_order_cnt_type[sps_id] = 0
	do
		//println("read_SliceH_pic_order_cnt_lsb_done");
		pic_order_cnt_lsb := read_result();
	end

	read_SliceH_delta_pic_order_cnt_bottom:action ==>
	guard 
		pic_order_present_flag[pps_id] = 1 and field_pic_flag = 0
	do
		//println("read_SliceH_delta_pic_order_cnt_bottom");
		start_vld();
	end

	//if (pic_order_present_flag && !field_pic_flag )
	read_SliceH_delta_pic_order_cnt_bottom_done: action ==>
	guard
		vld_end(),
		pic_order_present_flag[pps_id] = 1 and field_pic_flag = 0
	do
		//println("read_SliceH_delta_pic_order_cnt_bottom_done");
		delta_pic_order_cnt_bottom := vld_se();
	end

	//else (!pic_order_present_flag || field_pic_flag )
	read_SliceH_skip_delta_pic_order_cnt_bottom: action ==>
	guard
		pic_order_present_flag[pps_id] != 1 or field_pic_flag != 0
	do
		//println("read_SliceH_skip_delta_pic_order_cnt_bottom");
	end
	//end if

	read_SliceH_delta_pic_order_cnt0: action ==>
	guard
		pic_order_cnt_type[sps_id] = 1 and delta_pic_order_always_zero_flag[sps_id] = 0
	do
		//println("read_SliceH_delta_pic_order_cnt0");
		start_vld();
	end

	read_SliceH_skip_delta_pic_order_cnt0 : action ==>
	guard
		pic_order_cnt_type[sps_id] != 1 or delta_pic_order_always_zero_flag[sps_id] != 0
	do
		//println("read_SliceH_skip_delta_pic_order_cnt0");
	end

	//else if (pic_order_cnt_type ==1 && !delta_pic_order_always_zero_flag)
	read_SliceH_delta_pic_order_cnt0_done: action ==>
	guard
		vld_end(),
		pic_order_cnt_type[sps_id] = 1 and delta_pic_order_always_zero_flag[sps_id] = 0
	do
		//println("read_SliceH_delta_pic_order_cnt0_done");
		delta_pic_order_cnt[0] := vld_se();
	end

	read_SliceH_delta_pic_order_cnt1: action ==>
	guard 
		pic_order_present_flag[pps_id] = 1 and field_pic_flag = 0
	do
		//println("read_SliceH_delta_pic_order_cnt1");
		start_vld(); 
	end

	//if (pic_order_present_flag && !field_pic_flag )
	read_SliceH_delta_pic_order_cnt1_done: action ==>
	guard
		vld_end(),
		pic_order_present_flag[pps_id] = 1 and field_pic_flag = 0
	do
		//println("read_SliceH_delta_pic_order_cnt1_done");
		delta_pic_order_cnt[1] := vld_se();
	end

	//else (!pic_order_present_flag || field_pic_flag )
	read_SliceH_skip_delta_pic_order_cnt1: action ==>
	guard
		pic_order_present_flag[pps_id] != 1 or field_pic_flag != 0
	do
		//println("read_SliceH_skip_delta_pic_order_cnt1");
	end
	//end if
	
	skipPOC: action ==> 
	guard first_mb_in_slice!=0
	do
		//println("skipPOC");
	end

	CalcPOC: action ==> POC:[POC_val], SizeDPBMax :[MaxDPBSz[sps_id]]
	guard first_mb_in_slice=0
	var 
		int PicOrderCntMsb,
		int TopFieldOrderCnt,
		int BottomFieldOrderCnt,
		int POC_val,
		int MaxPicOrderCntLsb = lshift(1, log2_max_pic_order_cnt_lsb_minus4[sps_id]+4),
		int frame_num_offset, 
		int abs_frame_num, 
		int expected_delta_per_poc_cycle := 0, 
		int expectedpoc := 0
	do
		//println("CalcPOC");
		if nal_unit_type = 5 then 
			frame_num_offset := 0;
		else 
			if frame_num < prev_frame_num then
				frame_num_offset := prev_frame_num_offset + lshift(1, 4+log2_max_frame_num_minus4[sps_id]);
			else
				frame_num_offset := prev_frame_num_offset;
			end
		end
		if pic_order_cnt_type[sps_id] = 0 then 
			if nal_unit_type = 5 then
				prevPicOrderCntMsb := 0;
				prevPicOrderCntLsb := 0;
			end
			if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= rshift(MaxPicOrderCntLsb, 1)) then
				PicOrderCntMsb :=  prevPicOrderCntMsb + MaxPicOrderCntLsb;
				prevPicOrderCntMsb := PicOrderCntMsb;
				prevPicOrderCntLsb := 0;
			else 
				if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) > rshift(MaxPicOrderCntLsb, 1)) then 
					PicOrderCntMsb := prevPicOrderCntMsb - MaxPicOrderCntLsb;
					prevPicOrderCntMsb := PicOrderCntMsb;
				else
					PicOrderCntMsb :=  prevPicOrderCntMsb;
				end
			end
			BottomFieldOrderCnt := PicOrderCntMsb + pic_order_cnt_lsb;
			TopFieldOrderCnt := BottomFieldOrderCnt;
		else
			if pic_order_cnt_type[sps_id] = 1 then
				abs_frame_num := if num_ref_frames_in_pic_order_cnt_cycle[sps_id] != 0 then frame_num_offset + frame_num else 0 end ;
				if nal_ref_idc = 0 and abs_frame_num > 0 then abs_frame_num := abs_frame_num -1; end
				foreach int i in 0 .. num_ref_frames_in_pic_order_cnt_cycle[sps_id]-1 do
					expected_delta_per_poc_cycle := expected_delta_per_poc_cycle + offset_for_ref_frame[sps_id][ i ];
				end
				if abs_frame_num > 0 then
					expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle[sps_id]);
					foreach int i in 0 .. ((abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle[sps_id]) do
						expectedpoc := expectedpoc + offset_for_ref_frame[sps_id][ i ];
					end
				else
					expectedpoc :=0;
				end
				if nal_ref_idc = 0 then expectedpoc := expectedpoc + offset_for_non_ref_pic[sps_id]; end
				TopFieldOrderCnt := expectedpoc + delta_pic_order_cnt[0];
				BottomFieldOrderCnt := TopFieldOrderCnt + offset_for_top_to_bottom_field[sps_id] + delta_pic_order_cnt[1];
				if field_pic_flag = 1 then BottomFieldOrderCnt := BottomFieldOrderCnt +delta_pic_order_cnt[1]; end
			else // pic_order_cnt_type[sps_id] = 2
				TopFieldOrderCnt := if nal_unit_type = 5 then 0 else if nal_ref_idc > 0 then lshift(frame_num_offset + frame_num, 1) else lshift(frame_num_offset + frame_num, 1) - 1 end end;
				BottomFieldOrderCnt := TopFieldOrderCnt; 
			end 
		end
		POC_val := if TopFieldOrderCnt < BottomFieldOrderCnt then TopFieldOrderCnt else BottomFieldOrderCnt end ;
		////println("Currentpoc "+POC);
		prev_frame_num_offset := frame_num_offset;
		prev_frame_num := frame_num;
		prevPicOrderCntLsb := pic_order_cnt_lsb;
if TRACE_POC then
println("POC "+ POC_val);
end
	end

	//if (redundant_pic_cnt_present_flag)
	read_SliceH_redundant_pic_cnt: action ==>
	guard
		redundant_pic_cnt_present_flag[pps_id] = 1
	do
		//println("read_SliceH_redundant_pic_cnt");
		start_vld();
	end

	read_SliceH_redundant_pic_cnt_done: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_redundant_pic_cnt_done");
		redundant_pic_cnt := vld_ue();
	end

	//else
	read_SliceH_skip_redundant_pic_cnt: action ==>
	guard
		redundant_pic_cnt_present_flag[pps_id] = 0
	do
		//println("read_SliceH_skip_redundant_pic_cnt");
	end
	//end if

	//if (slice_type == B)
	read_SliceH_direct_spatial_mv_pred_flag: action ==>
	guard
		slice_type = SLICE_TYPE_B
	do
		//println("read_SliceH_direct_spatial_mv_pred_flag");
		set_bits_to_read(1);
	end

	read_SliceH_direct_spatial_mv_pred_flag_done: action ==>
	guard
		done_reading_bits()
	do
		//println("read_SliceH_direct_spatial_mv_pred_flag_done");
		direct_spatial_mv_pred_flag := read_result();
	end

	//else
	read_SliceH_skip_direct_spatial_mv_pred_flag: action ==>
	guard
		slice_type != SLICE_TYPE_B
	do
		//println("read_SliceH_skip_direct_spatial_mv_pred_flag");
	end
	//end if

	//if (slice_type == P || slice_type == SP || slice_type == B)
	read_SliceH_num_ref_idx_active_override_flag: action ==>
	guard
		slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP or slice_type = SLICE_TYPE_B
	do
		//println("read_SliceH_num_ref_idx_active_override_flag");
		set_bits_to_read(1);
	end

	//if (num_ref_idx_active_override_flag)
	read_SliceH_num_ref_idx_l0_active_minus1: action ==>
	guard
		done_reading_bits(),
		read_result() = 1
	do
		//println("read_SliceH_num_ref_idx_l0_active_minus1");
		num_ref_idx_active_override_flag := 1;
		start_vld();
	end

	//if (slice_type == B)
	read_SliceH_num_ref_idx_l1_active_minus1: action ==>
	guard
		vld_end(),
		slice_type = SLICE_TYPE_B
	do
		//println("read_SliceH_num_ref_idx_l1_active_minus1");
		slice_num_ref_idx_l0_active_minus1 := vld_ue();
		start_vld();
	end

	read_SliceH_num_ref_idx_l1_active_minus1_done: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_num_ref_idx_l1_active_minus1_done");
		slice_num_ref_idx_l1_active_minus1 := vld_ue();
	end
 
	//else (slice_type != B)
	read_SliceH_skip_num_ref_idx_l1_active_minus1: action ==>
	guard
		vld_end(),
		slice_type != SLICE_TYPE_B
	do
		//println("read_SliceH_skip_num_ref_idx_l1_active_minus1");
		slice_num_ref_idx_l0_active_minus1 := vld_ue();
	end
	//end if

	//else (!num_ref_idx_active_override_flag)
	read_SliceH_skip_num_ref_idx_l0_active_minus1: action ==>
	guard
		done_reading_bits(),
		read_result() = 0
	do
		//println("read_SliceH_skip_num_ref_idx_l0_active_minus1");
		num_ref_idx_active_override_flag := 0;
		slice_num_ref_idx_l0_active_minus1 := num_ref_idx_l0_active_minus1[pps_id];
		slice_num_ref_idx_l1_active_minus1 := num_ref_idx_l1_active_minus1[pps_id];
	end
	//end if

	//else (slice_type != P & slice_type != SP && slice_type != B)
	read_SliceH_skip_num_ref_idx_active_override_flag: action ==>
	guard
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	do
		//println("read_SliceH_skip_num_ref_idx_active_override_flag");
		slice_num_ref_idx_l0_active_minus1 := num_ref_idx_l0_active_minus1[pps_id];
		slice_num_ref_idx_l1_active_minus1 := num_ref_idx_l1_active_minus1[pps_id];
	end
	//end if
	


	//*******  ref_pic_list_reordering  ********/

	//if (slice_type % 5 != 2 && slice_type % 5 != 4)
	read_SliceH_ref_pic_list_reordering_flag_l0: action ==> RefList0Type:[ValRefListType]
	guard
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI
	var
		uint(size=2) ValRefListType
	do
		//println("read_SliceH_ref_pic_list_reordering_flag_l0");
		set_bits_to_read(1);
		if(slice_type = SLICE_TYPE_B) then
			ValRefListType := REFLIST0_BI_PRED;
		else
			ValRefListType := REFLIST0_PRED;
		end
	end

	read_SliceH_ref_pic_list_reordering_flag_l0_done: action ==> RefReordering_l0:[ref_pic_list_reordering_flag], Nb_RefFrame_l0:[slice_num_ref_idx_l0_active_minus1 + 1]
	guard 
		done_reading_bits(), first_mb_in_slice=0
	do
		//println("read_SliceH_ref_pic_list_reordering_flag_l0_done");
		ref_pic_list_reordering_flag := read_result();
		reordering_of_pic_nums_idc :=0;
	end

	skip_read_SliceH_ref_pic_list_reordering_flag_l0_done: action ==>
	guard
		done_reading_bits(), first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_ref_pic_list_reordering_flag_l0_done");
		ref_pic_list_reordering_flag := read_result();
		reordering_of_pic_nums_idc :=0;
	end

	//if (ref_pic_list_reordering_flag_l0)
	//do
	read_SliceH_reordering_of_pic_nums_idc_l0: action ==>
	guard 
		ref_pic_list_reordering_flag = 1
	do
		//println("read_SliceH_reordering_of_pic_nums_idc_l0");
		start_vld();
	end

	read_SliceH_reordering_of_pic_nums_idc_l0_done: action ==> RefReordering_l0:[reordering_of_pic_nums_idc]
	guard
		vld_end(), first_mb_in_slice=0
	do
		//println("read_SliceH_reordering_of_pic_nums_idc_l0_done");
		reordering_of_pic_nums_idc := vld_ue();
		if reordering_of_pic_nums_idc != 3 then start_vld(); end
	end

	skip_read_SliceH_reordering_of_pic_nums_idc_l0_done: action ==>
	guard
		vld_end(), first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_reordering_of_pic_nums_idc_l0_done");
		reordering_of_pic_nums_idc := vld_ue();
		if reordering_of_pic_nums_idc != 3 then start_vld(); end
	end

	//if (reordering_of_pic_nums_idc == 0 || reordering_of_pic_nums_idc == 1)
	read_SliceH_abs_diff_pic_num_minus1_l0_done: action ==> RefReordering_l0:[vld_ue()]
	guard
		vld_end(), first_mb_in_slice=0,
		reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
	do
		//println("read_SliceH_abs_diff_pic_num_minus1_l0_done");
	end

	//if (reordering_of_pic_nums_idc == 0 || reordering_of_pic_nums_idc == 1)
	skip_read_SliceH_abs_diff_pic_num_minus1_l0_done: action ==> 
	guard
		vld_end(), first_mb_in_slice!=0,
		reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
	do
		//println("skip_read_SliceH_abs_diff_pic_num_minus1_l0_done");
	end
	// else if (reordering_of_pic_nums_idc == 2)
	read_SliceH_long_term_pic_num_idc2_l0_done: action ==> RefReordering_l0:[vld_ue()]
	guard
		vld_end(), first_mb_in_slice=0,
		reordering_of_pic_nums_idc =2
	do
		//println("read_SliceH_long_term_pic_num_idc2_l0_done");
	end

	skip_read_SliceH_long_term_pic_num_idc2_l0_done: action ==>
	guard
		vld_end(), first_mb_in_slice!=0,
		reordering_of_pic_nums_idc =2
	do
		//println("skip_read_SliceH_long_term_pic_num_idc2_l0_done");
	end
	//else (reordering_of_pic_nums_idc == 3)
	read_SliceH_skip_reordering_of_pic_nums_idc3_l0: action ==>
	guard
		reordering_of_pic_nums_idc = 3
	do
		//println("read_SliceH_skip_reordering_of_pic_nums_idc3_l0");
	end
	//end if
	//while (reordering_of_pic_nums_idc != 3)

	//else ( !ref_pic_list_reordering_flag_l0  )
	read_SliceH_skip_reordering_of_pic_nums_idc_l0: action ==>
	guard 
		ref_pic_list_reordering_flag = 0
	do
		//println("read_SliceH_skip_reordering_of_pic_nums_idc_l0");
	end
					//if (slice_type % 5 == 1)
					read_SliceH_ref_pic_list_reordering_flag_l1: action ==> RefList1Type:[REFLIST1_BI_PRED]
					guard
						slice_type = SLICE_TYPE_B
					do
						//println("read_SliceH_ref_pic_list_reordering_flag_l1");
						set_bits_to_read(1);
					end

					read_SliceH_ref_pic_list_reordering_flag_l1_done: action ==> RefReordering_l1:[ref_pic_list_reordering_flag], Nb_RefFrame_l1:[slice_num_ref_idx_l1_active_minus1 + 1]
					guard 
						done_reading_bits(), first_mb_in_slice=0
					do
						//println("read_SliceH_ref_pic_list_reordering_flag_l1_done");
						ref_pic_list_reordering_flag := read_result();
						reordering_of_pic_nums_idc :=0;
					end

					skip_read_SliceH_ref_pic_list_reordering_flag_l1_done: action ==>
					guard
						done_reading_bits(), first_mb_in_slice!=0
					do
						//println("skip_read_SliceH_ref_pic_list_reordering_flag_l1_done");
						ref_pic_list_reordering_flag := read_result();
						reordering_of_pic_nums_idc :=0;
					end

					//if (ref_pic_list_reordering_flag_l1)
					//do
					read_SliceH_reordering_of_pic_nums_idc_l1: action ==>
					guard 
						ref_pic_list_reordering_flag = 1
					do
						//println("read_SliceH_reordering_of_pic_nums_idc_l1");
						start_vld();
					end

					read_SliceH_reordering_of_pic_nums_idc_l1_done: action ==> RefReordering_l1:[reordering_of_pic_nums_idc]
					guard
						vld_end(), first_mb_in_slice=0
					do
						//println("read_SliceH_reordering_of_pic_nums_idc_l1_done");
						reordering_of_pic_nums_idc := vld_ue();
						if reordering_of_pic_nums_idc != 3 then start_vld(); end
					end

					skip_read_SliceH_reordering_of_pic_nums_idc_l1_done: action ==>
					guard
						vld_end(), first_mb_in_slice!=0
					do
						//println("skip_read_SliceH_reordering_of_pic_nums_idc_l1_done");
						reordering_of_pic_nums_idc := vld_ue();
						if reordering_of_pic_nums_idc != 3 then start_vld(); end
					end

					//if (reordering_of_pic_nums_idc == 0 || reordering_of_pic_nums_idc == 1)
					read_SliceH_abs_diff_pic_num_minus1_l1_done: action ==> RefReordering_l1:[vld_ue()]
					guard
						vld_end(), first_mb_in_slice=0,
						reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
					do
						//println("read_SliceH_abs_diff_pic_num_minus1_l1_done");
					end

					//if (reordering_of_pic_nums_idc == 0 || reordering_of_pic_nums_idc == 1)
					skip_read_SliceH_abs_diff_pic_num_minus1_l1_done: action ==> 
					guard
						vld_end(), first_mb_in_slice!=0,
						reordering_of_pic_nums_idc =0 or reordering_of_pic_nums_idc =1
					do
						//println("skip_read_SliceH_abs_diff_pic_num_minus1_l1_done");
					end
					// else if (reordering_of_pic_nums_idc == 2)
					read_SliceH_long_term_pic_num_idc2_l1_done: action ==> RefReordering_l1:[vld_ue()]
					guard
						vld_end(), first_mb_in_slice=0,
						reordering_of_pic_nums_idc =2
					do
						//println("read_SliceH_long_term_pic_num_idc2_l1_done");
					end

					skip_read_SliceH_long_term_pic_num_idc2_l1_done: action ==>
					guard
						vld_end(), first_mb_in_slice!=0,
						reordering_of_pic_nums_idc =2
					do
						//println("skip_read_SliceH_long_term_pic_num_idc2_l1_done");
					end
					//else (reordering_of_pic_nums_idc == 3)
					read_SliceH_skip_reordering_of_pic_nums_idc3_l1: action ==>
					guard
						reordering_of_pic_nums_idc = 3
					do
						//println("read_SliceH_skip_reordering_of_pic_nums_idc3_l1");
					end
					//end if
					//while (reordering_of_pic_nums_idc != 3)

					//else ( !ref_pic_list_reordering_flag_l1  )
					read_SliceH_skip_reordering_of_pic_nums_idc_l1: action ==>
					guard 
						ref_pic_list_reordering_flag = 0
					do
						//println("read_SliceH_skip_reordering_of_pic_nums_idc_l1");
					end
					//end if

					//else (slice_type % 5 != 1)
					read_SliceH_skip_ref_pic_list_reordering_l1: action ==> RefReordering_l1:[0], Nb_RefFrame_l1:[0], RefList1Type:[0]
					guard
						slice_type != SLICE_TYPE_B
					do
						//println("read_SliceH_skip_ref_pic_list_reordering_l1");
					end

					skip_read_SliceH_skip_ref_pic_list_reordering_l1: action ==>
					guard
						slice_type != SLICE_TYPE_B
					do
						//println("skip_read_SliceH_skip_ref_pic_list_reordering_l1");
					end
					//end if
	
	//end if

	//else (slice_type % 5 == 2 || slice_type % 5 == 4)
	read_SliceH_skip_ref_pic_list_reordering: action ==> RefReordering_l0:[0], Nb_RefFrame_l0:[0], RefReordering_l1:[0], Nb_RefFrame_l1:[0], RefList0Type:[0]
	guard
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI, first_mb_in_slice=0
	do
		//println("read_SliceH_skip_ref_pic_list_reordering");
	end

	skip_read_SliceH_skip_ref_pic_list_reordering: action ==>
	guard
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI, first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_skip_ref_pic_list_reordering");
	end
	//end if
	//******* End of ref_pic_list_reordering  ********/


	//******* pred_weight_table  ********/
	//if (weighted_pred_flag && (slice_type == P or slice_type == SP)) ||
	//   (weighted_bipred_idc == 1 && slice_type == B)
	read_SliceH_pred_weight_table: action ==>
	guard
		(weighted_pred_flag[sps_id] = 1 and (slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP))
		or (weighted_bipred_idc[sps_id] = 1 and slice_type = SLICE_TYPE_B)
	do
		//println("SliceH : pred_weight_table not yet implemented"); 
	end
 
	//else
	read_SliceH_skip_pred_weight_table: action ==>
	do
		//println("read_SliceH_skip_pred_weight_table"); 
	end
	//end if
	//******* End of pred_weight_table  ********/

	//******* dec_ref_pic_marking  ********/

	// if (nal_ref_idc !=0)
	read_SliceH_dec_ref_pic_marking: action ==>
	guard
		nal_ref_idc !=0
	do
		//println("read_SliceH_dec_ref_pic_marking"); 
		if nal_unit_type = 5 then set_bits_to_read(2); else set_bits_to_read(1); end  
	end

	// if (IdrPicFlag)
	read_SliceH_no_output_of_prior_pics_flag_done: action ==> MMCO:[0, long_term_reference_flag]
	guard
		nal_unit_type = 5, first_mb_in_slice=0,
		done_reading_bits()
	do
		//println("read_SliceH_no_output_of_prior_pics_flag_done"); 
		no_output_of_prior_pics_flag := rshift(read_result(),1);
		long_term_reference_flag := mask_bits(read_result(),1);
	end

	skip_read_SliceH_no_output_of_prior_pics_flag_done: action ==> 
	guard
		nal_unit_type = 5, first_mb_in_slice!=0,
		done_reading_bits()
	do
		//println("skip_read_SliceH_no_output_of_prior_pics_flag_done"); 
		no_output_of_prior_pics_flag := rshift(read_result(),1);
		long_term_reference_flag := mask_bits(read_result(),1);
	end

	// else (!IdrPicFlag)
	read_SliceH_adaptative_ref_pic_marking_mode_flag_done: action ==> MMCO:[1,adaptative_ref_pic_marking_mode_flag]
	guard
		nal_unit_type != 5, first_mb_in_slice = 0,
		done_reading_bits()
	do
		//println("read_SliceH_adaptative_ref_pic_marking_mode_flag_done"); 
		adaptative_ref_pic_marking_mode_flag := read_result();
		if adaptative_ref_pic_marking_mode_flag = 1 then start_vld(); end
	end
	
	skip_read_SliceH_adaptative_ref_pic_marking_mode_flag_done: action ==> 
	guard
		nal_unit_type != 5, first_mb_in_slice != 0,
		done_reading_bits()
	do
		//println("skip_read_SliceH_adaptative_ref_pic_marking_mode_flag_done"); 
		adaptative_ref_pic_marking_mode_flag := read_result();
		if adaptative_ref_pic_marking_mode_flag = 1 then start_vld(); end
	end

	// if (adaptative_ref_pic_marking_mode_flag)
	//do
	read_SliceH_memory_management_control_operation_done: action ==> MMCO:[memory_management_control_operation]
	guard
		adaptative_ref_pic_marking_mode_flag = 1, first_mb_in_slice=0,
		vld_end()
	do
		//println("read_SliceH_memory_management_control_operation_done"); 
		memory_management_control_operation := vld_ue();
		if 	memory_management_control_operation = 1 or 
			memory_management_control_operation = 2 or 
			memory_management_control_operation = 3 or 
			memory_management_control_operation = 4 or 
			memory_management_control_operation = 6 then 
				start_vld(); 
		end
	end

	skip_read_SliceH_memory_management_control_operation_done: action ==> 
	guard
		adaptative_ref_pic_marking_mode_flag = 1, first_mb_in_slice!=0,
		vld_end()
	do
		//println("skip_read_SliceH_memory_management_control_operation_done"); 
		memory_management_control_operation := vld_ue();
		if 	memory_management_control_operation = 1 or 
			memory_management_control_operation = 2 or 
			memory_management_control_operation = 3 or 
			memory_management_control_operation = 4 or 
			memory_management_control_operation = 6 then 
				start_vld(); 
		end
	end

	// if (mmco == 1 || mmco == 3)
	read_SliceH_difference_of_pic_nums_minus1_done: action ==> MMCO:[difference_of_pic_nums_minus1]
	guard
		memory_management_control_operation = 1 or memory_management_control_operation = 3,
		vld_end(), first_mb_in_slice=0
	do
		//println("read_SliceH_difference_of_pic_nums_minus1_done"); 
		difference_of_pic_nums_minus1 := vld_ue();
		start_vld();
	end

	skip_read_SliceH_difference_of_pic_nums_minus1_done: action ==> 
	guard
		memory_management_control_operation = 1 or memory_management_control_operation = 3,
		vld_end(), first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_difference_of_pic_nums_minus1_done"); 
		difference_of_pic_nums_minus1 := vld_ue();
		start_vld();
	end
	// end if

	// if (mmco == 2)
	read_SliceH_long_term_pic_num_done: action ==> MMCO:[long_term_pic_num]
	guard
		memory_management_control_operation = 2,
		vld_end(), first_mb_in_slice=0
	do
		//println("read_SliceH_long_term_pic_num_done"); 
		long_term_pic_num := vld_ue();
		start_vld();
	end

	skip_read_SliceH_long_term_pic_num_done: action ==>
	guard
		memory_management_control_operation = 2,
		vld_end(), first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_long_term_pic_num_done"); 
		long_term_pic_num := vld_ue();
		start_vld();
	end
	// end if

	// if (mmco == 3 || mmco == 6)
	read_SliceH_long_term_frame_idx_done: action ==> MMCO:[long_term_frame_idx]
	guard
		memory_management_control_operation = 3 or memory_management_control_operation = 6,
		vld_end(), first_mb_in_slice=0
	do
		//println("read_SliceH_long_term_frame_idx_done"); 
		long_term_frame_idx := vld_ue();
		start_vld();
	end

	// if (mmco == 3 || mmco == 6)
	skip_read_SliceH_long_term_frame_idx_done: action ==>
	guard
		memory_management_control_operation = 3 or memory_management_control_operation = 6,
		vld_end(), first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_long_term_frame_idx_done"); 
		long_term_frame_idx := vld_ue();
		start_vld();
	end

	read_SliceH_long_not_term_frame_idx_done: action ==> 
	guard
		memory_management_control_operation != 3 and memory_management_control_operation != 6
	do
		//println("read_SliceH_long_not_term_frame_idx_done"); 
	end


	// end if

	// if (mmco == 4)
	read_SliceH_max_long_term_frame_idx_plus1_done: action ==> MMCO:[max_long_term_frame_idx_plus1]
	guard
		memory_management_control_operation = 4,
		vld_end(), first_mb_in_slice=0
	do
		//println("read_SliceH_max_long_term_frame_idx_plus1_done"); 
		max_long_term_frame_idx_plus1 := vld_ue();
		start_vld();
	end

	skip_read_SliceH_max_long_term_frame_idx_plus1_done: action ==> 
	guard
		memory_management_control_operation = 4,
		vld_end(), first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_max_long_term_frame_idx_plus1_done"); 
		max_long_term_frame_idx_plus1 := vld_ue();
		start_vld();
	end
	// end if

	// if (mmco == 5)
	read_SliceH_mmco_5: action ==>
	guard
		memory_management_control_operation = 5
	do
		//println("read_SliceH_mmco_5"); 
		start_vld();
		prev_frame_num:=0;
	end
	// end if

	// if (mmco == 0)
	read_SliceH_mmco_0: action ==>
	guard
		memory_management_control_operation = 0
	do
		//println("read_SliceH_mmco_0"); 
	end
	// end if
	// while (mmco != 0)

	// else (!adaptative_ref_pic_marking_mode_flag)
	read_SliceH_skip_memory_management_control_operation_done: action ==>
	guard
		adaptative_ref_pic_marking_mode_flag = 0
	do
		//println("read_SliceH_skip_memory_management_control_operation_done"); 
	end

	//else (nal_ref_idc == 0)
	read_SliceH_skip_dec_ref_pic_marking.IDRPic: action ==> MMCO :[0,0]
	guard
		nal_ref_idc = 0, first_mb_in_slice=0, nal_unit_type = 5
	do
		//println("read_SliceH_skip_dec_ref_pic_marking.IDRPic"); 
	end

	read_SliceH_skip_dec_ref_pic_marking.NonIDRPic: action ==> MMCO :[1,0]
	guard
		nal_ref_idc = 0, first_mb_in_slice=0, nal_unit_type != 5
	do
		//println("read_SliceH_skip_dec_ref_pic_marking.NonIDRPic"); 
	end

	skip_read_SliceH_skip_dec_ref_pic_marking: action ==>
	guard
		nal_ref_idc = 0, first_mb_in_slice!=0
	do
		//println("skip_read_SliceH_skip_dec_ref_pic_marking"); 
	end
	//end if
	//******* End of dec_ref_pic_marking  ********/

	//if (entropy_coding_mode_flag && slice_type != I && slice_type != SI)
	read_SliceH_cabac_init_idc: action ==>
	guard
		entropy_coding_mode_flag[pps_id] = 1,
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI
	do
		//println("read_SliceH_cabac_init_idc"); 
		start_vld();
	end

	read_SliceH_cabac_init_idc_done: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_cabac_init_idc_done"); 
		cabac_init_idc := vld_ue();
		start_vld();
	end

	//else 
	read_SliceH_skip_cabac_init_idc: action ==>
	guard
		entropy_coding_mode_flag[pps_id] = 0 or slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	do
		//println("read_SliceH_skip_cabac_init_idc"); 
		start_vld();
	end
	//end if

	read_SliceH_slice_qp_delta_done: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_slice_qp_delta_done"); 
		slice_qp_delta := vld_se();
		val_QP := 26 + pic_init_qp_minus26[pps_id] + slice_qp_delta;
		val_QP_Cb := qP_tab[val_QP + chroma_qp_index_offset[pps_id]];
		val_QP_Cr := qP_tab[val_QP + second_chroma_qp_index_offset[pps_id]];
	end

	// if ( slice_type == SP || slice_type == SI )
	read_SliceH_sp_for_switch_flag: action ==>
	guard
		slice_type = SLICE_TYPE_SP or slice_type = SLICE_TYPE_SI 
	do
		//println("read_SliceH_sp_for_switch_flag"); 
		if slice_type = SLICE_TYPE_SP then set_bits_to_read(1); else start_vld(); end
	end

	// if ( slice_type == SP )
	read_SliceH_sp_for_switch_flag_done: action ==>
	guard
		slice_type = SLICE_TYPE_SP,
		done_reading_bits()
	do
		//println("read_SliceH_sp_for_switch_flag_done"); 
		sp_for_switch_flag := read_result();
		start_vld();
	end
	// end if

	read_SliceH_slice_qs_delta_done: action ==>
	guard
		vld_end()
	do
		//println("read_SliceH_slice_qs_delta_done"); 
		slice_qs_delta := vld_se();
	end

	// else (slice_type != SP && slice_type != SI)
	read_SliceH_skip_sp_for_switch_flag: action ==>
	guard
		slice_type != SLICE_TYPE_SP and slice_type != SLICE_TYPE_SI 
	do
		//println("read_SliceH_skip_sp_for_switch_flag"); 
	end
	//end if

	// if ( deblocking_filter_control_present_flag )
	read_SliceH_disable_deblocking_filter_idc: action ==>
	guard
		deblocking_filter_control_present_flag[pps_id] = 1
	do
		//println("read_SliceH_disable_deblocking_filter_idc"); 
		start_vld();
	end

	// if ( disable_deblocking_filter_idc != 1 )
	read_SliceH_slice_alpha_c0_offset_div2: action ==> 
	guard
		vld_end(),
		vld_ue() != 1
	do
		//println("read_SliceH_slice_alpha_c0_offset_div2"); 
		disable_deblocking_filter_idc := vld_ue();
		start_vld();
	end

	read_SliceH_slice_beta_offset_div2: action ==>  
	guard
		vld_end()
	do
		//println("read_SliceH_slice_beta_offset_div2"); 
		slice_alpha_c0_offset_div2 := vld_se();
		val_slice_alpha_c0_offset:=lshift(slice_alpha_c0_offset_div2,1);
		start_vld();
	end

	read_SliceH_slice_beta_offset_div2_done: action ==> 
	guard
		vld_end()
	do
		//println("read_SliceH_slice_beta_offset_div2_done"); 
		slice_beta_offset_div2 := vld_se();
		val_slice_beta_offset:=lshift(slice_beta_offset_div2,1);
	end

	// else
	read_SliceH_skip_slice_alpha_c0_offset_div2: action ==>
	guard
		vld_end(),
		vld_ue() = 1
	do
		//println("read_SliceH_skip_slice_alpha_c0_offset_div2"); 
		disable_deblocking_filter_idc := vld_ue();
		val_slice_alpha_c0_offset:=0;
		val_slice_beta_offset:=0;
	end
	// end if

	// else (!deblocking_filter_control_present_flag )
	read_SliceH_skip_disable_deblocking_filter_idc: action ==>
	guard
		deblocking_filter_control_present_flag[pps_id] = 0
	do
		//println("read_SliceH_skip_disable_deblocking_filter_idc"); 
		val_slice_alpha_c0_offset:=0;
		val_slice_beta_offset:=0;
	end
	//end if

	//if ( num_slice_groups_minus1 > 0 && slice_group_map_type >= 3 && slice_group_map_type <= 5 )
	read_SliceH_slice_group_change_cycle: action ==>
	guard
		num_slice_groups_minus1[pps_id] > 0,
		slice_group_map_type[pps_id] >= 3,
		slice_group_map_type[pps_id] <= 5
	var 
		int x, 
		int n
	do
		//println("read_SliceH_slice_group_change_cycle");
		x := (pic_width_in_mbs_minus1[sps_id] + 1) * (pic_height_in_map_units_minus1[sps_id] +1) / slice_group_change_rate_minus1[pps_id] +1;
		//n := log_base2( x )
		x := x -1;
		n:= 0;
		while x>0 do
			x := rshift( x, 1);
			n := n+1;
		end
		set_bits_to_read( n );
	end

	read_SliceH_slice_group_change_cycle_done: action ==>
	guard
		done_reading_bits()
	do
		//println("read_SliceH_slice_group_change_cycle_done");
		slice_group_change_cycle := read_result();
		//println("read Slice header done");
	end

	//else
	read_SliceH_skip_slice_group_change_cycle: action ==>
	do
		//println("read_SliceH_skip_slice_group_change_cycle");
	////println("read Slice header done");
	end
	//end if

	//******* End of Slice HEADER  ********/

	/*************************************************************
	*************************************************************
	********       Slice DATA 	  	      *********
	*************************************************************
	*************************************************************/
 
	procedure NextMbAddress()
	begin
		val_CurrMbAddr := val_CurrMbAddr + 1;
		Mb_x := val_CurrMbAddr mod PicWidthInMbs;
		Mb_y := val_CurrMbAddr / PicWidthInMbs;
		if(DEBUG_NEW_PARSER) then
			println("\n\n\n*** New Mb *** Val = "+val_CurrMbAddr);
		end
	end


	//if (entropy_coding_mode_flag) : CABAC
	//while( !byte_aligned())
	read_SliceD_CABAC_alignement: action ==>
	guard
		entropy_coding_mode_flag[pps_id] = 1
	do
		//println("read_SliceD_CABAC_alignement");
		if bit_count mod 8 != 0 then set_bits_to_read(8-bit_count mod 8); /*else bits_to_read_count := -1;*/ end
	end

	read_SliceD_skip_CABAC_alignement: action ==>
	guard
		entropy_coding_mode_flag[pps_id] = 0
	do
		//println("read_SliceD_skip_CABAC_alignement");
	end

	SliceD_init: action ==>  ENTROPY_TYPE:[entropy_coding_mode_flag[pps_id]]
	guard
		(entropy_coding_mode_flag[pps_id] = 1 and done_reading_bits()) or entropy_coding_mode_flag[pps_id] = 0
	do
		//println("SliceD_init");
		val_CurrMbAddr := first_mb_in_slice;
		PicWidthInMbs := (pic_width_in_mbs_minus1[sps_id] +1);
		PicSizeInMbs := PicWidthInMbs * (pic_height_in_map_units_minus1[sps_id] +1);
		
		if IS_CAVLC() then
		  NonZeroCount   := [[ 0 : for int j in 0 .. 16-1] : for int i in 0 .. PICHEIGHT*PICWIDTH-1]; //FIXME ! size is not right
		  NonZeroCountCb := [[ 0 : for int j in 0 .. 4-1] : for int i in 0 .. PICHEIGHT*PICWIDTH-1]; //FIXME ! size is not right
		  NonZeroCountCr := [[ 0 : for int j in 0 .. 4-1] : for int i in 0 .. PICHEIGHT*PICWIDTH-1]; //FIXME ! size is not right
		end
		
		Mb_x := val_CurrMbAddr mod PicWidthInMbs;
		Mb_y := val_CurrMbAddr / PicWidthInMbs;

		moreDataFlag := 1;
		prevMbSkipped := 0;
		if field_pic_flag = 0 and mb_adaptive_frame_field_flag[sps_id] = 1 then MbaffFrameFlag := 1; else MbaffFrameFlag := 0; end
		FirstSEinSlice := true;
		//Init Tabs 
		
		if IS_CABAC() then
		  foreach int i in 0 .. PicWidthInMbs - 1 do
			  mbTab[i][mbCBF] := 0;
			  foreach int j in 0 .. 3 do
				  transblock_cbf_cr[i][j] := 0;
				  transblock_cbf_cb[i][j] := 0;
			  end
		  end
		  
		  foreach int i in 0 .. PicWidthInMbs - 1 do
			  foreach int j in 0 .. 15 do
				  transblock_cbf[i][j] := 0;
			  end
		  end
		  
		  foreach int i in 0 .. PicWidthInMbs - 1 do
			  foreach int j in 0 .. 1 do
				  transblock_cbf_dc_cr_cb[i][j] := 0;
			  end
		  end
		  //init mb_skip_flag
		  mb_skip_flag := 0;
		  //Init FoundSE
		  FoundSE := false;
		end
	end

	//do
	sync_do_mb_layer: action
		==> 
	do
		//println("sync_do_mb_layer");
	end


	//if (slice_type != I && slice_type != SI)
	//  if (!entropy_coding_mode_flag) : CAVLC
	read_SliceD_mb_skip_run: action ==>
	guard
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI,
		entropy_coding_mode_flag[pps_id] = 0
	do
		//println("read_SliceD_mb_skip_run");
		start_vld();
	end

	read_SliceD_mb_skip_run_done0: action ==>
	guard
		vld_end()
	do
		//println("read_SliceD_mb_skip_run_done0");
		mb_skip_run := vld_ue();
		if mb_skip_run >0 then 
			prevMbSkipped := 1; 
		else 
			prevMbSkipped := 0; 
		end
	end

	read_SliceD_mb_skip_run_done1.I_BLOC: action 
		==> 
			CurrMbAddr:[mb_addr],
			PicWidthInMb:[PicWidthInMbs],
			PicSizeInMb:[PicSizeInMbs],
			FirstMbInSlice:[first_mb_in_slice],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[0],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16, 
			MbIntraFlag:[0], 
			MbPartIdx:[1], 
			RefIdx:[0], 
			MbPartWidth:[16], 
			MbPartHeigth:[16], 
			MvRes:[0,0],
			LAST:[[true: for int t in 0 .. 26 ]] repeat 27
			
	guard
		prevMbSkipped = 1 and IS_CAVLC(),
		slice_type != SLICE_TYPE_P
	var 
		int mb_addr
	do
		//println("read_SliceD_mb_skip_run_done1.I_BLOC");
		mb_addr:=val_CurrMbAddr;
		NextMbAddress();
		mb_skip_run := mb_skip_run -1;
		if mb_skip_run = 0 then 
			prevMbSkipped := 0; 
			moreDataFlag := more_rbsp_data();
		end
if TRACE_MRL then
println("CurrMbAddr "+ mb_addr);
println("MbIntraFlag "+0);
println("QP "+val_QP);
println("QP_Cb "+ val_QP_Cb);
println("QP_Cr "+ val_QP_Cr);
println("ConstrainedIFlag "+constrained_intra_pred_flag[pps_id]);
println("PicWidthInMb "+PicWidthInMbs);
println("PicSizeInMb "+ PicSizeInMbs);
println("FirstMbInSlice "+ first_mb_in_slice);
println("slice_alpha_c0_offset "+val_slice_alpha_c0_offset);
println("slice_beta_offset "+val_slice_beta_offset);
println("LFDisable "+disable_deblocking_filter_idc);
println("cbp_blk "+0);
end
	end

	read_SliceD_mb_skip_run_done1.P_BLOC: action 
		==> 
			CurrMbAddr:[mb_addr],
			PicWidthInMb:[PicWidthInMbs],
			PicSizeInMb:[PicSizeInMbs],
			FirstMbInSlice:[first_mb_in_slice],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[0],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16, 
			MbIntraFlag:[0], 
			MbPartIdx:[1], 
			RefIdx:[0], 
			MbPartWidth:[16], 
			MbPartHeigth:[16], 
			MvRes:[0,0],
			LAST:[[true: for int t in 0 .. 25 ]] repeat 26
			
	guard
		prevMbSkipped = 1 and IS_CAVLC(),
		slice_type = SLICE_TYPE_P//not IS_Intra_16x16()
	var 
		int mb_addr
	do
		//println("read_SliceD_mb_skip_run_done1.P_BLOC");
		mb_addr:=val_CurrMbAddr;
		NextMbAddress();
		mb_skip_run := mb_skip_run -1;
		if mb_skip_run = 0 then 
			prevMbSkipped := 0; 
			moreDataFlag := more_rbsp_data();
		end
if TRACE_MRL then
println("CurrMbAddr "+ mb_addr);
println("MbIntraFlag "+0);
println("QP "+val_QP);
println("QP_Cb "+ val_QP_Cb);
println("QP_Cr "+ val_QP_Cr);
println("ConstrainedIFlag "+constrained_intra_pred_flag[pps_id]);
println("PicWidthInMb "+PicWidthInMbs);
println("PicSizeInMb "+ PicSizeInMbs);
println("FirstMbInSlice "+ first_mb_in_slice);
println("slice_alpha_c0_offset "+val_slice_alpha_c0_offset);
println("slice_beta_offset "+val_slice_beta_offset);
println("LFDisable "+disable_deblocking_filter_idc);
println("cbp_blk "+0);
end
	end
	
		read_SliceD_mb_skip_run_done2: action ==>
	guard
		prevMbSkipped = 0
	do
		//println("read_SliceD_mb_skip_run_done2");
	end

	read_SliceD_mb_skip_run_done2_moredata_1: action ==>
	guard moreDataFlag = 1
	do
		//println("read_SliceD_mb_skip_run_done2_moredata_1");
	end

	read_SliceD_mb_skip_run_done2_moredata_0: action ==>
	guard moreDataFlag = 0
	do
		//println("read_SliceD_mb_skip_run_done2_moredata_0");
	end

	// else if(CABAC && (slice_type != I && slice_type != SI))
	read_SliceD_mb_skip_flag: action ==>
	guard
		slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI and IS_CABAC()
	do
		//println("read_SliceD_mb_skip_flag");
		GetCabacSyntaxElement(CABAC_MB_SKIP_FLAG);
		StartCabacProcess();
		// mb_skip_flag   ae(v)
		// moreDataFlag = !mb_skip_flag
	end
		
	read_SliceD_mb_skip_flag_done: action ==>
	guard
		(slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI and IS_CABAC()) and cabac_end()
		
	do
		//println("read_SliceD_mb_skip_flag_done");
		mb_skip_flag := cabac_value();
		
		if mb_skip_flag = 1 then
			if slice_type = SLICE_TYPE_P then 
					mbTab[CabacCurrMbAddr()][mbTabMbtype] := P_Skip;
					mbTab[CabacCurrMbAddr()][mbSliceType] := SLICE_TYPE_P;
			else 
				if slice_type = SLICE_TYPE_B then 
					mbTab[CabacCurrMbAddr()][mbTabMbtype] := B_Skip; 
					mbTab[CabacCurrMbAddr()][mbSliceType] := SLICE_TYPE_B;
				end 
			end
		end
			
		mbTab[CabacCurrMbAddr()][mbSkipFlag] := mb_skip_flag;
		moreDataFlag := if mb_skip_flag = 1 then 0 else 1 end;
		SentMbSkipZeros := true;
	end
	
	read_SliceD_mb_skip_flag_sent_zeros: action ==>
	guard
		SentMbSkipZeros and mb_skip_flag = 1 
	do
		SentMbSkipZeros := false;
		FoundSE := false;
	end
	
	read_SliceD_mb_skip_flag_skip_sent_zeros: action ==>
	guard
		SentMbSkipZeros and mb_skip_flag = 0 
	do
		SentMbSkipZeros := false;
		FoundSE := false;
	end
	
	//else (slice_type = I || slice_type = SI)
	read_SliceD_skip_mb_skip: action ==>
	guard
		slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI
	do
		//println("read_SliceD_skip_mb_skip");
		mbTab[CabacCurrMbAddr()][mbSkipFlag] := 0;
	end
	//end if

	//if (moreDataFlag)
	//if( MbaffFrameFlag && ( val_CurrMbAddr % 2 = = 0 || ( val_CurrMbAddr % 2 = = 1 && prevMbSkipped ) ) ) : interleaved
	read_SliceD_mb_field_decoding_flag: action ==>
	guard
		moreDataFlag = 1,
		MbaffFrameFlag = 1,
		(( val_CurrMbAddr mod 2) = 0 or ( (val_CurrMbAddr mod 2) = 1 and prevMbSkipped = 1) )
	do
		//println("read_SliceD_mb_field_decoding_flag");
		////println("read_SliceD_mb_field_decoding_flag : interleaved not implemented");
	end

	procedure CabacCycleCopy()
	begin
		if IS_CABAC() then
			if val_CurrMbAddr >= PicWidthInMbs + 1 then
				foreach int i in 1 .. PicWidthInMbs + 1 do
					/* MbTab */
					foreach int j in 0 .. 9 do
						mbTab[i-1][j] := mbTab[i][j];
					end
					
					foreach int j in 0 .. 15 do
						transblock_cbf[i-1][j] := transblock_cbf[i][j];
					end
					
					foreach int j in 0 .. 3 do
						Ref_Idx_L0[i-1][j] := Ref_Idx_L0[i][j];
						Ref_Idx_L1[i-1][j] := Ref_Idx_L1[i][j];
						cabac_sub_mb_type[i-1][j] := cabac_sub_mb_type[i][j];
						transblock_cbf_cr[i-1][j] := transblock_cbf_cr[i][j];
						transblock_cbf_cb[i-1][j] := transblock_cbf_cb[i][j];
					end
					
					foreach int k in 0 .. 3 do
						foreach int m in 0 .. 3 do
							foreach int l in 0 .. 1 do
								Mvd_L0[i-1][k][m][l] := Mvd_L0[i][k][m][l];
								Mvd_L1[i-1][k][m][l] := Mvd_L1[i][k][m][l];
							end
						end
					end
					
					foreach int l in 0 .. 1 do
						transblock_cbf_dc_cr_cb[i-1][l] := transblock_cbf_dc_cr_cb[i][l];
					end
				end
			end

			foreach int i in 0 .. 9 do
				mbTab[CabacCurrMbAddr()][i] := 0;
			end
			
			foreach int j in 0 .. 15 do
					transblock_cbf[CabacCurrMbAddr()][j] := 0;
				end
			
			foreach int j in 0 .. 3 do
				Ref_Idx_L0[CabacCurrMbAddr()][j] := 0;
				Ref_Idx_L1[CabacCurrMbAddr()][j] := 0;
				cabac_sub_mb_type[CabacCurrMbAddr()][j] := 0;
				transblock_cbf_cr[CabacCurrMbAddr()][j] := 0;
				transblock_cbf_cb[CabacCurrMbAddr()][j] := 0;
			end
			
			foreach int i in 0 .. 3 do
				foreach int j in 0 .. 3 do
					foreach int l in 0 .. 1 do
						Mvd_L0[CabacCurrMbAddr()][i][j][l] := 0;
						Mvd_L1[CabacCurrMbAddr()][i][j][l] := 0;
					end
				end
			end
			
			foreach int l in 0 .. 1 do
				transblock_cbf_dc_cr_cb[CabacCurrMbAddr()][l] := 0;
			end
				
			
		end
	end
	
	// else
	read_SliceD_skip_mb_field_decoding_flag: action ==>
	guard
		moreDataFlag = 1
	do
		//println("read_SliceD_skip_mb_field_decoding_flag");
	end
	//end if
	// --> macrobloc_layer()
	//end if
	//if( !entropy_coding_mode_flag ) : CAVLC
	SliceD_update_CAVLC: action ==>
	guard
		entropy_coding_mode_flag[pps_id] = 0
	do
		//println("SliceD_update_CAVLC");
		moreDataFlag := more_rbsp_data();
	end

	send_data_position_information_is_ipcm: action 
		==> 
			CurrMbAddr:[mb_addr],
			PicWidthInMb:[PicWidthInMbs],
			PicSizeInMb:[PicSizeInMbs],
			FirstMbInSlice:[first_mb_in_slice],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[cbp_blk_tmp],
			MbIntraFlag:[mb_intra_flag]
	guard 
		IS_I_PCM()
	var 
		int mb_addr,
		int cbp_blk_tmp=val_cbp_blk
	do
		//println("send_data_position_information_is_ipcm");
if TRACE_MRL then
println("CurrMbAddr "+ val_CurrMbAddr);
println("MbIntraFlag "+ mb_intra_flag);
println("QP "+val_QP);
println("QP_Cb "+ val_QP_Cb);
println("QP_Cr "+ val_QP_Cr);
println("ConstrainedIFlag "+constrained_intra_pred_flag[pps_id]);
println("PicWidthInMb "+PicWidthInMbs);
println("PicSizeInMb "+ PicSizeInMbs);
println("FirstMbInSlice "+ first_mb_in_slice);
println("slice_alpha_c0_offset "+val_slice_alpha_c0_offset);
println("slice_beta_offset "+val_slice_beta_offset);
println("LFDisable "+disable_deblocking_filter_idc);
println("cbp_blk "+ cbp_blk_tmp);
end
		mb_addr:=val_CurrMbAddr;
		NextMbAddress();
		/* Save Memory procedure, cycle copy*/
		CabacCycleCopy();
	
		val_cbp_blk:=0;
	end

	send_data_position_information: action 
		==> 
			CurrMbAddr:[mb_addr],
			PicWidthInMb:[PicWidthInMbs],
			PicSizeInMb:[PicSizeInMbs],
			FirstMbInSlice:[first_mb_in_slice],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[cbp_blk_tmp],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16,
			MbIntraFlag:[mb_intra_flag]
	guard
		mb_skip_flag = 0
	var 
		int mb_addr,
		int cbp_blk_tmp=val_cbp_blk
	do
		//println("send_data_position_information");
if TRACE_MRL then 
println("CurrMbAddr "+ val_CurrMbAddr);
println("MbIntraFlag "+ mb_intra_flag);
println("QP "+val_QP);
println("QP_Cb "+ val_QP_Cb);
println("QP_Cr "+ val_QP_Cr);
println("ConstrainedIFlag "+constrained_intra_pred_flag[pps_id]);
println("PicWidthInMb "+PicWidthInMbs);
println("PicSizeInMb "+ PicSizeInMbs);
println("FirstMbInSlice "+ first_mb_in_slice);
println("slice_alpha_c0_offset "+val_slice_alpha_c0_offset);
println("slice_beta_offset "+val_slice_beta_offset);
println("LFDisable "+disable_deblocking_filter_idc);
println("cbp_blk "+ cbp_blk_tmp);		
end
		mb_addr:=val_CurrMbAddr;
		NextMbAddress();
		/* Save Memory procedure, cycle copy*/
		CabacCycleCopy();
		val_cbp_blk:=0;
	end
	
	send_data_position_information_mb_skip_flag.IBlock: action 
		==> 
			CurrMbAddr:[mb_addr],
			PicWidthInMb:[PicWidthInMbs],
			PicSizeInMb:[PicSizeInMbs],
			FirstMbInSlice:[first_mb_in_slice],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[0],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16, 
			MbIntraFlag:[0], 
			MbPartIdx:[1], 
			RefIdx:[0], 
			MbPartWidth:[16], 
			MbPartHeigth:[16], 
			MvRes:[0,0],
			VALUE:[[0: for int i in 0 .. 407 ]] repeat 408
	guard
		mb_skip_flag = 1,
		slice_type != SLICE_TYPE_P
	var 
		int mb_addr
	do
		//println("send_data_position_information_mb_skip_flag");
		mb_addr:=val_CurrMbAddr;
		NextMbAddress();
		/* Save Memory procedure, cycle copy*/
		CabacCycleCopy();
		SentMbSkipZeros := false;
		FoundSE := false;
		if TRACE_MRL then
			println("CurrMbAddr "+ mb_addr);
			println("MbIntraFlag "+0);
			println("QP "+val_QP);
			println("QP_Cb "+ val_QP_Cb);
			println("QP_Cr "+ val_QP_Cr);
			println("ConstrainedIFlag "+constrained_intra_pred_flag[pps_id]);
			println("PicWidthInMb "+PicWidthInMbs);
			println("PicSizeInMb "+ PicSizeInMbs);
			println("FirstMbInSlice "+ first_mb_in_slice);
			println("slice_alpha_c0_offset "+val_slice_alpha_c0_offset);
			println("slice_beta_offset "+val_slice_beta_offset);
			println("LFDisable "+disable_deblocking_filter_idc);
			println("cbp_blk "+0);
		end
	end

	
	send_data_position_information_mb_skip_flag.PBlock: action 
		==> 
			CurrMbAddr:[mb_addr],
			PicWidthInMb:[PicWidthInMbs],
			PicSizeInMb:[PicSizeInMbs],
			FirstMbInSlice:[first_mb_in_slice],
			slice_alpha_c0_offset:[val_slice_alpha_c0_offset],
			slice_beta_offset:[val_slice_beta_offset],
			LFDisable:[disable_deblocking_filter_idc],
			ConstrainedIFlag:[constrained_intra_pred_flag[pps_id]],
			cbp_blk:[0],
			QP:[val_QP], 
			QP_Cb:[val_QP_Cb], 
			QP_Cr:[val_QP_Cr], 
			ScalingList:[[16: for int s in 0 .. 15 ]] repeat 16, 
			MbIntraFlag:[0], 
			MbPartIdx:[1], 
			RefIdx:[0], 
			MbPartWidth:[16], 
			MbPartHeigth:[16], 
			MvRes:[0,0],
			VALUE:[[0: for int i in 0 .. 391 ]] repeat 392
	guard
		mb_skip_flag = 1,
		slice_type = SLICE_TYPE_P
	var 
		int mb_addr
	do
		//println("send_data_position_information_mb_skip_flag");
		mb_addr:=val_CurrMbAddr;
		NextMbAddress();
		/* Save Memory procedure, cycle copy*/
		CabacCycleCopy();
		SentMbSkipZeros := false;
		FoundSE := false;
		if TRACE_MRL then
			println("CurrMbAddr "+ mb_addr);
			println("MbIntraFlag "+0);
			println("QP "+val_QP);
			println("QP_Cb "+ val_QP_Cb);
			println("QP_Cr "+ val_QP_Cr);
			println("ConstrainedIFlag "+constrained_intra_pred_flag[pps_id]);
			println("PicWidthInMb "+PicWidthInMbs);
			println("PicSizeInMb "+ PicSizeInMbs);
			println("FirstMbInSlice "+ first_mb_in_slice);
			println("slice_alpha_c0_offset "+val_slice_alpha_c0_offset);
			println("slice_beta_offset "+val_slice_beta_offset);
			println("LFDisable "+disable_deblocking_filter_idc);
			println("cbp_blk "+0);
		end
	end
	
	
	syncSliceD_endwhile: action ==>
	do
		//println("syncSliceD_endwhile");
	end

	SliceD_moredata_1: action ==>
	guard moreDataFlag = 1
	do
		//println("SliceD_moredata_1");
	end

	SliceD_moredata_0: action ==>
	guard moreDataFlag = 0
	do
		//println("SliceD_moredata_0");
	end

	//else (CABAC)
	SliceD_update_CABAC: action ==>
	guard
		IS_CABAC()
	do
		//println("SliceD_update_CABAC");
		//if( slice_type != I && slice_type != SI )
		if slice_type != SLICE_TYPE_I and slice_type != SLICE_TYPE_SI then 
		  prevMbSkipped := mb_skip_flag; 
		end
		//end if
		//if( MbaffFrameFlag && val_CurrMbAddr % 2 = = 0 )
		if MbaffFrameFlag = 1 and (val_CurrMbAddr mod 2) = 0 then 
			moreDataFlag := 1; 
			//else 
			// end_of_slice_flag 2 ae(v)
			// moreDataFlag = !end_of_slice_flag end
			//println("read ae end_of_slice_flag");
		else
		  GetCabacSyntaxElement(CABAC_END_OF_SLICE_FLAG);
		  StartCabacProcess();
		end
		
	end
	
	SliceD_update_CABAC_done: action ==>
	guard
		IS_CABAC() and cabac_end()
	do
		//println("SliceD_update_CABAC_done");
		moreDataFlag :=  if cabac_value() = 1 then 0 else 1 end;
		//end if
		//NextMbAddress();
		// init FoundSE
		FoundSE := false;
	end
	
	//while( moreDataFlag )
	SliceD_while_moreDataFlag: action ==>
	guard
		moreDataFlag = 1
	do
		//println("SliceD_while_moreDataFlag");
	end

	SliceD_end: action ==>
	guard
		moreDataFlag = 0
	do
		//println("SliceD_end");
	//println("read Slice Data done");
	//println("");
	end
	//******* End of Slice DATA  ********/
 
	/*************************************************************
	*************************************************************
	********       Macroblock layer    	    *********
	*************************************************************
	*************************************************************/



	function NumMbPart() --> uint(size=3) : if mb_intra_flag = 0 then if slice_type = SLICE_TYPE_B then B_tab[mb_type][0] else P_tab[mb_type][0] end else 0 end end
	function MbPartPredMode(uint(size=1) x) --> uint(size=3) : 
		if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then 
			P_tab[mb_type][3+x] 
		else 
			if slice_type = SLICE_TYPE_B then 
				B_tab[mb_type][3+x] 
			else 
				7 
			end 
		end 
	end
	function IS_MBPred_L0(uint(size=1) x) --> bool : MbPartPredMode(x) = 0 end
	function IS_MBPred_L1(uint(size=1) x) --> bool : MbPartPredMode(x) = 1 end
	function IS_MBDirect(uint(size=1) x) --> bool : MbPartPredMode(x) = 3 end
	function IS_MBNA(uint(size=1) x) --> bool : MbPartPredMode(x) = 7 end
	function MbPartWidthHeigth(uint(size=1) x) --> uint(size=5) : 
		if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then 
			P_tab[mb_type][1+x] 
		else 
			if slice_type = SLICE_TYPE_B then B_tab[mb_type][1+x] else 1 end 
		end 
	end
	
	function MbPartPredModeCABAC(uint(size=1) x, int mbAddr) --> uint(size=3) : 
		if mbTab[mbAddr][1] = SLICE_TYPE_P or mbTab[mbAddr][1] = SLICE_TYPE_SP then 
			P_tab[mbTab[mbAddr][2]][3+x] 
		else 
			if slice_type = SLICE_TYPE_B then 
				B_tab[mbTab[mbAddr][2]][3+x] 
			else 
				7 
			end 
		end 
	end

	function IS_MBPred_L0_CABAC(uint(size=1) x, int mbAddr) --> bool : 
		if slice_type = SLICE_TYPE_P then
			if mbTab[mbAddr][2] > 3 then
				false
			else
				if mbAddr < 0 then 
					false 
				else 
					MbPartPredModeCABAC(x, mbAddr) = 0 
				end 
			end
		else
			if mbTab[mbAddr][2] > 22  then
				false
			else
				if mbAddr < 0 then 
					false 
				else 
					MbPartPredModeCABAC(x, mbAddr) = 0 
				end 
			end
		end
	end
	
	function IS_MBPred_L1_CABAC(uint(size=1) x, int mbAddr) --> bool : 
		if slice_type = SLICE_TYPE_P then
			if mbTab[mbAddr][2] > 3 then
				false
			else
				if mbAddr < 0 then 
					false 
				else 
					MbPartPredModeCABAC(x, mbAddr) = 1 
				end 
			end
		else
			if mbTab[mbAddr][2] > 22  then
				false
			else
				if mbAddr < 0 then 
					false 
				else 
					MbPartPredModeCABAC(x, mbAddr) = 1 
				end 
			end
		end
	end
	
	function IS_MBBiPred_CABAC(uint(size=1) x, int mbAddr) --> bool : 
		if slice_type = SLICE_TYPE_B then
			if mbTab[mbAddr][2] > 23 then
				false
			else
				if mbAddr < 0 then 
					false 
				else 
					MbPartPredModeCABAC(x, mbAddr) = 2 
				end 
			end
		else
			false
		end
	end


	
	read_MB_layer_mb_type: action ==>
	do
		//println("read_MB_layer_mb_type");
		if  IS_CAVLC() then
			start_vld();
		
		else 
			if IS_CABAC() then
				//initialization of binIdx
				binIdxMb := 0;
				GetCabacMbTypeSyntaxElement();
				StartCabacProcess();
				SEARCH_MB_TYPE := true;
			end 
		end
	
	end
	

	read_MB_layer_mb_type_done: action ==> 
	guard
		( IS_CAVLC() and vld_end()) or (IS_CABAC() and cabac_end() )
	do
		//println("read_MB_layer_mb_type_done");
		if IS_CAVLC() then
			mb_type := vld_ue();
		
		else 
			if IS_CABAC() then
				mb_type := cabac_value();
				SEARCH_MB_TYPE := false;
			end
		end
		
		if slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI then mb_intra_flag := 1; end
		if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then if mb_type < 5 then mb_intra_flag := 0; else mb_type:= mb_type - 5; mb_intra_flag := 1; end end
		if slice_type = SLICE_TYPE_B then if mb_type < 23 then mb_intra_flag := 0; else mb_type:= mb_type -23; mb_intra_flag := 1; end end
		
		//Update mbTab with the current type of mb and slice_type
		mbTab[CabacCurrMbAddr()][mbSliceType] := slice_type;
		mbTab[CabacCurrMbAddr()][mbTabMbtype] := mb_type;
		
		//Initialize bk counter for cbp_Luma, see Derivation process of ctxIdxInc for the syntax element coded_block_flag
		bk_cbp := 0;
		
	end

	//if( mb_type = = I_PCM )
	// while( !byte_aligned( ) )
	read_MB_layer_I_PCM_alignement: action  ==>  IntraPredMode : [ 4 ]
	guard
		IS_I_PCM()
	do
		//println("read_MB_layer_I_PCM_alignement");
		if bit_count mod 8 != 0 then set_bits_to_read(8-bit_count mod 8); /*else bits_to_read_count := -1;*/ end
		//Initialisation process for the arithmetic decoding engine
		if IS_CABAC() then
			PcmAlignementZeroBitDone := true;
			set_bits_to_read(9);			
		end
	end

	//for( i = 0; i < 256; i++ )
	read_MB_layer_pcm_sample_luma0: action ==> 
	guard
		done_reading_bits()
	do
		//println("read_MB_layer_pcm_sample_luma0");
		MB_inc := 0;
		set_bits_to_read(bit_depth_luma_minus8[sps_id]+8);
		foreach int i in 0 .. 15 do
			NonZeroCount[val_CurrMbAddr][i] := 16;
		end
	end

	read_MB_layer_pcm_sample_luma1: action  ==>  pix_I_PCM:[ v ]
	guard
		done_reading_bits(),
		MB_inc < 256
	var 
		int v
	do
		//println("read_MB_layer_pcm_sample_luma1");
		v := read_result();
		MB_inc := MB_inc + 1;
		if MB_inc < 256 then set_bits_to_read(bit_depth_luma_minus8[sps_id]+8); end 
	end
	
	read_MB_layer_pcm_sample_luma1_done: action ==>
	guard
		MB_inc = 256
	do
		//println("read_MB_layer_pcm_sample_luma1_done");
		start_pcm_chroma := true;
		//Initialisation process for the arithmetic decoding engine
		if IS_CABAC() then
			PcmSampleLumaDone := true;
			set_bits_to_read(9);
		end
	end
	
	// for( i = 0; i < 2 * MbWidthC * MbHeightC; i++ )
	read_MB_layer_pcm_sample_chroma0: action   ==> 
	guard
		start_pcm_chroma
	do
		//println("read_MB_layer_pcm_sample_chroma0");
		MB_inc := 0;
		set_bits_to_read(bit_depth_chroma_minus8[sps_id]+8);
		foreach  int i in 0 .. 3 do
			NonZeroCountCb[val_CurrMbAddr][i] := 16;
			NonZeroCountCr[val_CurrMbAddr][i] := 16;
		end
		start_pcm_chroma := false;

	end

	read_MB_layer_pcm_sample_chroma1: action  ==> pix_I_PCM:[ v ]
	guard
	done_reading_bits(),
		MB_inc < 2*64
	var 
		int v
	do
		//println("read_MB_layer_pcm_sample_chroma1");
		v := read_result();
		MB_inc := MB_inc + 1;
		if MB_inc < 2*64 then set_bits_to_read(bit_depth_chroma_minus8[sps_id]+8); end 
	end

	read_MB_layer_pcm_sample_done: action  ==> 
	guard
		MB_inc = 2*64
	do
		//println("read_MB_layer_pcm_sample_done");
		//Initialisation process for the arithmetic decoding engine
		if IS_CABAC() then
			PcmSampleChromaDone := true;
			set_bits_to_read(9);
		end
	end

	//} else {
	read_MB_layer_not_I_PCM: action ==>
	guard
		not IS_I_PCM()
	do
		//println("read_MB_layer_not_I_PCM");
		noSubMbPartSizeLessThan8x8Flag := 1;
	end

	//if( mb_type != I_NxN && MbPartPredMode( mb_type, 0 ) != Intra_16x16 && NumMbPart( mb_type ) = = 4 )
	read_MB_layer_sub_mb_pred: action ==>
	guard
		NumMbPart() = 4 // NumMbPart() tests the slice_type and return 0 if slice_type is I or SI
	do
		//println("read_MB_layer_sub_mb_pred");
	end
	// --> sub_mb_pred( mb_type )

	read_MB_layer_sub_mb_pred_done: action ==>
	do
		//println("read_MB_layer_sub_mb_pred_done");
	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
		foreach int i in 0 .. 3 do
			mbPartIdx := i;
			//  if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 )
			if not IS_B_Direct_8x8() then
				//    if( NumSubMbPart( sub_mb_type[ mbPartIdx ] ) > 1 )
				if NumSubMbPart() >1 then noSubMbPartSizeLessThan8x8Flag := 0; end
			else 
				if direct_8x8_interference_flag[sps_id] = 0 then noSubMbPartSizeLessThan8x8Flag := 0; end
			end
		end
	end

	// else (! ( mb_type != I_NxN && MbPartPredMode( mb_type, 0 ) != Intra_16x16 && NumMbPart( mb_type ) = = 4 ) )
	// if( transform_8x8_mode_flag && mb_type = = I_NxN )
	read_MB_layer_transform_size_8x8_flag: action ==>
	guard
		NumMbPart() != 4, // NumMbPart() tests the slice_type and return 0 if slice_type is I or SI
		transform_8x8_mode_flag[pps_id] = 1 and IS_Intra_4x4()
	do
		//println("read_MB_layer_transform_size_8x8_flag");
		if IS_CAVLC() then
			set_bits_to_read(1);
		else
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_TRANSFORM_SIZE_8x8_FLAG);
				StartCabacProcess();
			end
		end
	end

	read_MB_layer_transform_size_8x8_flag_done: action ==>
	guard
		NumMbPart() != 4,
		(IS_CAVLC() and done_reading_bits() ) or ( IS_CABAC() and cabac_end() )
	do
		//println("read_MB_layer_transform_size_8x8_flag_done");
		if IS_CAVLC() then
			transform_size_8x8_flag := read_result();
		else
			if IS_CABAC() then
				transform_size_8x8_flag := cabac_value();
			end
		end
	end

	// else
	read_MB_layer_skip_transform_size_8x8_flag: action ==>
	guard
		NumMbPart() != 4
	do
		//println("read_MB_layer_skip_transform_size_8x8_flag");
	end
	// end if 
	// --> mb_pred( mb_type )
	// end if

	// if( MbPartPredMode( mb_type, 0 ) != Intra_16x16 )
	read_MB_layer_coded_block_pattern: action ==>
	guard
	not IS_Intra_16x16()
	do
		//println("read_MB_layer_coded_block_pattern");
		if  IS_CAVLC() then
			start_vld();
		
		else 
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_CODED_BLOCK_PATERN_LUMA);
				StartCabacProcess();
				binIdx := 0;
			end 
		end
	end
	
	read_MB_layer_coded_block_pattern_start_cabac_chroma: action ==>
	guard
		IS_CABAC() and cabac_end() and ( not cbp_done ) 
	do
		//println("read_MB_layer_coded_block_pattern_start_cabac_chroma");
		cbp_cabac := cabac_value();
		//get CBP Chroma
		GetCabacSyntaxElement(CABAC_CODED_BLOCK_PATERN_CHROMA);
		StartCabacProcess();
		cbp_done := true;
		binIdx := 0;
	end
	
	read_MB_layer_coded_block_pattern_done: action ==> 
	guard
		( IS_CAVLC() and vld_end() ) or ( IS_CABAC() and cabac_end() and cbp_done)
	var 
		uint(size=6) coded_block_pattern,
		uint(size=6) cbp_temp
	do
		//println("read_MB_layer_coded_block_pattern_done");
		
		if  IS_CAVLC() then
			coded_block_pattern := vld_me();
		else 
			if IS_CABAC() then
				coded_block_pattern := cbp_cabac;
				cbp_temp := cabac_value();
				
				cbp_done := false;
				if cbp_temp = 1 then
					coded_block_pattern := coded_block_pattern + 16;
				else
					if cbp_temp = 2 then
						coded_block_pattern := coded_block_pattern + 32;
					end
				end
				cbp_done := false;
			end
		end
		
		val_CodedBlockPatternLuma := coded_block_pattern mod 16;
		CodedBlockPatternChroma := coded_block_pattern / 16;
		
		mbTab[CabacCurrMbAddr()][mbCBPLuma]	:= val_CodedBlockPatternLuma;
		mbTab[CabacCurrMbAddr()][mbCBPChroma]	:= CodedBlockPatternChroma;
		
		if( val_CodedBlockPatternLuma > 0 and 
			transform_8x8_mode_flag[pps_id]=1 and 
			slice_type != SLICE_TYPE_I and
			noSubMbPartSizeLessThan8x8Flag =1 and
			(( slice_type = SLICE_TYPE_B and mb_type = 0) or direct_8x8_interference_flag[sps_id]=1 ) )then 
				if IS_CAVLC() then
					set_bits_to_read(1); 
				else
					if IS_CABAC() then
						GetCabacSyntaxElement(CABAC_TRANSFORM_SIZE_8x8_FLAG);
						StartCabacProcess();
					end
				end
		end
	end

	//if( val_CodedBlockPatternLuma > 0 && transform_8x8_mode_flag && mb_type != I_NxN && noSubMbPartSizeLessThan8x8Flag && ( mb_type != B_Direct_16x16 | | direct_8x8_inference_flag ) ) 
	read_MB_layer_cbp_transform_size_8x8_flag_done: action ==>
	guard
		(IS_CAVLC() and done_reading_bits() ) or ( IS_CABAC() and cabac_end() )
	do
		//println("read_MB_layer_cbp_transform_size_8x8_flag_done");
		if( val_CodedBlockPatternLuma > 0 and transform_8x8_mode_flag[pps_id]=1 and not IS_Intra_4x4()and not IS_Intra_8x8() and noSubMbPartSizeLessThan8x8Flag =1 and (( slice_type = SLICE_TYPE_B and mb_type = 0) or direct_8x8_interference_flag[sps_id]=1 ) )then
			if IS_CAVLC() then
				transform_size_8x8_flag := read_result();
			else
				if IS_CABAC() then
					transform_size_8x8_flag := cabac_value();
				end
			end
		end 
	end
	//end if

	//else ( MbPartPredMode( mb_type, 0 ) == Intra_16x16 )
	read_MB_layer_skip_coded_block_pattern: action ==> 
	guard
		IS_Intra_16x16()
	do
		//println("read_MB_layer_skip_coded_block_pattern");
		val_CodedBlockPatternLuma := Intra_16x16_tab[mb_type][2];
		CodedBlockPatternChroma := Intra_16x16_tab[mb_type][1];
		mbTab[CabacCurrMbAddr()][mbCBPLuma]	:= val_CodedBlockPatternLuma;
		mbTab[CabacCurrMbAddr()][mbCBPChroma]	:= CodedBlockPatternChroma;
	end
	//end if

	//if( val_CodedBlockPatternLuma > 0 || CodedBlockPatternChroma > 0 | | MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
	read_MB_layer_mb_qp_delta: action ==>
	guard
		val_CodedBlockPatternLuma > 0 or CodedBlockPatternChroma > 0 or IS_Intra_16x16()
	do
		//println("read_MB_layer_mb_qp_delta");
		if IS_CAVLC() then
			start_vld();
		
		else 
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_MB_QP_DELTA);
				StartCabacProcess();
			end 
		end
	end

	read_MB_layer_mb_qp_delta_done: action ==> 
	guard
		( IS_CAVLC() and vld_end() ) or ( cabac_end() and IS_CABAC() )
	do
		//println("read_MB_layer_mb_qp_delta_done");
		if IS_CAVLC() then
			mb_qp_delta := vld_se();
		else 
			if IS_CABAC() then
				mb_qp_delta := cabac_value();
				
				if ( mb_qp_delta & 0x01) = 1 then
					mb_qp_delta := ( mb_qp_delta + 1 ) >> 1;
				else
					mb_qp_delta :=  -( ( mb_qp_delta + 1 ) >> 1);
				end
			end
		end
		mbTab[CabacCurrMbAddr()][mbQpDelta] := mb_qp_delta;
		val_QP := (val_QP + mb_qp_delta + 52) mod 52;
		val_QP_Cb := qP_tab[val_QP + chroma_qp_index_offset[pps_id]];
		val_QP_Cr := qP_tab[val_QP + second_chroma_qp_index_offset[pps_id]];
	end
	// --> residual( )

	//else
		
	read_MB_layer_skip_mb_qp_delta: action ==>  LAST:[[true: for int t in 0 .. 25 ]] repeat 26//27
	guard
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and not IS_Intra_16x16() ) and IS_CAVLC()
	do
		//println("read_MB_layer_skip_mb_qp_delta");
	end
/*		
	read_MB_layer_skip_mb_qp_delta.Block_4x4: action ==>  LAST:[[true: for int t in 0 .. 25 ]] repeat 26//27
	guard
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and IS_Intra_4x4() ) and IS_CAVLC()
	do
		//println("read_MB_layer_skip_mb_qp_delta");
	end
		
	read_MB_layer_skip_mb_qp_delta.others: action ==>  LAST:[[true: for int t in 0 .. 26 ]] repeat 27
	guard
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and ( not IS_Intra_16x16()) and (not IS_Intra_4x4()) ) and IS_CAVLC()
	do
		//println("read_MB_layer_skip_mb_qp_delta");
	end*/

	read_MB_layer_skip_mb_qp_delta_CABAC: action ==> VALUE:[[0: for int i in 0 .. 391]] repeat 392
	guard
		( val_CodedBlockPatternLuma = 0 and CodedBlockPatternChroma = 0 and not IS_Intra_16x16() ) and IS_CABAC()
	do
		//println("read_MB_layer_skip_mb_qp_delta_CABAC");
	end	
	//end if

	//end if
	//******* End of Macroblock layer  ********/

	/*************************************************************
	*************************************************************
	********       	Sub Mb Pred    	    *********
	*************************************************************
	*************************************************************/
	List ( type: List ( type: uint(size=5), size=4), size=4 ) P_tab_sub = //[sub_mb_type[mbPartIdx]][NumSubMbPart / MbPartWidth / MbPartHeight / SubMbPredMode]
		[ [1,8,8,0], [2,8,4,0], [2,4,8,0], [4,4,4,0] ];

	List ( type: List ( type: uint(size=5), size=4), size=13 ) B_tab_sub = //[sub_mb_type[mbPartIdx]][NumSubMbPart / MbPartWidth / MbPartHeight / SubMbPredMode]
		[ [4,4,4,3], [1,8,8,0], [1,8,8,1], [1,8,8,2], [2,8,4,0], [2,4,8,0], [2,8,4,1], [2,4,8,1], [2,8,4,2], [2,4,8,2], [4,4,4,0], [4,4,4,1], [4,4,4,2] ];
	//*************************************************************/


	function NumSubMbPart() --> uint(size=3) : if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then P_tab_sub[sub_mb_type[mbPartIdx]][0] else if slice_type = SLICE_TYPE_B then B_tab_sub[sub_mb_type[mbPartIdx]][0] else 0 end end end
	function SubMbPredMode() --> uint(size=3) : if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then P_tab_sub[sub_mb_type[mbPartIdx]][3] else if slice_type = SLICE_TYPE_B then B_tab_sub[sub_mb_type[mbPartIdx]][3] else 7 end end end
	function IS_SubMBPred_L0() --> bool : SubMbPredMode() = 0 end
	function IS_SubMBPred_L1() --> bool : SubMbPredMode() = 1 end
	function IS_SubMBNA() --> bool : SubMbPredMode() = 7 end
	function SubMbPartWidthHeigth(uint(size=1) x) --> uint(size=5) : if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then P_tab_sub[sub_mb_type[mbPartIdx]][1+x] else if slice_type = SLICE_TYPE_B then B_tab_sub[sub_mb_type[mbPartIdx]][1+x] else 1 end end end

	function SubMbPredMode_CABAC(int x, int mbAddr) --> uint(size=3) : if slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP then P_tab_sub[cabac_sub_mb_type[mbAddr][x]][3] else if slice_type = SLICE_TYPE_B then B_tab_sub[cabac_sub_mb_type[mbAddr][x]][3] else 7 end end end
	function IS_SubMBPred_L0_CABAC(int x, int mbAddr) --> bool : SubMbPredMode_CABAC(x, mbAddr) = 0 end
	function IS_SubMBPred_L1_CABAC(int x, int mbAddr) --> bool : SubMbPredMode_CABAC(x, mbAddr) = 1 end
	function IS_SubMBBiPred_CABAC(int x, int mbAddr)  --> bool : SubMbPredMode_CABAC(x, mbAddr) = 2 end


	sub_MB_pred_init_sub_mb_type: action ==> 
	do
		//println("sub_MB_pred_init_sub_mb_type");
		mbPartIdx := 0;
		
		if IS_CAVLC() then
			start_vld();
		else
			binIdxMb := 0;
			GetCabacSubMbTypeSyntaxElement();
			StartCabacProcess();
		end
		IS_L0 := true;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	read_sub_MB_pred_sub_mb_type: action ==> 
	guard
		( (vld_end() and mbPartIdx < 4) and IS_CAVLC() ) or
		( (cabac_end() and mbPartIdx < 4) and IS_CABAC() )
	do
		//println("read_sub_MB_pred_sub_mb_type");
		if IS_CAVLC() then
			sub_mb_type[mbPartIdx] := vld_ue();
			mbPartIdx := mbPartIdx +1;
			if mbPartIdx < 4 then start_vld(); end
		else
			if IS_CABAC() then
				sub_mb_type[mbPartIdx] := cabac_value();
				cabac_sub_mb_type[CabacCurrMbAddr()][mbPartIdx] := cabac_value();
				mbPartIdx := mbPartIdx +1;
				if mbPartIdx < 4 then 
					binIdxMb := 0;
					GetCabacSubMbTypeSyntaxElement();
					StartCabacProcess();
				end
			end
		end
		 
	end
	//end for

	sub_MB_pred_init_ref_idx_l0: action ==>
	guard 
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	//if( ( num_ref_idx_l0_active_minus1 > 0 | | mb_field_decoding_flag ) && mb_type != P_8x8ref0 && sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
	read_sub_MB_pred_ref_idx_l0: action ==> 
	guard
		mbPartIdx < 4,
		(slice_num_ref_idx_l0_active_minus1 > 0 or mb_field_decoding_flag = 1),
		not IS_B_Direct_8x8(), not IS_P_8x8ref0(), not IS_SubMBPred_L1(), not IS_SubMBNA()
	do
		if IS_CAVLC() then
			if slice_num_ref_idx_l0_active_minus1 = 1 then set_bits_to_read(1); else start_vld(); end
		else
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_REF_IDX_L0_L1);
				StartCabacProcess();
			end
		end
	end

	read_sub_MB_pred_ref_idx_l0_done: action ==> 
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			ref_idx_l0[mbPartIdx] := if slice_num_ref_idx_l0_active_minus1 = 1 then 1 - read_result() else vld_ue() end;
		else
			if IS_CABAC() then
				ref_idx_l0[mbPartIdx] := cabac_value();
				Ref_Idx_L0[CabacCurrMbAddr()][mbPartIdx] := cabac_value();
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_sub_MB_pred_skip_ref_idx_l0: action ==> 
	guard
		mbPartIdx < 4
	do
		ref_idx_l0[mbPartIdx] := 0;
		Ref_Idx_L0[CabacCurrMbAddr()][mbPartIdx] := 0;
		mbPartIdx := mbPartIdx +1;
	end
	//end if
	//end for

	sub_MB_pred_init_ref_idx_l1: action ==>
	guard 
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	//if( ( num_ref_idx_l0_active_minus1 > 0 | | mb_field_decoding_flag ) && mb_type != P_8x8ref0 && sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
	read_sub_MB_pred_ref_idx_l1: action ==> 
	guard
		mbPartIdx < 4,
		(slice_num_ref_idx_l1_active_minus1 > 0 or mb_field_decoding_flag = 1),
		not IS_B_Direct_8x8(), not IS_P_8x8ref0(), not IS_SubMBPred_L0(), not IS_SubMBNA()
	do
		if IS_CAVLC() then
			if slice_num_ref_idx_l1_active_minus1 = 1 then set_bits_to_read(1); else start_vld(); end
		else
			//FIXME Maybe will do like CAVLC
			GetCabacSyntaxElement(CABAC_REF_IDX_L0_L1);
			StartCabacProcess();
		end
		IS_L0 := false;
	end

	read_sub_MB_pred_ref_idx_l1_done: action ==> 
	guard
		( ( (slice_num_ref_idx_l1_active_minus1 = 1 and done_reading_bits()) or (slice_num_ref_idx_l1_active_minus1 > 1 and vld_end()) ) and IS_CAVLC() ) or
		( cabac_end() and IS_CABAC() ) 
	do
		if IS_CAVLC() then
			ref_idx_l1[mbPartIdx] := if slice_num_ref_idx_l1_active_minus1 = 1 then 1 - read_result() else vld_ue() end;
		else
			if IS_CABAC() then
				 ref_idx_l1[mbPartIdx] := cabac_value();
				 Ref_Idx_L1[CabacCurrMbAddr()][mbPartIdx] := cabac_value();
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_sub_MB_pred_skip_ref_idx_l1: action ==> 
	guard
		mbPartIdx < 4
	do
		ref_idx_l1[mbPartIdx] := 0;
		Ref_Idx_L1[CabacCurrMbAddr()][mbPartIdx] := 0;
		mbPartIdx := mbPartIdx +1;
	end
	//end if
	//end for

	sub_MB_pred_init_mvd_l0: action ==>
	guard 
		mbPartIdx = 4
	do
		mbPartIdx := 0;
	end
	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	// if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
	read_sub_MB_pred_mvd_l0: action ==> 
	guard
		mbPartIdx < 4,
		not IS_B_Direct_8x8(), not IS_SubMBPred_L1(), not IS_SubMBNA()
	do
		subMbPartIdx := 0;
		IS_L0 := true;
	end
	//   for( subMbPartIdx = 0; subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); subMbPartIdx++)
	//     for( compIdx = 0; compIdx < 2; compIdx++ )
	read_sub_MB_pred_mvd_l0_done0: action ==> MbPartIdx:[subMbPartIdx], RefIdx:[ref_idx_l0[mbPartIdx]], MbPartWidth:[SubMbPartWidthHeigth(0)], MbPartHeigth:[SubMbPartWidthHeigth(1)]
	guard
		subMbPartIdx < NumSubMbPart()
	do
		if IS_CAVLC() then
			start_vld();
		else
			if IS_CABAC() then
				  compIdx := 0;
				  GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
			      StartCabacProcess();
			end
		end
	end

	read_sub_MB_pred_mvd_l0_done1: action ==> MvRes:[mvd_l0]
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l0 := vld_se();
			start_vld();
		else
			if IS_CABAC() then
				mvd_l0 := cabac_value();
				//Save the decode mvd
				Mvd_L0[CabacCurrMbAddr()][mbPartIdx][subMbPartIdx][0] := mvd_l0;
				compIdx := 1;
				GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
				StartCabacProcess();
		
			end
		end
	end

	read_sub_MB_pred_mvd_l0_done2: action ==> MvRes:[mvd_l0] 
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l0 := vld_se();
		else
			if IS_CABAC() then
				mvd_l0 := cabac_value();
				//Save the decode mvd
				Mvd_L0[CabacCurrMbAddr()][mbPartIdx][subMbPartIdx][1] := mvd_l0;
			end
		end
		subMbPartIdx := subMbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_skip_mvd_l0_done0: action ==> 
	guard
		subMbPartIdx = NumSubMbPart()
	do
		mbPartIdx := mbPartIdx+1;
	end

	//else
	read_sub_MB_pred_skip_mvd_l0: action ==> 
	guard
		mbPartIdx < 4,
		IS_B_Direct_8x8() or IS_SubMBPred_L1() or IS_SubMBNA()
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	sub_MB_pred_init_mvd_l1: action ==>
	guard 
		mbPartIdx = 4
	do
		mbPartIdx := 0;
		IS_L0 := false;
	end

	//for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
	// if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 && SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
	read_sub_MB_pred_mvd_l1: action ==> 
	guard
		mbPartIdx < 4,
		not IS_B_Direct_8x8(), not IS_SubMBPred_L0(), not IS_SubMBNA()
	do
		subMbPartIdx := 0;
	end
	//   for( subMbPartIdx = 0; subMbPartIdx < NumSubMbPart( sub_mb_type[ mbPartIdx ] ); subMbPartIdx++)
	//     for( compIdx = 0; compIdx < 2; compIdx++ )
	read_sub_MB_pred_mvd_l1_done0: action ==> 
	guard
		subMbPartIdx < NumSubMbPart()
	do
		if IS_CAVLC() then
			start_vld();
		else
			if IS_CABAC() then
			      compIdx := 0;
			      GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
			      StartCabacProcess();
			end
		end
	end

	read_sub_MB_pred_mvd_l1_done1: action ==> 
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l1 := vld_se();
			start_vld();
		else
			if IS_CABAC() then
				mvd_l1 := cabac_value();
				//Save the decode mvd
				Mvd_L1[CabacCurrMbAddr()][mbPartIdx][subMbPartIdx][0] := mvd_l1;
				compIdx := 1;
				GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
				StartCabacProcess();
		
			end
		end
				
	end

	read_sub_MB_pred_mvd_l1_done2: action ==> 
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l1 := vld_se();
		else
			if IS_CABAC() then
				mvd_l1 := cabac_value();
				//Save the decode mvd
				Mvd_L1[CabacCurrMbAddr()][mbPartIdx][subMbPartIdx][1] := mvd_l1;
			end
		end
		subMbPartIdx := subMbPartIdx +1;
	end
	//end for

	read_sub_MB_pred_skip_mvd_l1_done0: action ==> 
	guard
		subMbPartIdx = NumSubMbPart()
	do
		mbPartIdx := mbPartIdx+1;
	end

	//else
	read_sub_MB_pred_skip_mvd_l1: action ==> 
	guard
		mbPartIdx < 4,
		IS_B_Direct_8x8() or IS_SubMBPred_L0() or IS_SubMBNA()
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	sub_MB_pred_done: action ==>
	guard 
		mbPartIdx = 4
	end
	//******* End of Sub Mb pred  ********/
 
	/*************************************************************
	*************************************************************
	********       	Mb Pred    	    *********
	*************************************************************
	*************************************************************/

	//if( MbPartPredMode( mb_type, 0 ) = = Intra_4x4 )
	MB_pred_init_Intra_4x4: action ==> IntraPredMode: [ 1 ]
	guard
		IS_Intra_4x4()
	do
		
		
		if  IS_CAVLC() then
			luma4x4BlkIdx := 0;
			set_bits_to_read(1);
		
		else 
			if IS_CABAC() then
				luma4x4BlkIdx := 0;
				GetCabacSyntaxElement(CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG);
				StartCabacProcess();
			end 
		end
if TRACE_MRL then
println("IntraPredMode: "+1);
end
		
	end

	//for( luma4x4BlkIdx=0; luma4x4BlkIdx<16; luma4x4BlkIdx++ )
	read_MB_pred_rem_intra4x4_pred_mode: action ==>
	guard
	 (IS_CAVLC() and done_reading_bits() and luma4x4BlkIdx < 16 ) or ( IS_CABAC() and cabac_end() and luma4x4BlkIdx < 16 )
	do
		if IS_CAVLC() then
			prev_intra4x4_pred_mode_flag := read_result();
			
			if prev_intra4x4_pred_mode_flag = 0 then 
				set_bits_to_read(3); 
			end
		else 
			if IS_CABAC() then
				prev_intra4x4_pred_mode_flag := cabac_value();
				
				if prev_intra4x4_pred_mode_flag = 0 then 
					GetCabacSyntaxElement(CABAC_REM_INTRA4x4_8x8_PRED_MODE);
					binIdx := 0;
					StartCabacProcess();
				end
			end
		end
	end

	//if( !prev_intra4x4_pred_mode_flag[ luma4x4BlkIdx ] )
	read_MB_pred_rem_intra4x4_pred_mode_done: action ==>
	guard
		(IS_CAVLC() and done_reading_bits() and prev_intra4x4_pred_mode_flag = 0 ) or ( IS_CABAC() and cabac_end() and prev_intra4x4_pred_mode_flag = 0 ) 
	do
		if IS_CAVLC() then
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := read_result();
			luma4x4BlkIdx := luma4x4BlkIdx +1;
			if luma4x4BlkIdx < 16 then set_bits_to_read(1); end
		else 
			if IS_CABAC() then
				rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := cabac_value();
				luma4x4BlkIdx := luma4x4BlkIdx +1;
				//Read until luma4x4BlkIdx = 16
				if luma4x4BlkIdx < 16 then
					GetCabacSyntaxElement(CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG);
					StartCabacProcess();
				end
			end
		end
	end

	//else
	read_MB_pred_skip_rem_intra4x4_pred_mode_done: action ==>
	guard
		prev_intra4x4_pred_mode_flag = 1
	do
		if IS_CAVLC() then
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := 15; // indicates that the mode is predicted using the neighbourhood 
			luma4x4BlkIdx := luma4x4BlkIdx +1;
			if luma4x4BlkIdx < 16 then set_bits_to_read(1); end
		else
			if IS_CABAC() then
				rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := 15; // indicates that the mode is predicted using the neighbourhood 
				luma4x4BlkIdx := luma4x4BlkIdx +1;
				//Read until luma4x4BlkIdx = 16
				if luma4x4BlkIdx < 16 then
					GetCabacSyntaxElement(CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG);
					StartCabacProcess();
				end
			end
		end
		
	end
	//end if

	read_MB_pred_skip_rem_intra4x4_pred_mode: action ==> IntraPredMode: [ [ rem_intra4x4_pred_mode[ s ] :for int s in 0 .. 15] ] repeat 16
	guard
		luma4x4BlkIdx = 16
	do
if TRACE_MRL then
		foreach int i in 0 .. 15 do
			println("IntraPredMode: "+rem_intra4x4_pred_mode[ i ]);
		end
end
	end
	//end for

	//else if( MbPartPredMode( mb_type, 0 ) = = Intra_8x8 )
	MB_pred_init_Intra_8x8: action ==> IntraPredMode :[ 2 ]
	guard
		IS_Intra_8x8()
	do
		luma4x4BlkIdx := 0;
		if  IS_CAVLC() then
			set_bits_to_read(1);
		else
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG);
				StartCabacProcess();
			end 
		end
	end

	//for( luma8x8BlkIdx=0; luma8x8BlkIdx<4; luma8x8BlkIdx++ )
	read_MB_pred_rem_intra8x8_pred_mode: action ==>
	guard
		(IS_CAVLC() and done_reading_bits() and luma4x4BlkIdx < 4) or ( IS_CABAC() and cabac_end() and luma4x4BlkIdx < 4 )
	do
		if IS_CAVLC() then
			prev_intra4x4_pred_mode_flag := read_result();
			
			if prev_intra4x4_pred_mode_flag = 0 then 
				set_bits_to_read(3); 
			end
		else 
			if IS_CABAC() then
				prev_intra4x4_pred_mode_flag := cabac_value();
				
				if prev_intra4x4_pred_mode_flag = 0 then 
					GetCabacSyntaxElement(CABAC_REM_INTRA4x4_8x8_PRED_MODE);
					binIdx := 0;
					StartCabacProcess();
				end
			end
		end
	end

	//if( !prev_intra8x8_pred_mode_flag[ luma8x8BlkIdx ] )
	read_MB_pred_rem_intra8x8_pred_mode_done: action ==>
	guard
		(IS_CAVLC() and done_reading_bits() and prev_intra4x4_pred_mode_flag = 0 ) or ( IS_CABAC() and cabac_end() and prev_intra4x4_pred_mode_flag = 0 )
	do
		if IS_CAVLC() then
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := read_result();
			luma4x4BlkIdx := luma4x4BlkIdx +1;
			if luma4x4BlkIdx < 4 then set_bits_to_read(1); end
		else 
			if IS_CABAC() then
				rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := cabac_value();
				luma4x4BlkIdx := luma4x4BlkIdx +1;
				//Read until luma4x4BlkIdx = 4
				if luma4x4BlkIdx < 4 then
					GetCabacSyntaxElement(CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG);
					StartCabacProcess();
				end
			end
		end
	end

	//else
	read_MB_pred_skip_rem_intra8x8_pred_mode_done: action ==>
	guard
		prev_intra4x4_pred_mode_flag = 1
	do
		if IS_CAVLC() then
			rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := 15; // indicates that the mode is predicted using the neighbourhood 
			luma4x4BlkIdx := luma4x4BlkIdx +1;
			if luma4x4BlkIdx < 4 then set_bits_to_read(1); end
		else
			if IS_CABAC() then
				rem_intra4x4_pred_mode[ luma4x4BlkIdx ] := 15; // indicates that the mode is predicted using the neighbourhood 
				luma4x4BlkIdx := luma4x4BlkIdx + 1;
				//Read until luma4x4BlkIdx = 16
				if luma4x4BlkIdx < 4 then
					GetCabacSyntaxElement(CABAC_PREV_INTRA4x4_8x8_PRED_MODE_FLAG);
					StartCabacProcess();
				end
			end
		end
	end
	//end if

	read_MB_pred_skip_rem_intra8x8_pred_mode: action ==> IntraPredMode: [ [ rem_intra4x4_pred_mode[ s ] :for int s in 0 .. 3] ] repeat 4
	guard
		luma4x4BlkIdx = 4
	end
	//end for

	//else
	MB_pred_init_Intra_16x16: action ==> IntraPredMode: [ 3, Intra_16x16_tab[mb_type][0] ]
	guard
		IS_Intra_16x16()
	do
if TRACE_MRL then
		println("IntraPredMode: "+3);
		println("IntraPredMode: "+Intra_16x16_tab[mb_type][0]);		
end
	end
	//end if

	//if( ChromaArrayType = = 1 | | ChromaArrayType = = 2 )
	read_MB_pred_intra_chroma_pred_mode: action ==>
	guard
		IS_Intra_4x4() or IS_Intra_8x8() or IS_Intra_16x16(),
		chroma_format_idc[sps_id] = 1 or chroma_format_idc[sps_id] = 2
	do
		if IS_CAVLC() then
			start_vld();
		else
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_INTRA_CHROMA_PRED_MODE);
				StartCabacProcess();
				binIdxMb := 0;
			end
		end
	end

	read_MB_pred_intra_chroma_pred_mode_done: action ==> IntraPredModeC: [intra_chroma_pred_mode]
	guard
		( IS_CAVLC() and vld_end() ) or ( IS_CABAC() and cabac_end() )
	do
		if IS_CAVLC() then
			intra_chroma_pred_mode := vld_ue();
		else
			if IS_CABAC() then
			intra_chroma_pred_mode := cabac_value();
			end
		end
		
		mbTab[CabacCurrMbAddr()][mbIntraChromaPredMode] := intra_chroma_pred_mode;
if TRACE_MRL then
		println("IntraPredModeC "+ intra_chroma_pred_mode);
end
	end

	//else
	read_MB_pred_skip_intra_chroma_pred_mode: action ==>
	guard
		IS_Intra_4x4() or IS_Intra_8x8() or IS_Intra_16x16(),
		chroma_format_idc[sps_id] = 0
	end
	// end if

	// else (INTER pred)
	// if( MbPartPredMode( mb_type, 0 ) != Direct ) {
	MB_pred_Inter_not_direct: action ==>
	guard
		not IS_MBDirect(0), not IS_Intra_4x4(), not IS_Intra_16x16(), not IS_Intra_8x8()
	do
		mbPartIdx := 0;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) && MbPartPredMode( mb_type, mbPartIdx ) != Pred_L1 )
	read_MB_pred_ref_idx_l0: action ==> 
	guard
		mbPartIdx < NumMbPart(),
		(slice_num_ref_idx_l0_active_minus1 > 0 or mb_field_decoding_flag = 1),
		not IS_MBPred_L1(mbPartIdx), not IS_MBNA(mbPartIdx)
	do
		if IS_CAVLC() then
			if slice_num_ref_idx_l0_active_minus1 = 1 then set_bits_to_read(1); else start_vld(); end
		else
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_REF_IDX_L0_L1);
				StartCabacProcess();
			end
		end 
		IS_L0 := true;
	end

	read_MB_pred_ref_idx_l0_done: action ==> MbPartIdx:[mbPartIdx-1], RefIdx:[ref_idx_l0[mbPartIdx-1]], MbPartWidth:[MbPartWidthHeigth(0)], MbPartHeigth:[MbPartWidthHeigth(1)]
	guard
		((slice_num_ref_idx_l0_active_minus1 = 1 and done_reading_bits()) or (slice_num_ref_idx_l0_active_minus1 > 1 and vld_end()) and IS_CAVLC() ) or
		( cabac_end() and IS_CABAC() ) 
	do
		if IS_CAVLC() then
			ref_idx_l0[mbPartIdx] := if slice_num_ref_idx_l0_active_minus1 = 1 then 1 - read_result() else vld_ue() end;
		else
			if IS_CABAC() then
				 ref_idx_l0[mbPartIdx] := cabac_value();
				 Ref_Idx_L0[CabacCurrMbAddr()][mbPartIdx] := cabac_value();
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_skip_ref_idx_l0: action ==> MbPartIdx:[mbPartIdx-1], RefIdx:[ref_idx_l0[mbPartIdx-1]], MbPartWidth:[MbPartWidthHeigth(0)], MbPartHeigth:[MbPartWidthHeigth(1)]
	guard
		mbPartIdx < NumMbPart()
	do
		ref_idx_l0[mbPartIdx] := 0;
		Ref_Idx_L0[CabacCurrMbAddr()][mbPartIdx] := 0;
		mbPartIdx := mbPartIdx +1;
	end
	//end if
	//end for

	MB_pred_init_ref_idx_l1: action ==> 
	guard
		mbPartIdx = NumMbPart()
	do
		mbPartIdx := 0;
		IS_L0 := false;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( ( num_ref_idx_l1_active_minus1 > 0 || mb_field_decoding_flag ) && MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
	read_MB_pred_ref_idx_l1: action ==> 
	guard
		mbPartIdx < NumMbPart(),
		(slice_num_ref_idx_l1_active_minus1 > 0 or mb_field_decoding_flag = 1),
		not IS_MBPred_L0(mbPartIdx), not IS_MBNA(mbPartIdx)
	do
		if IS_CAVLC() then
			if slice_num_ref_idx_l1_active_minus1 = 1 then set_bits_to_read(1); else start_vld(); end
		else
			if IS_CABAC() then
				GetCabacSyntaxElement(CABAC_REF_IDX_L0_L1);
				StartCabacProcess();
			end
		end 
		IS_L0 := false;
	end

	read_MB_pred_ref_idx_l1_done: action ==> 
	guard
		((slice_num_ref_idx_l1_active_minus1 = 1 and done_reading_bits()) or (slice_num_ref_idx_l1_active_minus1 > 1 and vld_end()) and IS_CAVLC() ) or
		(cabac_end() and IS_CABAC()) 
	do
		if IS_CAVLC() then
			ref_idx_l1[mbPartIdx] := if slice_num_ref_idx_l1_active_minus1 = 1 then 1 - read_result() else vld_ue() end;
		else
			if IS_CABAC() then
				 ref_idx_l1[mbPartIdx] := cabac_value();
				 Ref_Idx_L1[CabacCurrMbAddr()][mbPartIdx] := cabac_value();
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_skip_ref_idx_l1: action ==> 
	guard
		mbPartIdx < NumMbPart()
	do
		ref_idx_l1[mbPartIdx] := 0;
		Ref_Idx_L1[CabacCurrMbAddr()][mbPartIdx] := 0;
		mbPartIdx := mbPartIdx +1;
	end
	//end if
	//end for

	MB_pred_init_mvd_l0: action ==> 
	guard
		mbPartIdx = NumMbPart()
	do
		mbPartIdx := 0;
		IS_L0 := true;
	end

	//  for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//    if( MbPartPredMode ( mb_type, mbPartIdx ) != Pred_L1 )
	read_MB_pred_mvd_l0: action ==> 
	guard
		mbPartIdx < NumMbPart(),
		not IS_MBPred_L1(mbPartIdx), not IS_MBNA(mbPartIdx)
	do
		if IS_CAVLC() then
			start_vld();
		else
			if IS_CABAC() then
				  compIdx := 0;
			      GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
			      StartCabacProcess();
			end
		end
	end

	read_MB_pred_mvd_l0_done0: action ==> MvRes:[mvd_l0]
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l0 := vld_se();
			start_vld();
		else
			if IS_CABAC() then
				mvd_l0 := cabac_value();
				//Save the decode mvd
				Mvd_L0[CabacCurrMbAddr()][mbPartIdx][0][0] := mvd_l0;
				compIdx := 1;
				GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
				StartCabacProcess();
			end
		end
	end

	read_MB_pred_mvd_l0_done1: action ==> MvRes:[mvd_l0]
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l0 := vld_se();
		else
			if IS_CABAC() then
				mvd_l0 := cabac_value();
				//Save the decode mvd
				Mvd_L0[CabacCurrMbAddr()][mbPartIdx][0][1] := mvd_l0;
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_skip_mvd_l0: action ==> 
	guard
		mbPartIdx < NumMbPart()
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	MB_pred_init_mvd_l1: action ==> 
	guard
		mbPartIdx = NumMbPart()
	do
		mbPartIdx := 0;
		IS_L0 := false;
	end

	// for( mbPartIdx = 0; mbPartIdx < NumMbPart( mb_type ); mbPartIdx++)
	//   if( MbPartPredMode( mb_type, mbPartIdx ) != Pred_L0 )
	read_MB_pred_mvd_l1: action ==> 
	guard
		mbPartIdx < NumMbPart(),
		not IS_MBPred_L0(mbPartIdx), not IS_MBNA(mbPartIdx)
	do
		if IS_CAVLC() then
			start_vld();
		else
			if IS_CABAC() then
				  compIdx := 0;
			      GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
			      StartCabacProcess();
			end
		end
	end

	read_MB_pred_mvd_l1_done0: action ==> 
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l1 := vld_se();
			start_vld();
		else
			if IS_CABAC() then
				mvd_l1 := cabac_value();
				//Save the decode mvd
				Mvd_L1[CabacCurrMbAddr()][mbPartIdx][0][0] := mvd_l1;
				compIdx := 1;
				GetCabacSyntaxElement(CABAC_MVD_L0_0_0);
				StartCabacProcess();
		
			end
		end
	end

	read_MB_pred_mvd_l1_done1: action ==> 
	guard
		( vld_end() and IS_CAVLC() ) or ( cabac_end() and IS_CABAC() )
	do
		if IS_CAVLC() then
			mvd_l1 := vld_se();
		else
			if IS_CABAC() then
				mvd_l1 := cabac_value();
				//Save the decode mvd
				Mvd_L1[CabacCurrMbAddr()][mbPartIdx][0][1] := mvd_l1;
			end
		end
		mbPartIdx := mbPartIdx +1;
	end

	//else
	read_MB_pred_skip_mvd_l1: action ==> 
	guard
		mbPartIdx < NumMbPart()
	do
		mbPartIdx := mbPartIdx+1;
	end
	//end if
	//end for

	MB_pred_done: action ==> 
	guard
		mbPartIdx = NumMbPart()
	end

	//else (INTER pred, MbPartPredMode( mb_type, 0 ) == Direct ) )
	MB_pred_Inter_direct: action ==>
	guard
		IS_MBDirect(0)
	end 
	//******* End of Mb pred  ********/

	/*************************************************************
	*************************************************************
	********       Residual    	    *********
	*************************************************************
	*************************************************************/

	//*************************************************************/

	Residual_init: action ==>
	do
		//println("Residual_init");
		bmFlag := 0;
		startIdx := 0;
		endIdx := 15;
		if TRACE then
			println("*********************************************************************");
			println("MB:"+val_CurrMbAddr);
		end
	end
	
		
	//if( !bmFlag && startIdx = = 0 && MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
	Residual_luma_DC_init: action ==>
	guard
		bmFlag = 0,
		startIdx = 0,
		IS_Intra_16x16()
	do
		//println("Residual_luma_DC_init");
		block_startIdx := 0;
		block_endIdx := 15;
		maxNumCoeff := 16;
		leveltype := 0;
		//ctxBlockCat for CABAC
		ctxBlockCat := 0;
	end
	// --> residual_block( i16x16DClevel, 0, 15, 16 )

	Residual_return_luma_DC: action ==> LAST:[true]
	guard
		leveltype=0 and IS_CAVLC()
	do
		//println("Residual_return_luma_DC");
	end
	
	Residual_return_luma_DC_CABAC: action ==> VALUE:[ [level[i]: for int i in 0 .. 15]] repeat 16
	guard
		leveltype=0 and IS_CABAC()
	do
		//println("Residual_return_luma_DC_CABAC");
		SentLumaDCZeros := false;
		if TRACE then
			println("Luma DC 16x16");
			foreach int s in 0 .. 15 do
				println("LumaDC16x16[" + s + "] := " + level[s]);
			end
		end
	end

	//else
	Residual_luma_skip_DC_init: action ==> //LAST:[true]
	guard
		( bmFlag != 0 or startIdx != 0 or not IS_Intra_16x16() ) and IS_CAVLC()
	do
		//println("Residual_luma_skip_DC_init");
	end
/*	Residual_luma_skip_DC_init.Block_4x4: action ==> //LAST:[true]
	guard
		( bmFlag != 0 or startIdx != 0 or IS_Intra_4x4() ) and IS_CAVLC()
	end

	Residual_luma_skip_DC_init.others: action ==> LAST:[true]
	guard
		( bmFlag != 0 or startIdx != 0 or (not IS_Intra_16x16() and not IS_Intra_4x4() ) ) and IS_CAVLC()
	end
*/	
	Residual_luma_skip_DC_init_CABAC: action ==> //VALUE:[ [0: for int i in 0 .. 15]] repeat 16
	guard
		( bmFlag != 0 or startIdx != 0 or not IS_Intra_16x16() )and IS_CABAC()
	do
		//println("Residual_luma_skip_DC_init_CABAC");
		if TRACE then
			println("Skip Luma DC 16x16");
		end
	end
	
	//end if

	Residual_luma_AC_init: action ==>
	do
		//println("Residual_luma_AC_init");
		leveltype := 1;
		i8x8 := 0;
		i4x4 := 0; 
		ctxBlockCat := 1;
	end

	// for( i8x8 = 0; i8x8 < 4; i8x8++ )
	// if( !transform_size_8x8_flag || !entropy_coding_mode_flag )
	Residual_luma_AC_CAVLC: action ==>
	guard
		i8x8 < 4,
		transform_size_8x8_flag = 0 or entropy_coding_mode_flag[pps_id] = 0 // bloc4x4 or CAVLC
	do
		//println("Residual_luma_AC_CAVLC");
		if IS_Intra_16x16() then
			ctxBlockCat := 1;  
		else  
			ctxBlockCat := 2;
		end
		
		if TRACE then
			println("Starting Luma AC");
		end
	end

	// for( i4x4 = 0; i4x4 < 4; i4x4++ ) {
	// if( val_CodedBlockPatternLuma & ( 1 << i8x8 ) )
	Residual_luma_AC_CodedBlock8x8: action ==>
	guard
		i4x4 < 4,
		rshift(bitand(val_CodedBlockPatternLuma, lshift(1,i8x8) ), i8x8) = 1 // MB sub part 8x8 != 0
	do
		//println("Residual_luma_AC_CodedBlock8x8");
		luma4x4BlkIdx := i4x4 + lshift( i8x8, 2);
		//if( !bmFlag && endIdx > 0 &&  MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
		if bmFlag = 0 and endIdx > 0 and  IS_Intra_16x16() then 
			block_startIdx := if startIdx - 1 > 0 then startIdx - 1 else 0 end ;
			block_endIdx := endIdx -1;
			maxNumCoeff := 15;
			// --> residual_block( i16x16AClevel[i8x8*4+ i4x4],max( 0, startIdx1 ), endIdx1, 15)
		else
			block_startIdx := startIdx;
			block_endIdx := endIdx;
			maxNumCoeff := 16;
			// --> residual_block( level[ i8x8 * 4 + i4x4 ], startIdx, endIdx, 16)
		end
		//end if
		
		if TRACE then
			println("luma4x4BlkIdx:=" + luma4x4BlkIdx);
		end
	end

	Residual_return_luma_AC: action ==> LAST: [true]
	guard
		leveltype = 1 and IS_CAVLC()
	do
		//println("Residual_return_luma_AC");
	end
	
	Residual_return_luma_AC_CABAC_15_Coeff: action ==> VALUE:[ [level_temp[i]: for int i in 0 .. 15]] repeat 16
	guard
		leveltype = 1 and maxNumCoeff = 15 and IS_CABAC()
	var
		List (type:int(size=16),size=16) level_temp
	do
		//println("Residual_return_luma_AC_CABAC_15_Coeff");
		if TRACE then
			foreach int s in 0 .. 14 do
				println("LumaAC16x16[" + s + "] := " + level[s]);
			end
		end
		
		level_temp[0] := 0;
		foreach int s in 1 .. 15 do
			level_temp[s] := level[s - 1];
		end
	end
	
	Residual_return_luma_AC_CABAC_16_Coeff: action ==> VALUE:[ [level[i]: for int i in 0 .. 15]] repeat 16
	guard
		leveltype = 1 and maxNumCoeff = 16 and IS_CABAC()
	do
		//println("Residual_return_luma_AC_CABAC_16_Coeff");
		if TRACE then
			foreach int s in 0 .. 15 do
				println("LumaAC4x4[" + s + "] := " + level[s]);
			end
		end
	end
	
	
	// else 
	Residual_luma_skip_AC_CodedBlock8x8: action ==>  LAST: [true]
	guard
		(i4x4 < 4 and rshift(bitand(val_CodedBlockPatternLuma, lshift(1,i8x8) ), i8x8) = 0 ) and IS_CAVLC()
	do
		//println("Residual_luma_skip_AC_CodedBlock8x8");
		luma4x4BlkIdx := i4x4 + lshift( i8x8, 2);
		/*
		// if( !bmFlag && MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
		for( i = 0; i < 15; i++ )
		i16x16AClevel[ i8x8 * 4 + i4x4 ][ i ] = 0
		// else
		for( i = 0; i < 16; i++ )
		level[ i8x8 * 4 + i4x4 ][ i ] = 0
		// end if
		*/
	end
	// end if
	
	Residual_luma_skip_AC_CodedBlock8x8_CABAC_16: action ==> VALUE:[[0: for int i in 0 .. 15]] repeat 16
	guard
		( (i4x4 < 4 and rshift(bitand(val_CodedBlockPatternLuma, lshift(1,i8x8) ), i8x8) = 0 ) and IS_CABAC() )
	do
		//println("Residual_luma_skip_AC_CodedBlock8x8_CABAC_16");
		luma4x4BlkIdx := i4x4 + lshift( i8x8, 2);
		/*
		// if( !bmFlag && MbPartPredMode( mb_type, 0 ) = = Intra_16x16 )
		for( i = 0; i < 15; i++ )
		i16x16AClevel[ i8x8 * 4 + i4x4 ][ i ] = 0
		// else
		for( i = 0; i < 16; i++ )
		level[ i8x8 * 4 + i4x4 ][ i ] = 0
		// end if
		*/
		
		if TRACE then
			println("Skipping Luma AC 16x16");
		end
	end
	// end if
	
	/*
	if( !entropy_coding_mode_flag && transform_size_8x8_flag )
	for( i = 0; i < 16; i++ )
	level8x8[ i8x8 ][ 4 * i + i4x4 ] = level[ i8x8 * 4 + i4x4 ][ i ]
	*/
	Residual_luma_inc_AC_4x4: action ==>
	do
		//println("Residual_luma_inc_AC_4x4");
		i4x4 := i4x4 +1;
		if i4x4 = 4 then 
		  i4x4 := 0; 
		  i8x8 := i8x8 + 1; 
		end
	end
	//end for

	// else ( transform_size_8x8_flag = 1 && entropy_coding_mode_flag = 1 ) <==> CABAC && 8x8
	/* if( val_CodedBlockPatternLuma & ( 1 << i8x8 ) )
	residual_block( level8x8[ i8x8 ], 4 * startIdx, 4 * endIdx + 3, 64 ) 3 | 4
	else
	for( i = 0; i < 64; i++ )
	level8x8[ i8x8 ][ i ] = 0
	//end if
	*/

	Residual_luma_skip_AC_CAVLC: action ==> 
	guard
		i8x8 = 4
	do
		//println("Residual_luma_skip_AC_CAVLC");
	end
	//end for
	
	//--> residual_block( level8x8[ i8x8 ], 4 * startIdx, 4 * endIdx + 3, 64 )
	
	//if( ChromaArrayType = = 1 | | ChromaArrayType = = 2 )
	Residual_ChromaArrayType_1_2_init: action ==>
	guard
		(chroma_format_idc[sps_id] = 1 or chroma_format_idc[sps_id] = 2) and separate_colour_plane_flag[sps_id] = 0 
	do
		//println("Residual_ChromaArrayType_1_2_init");
		if chroma_format_idc[sps_id] = 1 then 
			NumC8x8 := 1;
		else 
			NumC8x8 := 2;
		end
		iCbCr := 0;
		leveltype := 2;
		luma4x4BlkIdx := 0;
	end

	
	// for( iCbCr = 0; iCbCr < 2; iCbCr++ )
	//if( ( CodedBlockPatternChroma & 3 ) && startIdx = = 0 ) // chroma DC residual present
	Residual_chroma_DC_init: action ==>
	guard
		iCbCr < 2,
		bitand(CodedBlockPatternChroma, 3) != 0 and startIdx = 0
	do
		//println("Residual_chroma_DC_init");
		block_startIdx := 0;
		block_endIdx := 4 * NumC8x8 - 1;
		maxNumCoeff := 4 * NumC8x8;
		ctxBlockCat := 3;
		if TRACE then
			println("Starting Chroma AC ");
			println("MB:" +val_CurrMbAddr + " iCbCr := " + iCbCr);
		end
	end 
	//--> residual_block( ChromaDCLevel[ iCbCr ], 0, 4 * NumC8x8 - 1, 4 * NumC8x8 )

	Residual_return_chroma_DC: action ==> LAST: [true]
	guard
		leveltype = 2 and IS_CAVLC()
	do
		//println("Residual_return_chroma_DC");
		iCbCr := iCbCr + 1; 
	end
	
	Residual_return_chroma_DC_CABAC_4_Coeff: action ==> VALUE:[[level[i]: for int i in 0 .. 3]] repeat 4
	guard
		leveltype = 2 and maxNumCoeff = 4 and IS_CABAC()
	do
		//println("Residual_return_chroma_DC_CABAC_4_Coeff");
		iCbCr := iCbCr + 1;
		if TRACE then
			foreach int s in 0 .. 3 do
				println("ChromaDC[" + s + "] := " + level[s]);
			end
		end
	end
	
	Residual_return_chroma_DC_CABAC_8_Coeff: action ==> VALUE:[[level[i]: for int i in 0 .. 7]] repeat 8
	guard
		leveltype = 2 and maxNumCoeff = 8 and IS_CABAC()
	do
		//println("Residual_return_chroma_DC_CABAC_8_Coeff");
		iCbCr := iCbCr + 1;
		if TRACE then
			foreach int s in 0 .. 7 do
				println("ChromaDC[" + s + "] := " + level[s]);
			end
		end
	end
	
	// else
	Residual_skip_chroma_DC_init: action ==> LAST: [true]
	guard
		( iCbCr < 2 and bitand(CodedBlockPatternChroma, 3) =0 or startIdx != 0 ) and IS_CAVLC()
	do
		//println("Residual_skip_chroma_DC_init");
		//for( i = 0; i < 4 * NumC8x8; i++ )
		//ChromaDCLevel[ iCbCr ][ i ] = 0
		iCbCr := iCbCr + 1; 
	end   
	//end if
	
	Residual_skip_chroma_DC_init_CABAC_1: action ==> VALUE:[[0: for int i in 0 .. 3]] repeat 4 
	guard
		( iCbCr < 2 and bitand(CodedBlockPatternChroma, 3) =0 or startIdx != 0 ) and IS_CABAC() and NumC8x8 = 1
	do
		//println("Residual_skip_chroma_DC_init_CABAC_1");
		//for( i = 0; i < 4 * NumC8x8; i++ )
		//ChromaDCLevel[ iCbCr ][ i ] = 0
		iCbCr := iCbCr + 1; 
		if TRACE then
			println("Skipping DC Chroma 4");
		end
	end   
	
	Residual_skip_chroma_DC_init_CABAC_2: action ==> VALUE:[[0: for int i in 0 .. 7]] repeat 8 
	guard
		( iCbCr < 2 and bitand(CodedBlockPatternChroma, 3) =0 or startIdx != 0 ) and IS_CABAC() and NumC8x8 = 2
	do
		//println("Residual_skip_chroma_DC_init_CABAC_2");
		//for( i = 0; i < 4 * NumC8x8; i++ )
		//ChromaDCLevel[ iCbCr ][ i ] = 0
		iCbCr := iCbCr + 1; 
		if TRACE then
			println("Skipping DC Chroma 8");
		end
	end   

	Residual_skip_chroma_DC: action ==>
	guard
		iCbCr = 2
	do
		//println("Residual_skip_chroma_DC");
	end
	//end for  

	Residual_chroma_AC_init: action ==>
	do
		//println("Residual_chroma_AC_init");
		leveltype := 3;
		iCbCr := 0;
		i8x8 := 0;
		i4x4 := 0;
		luma4x4BlkIdx := 0;
		ctxBlockCat := 4;
		if TRACE then
			println("Starting AC Chroma");
		end
	end

	//for( iCbCr = 0; iCbCr < 2; iCbCr++ )
	//  for( i8x8 = 0; i8x8 < NumC8x8; i8x8++ )
	//    for( i4x4 = 0; i4x4 < 4; i4x4++ )
	//      if( ( CodedBlockPatternChroma & 2 ) && endIdx > 0 ) // chroma AC residual present
	Residual_chroma_AC_CodedBlock4x4: action ==>
	guard
		iCbCr < 2,
		bitand(CodedBlockPatternChroma, 2) = 2 and endIdx > 0
	do
		//println("Residual_chroma_AC_CodedBlock4x4");
		luma4x4BlkIdx := i4x4 + lshift( i8x8, 2);
		block_startIdx := if startIdx - 1 > 0 then startIdx - 1 else 0 end ;
		block_endIdx := endIdx - 1;
		maxNumCoeff := 15;
	end
	// --> residual_block( ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ], max( 0, startIdx1 ), endIdx1, 15)

	Residual_return_chroma_AC: action ==> LAST:[true]
	guard
		leveltype = 3 and IS_CAVLC()
	do
		//println("Residual_return_chroma_AC");
		i4x4 := i4x4 +1;
		if i4x4 = 4 then 
			i4x4 := 0; 
			i8x8 := i8x8 +1; 
		end
		
		if i8x8 = NumC8x8 then 
			i8x8 := 0; 
			iCbCr := iCbCr +1; 
		end
	end
	
	Residual_return_chroma_AC_CABAC: action ==> VALUE:[[level_temp[i]: for int i in 0 .. 15]] repeat 16
	guard
		leveltype = 3 and IS_CABAC()
	var
		List (type:int(size=16),size=16) level_temp
	do
		//println("Residual_return_chroma_AC_CABAC");
		i4x4 := i4x4 +1;
		if i4x4 = 4 then 
			i4x4 := 0; 
			i8x8 := i8x8 +1; 
			SentChromaZeros := false;
		end
		
		if i8x8 = NumC8x8 then 
			i8x8 := 0; 
			iCbCr := iCbCr +1; 
		end
		if TRACE then
			println("luma4x4BlkIdx := " + luma4x4BlkIdx);
			foreach int s in 0 .. 7 do
				println("ChromaAC[" + s + "] := " + level[s]);
			end
		end
		level_temp[0] := 0;
		foreach int s in 1 .. 15 do
			level_temp[s] := level[s - 1];
		end
	end
	
	// else
	Residual_chroma_AC_skip_CodedBlock4x4: action ==> LAST: [true]
	guard
		(iCbCr < 2 and bitand(CodedBlockPatternChroma, 2) != 2 or endIdx <= 0) and IS_CAVLC()
	do
		/* for( i = 0; i < 15; i++ )
		ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ][ i ] = 0
		*/
		i4x4 := i4x4 +1;
		if i4x4 = 4 then i4x4 := 0; i8x8 := i8x8 +1; end
		if i8x8 = NumC8x8 then i8x8:=0; iCbCr := iCbCr +1; end
		luma4x4BlkIdx := i4x4 + lshift( i8x8, 2);
	end
	
	
	Residual_chroma_AC_skip_CodedBlock4x4_CABAC: action ==> VALUE: [[0: for int j in 0 .. 15]] repeat 16
	guard
		(iCbCr < 2 and bitand(CodedBlockPatternChroma, 2) != 2 or endIdx <= 0) and IS_CABAC()
	do
		/* for( i = 0; i < 15; i++ )
		ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ][ i ] = 0
		*/
		i4x4 := i4x4 +1;
		if i4x4 = 4 then 
			i4x4 := 0; 
			i8x8 := i8x8 +1; 
			SentChromaZeros := false;
		end
		if i8x8 = NumC8x8 then 
			i8x8:=0; 
			iCbCr := iCbCr +1; 
		end
		if TRACE then
			println("Skipping Chroma AC");
		end
		luma4x4BlkIdx := i4x4 + lshift( i8x8, 2);
	end
	
	//end if

	Residual_skip_chroma_AC: action ==> 
	guard
		iCbCr = 2
	end
	//end for
	//end for
	//end for

	// else if( ChromaArrayType = = 3 ) ==> Profile HP not yet implemented
	// else ( ChromaArrayType = = 0 ) ==> Profile HP not yet implemented

	//******* End of Residual  ********/

	/*************************************************************
	*************************************************************
	********       Residual Block CAVLC   	    *********
	*************************************************************
	*************************************************************/

	

	Residual_block_init_coeff_token: action ==>
	guard
		IS_CAVLC()
	var 
		uint(size=1) top, uint(size=1) left,//= 1 if MB not available
		uint(size=5) nA, 
		uint(size=5) nB
	do
		/*println("\nResidual_block_init_coeff_token");
					println("val_CurrMbAddr : "+val_CurrMbAddr);
					println("first_mb_in_slice : "+first_mb_in_slice);
					println("PicWidthInMbs : "+PicWidthInMbs);
					println("luma4x4BlkIdx : "+luma4x4BlkIdx);
					println("InverseScan4x4Tab[luma4x4BlkIdx] : "+InverseScan4x4Tab[luma4x4BlkIdx]);*/
		if leveltype = 2 then //chromaDC
			nc := -1;
		else
			top :=1; left :=1;
			if leveltype = 0 then luma4x4BlkIdx := 0; end
			if leveltype < 2 then //luma
				if (val_CurrMbAddr<first_mb_in_slice + PicWidthInMbs and InverseScan4x4Tab[luma4x4BlkIdx]<4) then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
					nB :=0; top:=0;
				else
					if(InverseScan4x4Tab[luma4x4BlkIdx]<4) then
						nB := NonZeroCount[val_CurrMbAddr-PicWidthInMbs][12+InverseScan4x4Tab[luma4x4BlkIdx]]; 
					else
						nB := NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]-4];
					end					
				end
				if ((val_CurrMbAddr = first_mb_in_slice and InverseScan4x4Tab[luma4x4BlkIdx] mod 4 = 0) or (Mb_x = 0 and InverseScan4x4Tab[luma4x4BlkIdx] mod 4 = 0))  then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
					nA :=0; left:=0;
				else
					if(InverseScan4x4Tab[luma4x4BlkIdx] mod 4 = 0) then
						nA := NonZeroCount[val_CurrMbAddr-1][3+InverseScan4x4Tab[luma4x4BlkIdx]]; 
					else
						nA := NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]-1];
					end
				end
			else //chroma
				if (val_CurrMbAddr<first_mb_in_slice + PicWidthInMbs and luma4x4BlkIdx<2) then // MB 4x4 current situated on the first line of MBs 4x4, so there is no MB 4x4 above  
					nB :=0; top:=0;
				else
					nB := if iCbCr = 0 then 
						if(luma4x4BlkIdx<2) then
							NonZeroCountCb[val_CurrMbAddr-PicWidthInMbs][2 + luma4x4BlkIdx]
						else
							NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx- 2]
						end					
					else 
						if(InverseScan4x4Tab[luma4x4BlkIdx]<2) then
							NonZeroCountCr[val_CurrMbAddr-PicWidthInMbs][2 + luma4x4BlkIdx]
						else
							NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx - 2]
						end					
					end;
						end					
				if ((val_CurrMbAddr = first_mb_in_slice and luma4x4BlkIdx mod 2 = 0) or (Mb_x = 0 and luma4x4BlkIdx mod 2 = 0)) then // MB 4x4 current situated on the first column of MBs 4x4, so there is no MB 4x4 at left  
					nA :=0; left:=0;
				else
					nA := if iCbCr = 0 then 
						if(luma4x4BlkIdx mod 2 = 0) then
							NonZeroCountCb[val_CurrMbAddr-1][1 + luma4x4BlkIdx]
						else
							NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx - 1]
						end
					else 
						if(InverseScan4x4Tab[luma4x4BlkIdx] mod 2 = 0) then
							NonZeroCountCr[val_CurrMbAddr-1][1 + luma4x4BlkIdx]
						else
							NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx - 1]
						end
					end;
				end
			end
			if top = 1 and left = 1 then
				nc := rshift(nA + nB +1, 1);
			else 
				nc := nA + nB ;
			end
		end
		if(DEBUG_NEW_PARSER) then
			println("******************** New Block Cavlc***************************");
			println("nC : "+nc);
		end
		start_CAVLC(0);
		level := [0 : for int i in 0 .. 15];
	end

	//if( TotalCoeff( coeff_token ) > 0 ) 
	Residual_block_read_suffixLength: action ==>
	guard
		CAVLC_end(),
		TotalCoeff() >0
	do
		if(DEBUG_NEW_PARSER) then
			println("TotalCoeff : "+TotalCoeff());
			println("Trailing Ones : "+TrailingOnes());
			println("\t\t Idx : "+luma4x4BlkIdx);
		end
		//println("Residual_block_read_suffixLength");
		if leveltype = 1 then //luma
    			val_cbp_blk:=(1<<InverseScan4x4Tab[luma4x4BlkIdx])+val_cbp_blk;
			NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]] := TotalCoeff();
		else //chroma
			if iCbCr = 0 then
				NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx] := TotalCoeff();
			else
				NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx] := TotalCoeff();
			end
		end
		if TotalCoeff() > 10 and TrailingOnes() < 3 then suffixLength := 1; else suffixLength := 0; end
		inc_nb_coeff := 0;
	end

	// for( i = 0; i < TotalCoeff( coeff_token ); i++ )
	//if( i < TrailingOnes( coeff_token ) )
	Residual_block_read_trailing_ones_sign_flag: action ==>
	guard
		inc_nb_coeff < TotalCoeff(),
		inc_nb_coeff < TrailingOnes()
	do
		//println("Residual_block_read_trailing_ones_sign_flag");
		set_bits_to_read(1);
	end

	Residual_block_read_trailing_ones_sign_flag_done: action ==>
	guard
		done_reading_bits()
	do
		//println("Residual_block_read_trailing_ones_sign_flag_done");
		level[ inc_nb_coeff ] := 1 - 2 * read_result();
		if(DEBUG_NEW_PARSER) then
			println("levelT1 : "+level[ inc_nb_coeff ]);
		end
		inc_nb_coeff := inc_nb_coeff +1 ;
	end

	//else
	Residual_block_read_level_prefix: action ==>
	guard
		inc_nb_coeff < TotalCoeff(),
		inc_nb_coeff >= TrailingOnes()
	do
		//println("Residual_block_read_level_prefix");
		set_bits_to_read(1);
		level_prefix := 0;
	end

	Residual_block_read_level_prefix_done0: action ==>
	guard
		done_reading_bits(),
		read_result() = 0
	do
		//println("Residual_block_read_level_prefix_done0");
		level_prefix := level_prefix +1;
		set_bits_to_read(1);
	end

	Residual_block_read_level_prefix_done1: action ==>
	guard
		done_reading_bits(),
		read_result() = 1
	var
		uint levelSuffixSize
	do
		//println("Residual_block_read_level_prefix_done1");
		levelCode := lshift( if level_prefix < 15 then level_prefix else 15 end, suffixLength );
		if level_prefix = 14 and suffixLength = 0 then levelSuffixSize := 4;
		else if level_prefix >=15 then levelSuffixSize := level_prefix - 3;
		else levelSuffixSize := suffixLength; end end
		if levelSuffixSize > 0 then set_bits_to_read(levelSuffixSize); end
	end

	Residual_block_read_level_suffix_done: action ==>
	guard
		done_reading_bits()
	do
		//println("Residual_block_read_level_suffix_done");
		//if( suffixLength > 0 | | level_prefix >= 14 )
		if suffixLength > 0 or level_prefix >= 14 then levelCode := levelCode + read_result(); end

		// if( level_prefix > = 15 && suffixLength = = 0 )
		if level_prefix >= 15 and  suffixLength = 0 then levelCode := levelCode +15; end

		// if( level_prefix > = 16 )
		if level_prefix >= 16 then levelCode := levelCode + lshift( 1,level_prefix - 3 ) - 4096; end

		// if( i = = TrailingOnes( coeff_token ) &&	TrailingOnes( coeff_token ) < 3 )
		if inc_nb_coeff = TrailingOnes() and	TrailingOnes() < 3 then levelCode := levelCode + 2; end

		// if( levelCode % 2 = = 0 )
		if (levelCode mod 2) = 0 then level[ inc_nb_coeff ] := rshift( levelCode + 2, 1);
		else	level[ inc_nb_coeff ] := rshift( -levelCode - 1, 1); end

		if(DEBUG_NEW_PARSER) then
			println("level : "+level[ inc_nb_coeff ]);
		end
		// if( suffixLength = = 0 )
		if suffixLength = 0 then suffixLength := 1; end

		//if( Abs( level[ i ] ) > ( 3 << ( suffixLength 1 ) ) &&	suffixLength < 6 )
		if  Abs(level[ inc_nb_coeff ]) > lshift(3,suffixLength - 1) and suffixLength < 6 then suffixLength := suffixLength +1; end
		inc_nb_coeff := inc_nb_coeff +1 ;
	end
	//end if

	// end if
	//end for 
	Residual_block_read_TotalCoeff_done: action ==>
	guard
		inc_nb_coeff = TotalCoeff()
	do
		//println("Residual_block_read_TotalCoeff_done");
		//if( TotalCoeff( coeff_token ) < endIdx startIdx + 1 )
		if TotalCoeff() < block_endIdx - block_startIdx +1 then start_CAVLC(1); end
		run := [0 : for int i in 0 .. 15];
	end

	Residual_block_read_total_zeros_done: action ==>
	guard
		CAVLC_end()
	do
		//println("Residual_block_read_total_zeros_done");
		//if( TotalCoeff( coeff_token ) < endIdx startIdx + 1 )
		if TotalCoeff() < block_endIdx - block_startIdx +1 then zerosLeft := total_zeros; else zerosLeft := 0; end
		inc_nb_coeff := 0;
		if(DEBUG_NEW_PARSER) then
			println("total_zeros : "+total_zeros);
		end
	end

	//for( i = 0; i < TotalCoeff( coeff_token ) 1; i++ )
	Residual_block_read_run_before: action ==>
	guard
		inc_nb_coeff < TotalCoeff()-1,
		zerosLeft > 0
	do
		//println("Residual_block_read_run_before");
		start_CAVLC(2);
	end

	Residual_block_read_run_before_done: action ==>
	guard
		CAVLC_end()
	do
		//println("Residual_block_read_run_before_done");
		run[inc_nb_coeff] := run_before;
		zerosLeft := zerosLeft - run_before;
		inc_nb_coeff := inc_nb_coeff+1;
		if(DEBUG_NEW_PARSER) then
			println("run_before : "+run_before);
		end
	end

	Residual_block_skip_read_run_before: action ==>
	guard
		inc_nb_coeff < TotalCoeff()-1,
		zerosLeft = 0
	do
		//println("Residual_block_skip_read_run_before");
		run[inc_nb_coeff] := 0;
		inc_nb_coeff := inc_nb_coeff+1;
	end

	//end for
	Residual_block_read_run_done: action ==> 
	guard
		inc_nb_coeff = TotalCoeff()-1
	do
		//println("Residual_block_read_run_done");
		run[TotalCoeff()-1] := zerosLeft;
		if (IS_Intra_16x16() and leveltype = 1) or leveltype = 3 then run[TotalCoeff()-1] := run[TotalCoeff()-1] +1; end//the first coeffAC will be replaced by coeffDC
		coeff_sent := -1;
	end
	// --> residual_return

	//end for
	Residual_block_send_run: action ==> LAST:[false], RUN:[run[coeff_sent]], VALUE:[level[coeff_sent]]
	guard
		coeff_sent < TotalCoeff()-1
	do
		coeff_sent := coeff_sent+1;
	end

	//end for
	Residual_block_send_done: action ==> 
	guard
		coeff_sent = TotalCoeff()-1
	end



	//else ( TotalCoeff( coeff_token ) = 0 )
	Residual_block_skip_read_suffixLength: action ==>
	guard
		CAVLC_end(),
		TotalCoeff() = 0
	do
		if(DEBUG_NEW_PARSER) then
			println("TotalCoeff : "+TotalCoeff());
			println("Trailing Ones : "+TrailingOnes());
			println("\t\t Idx : "+luma4x4BlkIdx);
		end
		if leveltype < 2 then //luma
			NonZeroCount[val_CurrMbAddr][InverseScan4x4Tab[luma4x4BlkIdx]] := 0;
		else //chroma
			if iCbCr = 0 then
				NonZeroCountCb[val_CurrMbAddr][luma4x4BlkIdx] := 0;
			else
				NonZeroCountCr[val_CurrMbAddr][luma4x4BlkIdx] := 0;
			end
		end
	end 
	// --> residual return

	//******* End of Residual Block CAVLC ********  

	/*************************************************************
	*************************************************************
	********       Residual Block CABAC			*********
	*************************************************************
	*************************************************************/
	//residual_block_cabac()
	
	//if( maxNumCoeff = = 64 | | ( ChromaArrayType = = 3 ) ) )
	Residual_block_Cabac_coded_block_flag_start: action ==>
	guard
		IS_CABAC()
	do
		//println("Residual_block_Cabac_coded_block_flag_start");
		//Read coded_block_flag Syntax Element
		GetCabacSyntaxElement(CABAC_CODED_BLOCK_FLAG);
		StartCabacProcess();
	end
	
	//coded_block_flag
	Residual_block_Cabac_coded_block_flag_done: action ==>
	guard
		 cabac_end()
	do
		coded_block_flag := cabac_value();
		//coded_block_flag := 1; //When coded_block_flag is not present, it is infered to be equal to 1
		//store cbf
		
		//16x16 Luma DC Block
		
		if ctxBlockCat = 0 then
			mbTab[CabacCurrMbAddr()][mbCBF] := coded_block_flag;
		end
		
		// 4x4 Luma AC Block
		if ctxBlockCat = 1 or ctxBlockCat = 2 then
			transblock_cbf[CabacCurrMbAddr()][luma4x4BlkIdx] := coded_block_flag;
			val_cbp_blk:=(coded_block_flag <<InverseScan4x4Tab[luma4x4BlkIdx])+val_cbp_blk;
		end
		
		if ctxBlockCat = 3 then
			transblock_cbf_dc_cr_cb[CabacCurrMbAddr()][iCbCr] := coded_block_flag;
		end
		
		if ctxBlockCat = 4 then
			if iCbCr = 0 then
				transblock_cbf_cb[CabacCurrMbAddr()][luma4x4BlkIdx] := coded_block_flag;
			else
				transblock_cbf_cr[CabacCurrMbAddr()][luma4x4BlkIdx] := coded_block_flag;
			end
		end
	
		numCoeff := block_endIdx + 1;
		blCabacIdx := block_startIdx;
		//Delete previous Decoded level
		foreach int i in 0 .. maxNumCoeff - 1 do
			 significant_coeff_flag[i]      := 0;
			 last_significant_coeff_flag[i] := 0;
			 level[i] := 0;
		end
	end

	//if( coded_block_flag ) {
	Residual_block_Cabac_read_significant_coeff_flag: action ==>
	guard
		coded_block_flag = 1 and blCabacIdx < numCoeff - 1
	do	
	
		//read significant_coeff_flag Syntax Element
		GetCabacSyntaxElement(CABAC_SIGNIFICANT_COEFF_FLAG);
		StartCabacProcess();
	end
		
	//significant_coeff_flag[ i ] 
	//if( significant_coeff_flag[ i ] ) 
	Residual_block_read_significant_coeff_flag_done: action ==>
	guard
		cabac_end() and blCabacIdx < numCoeff - 1
	do
		significant_coeff_flag[ blCabacIdx ] := cabac_value();
		
		if significant_coeff_flag[ blCabacIdx ] = 1 then
			GetCabacSyntaxElement(CABAC_LAST_SIGNIFICANT_COEFF_FLAG);
			StartCabacProcess();
		end
		
		//blCabacIdx := blCabacIdx + 1;
	end
	
	//last_significant_coeff_flag[ i ] 3 | 4 ae(v)
	//if( last_significant_coeff_flag[ i ] )
	//numCoeff = i + 1
	Residual_block_read_last_significant_coeff_flag_done: action ==>
	guard
		cabac_end() and significant_coeff_flag[ blCabacIdx ] = 1
	do
		last_significant_coeff_flag[ blCabacIdx ] := cabac_value();
		
		if last_significant_coeff_flag[ blCabacIdx ] = 1 then
			numCoeff := blCabacIdx + 1;
		end
		blCabacIdx := blCabacIdx + 1;
	end
	
	//else
	Residual_block_skip_last_significant_coeff_flag: action ==>
	guard
		significant_coeff_flag[ blCabacIdx ] = 0
	do
		blCabacIdx := blCabacIdx + 1;
	end
	
	//skip significant_coeff_flag[ i ] read
	Residual_block_skip_significant_coeff_flag_while: action ==>
	guard
		blCabacIdx >= numCoeff - 1
	do
		//Read coeff_abs_level_minus1[ numCoeff - 1 ]
		GetCabacSyntaxElement(CABAC_COEFF_ABS_LEVEL_MINUS1);
		StartCabacProcess();
		numDecodAbsLevelEq1 := 1;
		numDecodAbsLevelGt1 := 0;
	end
	
	Residual_block_read_coeff_abs_level_minus1_done: action ==>
	guard
		cabac_end()
	
	do
		tempCoeff := numCoeff - 1;
		coeff_abs_level_minus1[ tempCoeff ] := cabac_value();
		
		level[ numCoeff - 1 ] := coeff_abs_level_minus1[ numCoeff - 1 ];
		
		blCabacIdx := numCoeff - 2;
		
	end
	
	
	//for( i = numCoeff - 2; i >= 0; i-- )
	Residual_block_update_coeffLevel_start: action ==>
	guard
		blCabacIdx >= 0 and TestSignificantCoeffFlag(blCabacIdx, 1)
	do
		//Read coeff_abs_level_minus1[ numCoeff - 1 ]
		GetCabacSyntaxElement(CABAC_COEFF_ABS_LEVEL_MINUS1);
		StartCabacProcess();
	end
	
	Residual_block_update_coeffLevel_read: action ==>
	guard
		blCabacIdx >= 0 and TestSignificantCoeffFlag(blCabacIdx, 1) and cabac_end()
	do
		coeff_abs_level_minus1[ blCabacIdx ] := cabac_value();	
		
		level[ blCabacIdx ] := coeff_abs_level_minus1[ blCabacIdx ];
		
		blCabacIdx := blCabacIdx - 1;
	end
	
	
	Residual_block_update_coeffLevel_not_read: action ==> 
	guard
		blCabacIdx >= 0 and TestSignificantCoeffFlag(blCabacIdx, 0)
	do
		blCabacIdx := blCabacIdx - 1;
	end
	
	Residual_block_update_coeffLevel_done: action ==>
	guard
		blCabacIdx < 0
	end
	
	Residual_Sent_Zeros: action ==>
	guard
		coded_block_flag = 0
	end
	
	//******* End of Residual Block CABAC ********//  
	
	test_one_byte: action ==>
	guard
		done_reading_bits(),
		bitand( read_result(), 255 ) = 1
	do
	//	println("test_one_byte");
	end

	test_zero_byte: action ==>
	guard
		done_reading_bits(),
		bitand( read_result(), 255 ) = 0
	do
	//	println("test_zero_byte");
	end

	request_byte: action ==>
	guard
		done_reading_bits()
	do
	//	println("request_byte");
		set_bits_to_read( 8 );
	end
	
	generic_done: action ==>
	guard
		done_reading_bits()
	do
	//	println("generic_done");
	end

	byte_align: action ==>
	do
	//	println("byte_align");
		if(bitand( bit_count, 7 )!=0) then
			set_bits_to_read( 8 - bitand( bit_count, 7 ) );
		end
	end
	
	
//********************************************************************************************************************************** 
	schedule fsm look_for_Sequence_Header :
		look_for_Sequence_Header						( look_for_Sequence_Header							) --> search_start_code;
		look_for_Sequence_Header(read_next_byte)-->look_for_Sequence_Header;
		search_start_code ( search_start_code  ) --> stuck;
		search_start_code(read_next_byte)-->search_start_code;

	    // FIXME: add minimal error resilience.
	    // byte align, then look for a starting on any byte boundary.
	    // is hex 00000100.
	    stuck    ( byte_align     ) --> stuck_1a;

	    stuck_1a ( request_byte   ) --> stuck_1b;
	    stuck_1b ( test_zero_byte ) --> stuck_2a;
	    stuck_1b ( generic_done   ) --> stuck_1a;
	    stuck_1b(read_next_byte)-->stuck_1b;
	    stuck_2a ( request_byte   ) --> stuck_2b;
	    stuck_2a(read_next_byte)-->stuck_2a;
	    stuck_2b ( test_zero_byte ) --> stuck_3a;
	    stuck_2b ( generic_done   ) --> stuck_1a;
	    stuck_2b(read_next_byte)-->stuck_2b;
	
	    stuck_3a ( request_byte   ) --> stuck_3b;
	    stuck_3a(read_next_byte)-->stuck_3a;
	    stuck_3b ( test_zero_byte ) --> stuck_3a;
	    stuck_3b ( test_one_byte  ) --> read_Nal_unit_header;
	    stuck_3b ( generic_done   ) --> stuck_1a;
	    stuck_3b(read_next_byte)-->stuck_3b;

		// read Nal Unit header
		read_Nal_unit_header							( read_Nal_unit_header								) --> look_for_which_Header;
		read_Nal_unit_header (read_next_byte) --> read_Nal_unit_header;

		//
		look_for_which_Header                         	( look_for_which_Header								) --> find_header;
		look_for_which_Header                         	( read_next_byte								) --> look_for_which_Header;
		find_header	  									( read_next_byte								) --> find_header;
		find_header	  									( look_for_other_header								) --> search_start_code;
		find_header	  									( look_for_Sps_header	  							) --> read_Sps_id;
		find_header	  									( look_for_Pps_header	  							) --> read_Pps_seq_parameter_set_id;
		find_header	  									( look_for_Slice_header	  							) --> read_SliceH_slice_type;

		// read Sps header
		read_Sps_id	  										( read_Sps_id	    								) --> read_Sps_id_done;
		read_Sps_id (read_next_byte)-->read_Sps_id;
		read_Sps_id_done	 								( read_Sps_id_done	    							) --> read_Sps_check_profile_idc;
		read_Sps_id_done (read_next_byte)--> read_Sps_id_done;
		read_Sps_check_profile_idc	 						( read_Sps_chroma_format_idc	  					) --> undefined; //not yet realized
		read_Sps_check_profile_idc	 						( read_Sps_log2_max_frame_num_minus4				) --> read_Sps_pic_order_cnt_type;
		read_Sps_check_profile_idc (read_next_byte)--> read_Sps_check_profile_idc;
		read_Sps_pic_order_cnt_type	 						( read_Sps_pic_order_cnt_type	   					) --> read_Sps_check_pic_order_cnt_type;
		read_Sps_pic_order_cnt_type (read_next_byte)-->read_Sps_pic_order_cnt_type;
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_pic_order_cnt_type_skip01				) --> read_Sps_num_ref_frames; 
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_log2_max_pic_order_cnt_lsb_minus4		) --> read_Sps_log2_max_pic_order_cnt_lsb_minus4_done;
		read_Sps_check_pic_order_cnt_type(read_next_byte)-->read_Sps_check_pic_order_cnt_type;
		read_Sps_log2_max_pic_order_cnt_lsb_minus4_done		( read_Sps_log2_max_pic_order_cnt_lsb_minus4_done 	) --> read_Sps_num_ref_frames;
		read_Sps_log2_max_pic_order_cnt_lsb_minus4_done(read_next_byte)-->read_Sps_log2_max_pic_order_cnt_lsb_minus4_done;
		read_Sps_check_pic_order_cnt_type	 				( read_Sps_delta_pic_order_always_zero_flag			) --> read_Sps_offset_for_non_ref_pic;   
		read_Sps_check_pic_order_cnt_type(read_next_byte)-->read_Sps_check_pic_order_cnt_type;
		read_Sps_offset_for_non_ref_pic						( read_Sps_offset_for_non_ref_pic					) --> read_Sps_offset_for_top_to_bottom_field;	
		read_Sps_offset_for_non_ref_pic(read_next_byte)-->read_Sps_offset_for_non_ref_pic;
		read_Sps_offset_for_top_to_bottom_field				( read_Sps_offset_for_top_to_bottom_field	        ) --> read_Sps_num_ref_frames_in_pic_order_cnt_cycle;
		read_Sps_offset_for_top_to_bottom_field(read_next_byte)-->read_Sps_offset_for_top_to_bottom_field;
		read_Sps_num_ref_frames_in_pic_order_cnt_cycle		( read_Sps_num_ref_frames_in_pic_order_cnt_cycle	) --> read_Sps_offset_for_ref_frame0;
		read_Sps_num_ref_frames_in_pic_order_cnt_cycle(read_next_byte)-->read_Sps_num_ref_frames_in_pic_order_cnt_cycle;
		read_Sps_offset_for_ref_frame0						( read_Sps_offset_for_ref_frame0	                ) --> read_Sps_offset_for_ref_frame1;
		read_Sps_offset_for_ref_frame0(read_next_byte)-->read_Sps_offset_for_ref_frame0;
		read_Sps_offset_for_ref_frame1						( read_Sps_offset_for_ref_frame1 	                ) --> read_Sps_offset_for_ref_frame1;
		read_Sps_offset_for_ref_frame1						( read_Sps_skip_offset_for_ref_frame1				) --> read_Sps_num_ref_frames;      
		read_Sps_offset_for_ref_frame1(read_next_byte)-->read_Sps_offset_for_ref_frame1;
		read_Sps_num_ref_frames 							( read_Sps_num_ref_frames  	                        ) --> read_Sps_gaps_in_frame_num_value_allowed_flag;
		read_Sps_num_ref_frames(read_next_byte)-->read_Sps_num_ref_frames;
		read_Sps_gaps_in_frame_num_value_allowed_flag		( read_Sps_gaps_in_frame_num_value_allowed_flag  	) --> read_Sps_pic_width_in_mbs_minus1;
		read_Sps_gaps_in_frame_num_value_allowed_flag(read_next_byte)-->read_Sps_gaps_in_frame_num_value_allowed_flag;
		read_Sps_pic_width_in_mbs_minus1	 				( read_Sps_pic_width_in_mbs_minus1              	) --> read_Sps_pic_height_in_map_units_minus1;
		read_Sps_pic_width_in_mbs_minus1(read_next_byte)-->read_Sps_pic_width_in_mbs_minus1;
		read_Sps_pic_height_in_map_units_minus1 			( read_Sps_pic_height_in_map_units_minus1 	        ) --> read_Sps_frame_mbs_only_flag;
		read_Sps_pic_height_in_map_units_minus1(read_next_byte)-->read_Sps_pic_height_in_map_units_minus1;
		read_Sps_frame_mbs_only_flag 						( read_Sps_frame_mbs_only_flag	  	                ) --> read_Sps_mb_adaptive_frame_field_flag;
		read_Sps_frame_mbs_only_flag(read_next_byte)-->read_Sps_frame_mbs_only_flag;
		read_Sps_mb_adaptive_frame_field_flag				( read_Sps_mb_adaptive_frame_field_flag  	        ) --> read_Sps_mb_adaptive_frame_field_flag_done;
		read_Sps_mb_adaptive_frame_field_flag(read_next_byte)-->read_Sps_mb_adaptive_frame_field_flag;
		read_Sps_mb_adaptive_frame_field_flag_done			( read_Sps_mb_adaptive_frame_field_flag_done        ) --> read_Sps_direct_8x8_interference_flag;
		read_Sps_mb_adaptive_frame_field_flag_done(read_next_byte)-->read_Sps_mb_adaptive_frame_field_flag_done;
		read_Sps_mb_adaptive_frame_field_flag				( read_Sps_skip_mb_adaptive_frame_field_flag        ) --> read_Sps_direct_8x8_interference_flag;
		read_Sps_direct_8x8_interference_flag 				( read_Sps_direct_8x8_interference_flag             ) --> read_Sps_frame_cropping_flag;    
		read_Sps_direct_8x8_interference_flag(read_next_byte)-->read_Sps_direct_8x8_interference_flag;
		read_Sps_frame_cropping_flag						( read_Sps_frame_cropping_flag	  	                ) --> read_Sps_frame_crop_left_offset;
		read_Sps_frame_cropping_flag(read_next_byte)-->read_Sps_frame_cropping_flag;

		read_Sps_frame_crop_left_offset						( read_Sps_frame_crop_left_offset  	                ) --> read_Sps_frame_crop_right_offset;
		read_Sps_frame_crop_left_offset(read_next_byte)-->read_Sps_frame_crop_left_offset;
		read_Sps_frame_crop_right_offset					( read_Sps_frame_crop_right_offset				  	) --> read_Sps_frame_crop_top_offset;
		read_Sps_frame_crop_right_offset(read_next_byte)-->read_Sps_frame_crop_right_offset;
		read_Sps_frame_crop_top_offset						( read_Sps_frame_crop_top_offset  	                ) --> read_Sps_frame_crop_bottom_offset;
		read_Sps_frame_crop_top_offset(read_next_byte)-->read_Sps_frame_crop_top_offset;
		read_Sps_frame_crop_bottom_offset					( read_Sps_frame_crop_bottom_offset				  	) --> read_Sps_frame_crop_bottom_offset_done;
		read_Sps_frame_crop_bottom_offset(read_next_byte)-->read_Sps_frame_crop_bottom_offset;
		read_Sps_frame_crop_bottom_offset_done				( read_Sps_frame_crop_bottom_offset_done	        ) --> read_Sps_vui_parameters_present_flag;    
		read_Sps_frame_crop_bottom_offset_done(read_next_byte)-->read_Sps_frame_crop_bottom_offset_done;
		read_Sps_frame_crop_left_offset						( read_Sps_skip_frame_crop_left_offset	  	        ) --> read_Sps_vui_parameters_present_flag; 
		read_Sps_frame_crop_left_offset(read_next_byte)-->read_Sps_frame_crop_left_offset;
		read_Sps_vui_parameters_present_flag				( read_Sps_vui_parameters_present_flag	  	        ) --> read_Sps_vui_parameters_present_flag_done;
		read_Sps_vui_parameters_present_flag(read_next_byte)-->read_Sps_vui_parameters_present_flag;
		read_Sps_vui_parameters_present_flag_done			( read_Sps_vui_parameters_present_flag_done	  		) --> search_start_code; //end of Sps
		read_Sps_vui_parameters_present_flag_done(read_next_byte)-->read_Sps_vui_parameters_present_flag_done;

		// read Pps header
		read_Pps_seq_parameter_set_id 						( read_Pps_seq_parameter_set_id                     ) --> read_Pps_entropy_coding_mode_pic_order_flag;
		read_Pps_seq_parameter_set_id(read_next_byte)-->read_Pps_seq_parameter_set_id;
		read_Pps_entropy_coding_mode_pic_order_flag  		( read_Pps_entropy_coding_mode_pic_order_flag	  	) --> read_Pps_num_slice_groups_minus1;
		read_Pps_entropy_coding_mode_pic_order_flag(read_next_byte)-->read_Pps_entropy_coding_mode_pic_order_flag;
		read_Pps_num_slice_groups_minus1					( read_Pps_num_slice_groups_minus1				  	) --> look_Pps_slice_group_map_type; 			  
		read_Pps_num_slice_groups_minus1(read_next_byte)-->read_Pps_num_slice_groups_minus1;
		look_Pps_slice_group_map_type						( read_Pps_slice_group_map_type                     ) --> read_Pps_check_slice_group_map_type;
		look_Pps_slice_group_map_type(read_next_byte)-->look_Pps_slice_group_map_type;
		read_Pps_check_slice_group_map_type					( read_Pps_check_slice_group_map_type				) --> read_Pps_check_slice_group_map_type0;
		read_Pps_check_slice_group_map_type(read_next_byte)-->read_Pps_check_slice_group_map_type;
		//gorinje read_Pps_check_slice_group_map_type					( read_Pps_check_slice_group_map_type				) --> read_Pps_check_slice_group_map_type1;
		//gorinje read_Pps_check_slice_group_map_type					( read_Pps_check_slice_group_map_type				) --> read_Pps_check_slice_group_map_type2;
		//gorinje read_Pps_check_slice_group_map_type					( read_Pps_check_slice_group_map_type				) --> read_Pps_check_slice_group_map_type345;
		//gorinje read_Pps_check_slice_group_map_type					( read_Pps_check_slice_group_map_type				) --> read_Pps_check_slice_group_map_type6;
		//gorinje read_Pps_check_slice_group_map_type					( read_Pps_check_slice_group_map_type				) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_check_slice_group_map_type0				( read_Pps_run_length_minus1						) --> read_Pps_check_slice_group_map_type0;
		read_Pps_check_slice_group_map_type0(read_next_byte)-->read_Pps_check_slice_group_map_type0;
		//gorinje read_Pps_check_slice_group_map_type0				( read_Pps_run_length_minus1						) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_check_slice_group_map_type1				( read_Pps_check_slice_group_map_type1				) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_check_slice_group_map_type1(read_next_byte)-->read_Pps_check_slice_group_map_type1;
		read_Pps_check_slice_group_map_type2				( read_Pps_top_left	                                ) --> read_Pps_bottom_right;
		read_Pps_check_slice_group_map_type2(read_next_byte)-->read_Pps_check_slice_group_map_type2;
		read_Pps_bottom_right								( read_Pps_bottom_right								) --> read_Pps_check_slice_group_map_type2;
		read_Pps_bottom_right(read_next_byte)-->read_Pps_bottom_right;
		//gorinje read_Pps_bottom_right								( read_Pps_bottom_right								) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_check_slice_group_map_type345				( read_Pps_slice_group_change_direction_flag		) --> read_Pps_slice_group_change_rate_minus1;
		read_Pps_check_slice_group_map_type345(read_next_byte)-->read_Pps_check_slice_group_map_type345;
		read_Pps_slice_group_change_rate_minus1			    ( read_Pps_slice_group_change_rate_minus1	        ) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_slice_group_change_rate_minus1(read_next_byte)-->read_Pps_slice_group_change_rate_minus1;
		read_Pps_check_slice_group_map_type6				( read_Pps_pic_size_in_map_units_minus1				) --> search_start_code; //not yet realized
		read_Pps_check_slice_group_map_type6(read_next_byte)-->read_Pps_check_slice_group_map_type6;

		look_Pps_slice_group_map_type					    ( read_Pps_slice_group_map_type_skip 	  	        ) --> read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_num_ref_idx_l0_active_minus1				( read_Pps_num_ref_idx_l0_active_minus1	 	        ) --> read_Pps_num_ref_idx_l1_active_minus1;
		read_Pps_num_ref_idx_l0_active_minus1(read_next_byte)-->read_Pps_num_ref_idx_l0_active_minus1;
		read_Pps_num_ref_idx_l1_active_minus1				( read_Pps_num_ref_idx_l1_active_minus1             ) --> read_Pps_weighted_pred_bipred;
		read_Pps_num_ref_idx_l1_active_minus1(read_next_byte)-->read_Pps_num_ref_idx_l1_active_minus1;
		read_Pps_weighted_pred_bipred						( read_Pps_weighted_pred_bipred   	                ) --> read_Pps_pic_init_qp_minus26;
		read_Pps_weighted_pred_bipred(read_next_byte)-->read_Pps_weighted_pred_bipred;
		read_Pps_pic_init_qp_minus26						( read_Pps_pic_init_qp_minus26	  	                ) --> read_Pps_pic_init_qs_minus26;
		read_Pps_pic_init_qp_minus26(read_next_byte)-->read_Pps_pic_init_qp_minus26;
		read_Pps_pic_init_qs_minus26						( read_Pps_pic_init_qs_minus26	  	                ) --> read_Pps_chroma_qp_index_offset;
		read_Pps_pic_init_qs_minus26(read_next_byte)-->read_Pps_pic_init_qs_minus26;
		read_Pps_chroma_qp_index_offset						( read_Pps_chroma_qp_index_offset 	                ) --> read_Pps_flag_deblocking_constrained_redundant;
		read_Pps_chroma_qp_index_offset(read_next_byte)-->read_Pps_chroma_qp_index_offset;
		read_Pps_flag_deblocking_constrained_redundant		( read_Pps_flag_deblocking_constrained_redundant	) --> read_Pps_check_High_Profile;
		read_Pps_flag_deblocking_constrained_redundant(read_next_byte)-->read_Pps_flag_deblocking_constrained_redundant;
		read_Pps_check_High_Profile							( read_Pps_check_High_Profile					  	) --> read_Pps_not_High_Profile;
		read_Pps_check_High_Profile(read_next_byte)-->read_Pps_check_High_Profile;
		read_Pps_not_High_Profile							( read_Pps_not_High_Profile						  	) --> search_start_code;
		//read_Pps_not_High_Profile							( read_Pps_pic_scaling_matrix_present_flag		  	) --> read_Nal_unit_header; //not yet realized
		read_Pps_not_High_Profile(read_next_byte)-->read_Pps_not_High_Profile;

		// read Slice header
		read_SliceH_slice_type								( read_SliceH_slice_type  	                        ) --> read_SliceH_pps_id;
		read_SliceH_slice_type(read_next_byte)-->read_SliceH_slice_type;
		read_SliceH_pps_id									( read_SliceH_pps_id						  		) --> read_SliceH_check_separate_colour_plane_flag;
		read_SliceH_pps_id(read_next_byte)-->read_SliceH_pps_id;
		read_SliceH_check_separate_colour_plane_flag		( read_SliceH_check_separate_colour_plane_flag	 	) --> read_SliceH_check_separate_colour_plane_flag_done; 
		read_SliceH_check_separate_colour_plane_flag(read_next_byte)-->read_SliceH_check_separate_colour_plane_flag;
		read_SliceH_check_separate_colour_plane_flag_done	( read_SliceH_separate_colour_plane_flag_done		) --> read_SliceH_read_colour_plane_id;
		read_SliceH_check_separate_colour_plane_flag_done	( read_SliceH_skip_separate_colour_plane_flag	  	) --> read_SliceH_frame_num;	
		read_SliceH_check_separate_colour_plane_flag_done(read_next_byte)-->read_SliceH_check_separate_colour_plane_flag_done;
		read_SliceH_read_colour_plane_id					( read_SliceH_read_colour_plane_id				  	) --> read_SliceH_frame_num;
		read_SliceH_read_colour_plane_id(read_next_byte)-->read_SliceH_read_colour_plane_id;
		read_SliceH_frame_num								( read_SliceH_frame_num	  	                        ) --> read_SliceH_field_pic_flag;
		read_SliceH_frame_num								( skip_read_SliceH_frame_num	  	                        ) --> read_SliceH_field_pic_flag;
		read_SliceH_frame_num(read_next_byte)-->read_SliceH_frame_num;
		read_SliceH_field_pic_flag							( read_SliceH_field_pic_flag						) --> read_SliceH_bottom_field_flag;
		read_SliceH_field_pic_flag							( read_SliceH_skip_field_pic_flag					) --> read_SliceH_idr_pic_id;
		read_SliceH_field_pic_flag(read_next_byte)-->read_SliceH_field_pic_flag;
		read_SliceH_bottom_field_flag						( read_SliceH_bottom_field_flag						) --> read_SliceH_bottom_field_flag_done;
		read_SliceH_bottom_field_flag						( read_SliceH_skip_bottom_field_flag				) --> read_SliceH_idr_pic_id;
		read_SliceH_bottom_field_flag(read_next_byte)-->read_SliceH_bottom_field_flag;
		read_SliceH_bottom_field_flag_done					( read_SliceH_bottom_field_flag_done				) --> read_SliceH_idr_pic_id;
		read_SliceH_bottom_field_flag_done(read_next_byte)-->read_SliceH_bottom_field_flag_done;

		read_SliceH_idr_pic_id								( read_SliceH_idr_pic_id  	                        ) --> read_SliceH_idr_pic_id_done;
		read_SliceH_idr_pic_id								( read_SliceH_skip_idr_pic_id                       ) --> read_SliceH_pic_order_cnt_lsb;
		read_SliceH_idr_pic_id(read_next_byte)-->read_SliceH_idr_pic_id;
		read_SliceH_idr_pic_id_done							( read_SliceH_idr_pic_id_done		  				) --> read_SliceH_pic_order_cnt_lsb;	
		read_SliceH_idr_pic_id_done(read_next_byte)-->read_SliceH_idr_pic_id_done;

		read_SliceH_pic_order_cnt_lsb						( read_SliceH_pic_order_cnt_lsb  					) --> read_SliceH_pic_order_cnt_lsb_start;
		read_SliceH_pic_order_cnt_lsb(read_next_byte)-->read_SliceH_pic_order_cnt_lsb;
		read_SliceH_pic_order_cnt_lsb_start					( read_SliceH_pic_order_cnt_lsb_done  				) --> read_SliceH_pic_order_cnt_lsb_done;
		read_SliceH_pic_order_cnt_lsb_start(read_next_byte)-->read_SliceH_pic_order_cnt_lsb_start;
		read_SliceH_pic_order_cnt_lsb						( read_SliceH_skip_pic_order_cnt_lsb  				) --> read_SliceH_delta_pic_order_cnt_bottom_done;

		read_SliceH_pic_order_cnt_lsb_done					( read_SliceH_delta_pic_order_cnt_bottom			) --> read_SliceH_delta_pic_order_cnt_bottom_start;
		read_SliceH_pic_order_cnt_lsb_done(read_next_byte)-->read_SliceH_pic_order_cnt_lsb_done;
		read_SliceH_delta_pic_order_cnt_bottom_start		( read_SliceH_delta_pic_order_cnt_bottom_done		) --> CalcPOC;
		read_SliceH_delta_pic_order_cnt_bottom_start(read_next_byte)-->read_SliceH_delta_pic_order_cnt_bottom_start;
		read_SliceH_pic_order_cnt_lsb_done					( read_SliceH_skip_delta_pic_order_cnt_bottom		) --> CalcPOC;    

		read_SliceH_delta_pic_order_cnt_bottom_done			( read_SliceH_delta_pic_order_cnt0					) --> read_SliceH_delta_pic_order_cnt0_start;
		read_SliceH_delta_pic_order_cnt_bottom_done(read_next_byte)-->read_SliceH_delta_pic_order_cnt_bottom_done;
		read_SliceH_delta_pic_order_cnt0_start				( read_SliceH_delta_pic_order_cnt0_done				) --> read_SliceH_delta_pic_order_cnt0_done;
		read_SliceH_delta_pic_order_cnt0_start(read_next_byte)-->read_SliceH_delta_pic_order_cnt0_start;
		read_SliceH_delta_pic_order_cnt_bottom_done			( read_SliceH_skip_delta_pic_order_cnt0				) --> CalcPOC;
		read_SliceH_delta_pic_order_cnt_bottom_done(read_next_byte)-->read_SliceH_delta_pic_order_cnt_bottom_done;

		read_SliceH_delta_pic_order_cnt0_done				( read_SliceH_delta_pic_order_cnt1		 	        ) --> read_SliceH_delta_pic_order_cnt1_start;
		read_SliceH_delta_pic_order_cnt0_done(read_next_byte)-->read_SliceH_delta_pic_order_cnt0_done;
		read_SliceH_delta_pic_order_cnt1_start				( read_SliceH_delta_pic_order_cnt1_done 		    ) --> CalcPOC;	
		read_SliceH_delta_pic_order_cnt1_start(read_next_byte)-->read_SliceH_delta_pic_order_cnt1_start;
		read_SliceH_delta_pic_order_cnt0_done				( read_SliceH_skip_delta_pic_order_cnt1				) --> CalcPOC;

		CalcPOC												( CalcPOC	                                        ) --> read_SliceH_redundant_pic_cnt;
		CalcPOC												( skipPOC	                                        ) --> read_SliceH_redundant_pic_cnt;
		CalcPOC(read_next_byte)-->CalcPOC;
		read_SliceH_redundant_pic_cnt						( read_SliceH_redundant_pic_cnt                     ) --> read_SliceH_redundant_pic_cnt_done;
		read_SliceH_redundant_pic_cnt(read_next_byte)-->read_SliceH_redundant_pic_cnt;
		read_SliceH_redundant_pic_cnt_done					( read_SliceH_redundant_pic_cnt_done  				) --> read_SliceH_direct_spatial_mv_pred_flag;
		read_SliceH_redundant_pic_cnt_done(read_next_byte)-->read_SliceH_redundant_pic_cnt_done;
		read_SliceH_redundant_pic_cnt						( read_SliceH_skip_redundant_pic_cnt                ) --> read_SliceH_direct_spatial_mv_pred_flag;

		read_SliceH_direct_spatial_mv_pred_flag				( read_SliceH_direct_spatial_mv_pred_flag	        ) --> read_SliceH_direct_spatial_mv_pred_flag_done;
		read_SliceH_direct_spatial_mv_pred_flag(read_next_byte)-->read_SliceH_direct_spatial_mv_pred_flag;
		read_SliceH_direct_spatial_mv_pred_flag_done		( read_SliceH_direct_spatial_mv_pred_flag_done		) --> read_SliceH_num_ref_idx_active_override_flag;
		read_SliceH_direct_spatial_mv_pred_flag_done(read_next_byte)-->read_SliceH_direct_spatial_mv_pred_flag_done;
		read_SliceH_direct_spatial_mv_pred_flag				( read_SliceH_skip_direct_spatial_mv_pred_flag		) --> read_SliceH_num_ref_idx_active_override_flag;

		read_SliceH_num_ref_idx_active_override_flag		( read_SliceH_num_ref_idx_active_override_flag		) --> read_SliceH_num_ref_idx_l0_active_minus1;
		read_SliceH_num_ref_idx_active_override_flag(read_next_byte)-->read_SliceH_num_ref_idx_active_override_flag;
		read_SliceH_num_ref_idx_l0_active_minus1			( read_SliceH_num_ref_idx_l0_active_minus1			) --> read_SliceH_num_ref_idx_l1_active_minus1;
		read_SliceH_num_ref_idx_l0_active_minus1(read_next_byte)-->read_SliceH_num_ref_idx_l0_active_minus1;
		read_SliceH_num_ref_idx_l1_active_minus1			( read_SliceH_num_ref_idx_l1_active_minus1			) --> read_SliceH_num_ref_idx_l1_active_minus1_done;
		read_SliceH_num_ref_idx_l1_active_minus1(read_next_byte)-->read_SliceH_num_ref_idx_l1_active_minus1;
		read_SliceH_num_ref_idx_l1_active_minus1_done		( read_SliceH_num_ref_idx_l1_active_minus1_done		) --> read_SliceH_ref_pic_list_reordering_l0;
		read_SliceH_num_ref_idx_l1_active_minus1_done(read_next_byte)-->read_SliceH_num_ref_idx_l1_active_minus1_done;
		read_SliceH_num_ref_idx_l1_active_minus1			( read_SliceH_skip_num_ref_idx_l1_active_minus1		) --> read_SliceH_ref_pic_list_reordering_l0;
		read_SliceH_num_ref_idx_l0_active_minus1			( read_SliceH_skip_num_ref_idx_l0_active_minus1		) --> read_SliceH_ref_pic_list_reordering_l0;
		read_SliceH_num_ref_idx_active_override_flag		( read_SliceH_skip_num_ref_idx_active_override_flag	) --> read_SliceH_ref_pic_list_reordering_l0;

		//ref_pic_list_reordering_l0
		read_SliceH_ref_pic_list_reordering_l0				( read_SliceH_ref_pic_list_reordering_flag_l0           ) --> read_SliceH_ref_pic_list_reordering_flag_l0_done;
		read_SliceH_ref_pic_list_reordering_l0(read_next_byte)-->read_SliceH_ref_pic_list_reordering_l0;
		read_SliceH_ref_pic_list_reordering_l0				( read_SliceH_skip_ref_pic_list_reordering              ) --> read_SliceH_pred_weight_table;
		read_SliceH_ref_pic_list_reordering_l0				( skip_read_SliceH_skip_ref_pic_list_reordering         ) --> read_SliceH_pred_weight_table;
		read_SliceH_ref_pic_list_reordering_flag_l0_done	( read_SliceH_ref_pic_list_reordering_flag_l0_done      ) --> read_SliceH_reordering_of_pic_nums_idc_l0;
		read_SliceH_ref_pic_list_reordering_flag_l0_done	( skip_read_SliceH_ref_pic_list_reordering_flag_l0_done ) --> read_SliceH_reordering_of_pic_nums_idc_l0;
		read_SliceH_ref_pic_list_reordering_flag_l0_done(read_next_byte)-->read_SliceH_ref_pic_list_reordering_flag_l0_done;
		read_SliceH_reordering_of_pic_nums_idc_l0 			( read_SliceH_reordering_of_pic_nums_idc_l0             ) --> read_SliceH_reordering_of_pic_nums_idc_l0_done;
		read_SliceH_reordering_of_pic_nums_idc_l0			( read_SliceH_skip_reordering_of_pic_nums_idc_l0        ) --> read_SliceH_ref_pic_list_reordering_l1;	
		read_SliceH_reordering_of_pic_nums_idc_l0(read_next_byte)-->read_SliceH_reordering_of_pic_nums_idc_l0;
		read_SliceH_reordering_of_pic_nums_idc_l0_done		( read_SliceH_reordering_of_pic_nums_idc_l0_done        ) --> look_SliceH_reordering_of_pic_nums_idc_l0;	
		read_SliceH_reordering_of_pic_nums_idc_l0_done		( skip_read_SliceH_reordering_of_pic_nums_idc_l0_done   ) --> look_SliceH_reordering_of_pic_nums_idc_l0;	
		read_SliceH_reordering_of_pic_nums_idc_l0_done(read_next_byte)-->read_SliceH_reordering_of_pic_nums_idc_l0_done;
		look_SliceH_reordering_of_pic_nums_idc_l0			( read_SliceH_abs_diff_pic_num_minus1_l0_done           ) --> read_SliceH_reordering_of_pic_nums_idc_l0;	
		look_SliceH_reordering_of_pic_nums_idc_l0			( skip_read_SliceH_abs_diff_pic_num_minus1_l0_done      ) --> read_SliceH_reordering_of_pic_nums_idc_l0;	
		look_SliceH_reordering_of_pic_nums_idc_l0			( read_SliceH_long_term_pic_num_idc2_l0_done            ) --> read_SliceH_reordering_of_pic_nums_idc_l0;
		look_SliceH_reordering_of_pic_nums_idc_l0			( skip_read_SliceH_long_term_pic_num_idc2_l0_done       ) --> read_SliceH_reordering_of_pic_nums_idc_l0;
		look_SliceH_reordering_of_pic_nums_idc_l0			( read_SliceH_skip_reordering_of_pic_nums_idc3_l0       ) --> read_SliceH_ref_pic_list_reordering_l1;
		look_SliceH_reordering_of_pic_nums_idc_l0(read_next_byte)-->look_SliceH_reordering_of_pic_nums_idc_l0;
		//ref_pic_list_reordering_l1
		read_SliceH_ref_pic_list_reordering_l1				( read_SliceH_ref_pic_list_reordering_flag_l1           ) --> read_SliceH_ref_pic_list_reordering_flag_l1_done;
		read_SliceH_ref_pic_list_reordering_l1				( read_SliceH_skip_ref_pic_list_reordering_l1           ) --> read_SliceH_pred_weight_table;
		read_SliceH_ref_pic_list_reordering_l1				( skip_read_SliceH_skip_ref_pic_list_reordering_l1      ) --> read_SliceH_pred_weight_table;
		read_SliceH_ref_pic_list_reordering_l1(read_next_byte)-->read_SliceH_ref_pic_list_reordering_l1;
		read_SliceH_ref_pic_list_reordering_flag_l1_done	( read_SliceH_ref_pic_list_reordering_flag_l1_done      ) --> read_SliceH_reordering_of_pic_nums_idc_l1;
		read_SliceH_ref_pic_list_reordering_flag_l1_done	( skip_read_SliceH_ref_pic_list_reordering_flag_l1_done ) --> read_SliceH_reordering_of_pic_nums_idc_l1;
		read_SliceH_ref_pic_list_reordering_flag_l1_done(read_next_byte)-->read_SliceH_ref_pic_list_reordering_flag_l1_done;
		read_SliceH_reordering_of_pic_nums_idc_l1 			( read_SliceH_reordering_of_pic_nums_idc_l1             ) --> read_SliceH_reordering_of_pic_nums_idc_l1_done;
		read_SliceH_reordering_of_pic_nums_idc_l1			( read_SliceH_skip_reordering_of_pic_nums_idc_l1        ) --> read_SliceH_pred_weight_table;	
		read_SliceH_reordering_of_pic_nums_idc_l1(read_next_byte)-->read_SliceH_reordering_of_pic_nums_idc_l1;
		read_SliceH_reordering_of_pic_nums_idc_l1_done		( read_SliceH_reordering_of_pic_nums_idc_l1_done        ) --> look_SliceH_reordering_of_pic_nums_idc_l1;	
		read_SliceH_reordering_of_pic_nums_idc_l1_done		( skip_read_SliceH_reordering_of_pic_nums_idc_l1_done   ) --> look_SliceH_reordering_of_pic_nums_idc_l1;	
		read_SliceH_reordering_of_pic_nums_idc_l1_done(read_next_byte)-->read_SliceH_reordering_of_pic_nums_idc_l1_done;
		look_SliceH_reordering_of_pic_nums_idc_l1			( read_SliceH_abs_diff_pic_num_minus1_l1_done           ) --> read_SliceH_reordering_of_pic_nums_idc_l1;	
		look_SliceH_reordering_of_pic_nums_idc_l1			( skip_read_SliceH_abs_diff_pic_num_minus1_l1_done      ) --> read_SliceH_reordering_of_pic_nums_idc_l1;	
		look_SliceH_reordering_of_pic_nums_idc_l1			( read_SliceH_long_term_pic_num_idc2_l1_done            ) --> read_SliceH_reordering_of_pic_nums_idc_l1;
		look_SliceH_reordering_of_pic_nums_idc_l1			( skip_read_SliceH_long_term_pic_num_idc2_l1_done       ) --> read_SliceH_reordering_of_pic_nums_idc_l1;
		look_SliceH_reordering_of_pic_nums_idc_l1			( read_SliceH_skip_reordering_of_pic_nums_idc3_l1       ) --> read_SliceH_pred_weight_table;


		//pred_weight_table
		read_SliceH_pred_weight_table						( read_SliceH_pred_weight_table						) --> read_SliceH_dec_ref_pic_marking; //not yet realised
		read_SliceH_pred_weight_table						( read_SliceH_skip_pred_weight_table				) --> read_SliceH_dec_ref_pic_marking;
		//dec_ref_pic_marking
		read_SliceH_pred_weight_table(read_next_byte)-->read_SliceH_pred_weight_table;
		read_SliceH_dec_ref_pic_marking						( read_SliceH_dec_ref_pic_marking	                ) --> read_SliceH_check_IdrPicFlag;
		read_SliceH_dec_ref_pic_marking(read_next_byte)-->read_SliceH_dec_ref_pic_marking;
		read_SliceH_check_IdrPicFlag						( read_SliceH_no_output_of_prior_pics_flag_done		) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_IdrPicFlag						( skip_read_SliceH_no_output_of_prior_pics_flag_done		) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_IdrPicFlag						( read_SliceH_adaptative_ref_pic_marking_mode_flag_done) --> read_SliceH_check_mmco;
		read_SliceH_check_IdrPicFlag						( skip_read_SliceH_adaptative_ref_pic_marking_mode_flag_done) --> read_SliceH_check_mmco;
		read_SliceH_check_IdrPicFlag(read_next_byte)-->read_SliceH_check_IdrPicFlag;
		read_SliceH_check_mmco								( read_SliceH_skip_memory_management_control_operation_done ) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_mmco								( read_SliceH_memory_management_control_operation_done) --> read_SliceH_check_mmco_done;
		read_SliceH_check_mmco								( skip_read_SliceH_memory_management_control_operation_done) --> read_SliceH_check_mmco_done;
		read_SliceH_check_mmco(read_next_byte)-->read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_mmco_0								) --> read_SliceH_cabac_init_idc;
		read_SliceH_check_mmco_done							( read_SliceH_difference_of_pic_nums_minus1_done	) --> read_SliceH_check_mmco_36;
		read_SliceH_check_mmco_done							( skip_read_SliceH_difference_of_pic_nums_minus1_done	) --> read_SliceH_check_mmco_36;
		read_SliceH_check_mmco_done							( read_SliceH_long_term_pic_num_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( skip_read_SliceH_long_term_pic_num_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( skip_read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done(read_next_byte)-->read_SliceH_check_mmco_done;
		read_SliceH_check_mmco_36							( read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36							( skip_read_SliceH_long_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36							( read_SliceH_long_not_term_frame_idx_done				) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_36(read_next_byte)-->read_SliceH_check_mmco_36;
		read_SliceH_check_mmco_done							( read_SliceH_max_long_term_frame_idx_plus1_done	) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( skip_read_SliceH_max_long_term_frame_idx_plus1_done	) --> read_SliceH_check_mmco;
		read_SliceH_check_mmco_done							( read_SliceH_mmco_5								) --> read_SliceH_check_mmco;
		read_SliceH_dec_ref_pic_marking						( read_SliceH_skip_dec_ref_pic_marking				) --> read_SliceH_cabac_init_idc;
		read_SliceH_dec_ref_pic_marking						( skip_read_SliceH_skip_dec_ref_pic_marking			) --> read_SliceH_cabac_init_idc;
		read_SliceH_dec_ref_pic_marking(read_next_byte)-->read_SliceH_dec_ref_pic_marking;

		read_SliceH_cabac_init_idc							( read_SliceH_cabac_init_idc						) --> read_SliceH_cabac_init_idc_done;
		read_SliceH_cabac_init_idc(read_next_byte)-->read_SliceH_cabac_init_idc;
		read_SliceH_cabac_init_idc_done						( read_SliceH_cabac_init_idc_done	                ) --> read_SliceH_slice_qp_delta_done;
		read_SliceH_cabac_init_idc_done(read_next_byte)-->read_SliceH_cabac_init_idc_done;
		read_SliceH_cabac_init_idc							( read_SliceH_skip_cabac_init_idc					) --> read_SliceH_slice_qp_delta_done;

		read_SliceH_slice_qp_delta_done						( read_SliceH_slice_qp_delta_done	                ) --> read_SliceH_sp_for_switch_flag;
		read_SliceH_slice_qp_delta_done(read_next_byte)-->read_SliceH_slice_qp_delta_done;

		read_SliceH_sp_for_switch_flag						( read_SliceH_sp_for_switch_flag	                ) --> read_SliceH_sp_for_switch_flag_done;
		read_SliceH_sp_for_switch_flag(read_next_byte)-->read_SliceH_sp_for_switch_flag;
		read_SliceH_sp_for_switch_flag_done					( read_SliceH_sp_for_switch_flag_done				) --> read_SliceH_slice_qs_delta_done;
		read_SliceH_sp_for_switch_flag_done(read_next_byte)-->read_SliceH_sp_for_switch_flag_done;
		read_SliceH_slice_qs_delta_done						( read_SliceH_slice_qs_delta_done	                ) --> read_SliceH_disable_deblocking_filter_idc;
		read_SliceH_slice_qs_delta_done(read_next_byte)-->read_SliceH_slice_qs_delta_done;
		read_SliceH_sp_for_switch_flag						( read_SliceH_skip_sp_for_switch_flag				) --> read_SliceH_disable_deblocking_filter_idc;
		read_SliceH_sp_for_switch_flag(read_next_byte)-->read_SliceH_sp_for_switch_flag;

		read_SliceH_disable_deblocking_filter_idc			( read_SliceH_disable_deblocking_filter_idc 		) --> read_SliceH_slice_alpha_c0_offset_div2;		
		read_SliceH_disable_deblocking_filter_idc(read_next_byte)-->read_SliceH_disable_deblocking_filter_idc;
		read_SliceH_slice_alpha_c0_offset_div2				( read_SliceH_slice_alpha_c0_offset_div2	        ) --> read_SliceH_slice_beta_offset_div2;
		read_SliceH_slice_alpha_c0_offset_div2(read_next_byte)-->read_SliceH_slice_alpha_c0_offset_div2;
		read_SliceH_slice_beta_offset_div2					( read_SliceH_slice_beta_offset_div2				) --> read_SliceH_slice_beta_offset_div2_done;
		read_SliceH_slice_beta_offset_div2(read_next_byte)-->read_SliceH_slice_beta_offset_div2;
		read_SliceH_slice_beta_offset_div2_done				( read_SliceH_slice_beta_offset_div2_done	        ) --> read_SliceH_slice_group_change_cycle;
		read_SliceH_slice_beta_offset_div2_done(read_next_byte)-->read_SliceH_slice_beta_offset_div2_done;
		read_SliceH_slice_alpha_c0_offset_div2				( read_SliceH_skip_slice_alpha_c0_offset_div2		) --> read_SliceH_slice_group_change_cycle;
		read_SliceH_slice_alpha_c0_offset_div2(read_next_byte)-->read_SliceH_slice_alpha_c0_offset_div2;
		read_SliceH_disable_deblocking_filter_idc			( read_SliceH_skip_disable_deblocking_filter_idc 	) --> read_SliceH_slice_group_change_cycle;
		read_SliceH_disable_deblocking_filter_idc(read_next_byte)-->read_SliceH_disable_deblocking_filter_idc;

		read_SliceH_slice_group_change_cycle				( read_SliceH_slice_group_change_cycle				) --> read_SliceH_slice_group_change_cycle_done;
		read_SliceH_slice_group_change_cycle(read_next_byte)-->read_SliceH_slice_group_change_cycle;
		read_SliceH_slice_group_change_cycle_done			( read_SliceH_slice_group_change_cycle_done			) --> read_SliceD_CABAC_alignement;
		read_SliceH_slice_group_change_cycle_done(read_next_byte)-->read_SliceH_slice_group_change_cycle_done;
		read_SliceH_slice_group_change_cycle				( read_SliceH_skip_slice_group_change_cycle	) --> read_SliceD_CABAC_alignement;

		// read Slice Data    
		read_SliceD_CABAC_alignement						( read_SliceD_CABAC_alignement						) --> read_SliceD_init;
		read_SliceD_CABAC_alignement(read_next_byte)-->read_SliceD_CABAC_alignement;
		read_SliceD_CABAC_alignement						( read_SliceD_skip_CABAC_alignement	                ) --> read_SliceD_init;
		read_SliceD_init									( SliceD_init										) --> sync_do_mb_layer;
		read_SliceD_init(read_next_byte)-->read_SliceD_init;
		sync_do_mb_layer 									( sync_do_mb_layer									) --> read_SliceD_mb_skip;
		sync_do_mb_layer(read_next_byte)-->sync_do_mb_layer;
		read_SliceD_mb_skip									( read_SliceD_mb_skip_run							) --> read_SliceD_mb_skip_run_done0;
		read_SliceD_mb_skip(read_next_byte)-->read_SliceD_mb_skip;
		read_SliceD_mb_skip_run_done0						( read_SliceD_mb_skip_run_done0						) --> read_SliceD_mb_skip_run_done1;
		read_SliceD_mb_skip_run_done0(read_next_byte)-->read_SliceD_mb_skip_run_done0;
		read_SliceD_mb_skip_run_done1						( read_SliceD_mb_skip_run_done1						) --> read_SliceD_mb_skip_run_done1;
		read_SliceD_mb_skip_run_done1						( read_SliceD_mb_skip_run_done2						) --> read_SliceD_mb_skip_run_done2_moredata;
		read_SliceD_mb_skip_run_done1(read_next_byte)-->read_SliceD_mb_skip_run_done1;
		read_SliceD_mb_skip_run_done2_moredata              ( read_SliceD_mb_skip_run_done2_moredata_1          ) --> read_SliceD_mb_field_decoding_flag;
		read_SliceD_mb_skip_run_done2_moredata 				( read_SliceD_mb_skip_run_done2_moredata_0			) --> syncSliceD_endwhile;
		read_SliceD_mb_skip_run_done2_moredata(read_next_byte)-->read_SliceD_mb_skip_run_done2_moredata;
		read_SliceD_mb_skip									( read_SliceD_mb_skip_flag 							) --> read_SliceD_mb_skip; 
		read_SliceD_mb_skip									( read_SliceD_mb_skip_flag_done						) --> read_SliceD_mb_skip_flag_sent_zeros;
		read_SliceD_mb_skip									( read_SliceD_skip_mb_skip 							) --> read_SliceD_mb_field_decoding_flag;
		read_SliceD_mb_skip(read_next_byte)-->read_SliceD_mb_skip;

		read_SliceD_mb_skip_flag_sent_zeros					(read_SliceD_mb_skip_flag_sent_zeros				) --> SliceD_update;
		read_SliceD_mb_skip_flag_sent_zeros					(read_SliceD_mb_skip_flag_skip_sent_zeros			) --> read_SliceD_mb_field_decoding_flag;
		read_SliceD_mb_skip_flag_sent_zeros(read_next_byte)-->read_SliceD_mb_skip_flag_sent_zeros;
		
		read_SliceD_mb_field_decoding_flag					( read_SliceD_mb_field_decoding_flag				) --> undefined; // interleaved not implemented
		read_SliceD_mb_field_decoding_flag					( read_SliceD_skip_mb_field_decoding_flag			) --> read_MB_layer_mb_type;
		read_SliceD_mb_field_decoding_flag(read_next_byte)-->read_SliceD_mb_field_decoding_flag;
		// --> macrobloc_layer(read_next_byte)
		
		SliceD_update										( SliceD_update_CAVLC								) --> SliceD_moredata;
		SliceD_update(read_next_byte)-->SliceD_update;
		SliceD_update										( SliceD_update_CABAC								) --> SliceD_Update_done;
		SliceD_Update_done									( SliceD_update_CABAC_done							) --> SliceD_moredata;
		SliceD_Update_done(read_next_byte)-->SliceD_Update_done;

		SliceD_moredata                                     ( SliceD_moredata_1                                 ) --> SliceD_moredata_1_done;
		SliceD_moredata(read_next_byte)-->SliceD_moredata;
		SliceD_moredata_1_done								( send_data_position_information_is_ipcm            ) --> syncSliceD_endwhile;
		SliceD_moredata_1_done								( send_data_position_information	                ) --> syncSliceD_endwhile;
		SliceD_moredata_1_done								( send_data_position_information_mb_skip_flag       ) --> syncSliceD_endwhile;
		SliceD_moredata_1_done(read_next_byte)-->SliceD_moredata_1_done;
		SliceD_moredata 									( SliceD_moredata_0									) --> SliceD_stop_byte_align_done;
		SliceD_stop_byte_align_done							( send_data_position_information_is_ipcm            ) --> syncSliceD_endwhile;
		SliceD_stop_byte_align_done							( send_data_position_information	                ) --> syncSliceD_endwhile;
		SliceD_stop_byte_align_done							( send_data_position_information_mb_skip_flag       ) --> syncSliceD_endwhile;
		SliceD_stop_byte_align_done(read_next_byte)-->SliceD_stop_byte_align_done;
		syncSliceD_endwhile									( syncSliceD_endwhile								) --> SliceD_while_moreDataFlag;
		syncSliceD_endwhile(read_next_byte)-->syncSliceD_endwhile;

		SliceD_while_moreDataFlag							( SliceD_while_moreDataFlag							) --> sync_do_mb_layer;
		SliceD_while_moreDataFlag							( SliceD_end										) --> search_start_code;
		SliceD_while_moreDataFlag(read_next_byte)-->SliceD_while_moreDataFlag;
		read_SliceD_mb_field_decoding_flag					( SliceD_end										) --> search_start_code;
		read_SliceD_mb_field_decoding_flag(read_next_byte)-->read_SliceD_mb_field_decoding_flag;

		// macrobloc_layer
		read_MB_layer_mb_type								( read_MB_layer_mb_type								) --> read_MB_layer_mb_type_done;
		read_MB_layer_mb_type(read_next_byte)-->read_MB_layer_mb_type;
		//read_MB_layer_mb_type_done						( read_MB_layer_mb_type_not_done					) --> read_MB_layer_mb_type_done;
		read_MB_layer_mb_type_done							( read_MB_layer_mb_type_done						) --> read_MB_layer_check_I_PCM;
		read_MB_layer_mb_type_done(read_next_byte)-->read_MB_layer_mb_type_done;
		read_MB_layer_check_I_PCM							( read_MB_layer_I_PCM_alignement					) --> read_MB_layer_pcm_sample_luma0;
		read_MB_layer_check_I_PCM(read_next_byte)-->read_MB_layer_check_I_PCM;
		read_MB_layer_pcm_sample_luma0					    ( read_MB_layer_pcm_sample_luma0	                ) --> read_MB_layer_pcm_sample_luma1;
		read_MB_layer_pcm_sample_luma0(read_next_byte)-->read_MB_layer_pcm_sample_luma0;
		read_MB_layer_pcm_sample_luma1						( read_MB_layer_pcm_sample_luma1	                ) --> read_MB_layer_pcm_sample_luma1;
		read_MB_layer_pcm_sample_luma1						( read_MB_layer_pcm_sample_luma1_done		        ) --> read_MB_layer_pcm_sample_chroma0;	
		read_MB_layer_pcm_sample_luma1(read_next_byte)-->read_MB_layer_pcm_sample_luma1;
		read_MB_layer_pcm_sample_chroma0					( read_MB_layer_pcm_sample_chroma0					) --> read_MB_layer_pcm_sample_chroma1;	
		read_MB_layer_pcm_sample_chroma0(read_next_byte)-->read_MB_layer_pcm_sample_chroma0;
		read_MB_layer_pcm_sample_chroma1					( read_MB_layer_pcm_sample_chroma1					) --> read_MB_layer_pcm_sample_chroma1;
		read_MB_layer_pcm_sample_chroma1					( read_MB_layer_pcm_sample_done						) --> SliceD_update;	
		read_MB_layer_pcm_sample_chroma1(read_next_byte)-->read_MB_layer_pcm_sample_chroma1;
		read_MB_layer_check_I_PCM							( read_MB_layer_not_I_PCM							) --> read_MB_layer_check_pred;
		read_MB_layer_check_pred							( read_MB_layer_sub_mb_pred							) --> Sub_mb_pred; //--> sub_mb_pred
		read_MB_layer_check_pred(read_next_byte)-->read_MB_layer_check_pred;
		read_MB_layer_sub_mb_pred_done				        ( read_MB_layer_sub_mb_pred_done	                ) --> read_MB_layer_coded_block_pattern;
		read_MB_layer_sub_mb_pred_done(read_next_byte)-->read_MB_layer_sub_mb_pred_done;
		read_MB_layer_check_pred							( read_MB_layer_transform_size_8x8_flag				) --> read_MB_layer_transform_size_8x8_flag_done;
		read_MB_layer_check_pred(read_next_byte)-->read_MB_layer_check_pred;
		read_MB_layer_transform_size_8x8_flag_done			( read_MB_layer_transform_size_8x8_flag_done		) --> MB_pred; //--> mb_pred 
		read_MB_layer_transform_size_8x8_flag_done(read_next_byte)-->read_MB_layer_transform_size_8x8_flag_done;
		read_MB_layer_check_pred							( read_MB_layer_skip_transform_size_8x8_flag		) --> MB_pred; 
		read_MB_layer_check_pred(read_next_byte)-->read_MB_layer_check_pred;
		// --> mb_pred(read_next_byte)	

		read_MB_layer_coded_block_pattern					( read_MB_layer_coded_block_pattern					) --> read_MB_layer_coded_block_pattern_done;
		read_MB_layer_coded_block_pattern(read_next_byte)-->read_MB_layer_coded_block_pattern;
		read_MB_layer_coded_block_pattern_done				( read_MB_layer_coded_block_pattern_start_cabac_chroma ) --> read_MB_layer_coded_block_pattern_done;
		read_MB_layer_coded_block_pattern_done			    ( read_MB_layer_coded_block_pattern_done	        ) --> read_MB_layer_cbp_transform_size_8x8_flag_done;
		read_MB_layer_coded_block_pattern_done(read_next_byte)-->read_MB_layer_coded_block_pattern_done;
		read_MB_layer_cbp_transform_size_8x8_flag_done		( read_MB_layer_cbp_transform_size_8x8_flag_done	) --> read_MB_layer_mb_qp_delta;
		read_MB_layer_cbp_transform_size_8x8_flag_done(read_next_byte)-->read_MB_layer_cbp_transform_size_8x8_flag_done;
		read_MB_layer_coded_block_pattern					( read_MB_layer_skip_coded_block_pattern			) --> read_MB_layer_mb_qp_delta;
		read_MB_layer_coded_block_pattern(read_next_byte)-->read_MB_layer_coded_block_pattern;
		read_MB_layer_mb_qp_delta							( read_MB_layer_mb_qp_delta							) --> read_MB_layer_mb_qp_delta_done;
		read_MB_layer_mb_qp_delta(read_next_byte)-->read_MB_layer_mb_qp_delta;
		read_MB_layer_mb_qp_delta_done						( read_MB_layer_mb_qp_delta_done	                ) --> Residual_init; 
		read_MB_layer_mb_qp_delta_done(read_next_byte)-->read_MB_layer_mb_qp_delta_done;
		// --> residual (read_next_byte)
		read_MB_layer_mb_qp_delta							( read_MB_layer_skip_mb_qp_delta					) --> SliceD_update;
		read_MB_layer_mb_qp_delta							( read_MB_layer_skip_mb_qp_delta_CABAC				) --> SliceD_update;
		read_MB_layer_mb_qp_delta(read_next_byte)-->read_MB_layer_mb_qp_delta;

		// sub_mb_pred
		Sub_mb_pred											( sub_MB_pred_init_sub_mb_type						) --> read_sub_MB_pred_sub_mb_type;
		Sub_mb_pred(read_next_byte)-->Sub_mb_pred;
		read_sub_MB_pred_sub_mb_type						( read_sub_MB_pred_sub_mb_type						) --> read_sub_MB_pred_sub_mb_type;
		read_sub_MB_pred_sub_mb_type						( sub_MB_pred_init_ref_idx_l0						) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_sub_mb_type(read_next_byte)-->read_sub_MB_pred_sub_mb_type;
		read_sub_MB_pred_ref_idx_l0							( read_sub_MB_pred_ref_idx_l0						) --> read_sub_MB_pred_ref_idx_l0_done;
		read_sub_MB_pred_ref_idx_l0(read_next_byte)-->read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0_done					( read_sub_MB_pred_ref_idx_l0_done					) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0_done(read_next_byte)-->read_sub_MB_pred_ref_idx_l0_done;
		read_sub_MB_pred_ref_idx_l0							( read_sub_MB_pred_skip_ref_idx_l0					) --> read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l0							( sub_MB_pred_init_ref_idx_l1						) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l0(read_next_byte)-->read_sub_MB_pred_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l1							( read_sub_MB_pred_ref_idx_l1						) --> read_sub_MB_pred_ref_idx_l1_done;
		read_sub_MB_pred_ref_idx_l1(read_next_byte)-->read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1_done					( read_sub_MB_pred_ref_idx_l1_done					) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1_done(read_next_byte)-->read_sub_MB_pred_ref_idx_l1_done;
		read_sub_MB_pred_ref_idx_l1							( read_sub_MB_pred_skip_ref_idx_l1					) --> read_sub_MB_pred_ref_idx_l1;
		read_sub_MB_pred_ref_idx_l1							( sub_MB_pred_init_mvd_l0							) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_mvd_l0	                        ) --> read_sub_MB_pred_mvd_l0_done0;
		read_sub_MB_pred_mvd_l0(read_next_byte)-->read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0_done0						( read_sub_MB_pred_mvd_l0_done0						) --> read_sub_MB_pred_mvd_l0_done1;
		read_sub_MB_pred_mvd_l0_done0(read_next_byte)-->read_sub_MB_pred_mvd_l0_done0;
		read_sub_MB_pred_mvd_l0_done1						( read_sub_MB_pred_mvd_l0_done1						) --> read_sub_MB_pred_mvd_l0_done2;
		read_sub_MB_pred_mvd_l0_done1(read_next_byte)-->read_sub_MB_pred_mvd_l0_done1;
		read_sub_MB_pred_mvd_l0_done2						( read_sub_MB_pred_mvd_l0_done2						) --> read_sub_MB_pred_mvd_l0_done0;
		read_sub_MB_pred_mvd_l0_done2(read_next_byte)-->read_sub_MB_pred_mvd_l0_done2;
		read_sub_MB_pred_mvd_l0_done0						( read_sub_MB_pred_skip_mvd_l0_done0				) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( read_sub_MB_pred_skip_mvd_l0						) --> read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l0								( sub_MB_pred_init_mvd_l1							) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l0(read_next_byte)-->read_sub_MB_pred_mvd_l0;
		read_sub_MB_pred_mvd_l1								( read_sub_MB_pred_mvd_l1							) --> read_sub_MB_pred_mvd_l1_done0;
		read_sub_MB_pred_mvd_l1(read_next_byte)-->read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1_done0						( read_sub_MB_pred_mvd_l1_done0						) --> read_sub_MB_pred_mvd_l1_done1;
		read_sub_MB_pred_mvd_l1_done0(read_next_byte)-->read_sub_MB_pred_mvd_l1_done0;
		read_sub_MB_pred_mvd_l1_done1						( read_sub_MB_pred_mvd_l1_done1						) --> read_sub_MB_pred_mvd_l1_done2;
		read_sub_MB_pred_mvd_l1_done1(read_next_byte)-->read_sub_MB_pred_mvd_l1_done1;
		read_sub_MB_pred_mvd_l1_done2						( read_sub_MB_pred_mvd_l1_done2						) --> read_sub_MB_pred_mvd_l1_done0;
		read_sub_MB_pred_mvd_l1_done2(read_next_byte)-->read_sub_MB_pred_mvd_l1_done2;
		read_sub_MB_pred_mvd_l1_done0						( read_sub_MB_pred_skip_mvd_l1_done0				) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1								( read_sub_MB_pred_skip_mvd_l1						) --> read_sub_MB_pred_mvd_l1;
		read_sub_MB_pred_mvd_l1								( sub_MB_pred_done									) --> read_MB_layer_sub_mb_pred_done; // --> macrobloc_layer(read_next_byte)	
		read_sub_MB_pred_mvd_l1(read_next_byte)-->read_sub_MB_pred_mvd_l1;

		// mb_pred
		MB_pred												( MB_pred_init_Intra_4x4							) --> read_MB_pred_rem_intra4x4_pred_mode;
		MB_pred(read_next_byte)-->MB_pred;
		read_MB_pred_rem_intra4x4_pred_mode					( read_MB_pred_rem_intra4x4_pred_mode				) --> read_MB_pred_rem_intra4x4_pred_mode_done;
		read_MB_pred_rem_intra4x4_pred_mode(read_next_byte)-->read_MB_pred_rem_intra4x4_pred_mode;
		read_MB_pred_rem_intra4x4_pred_mode_done			( read_MB_pred_rem_intra4x4_pred_mode_done			) --> read_MB_pred_rem_intra4x4_pred_mode;
		read_MB_pred_rem_intra4x4_pred_mode_done			( read_MB_pred_skip_rem_intra4x4_pred_mode_done		) --> read_MB_pred_rem_intra4x4_pred_mode;	
		read_MB_pred_rem_intra4x4_pred_mode_done(read_next_byte)-->read_MB_pred_rem_intra4x4_pred_mode_done;
		read_MB_pred_rem_intra4x4_pred_mode					( read_MB_pred_skip_rem_intra4x4_pred_mode			) --> read_MB_pred_intra_chroma_pred_mode;
		MB_pred												( MB_pred_init_Intra_8x8							) --> read_MB_pred_rem_intra8x8_pred_mode;
		read_MB_pred_rem_intra8x8_pred_mode					( read_MB_pred_rem_intra8x8_pred_mode				) --> read_MB_pred_rem_intra8x8_pred_mode_done;
		read_MB_pred_rem_intra8x8_pred_mode(read_next_byte)-->read_MB_pred_rem_intra8x8_pred_mode;
		read_MB_pred_rem_intra8x8_pred_mode_done			( read_MB_pred_rem_intra8x8_pred_mode_done			) --> read_MB_pred_rem_intra8x8_pred_mode;
		read_MB_pred_rem_intra8x8_pred_mode_done			( read_MB_pred_skip_rem_intra8x8_pred_mode_done		) --> read_MB_pred_rem_intra8x8_pred_mode;	
		read_MB_pred_rem_intra8x8_pred_mode_done(read_next_byte)-->read_MB_pred_rem_intra8x8_pred_mode_done;
		read_MB_pred_rem_intra8x8_pred_mode					( read_MB_pred_skip_rem_intra8x8_pred_mode			) --> read_MB_pred_intra_chroma_pred_mode;
		MB_pred												( MB_pred_init_Intra_16x16							) --> read_MB_pred_intra_chroma_pred_mode;
		read_MB_pred_intra_chroma_pred_mode					( read_MB_pred_intra_chroma_pred_mode				) --> read_MB_pred_intra_chroma_pred_mode_done;
		read_MB_pred_intra_chroma_pred_mode(read_next_byte)-->read_MB_pred_intra_chroma_pred_mode;
		read_MB_pred_intra_chroma_pred_mode_done			( read_MB_pred_intra_chroma_pred_mode_done			) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer(read_next_byte)
		read_MB_pred_intra_chroma_pred_mode_done(read_next_byte)-->read_MB_pred_intra_chroma_pred_mode_done;
		read_MB_pred_intra_chroma_pred_mode					( read_MB_pred_skip_intra_chroma_pred_mode			) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer(read_next_byte)
		MB_pred												( MB_pred_Inter_not_direct							) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0								( read_MB_pred_ref_idx_l0							) --> read_MB_pred_ref_idx_l0_done;
		read_MB_pred_ref_idx_l0(read_next_byte)-->read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0_done						( read_MB_pred_ref_idx_l0_done						) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0_done(read_next_byte)-->read_MB_pred_ref_idx_l0_done;
		read_MB_pred_ref_idx_l0								( read_MB_pred_skip_ref_idx_l0						) --> read_MB_pred_ref_idx_l0;
		read_MB_pred_ref_idx_l0								( MB_pred_init_ref_idx_l1							) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1								( read_MB_pred_ref_idx_l1							) --> read_MB_pred_ref_idx_l1_done;
		read_MB_pred_ref_idx_l1(read_next_byte)-->read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1_done						( read_MB_pred_ref_idx_l1_done						) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1_done(read_next_byte)-->read_MB_pred_ref_idx_l1_done;
		read_MB_pred_ref_idx_l1								( read_MB_pred_skip_ref_idx_l1						) --> read_MB_pred_ref_idx_l1;
		read_MB_pred_ref_idx_l1								( MB_pred_init_mvd_l0								) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( read_MB_pred_mvd_l0								) --> read_MB_pred_mvd_l0_done0;
		read_MB_pred_mvd_l0(read_next_byte)-->read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0_done0							( read_MB_pred_mvd_l0_done0							) --> read_MB_pred_mvd_l0_done1;
		read_MB_pred_mvd_l0_done0(read_next_byte)-->read_MB_pred_mvd_l0_done0;
		read_MB_pred_mvd_l0_done1							( read_MB_pred_mvd_l0_done1							) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0_done1(read_next_byte)-->read_MB_pred_mvd_l0_done1;
		read_MB_pred_mvd_l0									( read_MB_pred_skip_mvd_l0							) --> read_MB_pred_mvd_l0;
		read_MB_pred_mvd_l0									( MB_pred_init_mvd_l1								) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( read_MB_pred_mvd_l1								) --> read_MB_pred_mvd_l1_done0;
		read_MB_pred_mvd_l1(read_next_byte)-->read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1_done0							( read_MB_pred_mvd_l1_done0							) --> read_MB_pred_mvd_l1_done1;
		read_MB_pred_mvd_l1_done0(read_next_byte)-->read_MB_pred_mvd_l1_done0;
		read_MB_pred_mvd_l1_done1							( read_MB_pred_mvd_l1_done1							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1_done1(read_next_byte)-->read_MB_pred_mvd_l1_done1;
		read_MB_pred_mvd_l1									( read_MB_pred_skip_mvd_l1							) --> read_MB_pred_mvd_l1;
		read_MB_pred_mvd_l1									( MB_pred_done										) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer(read_next_byte)	
		MB_pred												( MB_pred_Inter_direct								) --> read_MB_layer_coded_block_pattern; // --> macrobloc_layer(read_next_byte)

		// residual
		Residual_init										( Residual_init										) --> Residual_luma_DC_init;
		Residual_init(read_next_byte)-->Residual_init;
		Residual_luma_DC_init								( Residual_luma_DC_init								) --> Residual_block; // --> residual_block(read_next_byte)
		Residual_luma_DC_init(read_next_byte)-->Residual_luma_DC_init;
		Residual_return										( Residual_return_luma_DC							) --> Residual_luma_AC_init;
		Residual_return										( Residual_return_luma_DC_CABAC						) --> Residual_luma_AC_init;
		Residual_return(read_next_byte)-->Residual_return;
		Residual_luma_DC_init								( Residual_luma_skip_DC_init						) --> Residual_luma_AC_init;
		Residual_luma_DC_init								( Residual_luma_skip_DC_init_CABAC					) --> Residual_luma_AC_init;
		Residual_luma_DC_init(read_next_byte)-->Residual_luma_DC_init;
		Residual_luma_AC_init								( Residual_luma_AC_init								) --> Residual_luma_AC_CAVLC;
		Residual_luma_AC_init(read_next_byte)-->Residual_luma_AC_init;

		Residual_luma_AC_CAVLC								( Residual_luma_AC_CAVLC							) --> Residual_luma_AC_CodedBlock8x8;
		Residual_luma_AC_CAVLC(read_next_byte)-->Residual_luma_AC_CAVLC;
		Residual_luma_AC_CodedBlock8x8						( Residual_luma_AC_CodedBlock8x8					) --> Residual_block; // --> residual_block(read_next_byte)
		Residual_luma_AC_CodedBlock8x8(read_next_byte)-->Residual_luma_AC_CodedBlock8x8;
		Residual_return										( Residual_return_luma_AC							) --> Residual_luma_inc_AC_4x4;
		Residual_return										( Residual_return_luma_AC_CABAC_15_Coeff			) --> Residual_luma_inc_AC_4x4;
		Residual_return										( Residual_return_luma_AC_CABAC_16_Coeff			) --> Residual_luma_inc_AC_4x4;
		Residual_return(read_next_byte)-->Residual_return;
		
		Residual_luma_AC_CodedBlock8x8						( Residual_luma_skip_AC_CodedBlock8x8				) --> Residual_luma_inc_AC_4x4;
		Residual_luma_AC_CodedBlock8x8						( Residual_luma_skip_AC_CodedBlock8x8_CABAC_16			) --> Residual_luma_inc_AC_4x4;
		Residual_luma_AC_CodedBlock8x8(read_next_byte)-->Residual_luma_AC_CodedBlock8x8;
		Residual_luma_inc_AC_4x4							( Residual_luma_inc_AC_4x4							) --> Residual_luma_AC_CAVLC; 
		Residual_luma_inc_AC_4x4(read_next_byte)-->Residual_luma_inc_AC_4x4;
		Residual_luma_AC_CAVLC								( Residual_luma_skip_AC_CAVLC						) --> Residual_chroma;		
		Residual_luma_AC_CAVLC(read_next_byte)-->Residual_luma_AC_CAVLC;
		Residual_chroma										( Residual_ChromaArrayType_1_2_init					) --> Residual_chroma_DC_init;
		Residual_chroma(read_next_byte)-->Residual_chroma;
		Residual_chroma_DC_init								( Residual_chroma_DC_init							) --> Residual_block; // --> residual_block(read_next_byte)
		Residual_chroma_DC_init(read_next_byte)-->Residual_chroma_DC_init;
		Residual_return										( Residual_return_chroma_DC							) --> Residual_chroma_DC_init;
		Residual_return										( Residual_return_chroma_DC_CABAC_4_Coeff			) --> Residual_chroma_DC_init;
		Residual_return										( Residual_return_chroma_DC_CABAC_8_Coeff			) --> Residual_chroma_DC_init;
		Residual_return(read_next_byte)-->Residual_return;

		Residual_chroma_DC_init								( Residual_skip_chroma_DC_init						) --> Residual_chroma_DC_init;
		Residual_chroma_DC_init								( Residual_skip_chroma_DC_init_CABAC_1				) --> Residual_chroma_DC_init;
		Residual_chroma_DC_init								( Residual_skip_chroma_DC_init_CABAC_2				) --> Residual_chroma_DC_init;
		Residual_chroma_DC_init								( Residual_skip_chroma_DC							) --> Residual_chroma_AC_init;
		Residual_chroma_DC_init(read_next_byte)-->Residual_chroma_DC_init;
		Residual_chroma_AC_init								( Residual_chroma_AC_init							) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_chroma_AC_init(read_next_byte)-->Residual_chroma_AC_init;
		Residual_chroma_AC_CodedBlock4x4					( Residual_chroma_AC_CodedBlock4x4 					) --> Residual_block; // --> residual_block(read_next_byte)
		Residual_chroma_AC_CodedBlock4x4(read_next_byte)-->Residual_chroma_AC_CodedBlock4x4;
		Residual_return										( Residual_return_chroma_AC							) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_return										( Residual_return_chroma_AC_CABAC					) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_chroma_AC_CodedBlock4x4					( Residual_chroma_AC_skip_CodedBlock4x4 			) --> Residual_chroma_AC_CodedBlock4x4;
		Residual_chroma_AC_CodedBlock4x4					( Residual_chroma_AC_skip_CodedBlock4x4_CABAC 		) --> Residual_chroma_AC_CodedBlock4x4;

		Residual_chroma_AC_CodedBlock4x4					( Residual_skip_chroma_AC							) --> SliceD_update; 
		// --> macrobloc_layer / --> Slice_data

		// residual_block CAVLC
		Residual_block										( Residual_block_init_coeff_token					) --> Residual_block_read_suffixLength;
		Residual_block(read_next_byte)-->Residual_block;
		Residual_block_read_suffixLength					( Residual_block_read_suffixLength					) --> Residual_block_read_non_zero_coeff;
		Residual_block_read_suffixLength(read_next_byte)-->Residual_block_read_suffixLength;
		Residual_block_read_non_zero_coeff					( Residual_block_read_trailing_ones_sign_flag		) --> Residual_block_read_trailing_ones_sign_flag_done;
		Residual_block_read_non_zero_coeff(read_next_byte)-->Residual_block_read_non_zero_coeff;
		Residual_block_read_trailing_ones_sign_flag_done	( Residual_block_read_trailing_ones_sign_flag_done  ) --> Residual_block_read_non_zero_coeff;
		Residual_block_read_trailing_ones_sign_flag_done(read_next_byte)-->Residual_block_read_trailing_ones_sign_flag_done;
		Residual_block_read_non_zero_coeff					( Residual_block_read_level_prefix					) --> Residual_block_read_level_prefix_done;
		Residual_block_read_non_zero_coeff(read_next_byte)-->Residual_block_read_non_zero_coeff;
		Residual_block_read_level_prefix_done				( Residual_block_read_level_prefix_done0			) --> Residual_block_read_level_prefix_done;
		Residual_block_read_level_prefix_done				( Residual_block_read_level_prefix_done1			) --> Residual_block_read_level_suffix_done;
		Residual_block_read_level_prefix_done(read_next_byte)-->Residual_block_read_level_prefix_done;
		Residual_block_read_level_suffix_done				( Residual_block_read_level_suffix_done				) --> Residual_block_read_non_zero_coeff;
		Residual_block_read_level_suffix_done(read_next_byte)-->Residual_block_read_level_suffix_done;
		Residual_block_read_non_zero_coeff					( Residual_block_read_TotalCoeff_done				) --> Residual_block_read_total_zeros_done;
		Residual_block_read_non_zero_coeff(read_next_byte)-->Residual_block_read_non_zero_coeff;
		Residual_block_read_total_zeros_done				( Residual_block_read_total_zeros_done				) --> Residual_block_read_run_before;
		Residual_block_read_total_zeros_done(read_next_byte)-->Residual_block_read_total_zeros_done;
		Residual_block_read_run_before						( Residual_block_read_run_before					) --> Residual_block_read_run_before_done;
		Residual_block_read_run_before(read_next_byte)-->Residual_block_read_run_before;
		Residual_block_read_run_before_done					( Residual_block_read_run_before_done				) --> Residual_block_read_run_before;
		Residual_block_read_run_before_done(read_next_byte)-->Residual_block_read_run_before_done;
		Residual_block_read_run_before						( Residual_block_skip_read_run_before				) --> Residual_block_read_run_before;
		Residual_block_read_run_before						( Residual_block_read_run_done						) --> Residual_block_send_run;
		Residual_block_send_run								( Residual_block_send_run							) --> Residual_block_send_run;
		Residual_block_send_run								( Residual_block_send_done							) --> Residual_return;
		Residual_block_send_run(read_next_byte)-->Residual_block_send_run;
		Residual_block_read_suffixLength					( Residual_block_skip_read_suffixLength				) --> Residual_return;
		Residual_block_read_suffixLength(read_next_byte)-->Residual_block_read_suffixLength;

		// residual_block CABAC
		Residual_block										( Residual_block_Cabac_coded_block_flag_start		) --> Residual_Cabac_coded_block_flag_done;
		Residual_block(read_next_byte)-->Residual_block;
		Residual_Cabac_coded_block_flag_done				( Residual_block_Cabac_coded_block_flag_done		) --> Residual_block_Cabac_read_significant_coeff_flag;
		Residual_Cabac_coded_block_flag_done(read_next_byte)-->Residual_Cabac_coded_block_flag_done;

		Residual_block_Cabac_read_significant_coeff_flag	( Residual_block_Cabac_read_significant_coeff_flag	) --> Residual_block_read_significant_coeff_flag_done;
		Residual_block_Cabac_read_significant_coeff_flag	( Residual_Sent_Zeros								) --> Residual_return;
		Residual_block_Cabac_read_significant_coeff_flag	( Residual_block_skip_significant_coeff_flag_while	) --> Residual_block_read_coeff_abs_level_minus1_first;
		Residual_block_Cabac_read_significant_coeff_flag(read_next_byte)-->Residual_block_Cabac_read_significant_coeff_flag;

		Residual_block_read_significant_coeff_flag_done		( Residual_block_read_significant_coeff_flag_done	) --> Residual_block_read_last_significant_coeff_flag;
		Residual_block_read_significant_coeff_flag_done(read_next_byte)-->Residual_block_read_significant_coeff_flag_done;

		Residual_block_read_last_significant_coeff_flag		( Residual_block_read_last_significant_coeff_flag_done ) --> Residual_block_Cabac_read_significant_coeff_flag;
		Residual_block_read_last_significant_coeff_flag		( Residual_block_skip_last_significant_coeff_flag	) --> Residual_block_Cabac_read_significant_coeff_flag;
		Residual_block_read_last_significant_coeff_flag(read_next_byte)-->Residual_block_read_last_significant_coeff_flag;

		Residual_block_read_coeff_abs_level_minus1_first	( Residual_block_read_coeff_abs_level_minus1_done	) --> Residual_block_update_coeffLevel;
		Residual_block_read_coeff_abs_level_minus1_first(read_next_byte)-->Residual_block_read_coeff_abs_level_minus1_first;

		Residual_block_update_coeffLevel					( Residual_block_update_coeffLevel_start			) --> Residual_block_update_coeffLevel_read;
		Residual_block_update_coeffLevel					( Residual_block_update_coeffLevel_done				) --> Residual_return;
		Residual_block_update_coeffLevel					( Residual_block_update_coeffLevel_not_read			) --> Residual_block_update_coeffLevel;
		Residual_block_update_coeffLevel(read_next_byte)-->Residual_block_update_coeffLevel;
		Residual_block_update_coeffLevel_read				( Residual_block_update_coeffLevel_read				) --> Residual_block_update_coeffLevel;
		Residual_block_update_coeffLevel_read(read_next_byte)-->Residual_block_update_coeffLevel_read;
	
	end
	
	priority
		read_Sps_chroma_format_idc > read_Sps_log2_max_frame_num_minus4 ;
		read_SliceH_read_colour_plane_id > read_SliceH_frame_num ;
		read_SliceH_pred_weight_table > read_SliceH_skip_pred_weight_table;
		read_SliceH_difference_of_pic_nums_minus1_done > read_SliceH_long_term_frame_idx_done > skip_read_SliceH_long_term_frame_idx_done > read_SliceH_memory_management_control_operation_done;
		read_SliceH_sp_for_switch_flag_done > read_SliceH_slice_qs_delta_done ;
		read_SliceH_slice_group_change_cycle > read_SliceH_skip_slice_group_change_cycle;
		read_SliceD_mb_field_decoding_flag > read_SliceD_skip_mb_field_decoding_flag;
		read_MB_layer_transform_size_8x8_flag > read_MB_layer_skip_transform_size_8x8_flag;
		read_sub_MB_pred_ref_idx_l0 > read_sub_MB_pred_skip_ref_idx_l0;
		read_sub_MB_pred_ref_idx_l1 > read_sub_MB_pred_skip_ref_idx_l1;
		MB_pred_init_ref_idx_l1 > read_MB_pred_ref_idx_l0 > read_MB_pred_skip_ref_idx_l0;
		MB_pred_init_mvd_l0 > read_MB_pred_ref_idx_l1 > read_MB_pred_skip_ref_idx_l1;
		MB_pred_init_mvd_l1 >  read_MB_pred_mvd_l0 > read_MB_pred_skip_mvd_l0;
		MB_pred_done  > read_MB_pred_mvd_l1 > read_MB_pred_skip_mvd_l1;
		read_SliceD_mb_skip_flag_done > read_SliceD_mb_skip_flag;
		test_zero_byte > generic_done;
		test_one_byte  > generic_done;
		send_data_position_information_is_ipcm>send_data_position_information;
	end

end
