/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
import orcc.Imp_MacroBlockInfo.*;

actor Algo_MvBuffer()
	uint(size=6)  MbType,
	uint(size=4)  SubMbType,

	bool          NewPic,

	uint(size=32) Poc,

	uint(size=13) CurrMbAddr,
	uint(size=7)  PicWidthInMb,

	uint(size=4)  RefIdxL0,
	uint(size=4)  RefIdxL1,
	int (size=16) MvL0,
	int (size=16) MvL1,

	bool          Empty_DPB,
	int(size=32)  DelList,
	uint(size=31) LongTermList,

	int (size=32) RefList1
		==>
		:

	int (size=32) PIC_WIDTH_IN_PX        = 1280; //number of MB per lines
	int (size=32) PIC_HEIGHT_IN_PX       = 720; //number of MB per columns

	int (size=32) SENT_DONE = -2;

	uint(size=3) SZ_16x16 = 0;
	uint(size=3) SZ_16x8  = 1;
	uint(size=3) SZ_8x16  = 2;
	uint(size=3) SZ_8x8   = 3;
	uint(size=3) SZ_8x4   = 4;
	uint(size=3) SZ_4x8   = 5;
	uint(size=3) SZ_4x4   = 6;

	List(type: uint(size=3),size=8) NumMbPart_P =
		[
			1,2,2,4,4,1,1,1
		];

	List(type: uint(size=3),size=32) NumMbPart_B =
		[
			1,1,1,1,2,2,2,2,2,2,
			2,2,2,2,2,2,2,2,2,2,
			2,2,4,1,1,1,1,1,1,1,
			1,1
		];

	List(type: uint(size=3),size=8) SizeMb_P =
		[
			SZ_16x16, SZ_16x8, SZ_8x16, SZ_8x8, SZ_8x8, SZ_16x16, SZ_16x16, SZ_16x16
		];

	List(type: uint(size=3),size=32) SizeMb_B =
		[
			 SZ_8x8, SZ_16x16, SZ_16x16, SZ_16x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16,
			SZ_16x8,  SZ_8x16,  SZ_16x8,  SZ_8x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16,
			SZ_16x8,  SZ_8x16,   SZ_8x8,   SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,
			 SZ_8x8,  SZ_8x8
		];

	List(type: List(type: uint(size=3), size=16), size=2) NumSubMbPart =
		[
			[1/*Change me when B_Direct_8x8 will be supported !! 4*/, 1, 1, 1, 2, 2, 2, 2, 2, 2, 4, 4, 4, 0, 0, 0],
			[1, 2, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		];

	List(type: List(type: uint(size=3), size=16), size=2) SizeSubMb =
		[
			[SZ_4x4, SZ_8x8, SZ_8x8, SZ_8x8, SZ_8x4, SZ_4x8, SZ_8x4, SZ_4x8, SZ_8x4, SZ_4x8,
			 SZ_4x4, SZ_4x4, SZ_4x4, 0, 0, 0],
			[SZ_8x8, SZ_8x4, SZ_4x8, SZ_4x4, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0]
		];

	List(type: List(type: uint(size=3), size=16), size=2) SubMbPartPredMode =
		[
			[DIRECT, PRED_L0, PRED_L1, BIPRED, PRED_L0, PRED_L0, PRED_L1, PRED_L1, BIPRED, BIPRED,
			 PRED_L0, PRED_L1, BIPRED, NA, NA, NA],
			[PRED_L0, PRED_L0, PRED_L0, PRED_L0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0]
		];

	function Is_PredL0(uint(size=6) Mb_Type, uint(size=1) mb_part_idx)
				-->
			bool
		:
			if(Mb_Type >= BLOCK_TYPE_B_MIN and Mb_Type <= BLOCK_TYPE_B_MAX) then
				(MbPartPredMode_B[(Mb_Type - BLOCK_TYPE_B_MIN) & 31][mb_part_idx & 1] & PRED_L0) != 0
			else//if(Mb_Type >= BLOCK_TYPE_P_MIN and Mb_Type <= BLOCK_TYPE_P_MAX)
				if(Mb_Type != BLOCK_TYPE_P_SKIP)then
					(MbPartPredMode_P[(Mb_Type - BLOCK_TYPE_P_MIN) & 7][mb_part_idx & 1] & PRED_L0) != 0
				else
					true
				end
			end
		end


	function Is_PredL1(uint(size=6) Mb_Type, uint(size=1) mb_part_idx)
				-->
			bool
		:
			if(Mb_Type >= BLOCK_TYPE_B_MIN and Mb_Type <= BLOCK_TYPE_B_MAX) then
				(MbPartPredMode_B[(Mb_Type - BLOCK_TYPE_B_MIN) &  31][mb_part_idx & 1] & PRED_L1) != 0
			else//if(Mb_Type >= BLOCK_TYPE_P_MIN and Mb_Type <= BLOCK_TYPE_P_MAX)
				false
			end
		end

	List(type: List(type: List(type: int(size=5), size=PIC_HEIGHT_IN_PX/4), size=PIC_WIDTH_IN_PX/4), size=16) ListRefIdx;
	List(type: List(type: List(type: List(type: int(size=5), size=2), size=PIC_HEIGHT_IN_PX/4), size=PIC_WIDTH_IN_PX/4), size=16) ListMv;
	List(type: bool,          size=16) IsReference;
	List(type: uint(size=32), size=16) ListPoc;

	uint(size=3) MbPartIdxMax;
	uint(size=3) MbPartIdx;
	uint(size=3) SizeMbMv;
	uint(size=3) SubMbPartIdxMax;
	uint(size=3) SubMbPartIdx;
	uint(size=3) SizeSubMbMv;
	uint(size=1) Idx_Sub_Tab;
	uint(size=6) mb_type;
	bool         IsPredL0;
	bool         IsPredL1;
	uint(size=5) Size_RefList;
	uint(size=5) Idx_RefList;
	uint(size=4) WriteListIdx;
	uint(size=4) ReadListIdx;
	bool         CurrL1_IsShortTermRef;

	GetNewPic: action
			NewPic       :[IsNewPic],
			Poc          :[Picture_Order_Count],
			Empty_DPB    :[ValEmpty]//////////////////////////////
				==>
		guard
			IsNewPic
		do
			WriteListIdx := 0;
			while( IsReference[WriteListIdx] and WriteListIdx < 15)
			do
				WriteListIdx := WriteListIdx + 1;
			end
			IsReference[WriteListIdx] := true;
			ListPoc    [WriteListIdx] := Picture_Order_Count;
		end

	GetMbType.MacroBlkIorSI: action
			MbType :[MacroBlkType],
			NewPic  :[IsNewPic]
				==>
		guard
			MacroBlkType >= BLOCK_TYPE_INTRA_MIN and MacroBlkType <= BLOCK_TYPE_INTRA_MAX,
			not IsNewPic
		end

	EatTokens: action
			CurrMbAddr     :[Mb_Addr],
			PicWidthInMb   :[pic_width]
				==>
		var
			uint(size=32) Mbx,
			uint(size=32) Mby
		do
			Mbx := Mb_Addr mod pic_width;
			Mby := Mb_Addr  /  pic_width;
			//There are 16 Parts in a macroblock
			Mbx := Mbx * 4;
			Mby := Mby * 4;
			foreach int i in Mbx .. Mbx + 3
			do
				foreach int j in Mby .. Mby + 3
				do
					ListRefIdx[WriteListIdx][Mbx][Mby]     := -1;
					ListMv    [WriteListIdx][Mbx][Mby][0]  :=  0;
					ListMv    [WriteListIdx][Mbx][Mby][1]  :=  0;
				end
			end
		end

	GetMbType.Others: action
			MbType       :[MacroBlkType],
			NewPic       :[IsNewPic],
			CurrMbAddr   :[Curr_Mb_Addr],
			PicWidthInMb :[PicWidth]
				==>
		guard
			not(MacroBlkType >= BLOCK_TYPE_INTRA_MIN and MacroBlkType <= BLOCK_TYPE_INTRA_MAX),
			not IsNewPic
		do
			mb_type      := MacroBlkType;
			MbPartIdx    := 0;
			MbPartIdxMax :=
				if(MacroBlkType >= BLOCK_TYPE_B_MIN and MacroBlkType <= BLOCK_TYPE_B_MAX) then
					NumMbPart_B[(MacroBlkType - BLOCK_TYPE_B_MIN) & 31]
				else
					if(MacroBlkType != BLOCK_TYPE_P_SKIP)then
						NumMbPart_P[(MacroBlkType - BLOCK_TYPE_P_MIN) &  7]
					else
						1
					end
				end;
			SizeMbMv     :=
				if(MacroBlkType >= BLOCK_TYPE_B_MIN and MacroBlkType <= BLOCK_TYPE_B_MAX) then
					SizeMb_B[(MacroBlkType - BLOCK_TYPE_B_MIN) & 31]
				else
					if(MacroBlkType != BLOCK_TYPE_P_SKIP)then
						SizeMb_P[(MacroBlkType - BLOCK_TYPE_P_MIN) &  7]
					else
						SZ_16x16
					end
				end;
			Idx_Sub_Tab  :=
				if(MacroBlkType >= BLOCK_TYPE_B_MIN and MacroBlkType <= BLOCK_TYPE_B_MAX) then
					0
				else
					1
				end;
		end

	GetMbParameters.Block16x16: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_16x16
		do
			IsPredL0  := Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Block16x8: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_16x8
		do
			IsPredL0  := Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	GetMbParameters.Block8x16: action
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_8x16
		do
			IsPredL0  := Is_PredL0(mb_type, MbPartIdx);
			IsPredL1  := Is_PredL1(mb_type, MbPartIdx);
			MbPartIdx := MbPartIdx + 1;
		end

	LaunchGetSubMbParameters: action
			SubMbType :[ValSubMbType]
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv  = SZ_8x8
		do
			SubMbPartIdx    :=  0;
			SubMbPartIdxMax :=  NumSubMbPart[Idx_Sub_Tab][ValSubMbType & 15];
			SizeSubMbMv     :=  SizeSubMb[Idx_Sub_Tab][ValSubMbType & 15];
			IsPredL0        := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L0) != 0;
			IsPredL1        := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L1) != 0;
		end

	GetMbParametersFinished: action ==>
		guard
			MbPartIdx = MbPartIdxMax
		end

	GetSubMbParameters.Launch8x8: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_8x8
		do
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch8x4: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_8x4
		do
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch4x8: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_4x8
		do
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParameters.Launch4x4: action
				==>
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			SizeSubMbMv  = SZ_4x4
		do
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMbParametersFinished: action ==>
		guard
			SubMbPartIdx = SubMbPartIdxMax
		do
			MbPartIdx := MbPartIdx + 1;
		end

	GetBlockInfo.IsPredL0: action
			MvL0     :[Mvx,Mvy],
			RefIdxL0 :[ref_idx]
				==>
		guard
			    IsPredL0,
			not IsPredL1
		end

	GetBlockInfo.IsPredL1: action
			MvL1     :[Mvx,Mvy],
			RefIdxL1 :[ref_idx]
				==>
		guard
			not IsPredL0,
			    IsPredL1
		do
		end

	GetBlockInfo.BiPred: action
			MvL0     :[MvxL0,MvyL0],
			RefIdxL0 :[ref_idx_l0],
			MvL1     :[MvxL1,MvyL1],
			RefIdxL1 :[ref_idx_l1]
				==>
		guard
			IsPredL0,
			IsPredL1
		do
		end

	GetBlockInfo.IsDirect: action
				==>
		guard
			not IsPredL0,
			not IsPredL1
		do
			println("In MvBuffer GetBlockInfo.IsDirect");
			while true do end
		end


	ReadDelList.Launch: action
			DelList:[DelVal]
				==>
		guard
			DelVal != SENT_DONE
		do
			foreach int i in 0 .. 15
			do
				if(DelVal = ListPoc[i])then
					IsReference[i] := false;
				end
			end
		end


	ReadDelList.Done: action
			DelList:[DelVal]
				==>
		guard
			DelVal = SENT_DONE
		end

	ReadSizeRefList: action
			RefList1 :[SizeRefList]
				==>
		do
			Size_RefList := SizeRefList;
			Idx_RefList  := 0;
		end

	ReadRefList.Launch: action
			RefList1 :[ValRefList]
				==>
		guard
			Idx_RefList < Size_RefList
		do
/*			if(Idx_RefList   = 0)then
				ReadListIdx := 0;
				while(ListPoc[ReadListIdx] != ValRefList and ReadListIdx < 15)
				do
					ReadListIdx := ReadListIdx + 1;
				end
			end
*/			Idx_RefList := Idx_RefList + 1;
		end

	ReadRefList.Done: action ==>
		guard
			Idx_RefList >= Size_RefList
		end

	ReadLTList: action
			LongTermList :[LTList] repeat 16
				==>
		do
			CurrL1_IsShortTermRef := false;
			foreach int i in 0 .. 15
			do
				if(LTList[i] = ListPoc[ReadListIdx])then
					CurrL1_IsShortTermRef := true;
				end
			end
		end

	schedule fsm GetNewPic:
		GetNewPic          (GetNewPic                  )--> ReadSizeRefList;

		ReadSizeRefList    (ReadSizeRefList            )--> ReadRefList;

		ReadRefList        (ReadRefList.Launch         )--> ReadRefList;
		ReadRefList        (ReadRefList.Done           )--> ReadLTList;

		ReadLTList         (ReadLTList                 )--> GetMbType;

		GetMbType          (GetNewPic                  )--> ReadDelList;
		GetMbType          (GetMbType.MacroBlkIorSI    )--> EatTokens;
		GetMbType          (GetMbType.Others           )--> GetMbParameters;

		EatTokens          (EatTokens                  )--> GetMbType;

		GetMbParameters    (GetMbParameters            )--> GetBlockInfo4Mb;
		GetMbParameters    (LaunchGetSubMbParameters   )--> GetSubMbParameters;
		GetMbParameters    (GetMbParametersFinished    )--> GetMbType;

		GetBlockInfo4Mb    (GetBlockInfo               )--> GetMbParameters;

		GetSubMbParameters (GetSubMbParameters         )--> GetBlockInfo4SubMb;
		GetSubMbParameters (GetSubMbParametersFinished )--> GetMbParameters;

		GetBlockInfo4SubMb (GetBlockInfo               )--> GetSubMbParameters;

		ReadDelList        (ReadDelList.Launch         )--> ReadDelList;
		ReadDelList        (ReadDelList.Done           )--> ReadSizeRefList;
	end
end
