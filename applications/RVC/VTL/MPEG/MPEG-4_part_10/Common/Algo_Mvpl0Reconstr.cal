/********************************************************************************

This software module was originally developed by 
Damien de Saint Jorre (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/
actor Algo_Mvpl0Reconstr()
	uint(size=6)  mb_type,
	uint(size=4)  sub_mb_type,
	uint(size=4)  slice_type,

	uint(size=13) CurrMbAddr,
	uint(size=13) FirstMbInSlice,
	uint(size=7)  PicWidthInMb,

	uint(size=4)  MbPredRefIdx,
	uint(size=4)  SubMbPredRefIdx,	

	int (size=16) Mv
		==>
	int (size=16) Mvpl0
		:

	uint(size=2) NA = 0;
	uint(size=2) PRED_L0 = 1;
	uint(size=2) PRED_L1 = 2;
	uint(size=2) BIPRED  = 3;
	uint(size=2) DIRECT  = 4;

	uint(size=4) SLICE_TYPE_P  = 0;
	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;

	uint(size=6) BLOCK_TYPE_INTRA_MIN = 0;
	uint(size=6) BLOCK_TYPE_INTRA_MAX = 25;
	uint(size=6) BLOCK_TYPE_P_MIN     = 26;
	uint(size=6) P_L0_16x16           = 26;
	uint(size=6) BLOCK_TYPE_B_MIN     = 31;
	uint(size=6) BLOCK_TYPE_B_MAX     = 53;
	uint(size=6) BLOCK_TYPE_P_SKIP    = 54;

	int           SZ_TAB      = 128;
	int           MASK_TAB    = 127;
	uint(size=32) LOG2_SZ_TAB = 7;

	uint(size=3) SZ_16x16 = 0;
	uint(size=3) SZ_16x8  = 1;
	uint(size=3) SZ_8x16  = 2;
	uint(size=3) SZ_8x8   = 3;
	uint(size=3) SZ_8x4   = 4;
	uint(size=3) SZ_4x8   = 5;
	uint(size=3) SZ_4x4   = 6;


	List(type: List(type: uint(size=3),size=2),size=8) MbPartPredMode_P =
		[
			[PRED_L0,NA],[PRED_L0,PRED_L0],[PRED_L0,PRED_L0],[NA,NA],[NA,NA],[PRED_L0,NA],[NA,NA],[NA,NA]
		];

	List(type: List(type: uint(size=3),size=2),size=32) MbPartPredMode_B =
		[
			[DIRECT,NA], [PRED_L0,NA], [PRED_L1,NA], [BIPRED,NA], [PRED_L0,PRED_L0], [PRED_L0,PRED_L0], [PRED_L1,PRED_L1], [PRED_L1,PRED_L1], [PRED_L0,PRED_L1], [PRED_L0,PRED_L1],
			[PRED_L1,PRED_L0], [PRED_L1,PRED_L0], [PRED_L0,BIPRED], [PRED_L0,BIPRED], [PRED_L1,BIPRED], [PRED_L1,BIPRED], [BIPRED,PRED_L0], [BIPRED,PRED_L0], [BIPRED,PRED_L1], [BIPRED,PRED_L1],
			[BIPRED,BIPRED], [BIPRED,BIPRED], [NA,NA], [DIRECT,NA], [NA,NA], [NA,NA], [NA,NA], [NA,NA], [NA,NA], [NA,NA],
			[NA,NA], [NA,NA]
		];

	List(type: List(type: uint(size=3), size=16), size=2) SubMbPartPredMode =
		[
			[DIRECT, PRED_L0, PRED_L1, BIPRED, PRED_L0, PRED_L0, PRED_L1, PRED_L1, BIPRED, BIPRED,
			 PRED_L0, PRED_L1, BIPRED, NA, NA, NA],
			[PRED_L0, PRED_L0, PRED_L0, PRED_L0, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0]
		];

	List(type: uint(size=3),size=8) SizeMb_P =
		[
			SZ_16x16, SZ_16x8, SZ_8x16, SZ_8x8, SZ_8x8, SZ_16x16, SZ_16x16, SZ_16x16
		];

	List(type: uint(size=3),size=32) SizeMb_B =
		[
			 SZ_8x8, SZ_16x16, SZ_16x16, SZ_16x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16,
			SZ_16x8,  SZ_8x16,  SZ_16x8,  SZ_8x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16, SZ_16x8, SZ_8x16,
			SZ_16x8,  SZ_8x16,   SZ_8x8,   SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,  SZ_8x8,
			 SZ_8x8,  SZ_8x8
		];

	List(type: List(type: uint(size=3), size=16), size=2) SizeSubMb =
		[
			[SZ_4x4, SZ_8x8, SZ_8x8, SZ_8x8, SZ_8x4, SZ_4x8, SZ_8x4, SZ_4x8, SZ_8x4, SZ_4x8,
			 SZ_4x4, SZ_4x4, SZ_4x4, 0, 0, 0],
			[SZ_8x8, SZ_8x4, SZ_4x8, SZ_4x4, 0, 0, 0, 0, 0, 0,
			 0, 0, 0, 0, 0, 0]
		];

	List(type: uint(size=3),size=8) NumMbPart_P =
		[
			1,2,2,4,4,1,1,1
		];

	List(type: uint(size=3),size=32) NumMbPart_B =
		[
			1,1,1,1,2,2,2,2,2,2,
			2,2,2,2,2,2,2,2,2,2,
			2,2,4,1,1,1,1,1,1,1,
			1,1
		];	

	List(type: List(type: uint(size=3), size=16), size=2) NumSubMbPart =
		[
			[4, 1, 1, 1, 2, 2, 2, 2, 2, 2, 4, 4, 4, 0, 0, 0],
			[1, 2, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		];

	//Size of MvTab must be >= PicWidthInMb + 1 and must be equal to pow(2,n) for masking bits easily.
	List(type: List(type: List(type: int(size=16),size=2), size=16),size= SZ_TAB) MvTab;
	List(type: List(type: uint(size=4), size=16),size= SZ_TAB) RefIdxTab;

	uint(size=3) MbPartIdxMax;
	uint(size=3) MbPartIdx;
	uint(size=3) SubMbPartIdxMax;
	uint(size=3) SubMbPartIdx;
	uint(size=3) SizeMbMv;
	uint(size=6) MbType;
	uint(size=LOG2_SZ_TAB) Idx;
	uint(size=1) Idx_Sub_Tab;
	bool IsPred4SubMb;
	uint(size=3) SizeSubMbMv;
	List(type: uint(size=4), size=4)  SubMbType;
	int (size=LOG2_SZ_TAB+1) Idx_mbAddrA;
	int (size=LOG2_SZ_TAB+1) Idx_mbAddrB;
	int (size=LOG2_SZ_TAB+1) Idx_mbAddrC;
	int (size=LOG2_SZ_TAB+1) Idx_mbAddrD;

	function Is_PredL0(uint(size=6) Mb_Type, uint(size=1) mb_part_idx)
				-->
			bool
		:
			if(Mb_Type >= BLOCK_TYPE_B_MIN and Mb_Type <= BLOCK_TYPE_B_MAX) then
				(MbPartPredMode_B[(Mb_Type - BLOCK_TYPE_B_MIN) &  7][mb_part_idx & 1] & PRED_L0) != 0
			else//if(Mb_Type >= BLOCK_TYPE_P_MIN and Mb_Type <= BLOCK_TYPE_P_MAX)
				(MbPartPredMode_P[(Mb_Type - BLOCK_TYPE_P_MIN) & 31][mb_part_idx & 1] & PRED_L0) != 0
			end
		end

	function median(int a, int b, int c)
				-->
			int
		:
			if(   b<=a and a<=c
			   or c<=a and a<=b )then
				a
			else
				if(   a<=b and b<=c
				   or c<=b and b<=a )then
					b
				else
					c
				end
			end
		end	

		List(type: int (size=16),size=2) IMvA;
		List(type: int (size=16),size=2) IMvB;
		List(type: int (size=16),size=2) IMvC;	
		List(type: int (size=16),size=2) OMv;
	procedure ComputeMvPredL0(int(size=5) RefIdxCurr, int(size=5) Ref_Idx_A, int(size=5) Ref_Idx_B, int(size=5) Ref_Idx_C)
		begin
			OMv :=
				if(Ref_Idx_B = -1 and Ref_Idx_C = -1)then
					[IMvA[0],IMvA[1]]
				else
					if(   RefIdxCurr  = Ref_Idx_A and RefIdxCurr != Ref_Idx_B and RefIdxCurr != Ref_Idx_C
					   or RefIdxCurr != Ref_Idx_A and RefIdxCurr  = Ref_Idx_B and RefIdxCurr != Ref_Idx_C
					   or RefIdxCurr != Ref_Idx_A and RefIdxCurr != Ref_Idx_B and RefIdxCurr  = Ref_Idx_C	)then
						if(RefIdxCurr = Ref_Idx_A)then
							[IMvA[0],IMvA[1]]
						else
							if(RefIdxCurr = Ref_Idx_B)then
								[IMvB[0],IMvB[1]]
							else
								[IMvC[0],IMvC[1]]
							end
						end
					else
						[ median(IMvA[0],IMvB[0],IMvC[0]),
						  median(IMvA[1],IMvB[1],IMvC[1]) ]
					end
				end;
		end

	GetMbType.MacroBlkIorSI: action
			mb_type    :[MacroBlkType],
			slice_type :[SlcTyp]
				==>
		guard
			MacroBlkType >= BLOCK_TYPE_INTRA_MIN and MacroBlkType <= BLOCK_TYPE_INTRA_MAX
		end

	GetMbType.P_Skip: action
			mb_type    :[MacroBlkType],
			slice_type :[SlcTyp]
				==>
		guard
			SlcTyp = SLICE_TYPE_P or SlcTyp = SLICE_TYPE_SP,
			MacroBlkType = BLOCK_TYPE_P_SKIP
		do
			MbPartIdx    := 0;
			MbPartIdxMax := 1;
			SizeMbMv     := SZ_16x16;
			MbType       := P_L0_16x16;
		end

	GetMbType.Others: action
			mb_type    :[MacroBlkType],
			slice_type :[SlcTyp]
				==>
		do
			Idx_Sub_Tab   :=
				if(SlcTyp = SLICE_TYPE_B) then
					0
				else
					1
				end;
			MbType        := MacroBlkType;
			MbPartIdx     := 0;
			MbPartIdxMax  :=
				if(SlcTyp = SLICE_TYPE_B) then
					NumMbPart_B[(MacroBlkType - BLOCK_TYPE_B_MIN) & 31]	
				else
					NumMbPart_P[(MacroBlkType - BLOCK_TYPE_P_MIN) &  7]
				end;	
			SizeMbMv  :=
				if(SlcTyp = SLICE_TYPE_B) then
					SizeMb_B[(MacroBlkType - BLOCK_TYPE_B_MIN) & 31]	
				else
					SizeMb_P[(MacroBlkType - BLOCK_TYPE_P_MIN) &  7]
				end;
		end

	EatTokens: action
			CurrMbAddr     :[Curr_Mb_Addr],
			FirstMbInSlice :[b],
			PicWidthInMb   :[c]
				==>
		do
			Idx := Curr_Mb_Addr & MASK_TAB;
			RefIdxTab[Idx] := [-1: for int i in 0 .. 15];
			MvTab[Idx]     := [[0,0]: for int i in 0 .. 15];	
		end

	GetMbInfos.P_Skip: action
			CurrMbAddr     :[Curr_Mb_Addr],
			FirstMbInSlice :[Fst_Mb],
			PicWidthInMb   :[pic_width_in_mb]
				==>
			Mvpl0 :[MvpL0] repeat 2
		var
			uint(size=LOG2_SZ_TAB) Idx_mbAddrA = (Curr_Mb_Addr - 1) & MASK_TAB,
			uint(size=LOG2_SZ_TAB) Idx_mbAddrB = (Curr_Mb_Addr - pic_width_in_mb) & MASK_TAB,
			uint(size=LOG2_SZ_TAB) Idx_mbAddrC,

			int (size=5)           RefIdxA,
			int (size=5)           RefIdxB,
			int (size=5)           RefIdxC,

			List(type: int(size=16), size=2)  MvpL0
		do
			Idx         :=  Curr_Mb_Addr      & MASK_TAB;
			RefIdxTab[Idx] := [0: for int i in 0 .. 15];
			//if mbAddrB is not available
			if( (Curr_Mb_Addr - Fst_Mb) < pic_width_in_mb) then
				MvpL0 := [0,0];
			else
				//if mbAddrA is not available	
				if( (Curr_Mb_Addr mod pic_width_in_mb) = 0) then
					MvpL0 := [0,0];
				else
					//if refIdxL0A is equal to 0 and both components of mvL0A are equal to 0
					if(RefIdxTab[Idx_mbAddrA][5] = 0 and MvTab[Idx_mbAddrA][5][0] = 0 and MvTab[Idx_mbAddrA][5][1] = 0) then
						MvpL0 := [0,0];
					else
						//if refIdxL0B is equal to 0 and both components of mvL0B are equal to 0	
						if(RefIdxTab[Idx_mbAddrB][10] = 0 and MvTab[Idx_mbAddrB][10][0] = 0 and MvTab[Idx_mbAddrB][10][1] = 0) then
							MvpL0 := [0,0];	
						else
					
							if( (Curr_Mb_Addr + 1) >= pic_width_in_mb + Fst_Mb)then
								if((Curr_Mb_Addr - pic_width_in_mb + 1) mod pic_width_in_mb != 0)then
									Idx_mbAddrC := (Curr_Mb_Addr - pic_width_in_mb + 1) & MASK_TAB;
									IMvC        := [MvTab [Idx_mbAddrC][10][0],MvTab [Idx_mbAddrC][10][1]];
									RefIdxC     := RefIdxTab[Idx_mbAddrC][10];
								else
									Idx_mbAddrC := -1;
									if((Curr_Mb_Addr >= (pic_width_in_mb + 1)) and Curr_Mb_Addr  >=  (pic_width_in_mb + 1 +Fst_Mb))then
										Idx_mbAddrD := (Curr_Mb_Addr - pic_width_in_mb - 1) & MASK_TAB;
										IMvC        := [MvTab [Idx_mbAddrD][15][0],MvTab [Idx_mbAddrD][15][1]];
										RefIdxC     := RefIdxTab[Idx_mbAddrA][15];
									else
										IMvC    := [0,0];
										RefIdxC := -1;
									end
								end
							else
								IMvC    := [0,0];
								RefIdxC := -1;
							end
							RefIdxA := RefIdxTab[Idx_mbAddrA][5];
							IMvA := [MvTab[Idx_mbAddrA][5][0] , MvTab [Idx_mbAddrA][5][1]];
							RefIdxB := RefIdxTab[Idx_mbAddrB][10];	
							IMvB     := [MvTab[Idx_mbAddrB][10][0],MvTab[Idx_mbAddrB][10][1]];
							ComputeMvPredL0(0,RefIdxA,RefIdxB,RefIdxC);
							MvpL0 := [OMv[0],OMv[1]];
						end
					end
				end
			end
			foreach int i in 0 .. 15
			do
				MvTab[Idx][i][0] := MvpL0[0];
				MvTab[Idx][i][1] := MvpL0[1];
			end
		end

	GetMbInfos.Others: action
			CurrMbAddr     :[Curr_Mb_Addr],
			FirstMbInSlice :[Fst_Mb],
			PicWidthInMb   :[pic_width_in_mb]	
				==>
		do
			Idx := Curr_Mb_Addr & MASK_TAB;
			MvTab[Idx] := [[0,0]: for int i in 0 .. 15];

			if( (Curr_Mb_Addr mod pic_width_in_mb) = 0) then
				Idx_mbAddrA := -1;
			else
				Idx_mbAddrA := (Curr_Mb_Addr - 1) & MASK_TAB;
			end

			if( (Curr_Mb_Addr - Fst_Mb) < pic_width_in_mb) then
				Idx_mbAddrB := -1;
			else
				Idx_mbAddrB := (Curr_Mb_Addr - pic_width_in_mb) & MASK_TAB;
			end

			if( (Curr_Mb_Addr + 1) >= pic_width_in_mb + Fst_Mb)then
				if((Curr_Mb_Addr - pic_width_in_mb + 1) mod pic_width_in_mb != 0)then
					Idx_mbAddrC := (Curr_Mb_Addr - pic_width_in_mb + 1) & MASK_TAB;
				else
					Idx_mbAddrC := -1;
					if((Curr_Mb_Addr >= (pic_width_in_mb + 1)) and Curr_Mb_Addr  >=  (pic_width_in_mb + 1 +Fst_Mb))then
						Idx_mbAddrD := (Curr_Mb_Addr - pic_width_in_mb - 1) & MASK_TAB;
					else
						Idx_mbAddrD := -1;
					end
				end
			else
				Idx_mbAddrC := -1;
				Idx_mbAddrD := -1;
			end
		end

	ComputeMvpL0.Launch16x16: action
			MbPredRefIdx :[RefIdxCurr]
				==>
			Mvpl0 :[MvpL0] repeat 2
		guard
			MbPartIdx < MbPartIdxMax,
			Is_PredL0(MbType, MbPartIdx),
			SizeMbMv = SZ_16x16
		var
			List(type: int(size=16), size=2) MvpL0,
			int (size=5) RefIdxA,
			int (size=5) RefIdxB,
			int (size=5) RefIdxC
		do
			foreach int i in 0 .. 15
			do
				RefIdxTab[Idx][i] := RefIdxCurr;
			end

			if( Idx_mbAddrA = -1) then
				RefIdxA := -1;
				IMvA    := [0,0];
			else
				RefIdxA := RefIdxTab[Idx_mbAddrA][5];
				IMvA[0] := MvTab [Idx_mbAddrA][5][0];
				IMvA[1] := MvTab [Idx_mbAddrA][5][1];
			end
			if( Idx_mbAddrB = -1 ) then
				RefIdxB := -1;
				IMvB     := [0,0];
			else
				RefIdxB := RefIdxTab[Idx_mbAddrB][10];	
				IMvB     := [MvTab[Idx_mbAddrB][10][0],MvTab[Idx_mbAddrB][10][1]];	
			end
			if(Idx_mbAddrC != -1)then
				IMvC     := [MvTab [Idx_mbAddrC][10][0],MvTab [Idx_mbAddrC][10][1]];
				RefIdxC  := RefIdxTab[Idx_mbAddrC][10];
			else
				if(Idx_mbAddrD != -1)then
					IMvC     := [MvTab [Idx_mbAddrD][15][0],MvTab [Idx_mbAddrD][15][1]];
					RefIdxC := RefIdxTab[Idx_mbAddrA][15];	
				else
					IMvC :=[0,0];
					RefIdxC := -1;
				end
			end
			ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
			MvpL0 := [OMv[0],OMv[1]];
		end

	ComputeMvpL0.Launch16x8: action
			MbPredRefIdx :[RefIdxCurr]
				==>
			Mvpl0 :[MvpL0] repeat 2
		guard
			MbPartIdx < MbPartIdxMax,
			Is_PredL0(MbType, MbPartIdx),
			SizeMbMv = SZ_16x8
		var
			List(type: int(size=16), size=2) MvpL0,
			int (size=5) RefIdxA,
			int (size=5) RefIdxB,
			int (size=5) RefIdxC
		do
			foreach int i in 0 .. 7
			do
				RefIdxTab[Idx][i + 8 * (MbPartIdx&1)] := RefIdxCurr;
			end

			if(MbPartIdx = 0)then
				if( Idx_mbAddrA = -1) then
					RefIdxA := -1;
					IMvA    := [0,0];
				else
					RefIdxA := RefIdxTab[Idx_mbAddrA][5];
					IMvA[0] := MvTab [Idx_mbAddrA][5][0];
					IMvA[1] := MvTab [Idx_mbAddrA][5][1];
				end
				if( Idx_mbAddrB = -1 ) then
					RefIdxB := -1;
					IMvB     := [0,0];
				else
					RefIdxB := RefIdxTab[Idx_mbAddrB][10];	
					IMvB    := [MvTab[Idx_mbAddrB][10][0],MvTab[Idx_mbAddrB][10][1]];	
				end
				if(Idx_mbAddrC != -1)then
					IMvC     := [MvTab [Idx_mbAddrC][10][0],MvTab [Idx_mbAddrC][10][1]];
					RefIdxC := RefIdxTab[Idx_mbAddrC][10];
				else
					if(Idx_mbAddrD != -1)then
						IMvC     := [MvTab [Idx_mbAddrD][15][0],MvTab [Idx_mbAddrD][15][1]];
						RefIdxC := RefIdxTab[Idx_mbAddrD][15];	
					else
						IMvC :=[0,0];
						RefIdxC := -1;
					end
				end
				if(RefIdxCurr = RefIdxB)then
					MvpL0 := [IMvB[0],IMvB[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];	
				end
			else
				if( Idx_mbAddrA = -1) then
					RefIdxA := -1;	
					RefIdxC := -1;
					IMvA    := [0,0];
					IMvC    := [0,0];
				else
					RefIdxA := RefIdxTab[Idx_mbAddrA][13];
					IMvA    := [ MvTab[Idx_mbAddrA][13][0] , MvTab[Idx_mbAddrA][13][1] ];
					RefIdxC := RefIdxTab[Idx_mbAddrA][7];
					IMvC    := [ MvTab[Idx_mbAddrA][7][0] , MvTab[Idx_mbAddrA][7][1] ];
				end
				RefIdxB := RefIdxTab[Idx][2];
				IMvB    := [ MvTab[Idx][2][0] , MvTab[Idx][2][1] ];
				if(RefIdxCurr = RefIdxA)then
					MvpL0 := [IMvA[0],IMvA[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];
				end
			end
		end

	ComputeMvpL0.Launch8x16: action
			MbPredRefIdx :[RefIdxCurr]
				==>
			Mvpl0 :[MvpL0] repeat 2
		guard
			MbPartIdx < MbPartIdxMax,
			Is_PredL0(MbType, MbPartIdx),
			SizeMbMv = SZ_8x16
		var
			List(type: int(size=16), size=2) MvpL0,
			int (size=5) RefIdxA,
			int (size=5) RefIdxB,
			int (size=5) RefIdxC
		do
			foreach int i in 0 .. 3
			do
				RefIdxTab[Idx][i + 4 * (MbPartIdx&1)] := RefIdxCurr;
			end
			foreach int i in 8 .. 11
			do
				RefIdxTab[Idx][i + 4 * (MbPartIdx&1)] := RefIdxCurr;
			end

			if(MbPartIdx = 0)then
				if( Idx_mbAddrA = -1) then
					RefIdxA := -1;
					IMvA    := [0,0];
				else
					RefIdxA := RefIdxTab[Idx_mbAddrA][5];
					IMvA    := [MvTab[Idx_mbAddrA][5][0] , MvTab[Idx_mbAddrA][5][1]];
				end
				if( Idx_mbAddrB = -1 ) then
					RefIdxB := -1;
					IMvB    := [0,0];
					if( Idx_mbAddrD = -1 )then
						RefIdxC := -1;
						IMvC    := [0,0];	
					else
						RefIdxC := RefIdxTab[Idx_mbAddrD][15];
						IMvC    := [MvTab[Idx_mbAddrD][15][0],MvTab[Idx_mbAddrD][15][1]];	
					end
				else
					RefIdxB := RefIdxTab[Idx_mbAddrB][10];
					IMvB    := [MvTab[Idx_mbAddrB][10][0],MvTab[Idx_mbAddrB][10][1]];
					RefIdxC := RefIdxTab[Idx_mbAddrB][14];
					IMvC    := [MvTab[Idx_mbAddrB][14][0],MvTab[Idx_mbAddrB][14][1]];
				end

				if(RefIdxCurr = RefIdxA)then
					MvpL0 := [IMvA[0],IMvA[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];
				end
			else
				RefIdxA := RefIdxTab[Idx][1];
				IMvA    := [ MvTab[Idx][1][0] , MvTab[Idx][1][1] ];	
				if( Idx_mbAddrB = -1) then
					RefIdxB := -1;
					IMvB    := [0,0];
					RefIdxC := -1;
					IMvC    := [0,0];
				else
					RefIdxB := RefIdxTab[Idx_mbAddrB][14];
					IMvB    := [MvTab[Idx_mbAddrB][14][0],MvTab[Idx_mbAddrB][14][1]];
					RefIdxC := RefIdxTab[Idx_mbAddrB][11];
					IMvC    := [MvTab[Idx_mbAddrB][11][0],MvTab[Idx_mbAddrB][11][1]];
				end
				if( Idx_mbAddrC != -1 ) then
					RefIdxC := RefIdxTab[Idx_mbAddrC][10];
					IMvC    := [MvTab[Idx_mbAddrC][10][0],MvTab[Idx_mbAddrC][10][1]];
				end

				if(RefIdxCurr = RefIdxC)then
					MvpL0 := [IMvC[0],IMvC[1]];
				else
					ComputeMvPredL0(RefIdxCurr,RefIdxA,RefIdxB,RefIdxC);
					MvpL0 := [OMv[0],OMv[1]];
				end
			end
		end

	ComputeMvpL0.Launch8x8: action
			sub_mb_type :[ValSubMbType]
				==>
		guard
			MbPartIdx < MbPartIdxMax,
			SizeMbMv = SZ_8x8
		do
		/*	if(RefIdxB = -1 and RefIdxC = -1)then
				foreach int i in 0 .. 3
				do
					RefIdxTab[Idx][(MbPartIdx & 3) *4 + i] := RefIdxCurr;
				end
				MvpL0 := ListMvA[0];
			else
			end	*/
			println("bouh");
			SubMbPartIdx    := 0;
			SubMbPartIdxMax := NumSubMbPart[Idx_Sub_Tab][ValSubMbType & 15];
			IsPred4SubMb    := (SubMbPartPredMode[Idx_Sub_Tab][ValSubMbType & 15] & PRED_L0) != 0;
			SizeSubMbMv     := SizeSubMb[Idx_Sub_Tab][ValSubMbType & 15];
			SubMbType[MbPartIdx & 3] := ValSubMbType;
		end

	ComputeMvpL0.Skip: action
				==>
			Mvpl0 :[0,0]
		guard
			MbPartIdx < MbPartIdxMax,
			not Is_PredL0(MbType, MbPartIdx),
			SizeMbMv != SZ_8x8
		do
			MbPartIdx := MbPartIdx + 1;
		end

	GetMv.Skip: action
		Mv:[Mvx, Mvy]
				==>
		end

	ComputeMvpL0.Done: action ==>
		guard
			MbPartIdx = MbPartIdxMax
		end

	ComputeSubMvpL0.Launch8x8: action
			SubMbPredRefIdx :[RefIdxCurr]
				==>
Mvpl0 :[42,42]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_8x8
		var
			List(type: int(size=16), size=2) MvpL0
		end

	ComputeSubMvpL0.Launch8x4: action
			SubMbPredRefIdx :[RefIdxCurr]
				==>
Mvpl0 :[42,42]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_8x4
		var
			List(type: int(size=16), size=2) MvpL0
		end

	ComputeSubMvpL0.Launch4x8: action
			SubMbPredRefIdx :[RefIdxCurr]
				==>
Mvpl0 :[42,42]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_4x8
		var
			List(type: int(size=16), size=2) MvpL0
		end

	ComputeSubMvpL0.Launch4x4: action
			SubMbPredRefIdx :[RefIdxCurr]
				==>
Mvpl0 :[42,42]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			IsPred4SubMb,
			SizeSubMbMv = SZ_4x4
		var
			List(type: int(size=16), size=2) MvpL0
		end

	ComputeSubMvpL0.Skip: action
				==>
Mvpl0 :[0,0]
		guard
			SubMbPartIdx < SubMbPartIdxMax,
			not IsPred4SubMb
		end

	ComputeSubMvpL0.Done: action ==>
		guard
			SubMbPartIdx = SubMbPartIdxMax
		do
			MbPartIdx := MbPartIdx + 1;
		end

///////////////////////////////////////////////////////////////////


	GetMv.Launch16x8: action
		Mv:[Mvx, Mvy]
				==>
		do
			foreach int i in 0 .. 7
			do
				MvTab[Idx][i+(8*(MbPartIdx & 1))] := [Mvx,Mvy];
			end
			MbPartIdx := MbPartIdx + 1;
		end

	GetMv.Launch8x16: action
		Mv:[Mvx, Mvy]
				==>
		do
			foreach int i in 0 .. 3
			do
				MvTab[Idx][i+(4*(MbPartIdx & 1))] := [Mvx,Mvy];
			end
			foreach int i in 8 .. 11
			do
				MvTab[Idx][i+(4*(MbPartIdx & 1))] := [Mvx,Mvy];
			end
			MbPartIdx := MbPartIdx + 1;
		end

	GetMv.Launch16x16: action
		Mv:[Mvx, Mvy]
				==>
		do
			foreach int i in 0 .. 15
			do
				MvTab[Idx][i] := [Mvx,Mvy];
			end
			MbPartIdx := MbPartIdx + 1;
		end


	GetSubMv.Launch8x8: action
		Mv:[Mvx, Mvy]
				==>
		do
			foreach int i in 0 .. 3
			do
				MvTab[Idx][i + 4*(MbPartIdx&3)] := [Mvx,Mvy];
			end
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMv.Launch8x4: action
		Mv:[Mvx, Mvy]
				==>
		do
			MvTab[Idx][4*(MbPartIdx&3) + 2*(SubMbPartIdx&1)]     := [Mvx,Mvy];
			MvTab[Idx][4*(MbPartIdx&3) + 2*(SubMbPartIdx&1) + 1] := [Mvx,Mvy];
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMv.Launch4x8: action
		Mv:[Mvx, Mvy]
				==>
		do
			MvTab[Idx][4*(MbPartIdx&3) + (SubMbPartIdx&1)]     := [Mvx,Mvy];
			MvTab[Idx][4*(MbPartIdx&3) + (SubMbPartIdx&1) + 2] := [Mvx,Mvy];
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMv.Launch4x4: action
		Mv:[Mvx, Mvy]
				==>
		do
			MvTab[Idx][4*(MbPartIdx&3) + (SubMbPartIdx&3)]     := [Mvx,Mvy];
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	GetSubMv.Skip: action
		Mv:[Mvx, Mvy]
				==>
		do
			SubMbPartIdx := SubMbPartIdx + 1;
		end

	schedule fsm GetMbType:
		GetMbType         (GetMbType.MacroBlkIorSI  )--> EatTokens;
		GetMbType         (GetMbType.P_Skip         )--> GetMbInfos4P_Skip;
		GetMbType         (GetMbType.Others         )--> GetMbInfos4Others;

		EatTokens         (EatTokens                )--> GetMbType;

		GetMbInfos4P_Skip (GetMbInfos.P_Skip        )--> GetMvSkip;

		GetMbInfos4Others (GetMbInfos.Others        )--> ComputeMvpL0;

		ComputeMvpL0      (ComputeMvpL0.Launch16x8  )--> GetMv16x8;
		ComputeMvpL0      (ComputeMvpL0.Launch8x16  )--> GetMv8x16;
		ComputeMvpL0      (ComputeMvpL0.Launch8x8   )--> ComputeSubMvpL0;
		ComputeMvpL0      (ComputeMvpL0.Launch16x16 )--> GetMv16x16;
		ComputeMvpL0      (ComputeMvpL0.Skip        )--> GetMvSkip;
		ComputeMvpL0      (ComputeMvpL0.Done        )--> GetMbType;

		ComputeSubMvpL0      (ComputeSubMvpL0.Launch8x8 )--> GetSubMv8x8;
		ComputeSubMvpL0      (ComputeSubMvpL0.Launch8x4 )--> GetSubMv8x4;
		ComputeSubMvpL0      (ComputeSubMvpL0.Launch4x8 )--> GetSubMv4x8;
		ComputeSubMvpL0      (ComputeSubMvpL0.Launch4x4 )--> GetSubMv4x4;
		ComputeSubMvpL0      (ComputeSubMvpL0.Skip      )--> GetSubMvSkip;
		ComputeSubMvpL0      (ComputeSubMvpL0.Done      )--> ComputeMvpL0;

		GetMv16x8      (GetMv.Launch16x8  )--> ComputeMvpL0;
		GetMv8x16      (GetMv.Launch8x16  )--> ComputeMvpL0;
		GetMv16x16      (GetMv.Launch16x16 )--> ComputeMvpL0;
		GetMvSkip      (GetMv.Skip        )--> ComputeMvpL0;

		GetSubMv8x8      (GetSubMv.Launch8x8  )--> ComputeSubMvpL0;
		GetSubMv8x4      (GetSubMv.Launch8x4  )--> ComputeSubMvpL0;
		GetSubMv4x8      (GetSubMv.Launch4x8   )--> ComputeSubMvpL0;
		GetSubMv4x4      (GetSubMv.Launch4x4 )--> ComputeSubMvpL0;
		GetSubMvSkip      (GetSubMv.Skip        )--> ComputeSubMvpL0;

		GetMvSkip (GetMv.Skip )--> GetMbType;

	end

	priority
		GetMbType.MacroBlkIorSI > GetMbType.Others;
		GetMbType.P_Skip        > GetMbType.Others;
	end
end