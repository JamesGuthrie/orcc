/********************************************************************************

This software module was originally developed by 
Florian Decologne (IETR/INSA of Rennes), 
in the course of development of the ISO/IEC 23002-4 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-4.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-4 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards. 

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-4 once the ISO/IEC 23002-4 has been adopted; and 
(2) to develop the ISO/IEC 23002-4: 

IETR/INSA of Rennes grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-4 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-4 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-4.  To the extent that IETR/INSA of Rennes
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-4 in a conforming product, IETR/INSA of
Rennes will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-4

IETR/INSA of Rennes retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2008.
*****************************************************************************/

//Modified by Mederic Blestel and Endri Bezati IETR/INSA of Rennes
//Modified by Mickael Raulet IETR/INSA of Rennes
//Modified by Damien de Saint Jorre IETR/INSA of Rennes

//Delete IdxNotFound
actor Algo_MMCO () 
	uint(size=31) MMCO,
	uint(size=31) FraNum,
	uint(size=31) MaxFrameNum,
	uint(size=5)  NumReferenceFrame,
	uint(size=32) POC
		==>
	int (size=32) DelList,
	uint(size=31) LongTermList,
	uint(size=31) ShortTermList,
	uint(size=4)  SzShortTermList,
	bool          IsIDR
		:


/*
*
* Constant
*
*/

	int (size=32) SENT_DONE = -2;


/*
*
* Global variables
*
*/

	List(type:uint(size=31), size=16) STList              := [  0    : for int s in Integers(0,15)];
	List(type:bool         , size=16) ShortTermFalseFrame := [ false : for int s in Integers(0,15)];
	List(type:int (size=32), size=16) LTList              := [ -1    : for int s in Integers(0,15)];
	List(type:uint(size=31), size=16) DelListTab          := [  0    : for int s in Integers(0,15)];

	List(type:int (size=32), size=32) FrameNumList        := [ -1    : for int s in Integers(0,31)];
	List(type:int (size=32), size=32) PocList             := [  0    : for int s in Integers(0,31)];

	int (size=6)  NbFrameDel       := 0;
	uint(size=31) FrameNum         := 0;
	uint(size=32) ValCurrPoc       := 0;
	uint(size=31) LastFrameNum     := 0;
	uint(size=31) ValMaxFrameNum   := 0;
	uint(size=5)  NumRefFrame      := 0;
	uint(size=5)  ShortTermCount   := 0;
	uint(size=5)  LongTermCount    := 0;
	uint(size=5)  NbShortTermSent  := 0;
	uint(size=5)  NbLongTermSent   := 0;
	uint(size=1)  FlagLongTerm     := 0;
	uint(size=4)  LongTermFrameIdx := 0;
	uint(size=6)  IdxPocList       := 0;
	bool          ValIsIDR         := false;
	int (size=32) ValDelPoc        := 0;




	bool IdxNotFound;

/*
*
* Actions
*
*/


	//Get the Frame Num and others informations about the current picture
	read_num_ref_frames: action
			NumReferenceFrame :[ValNumRefFrame],
			FraNum            :[ValFrame_Num],
			MaxFrameNum       :[MaxFrNu],
			POC               :[PicOrderCnt]
				==>
		do
			NumRefFrame     := ValNumRefFrame;
			ValMaxFrameNum  := MaxFrNu;
			LastFrameNum    := FrameNum;
			FrameNum        := ValFrame_Num;
			NbFrameDel      := 0;
			NbShortTermSent := 0;
			ValCurrPoc      := PicOrderCnt;
			if(ValFrame_Num = 0 and PicOrderCnt = 0) then
				ValIsIDR := true;
				foreach int j in Integers(0,31)
				do
					FrameNumList[j] := -1;
				end
			else
				ValIsIDR := false;
			end
//println("\tMMCO FrNu:"+ValFrame_Num+" MaxFrameNum:"+MaxFrNu);
		end


	//If the new frame num isn't following the previous frame num,
	//we must fill the short term list with all the missed frame num
	FillFalseRefFrame.launch : action 
				==>
			SzShortTermList :[ShortTermCount]
		var
			uint(size=31) false_frame_num := (LastFrameNum + 1) mod ValMaxFrameNum
		do
				while(false_frame_num != FrameNum)
				do
					if(LongTermCount + ShortTermCount = NumRefFrame) then
						if(NbFrameDel  >  15) then
							NbFrameDel := 15;
						end
						if (ShortTermFalseFrame[ShortTermCount - 1] = false) then
							DelListTab[NbFrameDel] := STList[ShortTermCount - 1];
							NbFrameDel             := NbFrameDel + 1;
						end
						ShortTermCount := ShortTermCount - 1;
					end
					foreach int i in Integers(0,ShortTermCount - 1)
					do
						STList             [ShortTermCount - i] := STList             [ShortTermCount - i - 1];
						ShortTermFalseFrame[ShortTermCount - i] := ShortTermFalseFrame[ShortTermCount - i - 1];
					end
					STList[0]              := false_frame_num;
					ShortTermFalseFrame[0] := true;
					ShortTermCount         := ShortTermCount + 1;
					false_frame_num        := (false_frame_num + 1) mod ValMaxFrameNum;
				end
		end


	FillFalseRefFrame.done : action
				==>
			SzShortTermList :[ShortTermCount]
		guard
			(FrameNum = (LastFrameNum + 1) mod ValMaxFrameNum) or (FrameNum = LastFrameNum)
		end


	SendLongTermList.launch: action
				==>
			LongTermList :[ValLongTermList]
		guard
			NbLongTermSent < 16
		var
			uint(size=31) ValLongTermList
		do
			ValLongTermList := LTList[NbLongTermSent];
			NbLongTermSent  := NbLongTermSent + 1;
//	if(ValLongTermList!= -1)then
//println("\tMMCO LTList:"+ValLongTermList);
//	end
		end


	SendShortTermList.launch: action
				==>
			ShortTermList :[ValShortTermList]
		guard
			NbShortTermSent < ShortTermCount
		var
			uint(size=31) ValShortTermList
		do
			ValShortTermList := STList[NbShortTermSent];
			NbShortTermSent  := NbShortTermSent + 1;
//println("\tMMCO STList:"+ValShortTermList);
		end

	
	SendLongTermList.done: action ==>
		do
			NbLongTermSent  := 0;
		end


	read_IDR: action
			MMCO :[NotIdr , is_long_term]
				==>
		guard 
			NotIdr = 0
		do
			FlagLongTerm     := is_long_term;
			LongTermFrameIdx := 0;
			ShortTermCount   := 0;
			LongTermCount    := 0;
			LTList           := [-1 :for int s in Integers(0,15)];
			NbFrameDel       := 0;
//println("\tMMCO IDR Pict");
		end


	read_not_IDR_not_MMCO: action
			MMCO :[NotIdr , adaptive_ref_pic_marking_mode_flag]
				==>
		guard
			(NotIdr = 1) and (adaptive_ref_pic_marking_mode_flag = 0)
		do
			FlagLongTerm := 0;
//println("\tMMCO Not IDR and Not MMCO");
		end


	read_not_IDR_MMCO: action
			MMCO :[NotIdr , adaptive_ref_pic_marking_mode_flag]
				==>
		guard 
			(NotIdr = 1) and (adaptive_ref_pic_marking_mode_flag = 1)
		do
			FlagLongTerm := 0;
//println("\tMMCO MMCO on");
		end


	MMCO_opcode_IsEqualTo0: action
			MMCO :[opcode]
				==>
		guard 
			opcode = 0
		do
//println("\tMMCO MMCO finished");
		end


	// Mark a short term reference picture as "unused for reference "
	MMCO_opcode.IsEqualTo1: action
			MMCO :[opcode, difference_of_pic_nums_minus1]
				==>
		guard 
			opcode = 1
		var 
			int(size=5)  idx := -1,
			int(size=32) FrameNumST
		do
			FrameNumST := FrameNum - difference_of_pic_nums_minus1 - 1;
			if(FrameNumST < 0) then
				FrameNumST := FrameNumST + ValMaxFrameNum;
			end
			foreach int i in Integers( 0, ShortTermCount - 1 )
			do
				if (STList[i] = FrameNumST) then 
					idx := i;
				end
			end
//println("\tMMCO Del:"+FrameNumST);
			if(idx != -1) then
				if (ShortTermFalseFrame[idx] = false) then
					DelListTab[NbFrameDel] := FrameNumST;
					NbFrameDel             := NbFrameDel + 1;
				end
				foreach int i in Integers(idx, ShortTermCount - 2)
				do
					STList[i]              := STList[i+1];
					ShortTermFalseFrame[i] := ShortTermFalseFrame[i+1];
				end
				ShortTermCount         := ShortTermCount - 1;
			end
		end


	// Mark a long term reference picture as "unused for reference "
	MMCO_opcode.IsEqualTo2: action
			MMCO:[opcode, IdxLTFrame ]
				==>
		guard 
			opcode = 2
		do
			if(LTList[IdxLTFrame]  != -1) then
//println("\tMMCO Del:"+LTList[IdxLTFrame]);
				DelListTab[NbFrameDel] := LTList[IdxLTFrame];
				NbFrameDel             := NbFrameDel + 1;
				LTList[IdxLTFrame]     := -1;
				LongTermCount          := LongTermCount - 1;
			end
		end


	// Mark a short term reference picture as long term
	MMCO_opcode.IsEqualTo3: action
			MMCO:[opcode, difference_of_pic_nums_minus1, IdxLTFrame]
				==>
		guard 
			opcode = 3
		var
			int(size=5) idx := -1,
			int(size=32)FrameNumST
		do
			FrameNumST := FrameNum - difference_of_pic_nums_minus1 - 1; 
			if(FrameNumST < 0) then
				FrameNumST := FrameNumST + ValMaxFrameNum;
			end
			foreach int i in Integers(0, ShortTermCount-1)
			do
				if (STList[i] = FrameNumST) then
					idx := i;
				end
			end
			if(idx != -1) then
				foreach int i in Integers(idx, ShortTermCount - 2)
				do
						STList[i]              := STList[i + 1];
						ShortTermFalseFrame[i] := ShortTermFalseFrame[i + 1];
				end
				ShortTermCount := ShortTermCount - 1;
				
				if (LTList[IdxLTFrame] = -1) then
					LongTermCount := LongTermCount + 1;
				else
					DelListTab[NbFrameDel] := LTList[IdxLTFrame];
					NbFrameDel             := NbFrameDel + 1;
				end
				LTList[IdxLTFrame] := FrameNumST;
			end
		end


	// Specify the maximum long term frame index
	MMCO_opcode.IsEqualTo4: action
			MMCO:[opcode, long_term_max_idx]
				==>
		guard 
			opcode = 4
		do
			foreach int i in Integers(long_term_max_idx, 15)
			do
				if (LTList[i] != -1) then
//println("\tMMCO Del:"+LTList[i]);
					DelListTab[NbFrameDel] := LTList[i];
					NbFrameDel             := NbFrameDel + 1;
					LTList[i]              := -1;
					LongTermCount          := LongTermCount - 1;
				end
			end
		end


	// Mark all reference picture as "unused for reference "
	MMCO_opcode.IsEqualTo5: action
			MMCO:[opcode]
				==>
		guard 
			opcode = 5
		do
			FrameNum        := 0;
			ShortTermCount  := 0;
			STList          := [-1 :for int s in Integers(0,16-1)];
			LongTermCount   := 0;
			LTList          := [-1 :for int s in Integers(0,16-1)];
			NbFrameDel      := 0;
			ValIsIDR        := true;
			foreach int j in Integers(0,31)
			do
				FrameNumList[j] := -1;
			end
		end


	// Mark the current picture as long term reference picture
	MMCO_opcode.IsEqualTo6: action
			MMCO:[opcode, IdxLTFrame]
				==>
		guard 
			opcode = 6
		do
			LongTermFrameIdx := IdxLTFrame;
			FlagLongTerm     := 1;
		end


	AddFrame.InSTList: action
				==>
			IsIDR         :[ValIsIDR]
		guard
			FlagLongTerm = 0
		var
			uint(size=4) j := 0
		do
			foreach int i in Integers(0,ShortTermCount -1)
			do
				if(STList[i] != FrameNum)then
					STList[j] := STList[i];
					j := j + 1;
				else
					ShortTermCount := ShortTermCount - 1;
				end
			end
			foreach int i in Integers(0,LongTermCount - 1)
			do
				if(LTList[i] = FrameNum)then
					LTList[i]     := -1;
					LongTermCount := LongTermCount - 1;
				end
			end
			DelListTab[NbFrameDel] := FrameNum;
			NbFrameDel             := NbFrameDel + 1;

			if (LongTermCount + ShortTermCount = NumRefFrame) then
				ShortTermCount := ShortTermCount - 1;
				if(ShortTermFalseFrame[ShortTermCount] = false) then
					DelListTab[NbFrameDel] := STList[ShortTermCount];
					NbFrameDel             := NbFrameDel + 1;
				end
			end
			foreach int i in Integers (0, ShortTermCount - 1)
			do
				STList             [ShortTermCount - i] := STList             [ShortTermCount - i - 1];
				ShortTermFalseFrame[ShortTermCount - i] := ShortTermFalseFrame[ShortTermCount - i - 1];
			end
			STList[0]              := FrameNum;
			ShortTermFalseFrame[0] := false;
			ShortTermCount         := ShortTermCount +1;
			IdxPocList             := 0;
//println("\tMMCO IsIDR:"+ValIsIDR);
		end


	AddFrame.InLTList: action
				==>
			IsIDR         :[ValIsIDR]
		var
			uint(size=4) j := 0
		do
			foreach int i in Integers(0,ShortTermCount -1)
			do
				if(STList[i] != FrameNum)then
					STList[j] := STList[i];
					j := j + 1;
				else
					ShortTermCount := ShortTermCount - 1;
				end
			end
			foreach int i in Integers(0,LongTermCount - 1)
			do
				if(LTList[i] = FrameNum)then
					LTList[i]     := -1;
					LongTermCount := LongTermCount - 1;
				end
			end
			DelListTab[NbFrameDel] := FrameNum;
			NbFrameDel             := NbFrameDel + 1;

			if (LTList[LongTermFrameIdx] != -1) then
				DelListTab[NbFrameDel] := LTList[LongTermFrameIdx];
				NbFrameDel             := NbFrameDel + 1;
			else 
				LongTermCount          := LongTermCount +1;
			end
			LTList[LongTermFrameIdx]   := FrameNum;

			if (LongTermCount + ShortTermCount > NumRefFrame) then
				ShortTermCount := ShortTermCount - 1;
				if(ShortTermFalseFrame[ShortTermCount] = false) then
					DelListTab[NbFrameDel] := STList[ShortTermCount];
					NbFrameDel             := NbFrameDel + 1;
				end
			end
			IdxPocList             := 0;
//println("\tMMCO IsIDR:"+ValIsIDR);
		end


	GetNextPocToDel: action ==>
		var
			bool IdxNotFound2
		do
			//It will be modified when the front-end will be fixed !!!!!!
			IdxNotFound := true;
			foreach int i in Integers(0,NbFrameDel-1)
			do
				IdxNotFound2 := IdxNotFound;
				if(IdxNotFound)
				then
					foreach int j in Integers(0,31)
					do
						if(FrameNumList[j]   = DelListTab[i] and (PocList[j] != ValCurrPoc))then
							FrameNumList[j] := -1;
							ValDelPoc       := PocList[j];
							IdxNotFound2    := false;
						end
					end
				end
				IdxNotFound := IdxNotFound2;
			end
			if(IdxNotFound = true)then
				NbFrameDel := 0;
			end
		end

	//Send the DelList
	SendDelList.PocValue : action
				==>
			DelList:[ValDelPoc]
		guard
			NbFrameDel > 0
		end

	//Sent of the DelList is completed
	SendDelList.done : action
				==>
			DelList :[SENT_DONE]
		var
			bool IdxNotFound2
		do
			IdxNotFound := true;
/*			while(IdxNotFound)
			do
				IdxNotFound2 := IdxNotFound;
				if(FrameNumList[ValIdx] = -1 or ValIdx = 31) then
					PocList[ValIdx]      := PicOrderCnt;
					FrameNumList[ValIdx] := ValFrame_Num;
					IdxNotFound2         := false;
				end
				IdxNotFound := IdxNotFound2;
				ValIdx := ValIdx + 1;
			end
*/
			foreach int i in Integers(0,31)
			do
				IdxNotFound2 := IdxNotFound;
				if((FrameNumList[i] = -1 or i = 31) and (IdxNotFound)) then
					PocList[i]      := ValCurrPoc;
					FrameNumList[i] := FrameNum;
					IdxNotFound2    := false;
				end
				IdxNotFound := IdxNotFound2;
			end
		end

/*
*
* Scheduler
*
*/
	schedule fsm  read_num_ref_frames:
		read_num_ref_frames (read_num_ref_frames      )--> FillFalseRefFrame;

		FillFalseRefFrame   (FillFalseRefFrame        )--> SendLongTermList;

		SendLongTermList    (SendLongTermList.launch  )--> SendLongTermList;
		SendLongTermList    (SendShortTermList.launch )--> SendLongTermList;
		SendLongTermList    (SendLongTermList.done    )--> check_IDR;

		/* Get values about memory_management_control_operation */
		check_IDR           (read_IDR                 )--> AddFrameInList;
		check_IDR           (read_not_IDR_not_MMCO    )--> AddFrameInList;
		check_IDR           (read_not_IDR_MMCO        )--> MMCO_opcode;
		MMCO_opcode         (MMCO_opcode              )--> MMCO_opcode;
		MMCO_opcode         (MMCO_opcode_IsEqualTo0   )--> AddFrameInList;

		AddFrameInList      (AddFrame                 )--> GetNextPocToDel;

		GetNextPocToDel     (GetNextPocToDel          )--> SendDelLists;

		SendDelLists        (SendDelList.PocValue     )--> GetNextPocToDel;
		SendDelLists        (SendDelList.done         )--> read_num_ref_frames;
	end

	priority
		SendDelList.PocValue    > SendDelList.done;
		SendLongTermList.launch > SendShortTermList.launch  > SendLongTermList.done;
		FillFalseRefFrame.done  > FillFalseRefFrame.launch;
		AddFrame.InSTList       > AddFrame.InLTList;
	end

end
