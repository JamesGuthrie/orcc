/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_DecodeResidual()
	bool          EntropyCodingMode,
	uint(size=4)  SliceType,
	uint(size=6)  MbType,
	bool          TransfSz8x8,
	uint(size=6)  CodBlkPatnLm,
	uint(size=2)  ChromaArrayType,
	uint(size=2)  Num_C8x8,

	bool         BmFlag,
	uint(size=4) StartIdx,
	uint(size=4) EndIdx,
	uint(size=5) NATab,
	uint(size=5) NBTab,
	bool         LeftMbExists,
	bool         AboveMbExists,

	uint(size=5) Total_Coeff
		==>
	bool         SkipNal,
	uint(size=4) LaunchActor,

	int (size=8) ResBlknC,
	uint(size=5) ResBlkMaxNumCoeff,
	uint(size=5) ResBlkStartIdx,
	uint(size=5) ResBlkEndIdx
		:

	bool         CAVLC_ENTROPY = false;
//	bool         CABAC_ENTROPY = true;

	uint(size=4) RESIDUAL_BLOCK_CAVLC = 8;
	uint(size=4) RESIDUAL_BLOCK_CABAC = 9;

//	uint(size=4) SLICE_TYPE_P  = 0;
//	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
//	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;


//	uint(size=6) BLOCK_TYPE_I_8x8_or_4x4   = 0;
	uint(size=6) BLOCK_TYPE_INTA_16x16_MIN = 1;
	uint(size=6) BLOCK_TYPE_INTA_16x16_MAX = 24;
//	uint(size=6) BLOCK_TYPE_I_PCM          = 25;

	uint(size=2) Y_COMPONENT = 0;


	bool          bmFlag;
	int (size=5)  startIdx;
	uint(size=4)  endIdx;
	uint(size=4)  StartIdxSent;
	uint(size=4)  EndIdxSent;
	uint(size=2)  chroma_array_type;
	uint(size=2)  NumC8x8;	

	bool          entropy_coding_mode_flag;
	uint(size=4)  slice_type;
	uint(size=6)  mb_type;
	bool          transform_size_8x8_flag;
	uint(size=6)  CodedBlockPatternLuma;
	uint(size=4)  ActorSelected;
	List(type: uint(size=5), size = 24 ) TotalCoeffTab;
	List(type: bool        , size = 24 ) MbExists := [true : for int s in 0 .. 23];
	List(type: uint(size=5), size = 16 ) IdxLeftNeighbour  = [16, 0,17, 2, 1, 4, 3, 6,18, 8,19,10, 9,12,11,14];
	List(type: uint(size=5), size = 16 ) IdxAboveNeighbour = [20,21, 0, 1,22,23, 4, 5, 2, 3, 6, 7, 8, 9,12,13];
	uint(size=4) IdxCurrMb := 0;
	uint(size=3) i8x8Loop;
	uint(size=2) Component_type := 0;
	uint(size=5) maxNumCoeff;

	GetParameters: action
			EntropyCodingMode :[TypeOfEntropy],
			BmFlag            :[ValBmFlag],
			StartIdx          :[ValStartIdx],
			EndIdx            :[ValEndIdx],
			SliceType         :[ValSliceType],
			MbType            :[ValMbType],
			TransfSz8x8       :[ValTransfSz8x8],
			CodBlkPatnLm      :[ValCodBlkPatnLm],
			NATab             :[ValNATab] repeat 4,
			NBTab             :[ValNBTab] repeat 4,
			LeftMbExists      :[ValLeftMbExists],
			AboveMbExists     :[ValAboveMbExists],
			ChromaArrayType   :[ValChromaArrayType],
			Num_C8x8          :[ValNum_C8x8]
				==>
		do
			bmFlag                   := ValBmFlag;
			entropy_coding_mode_flag := TypeOfEntropy;
			startIdx                 := ValStartIdx;
			endIdx                   := ValEndIdx;
			slice_type               := ValSliceType;
			mb_type                  := ValMbType;
			transform_size_8x8_flag  := ValTransfSz8x8;
			CodedBlockPatternLuma    := ValCodBlkPatnLm;
			chroma_array_type        := ValChromaArrayType;
			NumC8x8                  := ValNum_C8x8;

			ActorSelected :=
				if(entropy_coding_mode_flag = CAVLC_ENTROPY)then
					RESIDUAL_BLOCK_CAVLC
				else
					RESIDUAL_BLOCK_CABAC
				end;
			foreach int i in 0 .. 3
			do
				TotalCoeffTab[16+i] := ValNATab[i];
				MbExists     [16+i] := ValLeftMbExists;
				TotalCoeffTab[20+i] := ValNBTab[i];
				MbExists     [20+i] := ValAboveMbExists;
			end
			
			i8x8Loop      := 0;
			IdxCurrMb     := 0;
			println("GetParameters");
		end

	ResLuma_Launch16x16DCResBlock: action
				==>
			LaunchActor :[ActorSelected],
			SkipNal     :[    false    ]
		guard
			bmFlag   = false,
			startIdx = 0,
			(slice_type = SLICE_TYPE_I) or (slice_type = SLICE_TYPE_SI),
			mb_type <= BLOCK_TYPE_INTA_16x16_MAX,
			mb_type >= BLOCK_TYPE_INTA_16x16_MIN
		do
			println("ResLuma_Launch16x16DCResBlock");
			Component_type := Y_COMPONENT;
			maxNumCoeff    := 16;
			StartIdxSent   :=  0;
			EndIdxSent     :=  15;
		end

	ResLuma_CheckTransfSzAndCavlc: action ==>
		guard
			   transform_size_8x8_flag  = false
			or entropy_coding_mode_flag = CAVLC_ENTROPY
		do
			println("ResLuma_CheckTransfSzAndCavlc");
			IdxCurrMb      := 0;
		end

	ResLuma_CheckCodedBlockPattern: action ==>
		guard
			bitand(CodedBlockPatternLuma,1) = 1
		do
			println("ResLuma_CheckCodedBlockPattern");
		end

	ResLuma_CheckBmFlagAndEndIdxAndMbType: action
				==>
			LaunchActor :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ],
			SkipNal     :[     false     ,     false     ,     false     ,     false     ]
		guard
			not bmFlag,
			endIdx > 0,
			(slice_type = SLICE_TYPE_I) or (slice_type = SLICE_TYPE_SI),
			mb_type <= BLOCK_TYPE_INTA_16x16_MAX,
			mb_type >= BLOCK_TYPE_INTA_16x16_MIN
		do
			println("ResLuma_CheckBmFlagAndEndIdxAndMbType");
			Component_type := Y_COMPONENT;
			maxNumCoeff    := 15;
			StartIdxSent   :=
				if(0 > startIdx - 1) then
					0
				else
					startIdx - 1
				end;
			EndIdxSent     :=  endIdx - 1;
		end

	ResLuma_LaunchResBlk_1: action
				==>
			LaunchActor :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ],
			SkipNal     :[     false     ,     false     ,     false     ,     false     ]
		do
			println("ResLuma_LaunchResBlk_1");
			Component_type := Y_COMPONENT;
			maxNumCoeff    := 16;
			StartIdxSent   := startIdx;
			EndIdxSent     := endIdx;
		end

	ResLuma_CheckBmFlagAndMbType: action ==>
		guard
			bmFlag = false,
			(slice_type = SLICE_TYPE_I) or (slice_type = SLICE_TYPE_SI),
			mb_type <= BLOCK_TYPE_INTA_16x16_MAX,
			mb_type >= BLOCK_TYPE_INTA_16x16_MIN
		do
			println("ResLuma_CheckBmFlagAndMbType");
			/*
			foreach int i4x4 in 0 .. 3
			do
				foreach int i in 0 .. 14
				do
					i16x16ACLevel[i8x8Loop*4 + i4x4][i] := 0:
				end
			end
			*/
		end

	ResetLevelTab: action ==>
		do
			println("ResetLevelTab");
			/*
			foreach int i4x4 in 0 .. 3
			do
				foreach int i in 0 .. 15
				do
					level[i8x8Loop*4 + i4x4][i] := 0:
				end
			end
			*/
		end

	EndLoop8x8.IsEqualToFalse: action ==>
		guard
			i8x8Loop < 4
		do
			println("EndLoop8x8");
			i8x8Loop := i8x8Loop + 1;
			CodedBlockPatternLuma := rshift(CodedBlockPatternLuma, 1);
		end

	ResLuma_CheckCavlc8x8: action ==>
		guard
			entropy_coding_mode_flag = CAVLC_ENTROPY,
			transform_size_8x8_flag  = true
		do
			println("ResLuma_CheckCavlc8x8");
			/*
			foreach int i8x8 in 0 .. 3
			do
				foreach int i4x4 in 0 .. 3
				do
					foreach int i in 0 .. 15
					do
						level8x8[ i8x8 ][ 4 * i + i4x4 ] = level[ i8x8 * 4 + i4x4 ][ i ]
					end
				end
			end
			*/
		end




	/*Not implemented yet: CABAC
	else
		for(i8x8=0;i8x8<4;i8x8++)
		{
			if(CodeBlockPatternLuma & (1<<i8x8)) // ==> action CheckCodedBlockPattern
				residual_block(...);
			else
				for(i=0;i<64;i++)
					level8x8[i8x8][i]=0;
		}
*/

	SendEndResidual: action
				==>
			SkipNal :[true]
		do
			println("SendEndResidual");
		end

	SendResBlockParameters: action
				==>
			ResBlknC          :[nC],
			ResBlkMaxNumCoeff :[maxNumCoeff],
			ResBlkStartIdx    :[StartIdxSent],
			ResBlkEndIdx      :[EndIdxSent]
		var
			int(size=8) nC
		do
			println("SendResBlockParameters");
			if(Component_type = Y_COMPONENT)then
				println("\t\t Idx : "+IdxCurrMb+ " ; IdxLeftNeighbour : "+IdxLeftNeighbour[IdxCurrMb] + ","+IdxAboveNeighbour[IdxCurrMb]+"TotalCoeffTab 1 and 2:"+TotalCoeffTab[IdxLeftNeighbour[IdxCurrMb]]+ " ; "+TotalCoeffTab[IdxAboveNeighbour[IdxCurrMb]]);
				nC :=
					if(MbExists[IdxLeftNeighbour[IdxCurrMb]] and MbExists[IdxAboveNeighbour[IdxCurrMb]])then
						rshift(TotalCoeffTab[IdxLeftNeighbour[IdxCurrMb]] + TotalCoeffTab[IdxAboveNeighbour[IdxCurrMb]] +1, 1)
					else
						TotalCoeffTab[IdxLeftNeighbour[IdxCurrMb]] + TotalCoeffTab[IdxAboveNeighbour[IdxCurrMb]]
					end;
				IdxCurrMb := IdxCurrMb + 1;
			else
				println("Component_type != Y_COMPONENT not implemented yet !!! ");
				while true do end
			end
		end

	GetTotalCoeff: action
			Total_Coeff:[ValTotal_Coeff]
				==>
		do
			TotalCoeffTab[IdxCurrMb - 1] := ValTotal_Coeff;
			println("GetTotalCoeff");
		end

	ChromaArrayTypeVal.IsEqualTo1or2: action
				==>
		guard
			   chroma_array_type = 1
			or chroma_array_type= 2
		end

	a:action ==>
	do
		println("DecodeResidual not finished yet !");
	end

	schedule fsm GetParameters:
		GetParameters (GetParameters )--> ResLumaCheckIntra16x16;

			/* residual_luma()*/
			ResLumaCheckIntra16x16       (ResLuma_Launch16x16DCResBlock         )--> ResLumaSendResBlkPar1;
			ResLumaCheckIntra16x16       (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
			ResLumaCheckIntra16x16 (a)--> undefined;//Cabac stuff not implemented yet

			ResLumaSendResBlkPar1        (SendResBlockParameters                )--> ResLumaGetTotalCoeff1;

			ResLumaGetTotalCoeff1        ( GetTotalCoeff                        )--> ResLumaCheckTrnsSzAndEntropy;

			ResLumaCheckTrnsSzAndEntropy (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
			ResLumaCheckTrnsSzAndEntropy (a)--> undefined;//Cabac stuff not implemented yet

			CheckCodeBlockBmFlag         (ResLuma_CheckCodedBlockPattern        )--> CheckBmFlagEndIx;
			CheckCodeBlockBmFlag         (ResLuma_CheckBmFlagAndMbType          )--> CheckEndLoop8x8;
			CheckCodeBlockBmFlag         (ResetLevelTab                         )--> CheckEndLoop8x8;

			CheckBmFlagEndIx             (ResLuma_CheckBmFlagAndEndIdxAndMbType )--> ResLumaSendResBlkPar2_0;
			CheckBmFlagEndIx             (ResLuma_LaunchResBlk_1                )--> ResLumaSendResBlkPar2_0;

			ResLumaSendResBlkPar2_0      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_0;

			ResLumaGetTotalCoeff2_0      (GetTotalCoeff                         )--> ResLumaSendResBlkPar2_1;

			ResLumaSendResBlkPar2_1      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_1;

			ResLumaGetTotalCoeff2_1      (GetTotalCoeff                         )--> ResLumaSendResBlkPar2_2;

			ResLumaSendResBlkPar2_2      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_2;

			ResLumaGetTotalCoeff2_2      (GetTotalCoeff                         )--> ResLumaSendResBlkPar2_3;

			ResLumaSendResBlkPar2_3      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_3;

			ResLumaGetTotalCoeff2_3      (GetTotalCoeff                         )--> CheckEndLoop8x8;

			CheckEndLoop8x8              (EndLoop8x8.IsEqualToFalse             )--> CheckCodeBlockBmFlag;
			CheckEndLoop8x8              (ResLuma_CheckCavlc8x8 )--> a;
			CheckEndLoop8x8 (a )--> undefined;

		SendEndResidual(SendEndResidual )-->GetParameters;
	a(a)-->undefined;
	end
	priority
		ResLuma_Launch16x16DCResBlock  > ResLuma_CheckTransfSzAndCavlc;
		ResLuma_CheckTransfSzAndCavlc  > a;
		ResLuma_CheckCodedBlockPattern > ResLuma_CheckBmFlagAndMbType  > ResetLevelTab;
		ResLuma_CheckBmFlagAndEndIdxAndMbType > ResLuma_LaunchResBlk_1;
		EndLoop8x8.IsEqualToFalse             > ResLuma_CheckCavlc8x8 > a;
	end
end
