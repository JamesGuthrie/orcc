/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_DecodeResidual()
	bool          EntropyCodingMode,
	uint(size=4)  SliceType,
	uint(size=6)  MbType,
	bool          TransfSz8x8,
	uint(size=6)  CodBlkPatnLm,
	uint(size=6)  CodBlkPatnChm,
	uint(size=2)  ChromaArrayType,
	uint(size=2)  Num_C8x8,

	bool         BmFlag,
	uint(size=4) StartIdx,
	uint(size=4) EndIdx,
	uint(size=5) NATab,
	uint(size=5) NBTab,
	bool         LeftMbExists,
	bool         AboveMbExists,

	uint(size=5) Total_Coeff
		==>
	bool         SkipNal,
	uint(size=4) LaunchActor,

	int (size=8) ResBlknC,
	uint(size=5) ResBlkMaxNumCoeff,
	uint(size=5) ResBlkStartIdx,
	uint(size=5) ResBlkEndIdx
		:

	bool         CAVLC_ENTROPY = false;
//	bool         CABAC_ENTROPY = true;

	uint(size=4) RESIDUAL_BLOCK_CAVLC = 8;
	uint(size=4) RESIDUAL_BLOCK_CABAC = 9;

//	uint(size=4) SLICE_TYPE_P  = 0;
//	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
//	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;


//	uint(size=6) BLOCK_TYPE_I_8x8_or_4x4   = 0;
	uint(size=6) BLOCK_TYPE_INTA_16x16_MIN = 1;
	uint(size=6) BLOCK_TYPE_INTA_16x16_MAX = 24;
//	uint(size=6) BLOCK_TYPE_I_PCM          = 25;

	uint(size=2) LUMA_COMPONENT      = 0;
	uint(size=2) CHROMA_DC_COMPONENT = 1;
	uint(size=2) CHROMA_AC_COMPONENT = 1;

	uint(size=2) RESIDUAL_LUMA_LUMA_OUTPUT := 0;
	uint(size=2) RESIDUAL_LUMA_CHROMA1_OUTPUT := 0;
	uint(size=2) RESIDUAL_LUMA_CHROMA2_OUTPUT := 0;


	bool          bmFlag;
	int (size=5)  startIdx;
	uint(size=4)  endIdx;
	uint(size=4)  StartIdxSent;
	uint(size=4)  EndIdxSent;
	uint(size=2)  chroma_array_type;
	uint(size=2)  NumC8x8;	

	bool          entropy_coding_mode_flag;
	uint(size=4)  slice_type;
	uint(size=6)  mb_type;
	bool          transform_size_8x8_flag;
	uint(size=6)  CodedBlockPatternLuma;
	uint(size=6)  CodedBlockPatternChroma;
	uint(size=4)  ActorSelected;
	List(type: uint(size=5), size = 24 ) TotalCoeffTab;
	List(type: bool        , size = 24 ) MbExists := [true : for int s in 0 .. 23];
	List(type: uint(size=5), size = 16 ) IdxLeftNeighbour  = [16, 0,17, 2, 1, 4, 3, 6,18, 8,19,10, 9,12,11,14];
	List(type: uint(size=5), size = 16 ) IdxAboveNeighbour = [20,21, 0, 1,22,23, 4, 5, 2, 3, 6, 7, 8, 9,12,13];
	uint(size=4) IdxCurrMb := 0;
	uint(size=3) i8x8Loop;
	uint(size=3) iCbCrLoop;
	uint(size=2) Component_type := 0;
	uint(size=5) maxNumCoeff;

	uint(size=2) ResidualLumaOutput := 0;

	GetParameters: action
			EntropyCodingMode :[TypeOfEntropy],
			BmFlag            :[ValBmFlag],
			StartIdx          :[ValStartIdx],
			EndIdx            :[ValEndIdx],
			SliceType         :[ValSliceType],
			MbType            :[ValMbType],
			TransfSz8x8       :[ValTransfSz8x8],
			CodBlkPatnLm      :[ValCodBlkPatnLm],
			CodBlkPatnChm     :[ValCodBlkPatnChm],
			NATab             :[ValNATab] repeat 4,
			NBTab             :[ValNBTab] repeat 4,
			LeftMbExists      :[ValLeftMbExists],
			AboveMbExists     :[ValAboveMbExists],
			ChromaArrayType   :[ValChromaArrayType],
			Num_C8x8          :[ValNum_C8x8]
				==>
		do
			bmFlag                   := ValBmFlag;
			entropy_coding_mode_flag := TypeOfEntropy;
			startIdx                 := ValStartIdx;
			endIdx                   := ValEndIdx;
			slice_type               := ValSliceType;
			mb_type                  := ValMbType;
			transform_size_8x8_flag  := ValTransfSz8x8;
			CodedBlockPatternLuma    := ValCodBlkPatnLm;
			CodedBlockPatternChroma  := ValCodBlkPatnChm;
			chroma_array_type        := ValChromaArrayType;
			NumC8x8                  := ValNum_C8x8;

			ActorSelected :=
				if(entropy_coding_mode_flag = CAVLC_ENTROPY)then
					RESIDUAL_BLOCK_CAVLC
				else
					RESIDUAL_BLOCK_CABAC
				end;
			foreach int i in 0 .. 3
			do
				TotalCoeffTab[16+i] := ValNATab[i];
				MbExists     [16+i] := ValLeftMbExists;
				TotalCoeffTab[20+i] := ValNBTab[i];
				MbExists     [20+i] := ValAboveMbExists;
			end

			ResidualLumaOutput := RESIDUAL_LUMA_LUMA_OUTPUT;

			i8x8Loop      := 0;
			IdxCurrMb     := 0;
		end

	ResLumaOutput.IsLuma: action ==>
		guard
			ResidualLumaOutput = RESIDUAL_LUMA_LUMA_OUTPUT
		end

	ResLuma_Launch16x16DCResBlock: action
				==>
			LaunchActor :[ActorSelected],
			SkipNal     :[    false    ]
		guard
			bmFlag   = false,
			startIdx = 0,
			(slice_type = SLICE_TYPE_I) or (slice_type = SLICE_TYPE_SI),
			mb_type <= BLOCK_TYPE_INTA_16x16_MAX,
			mb_type >= BLOCK_TYPE_INTA_16x16_MIN
		do
			Component_type := LUMA_COMPONENT;
			maxNumCoeff    := 16;
			StartIdxSent   :=  0;
			EndIdxSent     :=  15;
		end

	ResLuma_CheckTransfSzAndCavlc: action ==>
		guard
			   transform_size_8x8_flag  = false
			or entropy_coding_mode_flag = CAVLC_ENTROPY
		do
			IdxCurrMb      := 0;
		end

	ResLuma_CheckCodedBlockPattern: action ==>
		guard
			bitand(CodedBlockPatternLuma,1) = 1
		end

	ResLuma_CheckBmFlagAndEndIdxAndMbType: action
				==>
			LaunchActor :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ],
			SkipNal     :[     false     ,     false     ,     false     ,     false     ]
		guard
			not bmFlag,
			endIdx > 0,
			(slice_type = SLICE_TYPE_I) or (slice_type = SLICE_TYPE_SI),
			mb_type <= BLOCK_TYPE_INTA_16x16_MAX,
			mb_type >= BLOCK_TYPE_INTA_16x16_MIN
		do
			Component_type := LUMA_COMPONENT;
			maxNumCoeff    := 15;
			StartIdxSent   :=
				if(0 > startIdx - 1) then
					0
				else
					startIdx - 1
				end;
			EndIdxSent     :=  endIdx - 1;
		end

	ResLuma_LaunchResBlk_1: action
				==>
			LaunchActor :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ],
			SkipNal     :[     false     ,     false     ,     false     ,     false     ]
		do
			Component_type := LUMA_COMPONENT;
			maxNumCoeff    := 16;
			StartIdxSent   := startIdx;
			EndIdxSent     := endIdx;
		end

	ResLuma_CheckBmFlagAndMbType: action ==>
		guard
			bmFlag = false,
			(slice_type = SLICE_TYPE_I) or (slice_type = SLICE_TYPE_SI),
			mb_type <= BLOCK_TYPE_INTA_16x16_MAX,
			mb_type >= BLOCK_TYPE_INTA_16x16_MIN
		do
			/*
			foreach int i4x4 in 0 .. 3
			do
				foreach int i in 0 .. 14
				do
					i16x16ACLevel[i8x8Loop*4 + i4x4][i] := 0:
				end
			end
			*/
		end

	ResetLevelTab: action ==>
		do
			/*
			foreach int i4x4 in 0 .. 3
			do
				foreach int i in 0 .. 15
				do
					level[i8x8Loop*4 + i4x4][i] := 0:
				end
			end
			*/
		end

	EndLoop8x8.IsEqualToFalse: action ==>
		guard
			i8x8Loop < 4
		do
			i8x8Loop := i8x8Loop + 1;
			CodedBlockPatternLuma := rshift(CodedBlockPatternLuma, 1);
		end

	ResLuma_CheckCavlc8x8: action ==>
		guard
			entropy_coding_mode_flag = CAVLC_ENTROPY,
			transform_size_8x8_flag  = true
		do
			/*
			foreach int i8x8 in 0 .. 3
			do
				foreach int i4x4 in 0 .. 3
				do
					foreach int i in 0 .. 15
					do
						level8x8[ i8x8 ][ 4 * i + i4x4 ] = level[ i8x8 * 4 + i4x4 ][ i ]
					end
				end
			end
			*/
		end




	/*Not implemented yet: CABAC
	else
		for(i8x8=0;i8x8<4;i8x8++)
		{
			if(CodeBlockPatternLuma & (1<<i8x8)) // ==> action CheckCodedBlockPattern
				residual_block(...);
			else
				for(i=0;i<64;i++)
					level8x8[i8x8][i]=0;
		}
*/

	SendResBlockParameters: action
				==>
			ResBlknC          :[nC],
			ResBlkMaxNumCoeff :[maxNumCoeff],
			ResBlkStartIdx    :[StartIdxSent],
			ResBlkEndIdx      :[EndIdxSent]
		var
			int(size=8) nC
		do
			if(Component_type = LUMA_COMPONENT)then
				println("\t\t Idx : "+IdxCurrMb+ " ; IdxLeftNeighbour : "+IdxLeftNeighbour[IdxCurrMb] + ","+IdxAboveNeighbour[IdxCurrMb]+" ; TotalCoeffTab 1 and 2: "+TotalCoeffTab[IdxLeftNeighbour[IdxCurrMb]]+ " ; "+TotalCoeffTab[IdxAboveNeighbour[IdxCurrMb]]);
				nC :=
					if(MbExists[IdxLeftNeighbour[IdxCurrMb]] and MbExists[IdxAboveNeighbour[IdxCurrMb]])then
						rshift(TotalCoeffTab[IdxLeftNeighbour[IdxCurrMb]] + TotalCoeffTab[IdxAboveNeighbour[IdxCurrMb]] +1, 1)
					else
						TotalCoeffTab[IdxLeftNeighbour[IdxCurrMb]] + TotalCoeffTab[IdxAboveNeighbour[IdxCurrMb]]
					end;
			else
				if(Component_type = CHROMA_DC_COMPONENT) then
					nC :=
						if(chroma_array_type = 1) then
							-1
						else
							-2
						end;
				else
					println("Component_type != LUMA_COMPONENT ... not implemented yet !!! ");
					while true do end
				end
			end
			IdxCurrMb := IdxCurrMb + 1;
		end

	GetTotalCoeff: action
			Total_Coeff:[ValTotal_Coeff]
				==>
		do
			TotalCoeffTab[IdxCurrMb - 1] := ValTotal_Coeff;
		end

	ChromaArrayTypeVal.IsEqualTo1or2: action
				==>
		guard
			   chroma_array_type = 1
			or chroma_array_type= 2
		do
//			for( iCbCr = 0; iCbCr < 2; iCbCr++ )
//				for( i = 0; i < 4 * NumC8x8; i++ )
//					ChromaDCLevel[ iCbCr ][ i ] = 0;
			iCbCrLoop := 0;
		end

	ChromaDCResBlk: action
				==>
			LaunchActor :[ ActorSelected , ActorSelected ],
			SkipNal     :[     false     ,     false     ]
		guard
			bitand(CodedBlockPatternChroma, 3) != 0,
			startIdx = 0
		do
			Component_type := CHROMA_DC_COMPONENT;
			StartIdxSent   := 0;
			EndIdxSent     := 4 * NumC8x8 - 1;
			maxNumCoeff    := 4 * NumC8x8;
		end

	ChromaAcComponentPresent: action ==>
		guard
			bitand(CodedBlockPatternChroma, 2) != 0,
			endIdx > 0
		do
			Component_type := CHROMA_AC_COMPONENT;
			StartIdxSent :=
				if(0 > startIdx - 1) then
					0
				else
					startIdx - 1
				end;
			EndIdxSent   := endIdx - 1;
			maxNumCoeff  := 15;
		end

	ChromaAcLoopiCbCr: action ==>
		guard
			iCbCrLoop < 2
		do
			iCbCrLoop := iCbCrLoop + 1;
			i8x8Loop  := 0;
		end

	ChromaAcLoopi8x8: action ==>
		guard
			i8x8Loop < NumC8x8
		do
			i8x8Loop := i8x8Loop + 1;
		end

	ChromaAcLoopi4x4: action
				==>
			LaunchActor :[ ActorSelected , ActorSelected , ActorSelected , ActorSelected ],
			SkipNal     :[     false     ,     false     ,     false     ,     false     ]
		end

	ChromaAcComponentNotPresent: action ==>
		do
			/*
				foreach int iCbCr in 0 .. 1
				do
					foreach int i8x8 in 0 .. NumC8x8 - 1
					do
						foreach int i4x4 in 0 .. 3
						do
							foreach int i in 0 .. 14
							do
								ChromaACLevel[ iCbCr ][ i8x8*4+i4x4 ][ i ] = 0
							end
						end
					end
				end
			*/
		end

	ChromaArrayTypeVal.IsEqualTo3: action
				==>
		guard
			chroma_array_type = 3
		do
			println("ChromaArrayTypeVal.IsEqualTo3 not implemented yet !");
		end

	a:action ==>
	do
		println("DecodeResidual not finished yet !");
	end


	SendEndResidual: action
				==>
			SkipNal :[true]
		end

	schedule fsm GetParameters:
		GetParameters (GetParameters )--> ResLumaCheckIntra16x16;

				/* residual_luma()*/
				ResLumaCheckIntra16x16       (ResLuma_Launch16x16DCResBlock         )--> ResLumaSendResBlkPar1;
				ResLumaCheckIntra16x16       (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
				ResLumaCheckIntra16x16 (a)--> undefined;//Cabac stuff not implemented yet
	
				ResLumaSendResBlkPar1        (SendResBlockParameters                )--> ResLumaGetTotalCoeff1;
	
				ResLumaGetTotalCoeff1        ( GetTotalCoeff                        )--> ResLumaCheckTrnsSzAndEntropy;
	
				ResLumaCheckTrnsSzAndEntropy (ResLuma_CheckTransfSzAndCavlc         )--> CheckCodeBlockBmFlag;
				ResLumaCheckTrnsSzAndEntropy (a)--> undefined;//Cabac stuff not implemented yet
	
				CheckCodeBlockBmFlag         (ResLuma_CheckCodedBlockPattern        )--> CheckBmFlagEndIx;
				CheckCodeBlockBmFlag         (ResLuma_CheckBmFlagAndMbType          )--> CheckEndLoop8x8;
				CheckCodeBlockBmFlag         (ResetLevelTab                         )--> CheckEndLoop8x8;
	
				CheckBmFlagEndIx             (ResLuma_CheckBmFlagAndEndIdxAndMbType )--> ResLumaSendResBlkPar2_0;
				CheckBmFlagEndIx             (ResLuma_LaunchResBlk_1                )--> ResLumaSendResBlkPar2_0;
	
				ResLumaSendResBlkPar2_0      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_0;
	
				ResLumaGetTotalCoeff2_0      (GetTotalCoeff                         )--> ResLumaSendResBlkPar2_1;
	
				ResLumaSendResBlkPar2_1      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_1;
	
				ResLumaGetTotalCoeff2_1      (GetTotalCoeff                         )--> ResLumaSendResBlkPar2_2;
	
				ResLumaSendResBlkPar2_2      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_2;
	
				ResLumaGetTotalCoeff2_2      (GetTotalCoeff                         )--> ResLumaSendResBlkPar2_3;
	
				ResLumaSendResBlkPar2_3      (SendResBlockParameters                )--> ResLumaGetTotalCoeff2_3;
	
				ResLumaGetTotalCoeff2_3      (GetTotalCoeff                         )--> CheckEndLoop8x8;
	
				CheckEndLoop8x8              (EndLoop8x8.IsEqualToFalse             )--> CheckCodeBlockBmFlag;
				CheckEndLoop8x8              (ResLuma_CheckCavlc8x8                 )--> ResidualLumaFinished;


			CheckEndLoop8x8 (ResLumaOutput.IsLuma      )--> CheckChromaArrayType;
			CheckEndLoop8x8 (a )--> undefined;

			ResidualLumaFinished (ResLumaOutput.IsLuma )--> CheckChromaArrayType;
			ResidualLumaFinished (a )-->undefined;

		CheckChromaArrayType (ChromaArrayTypeVal.IsEqualTo1or2 )--> CheckChromaDc;
		CheckChromaArrayType (ChromaArrayTypeVal.IsEqualTo3    )--> undefined;
		CheckChromaArrayType (SendEndResidual                  )--> GetParameters;

		CheckChromaDc (ChromaDCResBlk )--> ChromaDCSendResBlockParam_1;
		CheckChromaDc (ChromaAcComponentPresent )--> undefined;
		CheckChromaDc (ChromaAcComponentNotPresent )--> SendEndResidual;
	
		ChromaDCSendResBlockParam_1 (SendResBlockParameters                )--> ChromaDCGetTotalCoeff_1;

		ChromaDCGetTotalCoeff_1     (GetTotalCoeff                        )--> ChromaDCSendResBlockParam_2;
	
		ChromaDCSendResBlockParam_2 (SendResBlockParameters                )--> ChromaDCGetTotalCoeff_2;

		ChromaDCGetTotalCoeff_2     (GetTotalCoeff                        )--> CheckChromaAC;

		CheckChromaAC (ChromaAcComponentPresent )--> CheckLoopiCbCr;
		CheckChromaAC (ChromaAcComponentNotPresent )--> SendEndResidual;

		CheckLoopiCbCr (ChromaAcLoopiCbCr )--> CheckLoopi8x8;
		CheckLoopiCbCr (SendEndResidual )--> GetParameters;

		CheckLoopi8x8 (ChromaAcLoopi8x8 )--> ChromaAcSendResBlockPar_1;
		CheckLoopi8x8 (ChromaAcLoopiCbCr )--> CheckLoopi8x8;
		CheckLoopi8x8 (SendEndResidual )--> GetParameters;
	
		ChromaAcSendResBlockPar_1      (SendResBlockParameters                )--> ChromaAcGetTotalCoeff_1;

		ChromaAcGetTotalCoeff_1      (GetTotalCoeff                         )--> ChromaAcSendResBlockPar_2;

		ChromaAcSendResBlockPar_2      (SendResBlockParameters                )--> ChromaAcGetTotalCoeff_2;

		ChromaAcGetTotalCoeff_2      (GetTotalCoeff                         )--> ChromaAcSendResBlockPar_3;

		ChromaAcSendResBlockPar_3      (SendResBlockParameters                )--> ChromaAcGetTotalCoeff_3;

		ChromaAcGetTotalCoeff_3      (GetTotalCoeff                         )--> ChromaAcSendResBlockPar_4;

		ChromaAcSendResBlockPar_4      (SendResBlockParameters                )--> ChromaAcGetTotalCoeff_4;

		ChromaAcGetTotalCoeff_4      (GetTotalCoeff                         )--> CheckLoopi8x8;

		SendEndResidual(SendEndResidual )--> GetParameters;
	a(a)-->undefined;
	end
	priority
		ResLuma_Launch16x16DCResBlock  > ResLuma_CheckTransfSzAndCavlc;
		ResLuma_CheckTransfSzAndCavlc  > a;
		ResLuma_CheckCodedBlockPattern > ResLuma_CheckBmFlagAndMbType  > ResetLevelTab;
		ResLuma_CheckBmFlagAndEndIdxAndMbType > ResLuma_LaunchResBlk_1;
		EndLoop8x8.IsEqualToFalse             > ResLuma_CheckCavlc8x8 > ResLumaOutput.IsLuma;
		ResLumaOutput.IsLuma       > a;
		ChromaArrayTypeVal.IsEqualTo1or2 > ChromaArrayTypeVal.IsEqualTo3 > SendEndResidual;
		ChromaDCResBlk > ChromaAcComponentPresent;
		ChromaAcComponentPresent > ChromaAcComponentNotPresent;
		ChromaAcLoopiCbCr  > SendEndResidual;
		ChromaAcLoopi8x8 > SendEndResidual;
	end
end
