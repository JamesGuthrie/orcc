/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference
 purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or 
modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software 
module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the 
MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the 
<standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use 
in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module 
or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure 
the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third 
parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_MergeDataFromSlcDataAndMbLayer()
	bool          SkipMbLayer,
	bool          TransfSz8x8Flag,
	uint(size=6)  MbType,
	uint(size=4)  SliceType,
	uint(size=4)  RemIntraYxYPredMode,

	int (size=8)  SDataQp_Y_Cb_Cr,

	int (size=8)  MbLayerQp_Y_Cb_Cr,

	uint(size=4)  SubMbPredRefIdxL0,
	uint(size=4)  SubMbPredRefIdxL1,
	uint(size=3)  SubMbPredSelectList,
	uint(size=5)  SubMbPredMbPartHeight,
	uint(size=5)  SubMbPredMbPartWidth,
	uint(size=3)  SubMbPredMbPartIdx,
	bool          SubMbPredEndRefIdxL0,
	int(size=16)  SubMbPredMvResl0,

	uint(size=4)  MbPredRefIdxL0,
	uint(size=4)  MbPredRefIdxL1,
	uint(size=3)  MbPredSelectList,
	uint(size=5)  MbPredMbPartHeight,
	uint(size=5)  MbPredMbPartWidth,
	uint(size=3)  MbPredMbPartIdx,
	bool          MbPredEndRefIdxL0,
	int (size=16) MbPredMvResl0,
	bool          MbPredEndMvRes

		==>
	uint(size=1)  MbIntraFlag,
	uint(size=4)  IntraPredMode,
	uint(size=4)  RefIdxl0,
	uint(size=4)  RefIdxl1,
	int (size=16) MvResl0,
	uint(size=5)  MbPartHeight,
	uint(size=5)  MbPartWidth,
	uint(size=3)  MbPartIdx,
	int (size=8)  ScalingList,
	int (size=8)  Qp,
	int (size=8)  Qp_Cb,
	int (size=8)  Qp_Cr,
	uint(size=6)  MacroBlockType,
	uint(size=4)  slice_type,
	bool          TransformSize8x8,
	uint(size=3)  SelectList
		:

	uint(size=6) BLOCK_TYPE_INTRA_MIN       = 0;
	uint(size=6) BLOCK_TYPE_I_8x8_or_4x4    = 0;
	uint(size=6) BLOCK_TYPE_INTRA_16x16_MIN = 1;
	uint(size=6) BLOCK_TYPE_INTRA_16x16_MAX = 24;
	uint(size=6) BLOCK_TYPE_I_PCM           = 25;
	uint(size=6) BLOCK_TYPE_INTRA_MAX       = 25;
	uint(size=6) BLOCK_TYPE_P_8X8           = 29;
	uint(size=6) BLOCK_TYPE_P_8X8_REF0      = 30;
	uint(size=6) BLOCK_TYPE_B_8X8           = 53;
	uint(size=6) BLOCK_TYPE_P_SKIP          = 54;

	uint(size=4) SLICE_TYPE_P  = 0;
	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;

	uint(size=6) mb_type;

	MbLayerSkipped: action
			SkipMbLayer     :[skip],
			SDataQp_Y_Cb_Cr :[ ValQp , ValQpCb , ValQpCr ]
				==>
			MbIntraFlag     :[0],
			RefIdxl0        :[0],
			RefIdxl1        :[0],
			SelectList      :[0],
			MvResl0         :[0,0],
			MbPartHeight    :[16],
			MbPartWidth     :[16],
			MbPartIdx       :[1],
			ScalingList     :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp              :[ValQp],
			Qp_Cb           :[ValQpCb],
			Qp_Cr           :[ValQpCr],
			MacroBlockType  :[BLOCK_TYPE_P_SKIP],
			slice_type      :[SLICE_TYPE_P]
		guard
			skip = true
		end

	MbLayer.IsIntra4x4or8x8: action
			SkipMbLayer       :[skip],
			MbType            :[mb_type],
			SliceType         :[ValSliceType],
			MbLayerQp_Y_Cb_Cr :[ValQp , ValQpCb , ValQpCr]
				==>
			MbIntraFlag      :[1],
			ScalingList    :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp             :[ValQp],
			Qp_Cb          :[ValQpCb],
			Qp_Cr          :[ValQpCr],
			MacroBlockType :[mb_type],
			slice_type     :[ValSliceType]
		guard
			skip    =  false,
			mb_type = BLOCK_TYPE_I_8x8_or_4x4
		end

	MbLayer.IsIntra4x4: action
			TransfSz8x8Flag     :[Is8x8],
			RemIntraYxYPredMode :[rem_intra_4x4_pred_mode] repeat 16
				==>
			TransformSize8x8 :[Is8x8],
			IntraPredMode    :[intra_pred_mode] repeat 17
		guard
			Is8x8   = false
		var
			List(type: uint(size=4), size=17) intra_pred_mode
		do
			intra_pred_mode[0] := 1;
			foreach int i in 0 .. 15
			do
				intra_pred_mode[i+1] := rem_intra_4x4_pred_mode[i];
			end
		end

	MbLayer.IsIntra8x8: action
			TransfSz8x8Flag     :[Is8x8],
			RemIntraYxYPredMode :[rem_intra_8x8_pred_mode] repeat 4
				==>
			TransformSize8x8 :[Is8x8],
			IntraPredMode    :[intra_pred_mode] repeat 4
		guard
			Is8x8   = true
		var
			List(type: uint(size=4), size=5) intra_pred_mode
		do
			intra_pred_mode[0] := 2;
			foreach int i in 0 .. 4
			do
				intra_pred_mode[i+1] := rem_intra_8x8_pred_mode[i];
			end
		end

	MbLayer.IsIntra16x16: action
			SkipMbLayer       :[skip],
			MbType            :[mb_type],
			SliceType         :[ValSliceType],
			TransfSz8x8Flag   :[Is8x8],
			MbLayerQp_Y_Cb_Cr :[ValQp , ValQpCb , ValQpCr]
				==>
			MbIntraFlag    :[1],
			IntraPredMode  :[ 3 , (mb_type - 1) & 3],
			ScalingList    :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp             :[ValQp],
			Qp_Cb          :[ValQpCb],
			Qp_Cr          :[ValQpCr],
			MacroBlockType :[mb_type],
			slice_type     :[ValSliceType]
		guard
			skip     =  false,
			mb_type >= BLOCK_TYPE_INTRA_16x16_MIN,
			mb_type <= BLOCK_TYPE_INTRA_16x16_MAX
		end

	MbLayer.IsIntraPCM: action
			SkipMbLayer     :[skip],
			MbType          :[mb_type],
			SliceType       :[ValSliceType],
			TransfSz8x8Flag :[Is8x8]
				==>
			MbIntraFlag    :[1],
			IntraPredMode  :[4],
			MacroBlockType :[mb_type],
			slice_type     :[ValSliceType]
		guard
			skip    =  false,
			mb_type = BLOCK_TYPE_I_PCM
		end

	MbLayer.IsNotIntra: action
			SkipMbLayer     :[skip],
			MbType          :[Mb_type],
			SliceType       :[ValSliceType],
			TransfSz8x8Flag :[Is8x8],
			MbLayerQp_Y_Cb_Cr :[ValQp , ValQpCb , ValQpCr]
				==>
			MbIntraFlag    :[0],
			ScalingList    :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp             :[ValQp],
			Qp_Cb          :[ValQpCb],
			Qp_Cr          :[ValQpCr],
			MacroBlockType :[mb_type],
			slice_type     :[ValSliceType]
		guard
			skip    = false,
			Mb_type > BLOCK_TYPE_INTRA_MAX
		do
			mb_type := Mb_type;
		end

	LaunchSubMbPred: action ==>
		guard
			   (mb_type = BLOCK_TYPE_P_8X8)
			or (mb_type = BLOCK_TYPE_P_8X8_REF0)
			or (mb_type = BLOCK_TYPE_B_8X8)
		end

	LaunchMbPred: action ==>
		end

	ReadMbPredParam1.MbIntra: action
			MbPredRefIdxL0     :[ref_idx_l0],
			MbPredRefIdxL1     :[ref_idx_l1],
			MbPredSelectList   :[selectlist],
			MbPredMbPartHeight :[mb_part_height],
			MbPredMbPartWidth  :[mb_part_width],
			MbPredMbPartIdx    :[mb_part_idx],
			MbPredEndRefIdxL0  :[Finished]
				==>
			RefIdxl0     :[ref_idx_l0],
			RefIdxl1     :[ref_idx_l1],
			MbPartHeight :[mb_part_height],
			MbPartWidth  :[mb_part_width],
			MbPartIdx    :[mb_part_idx],
			SelectList   :[selectlist]
		guard
			Finished = false,
			mb_type >= BLOCK_TYPE_INTRA_MIN,
			mb_type <= BLOCK_TYPE_INTRA_MAX
		end

	ReadMbPredParam1.MbInter: action
			MbPredRefIdxL0     :[ref_idx_l0],
			MbPredRefIdxL1     :[ref_idx_l1],
			MbPredSelectList   :[selectlist],
			MbPredMbPartHeight :[mb_part_height],
			MbPredMbPartWidth  :[mb_part_width],
			MbPredMbPartIdx    :[mb_part_idx],
			MbPredEndRefIdxL0  :[Finished]
				==>
			RefIdxl0     :[ref_idx_l0],
			RefIdxl1     :[ref_idx_l1],
			MbPartHeight :[mb_part_height],
			MbPartWidth  :[mb_part_width],
			MbPartIdx    :[mb_part_idx],
			SelectList   :[selectlist]
		guard
			Finished = false
		end

	ReadMbPredParam1Finished: action
			MbPredEndRefIdxL0 :[Finished]
				==>
		guard
			Finished = true
		end

	ReadMbPredParam2: action
			MbPredMvResl0  :[mv_res] repeat 2,
			MbPredEndMvRes :[Finished]
				==>
			MvResl0        :[mv_res] repeat 2
		guard
			Finished = false
		end

	ReadMbPredParam2Finished: action
			MbPredEndMvRes :[Finished]
				==>
		guard
			Finished = true
		end

	ReadSubMbPredParam: action
			SubMbPredRefIdxL0     :[ref_idx_l0],
			SubMbPredSelectList   :[selectlist],
			SubMbPredRefIdxL1     :[ref_idx_l1],
			SubMbPredMvResl0      :[mv_res] repeat 2,
			SubMbPredMbPartHeight :[mb_part_height],
			SubMbPredMbPartWidth  :[mb_part_width],
			SubMbPredMbPartIdx    :[mb_part_idx],
			SubMbPredEndRefIdxL0  :[Finished]
				==>
			RefIdxl0     :[ref_idx_l0],
			RefIdxl1     :[ref_idx_l1],
			SelectList   :[selectlist],
			MvResl0      :[mv_res] repeat 2,
			MbPartHeight :[mb_part_height],
			MbPartWidth  :[mb_part_width],
			MbPartIdx    :[mb_part_idx]
		guard
			Finished = false
		end

	ReadSubMbPredParamFinished: action
			SubMbPredEndRefIdxL0 :[Finished]
				==>
		guard
			Finished = true
		end

	schedule fsm ReadMbLayer:
		ReadMbLayer (MbLayerSkipped          )--> ReadMbLayer;
		ReadMbLayer (MbLayer.IsIntra4x4or8x8 )--> IsIntra4x4or8x8;
		ReadMbLayer (MbLayer.IsIntra16x16    )--> ReadMbPredParam1;
		ReadMbLayer (MbLayer.IsIntraPCM      )--> ReadMbLayer;
		ReadMbLayer (MbLayer.IsNotIntra      )--> CheckMbTypeInter;

		IsIntra4x4or8x8 (MbLayer.IsIntra8x8 )--> ReadMbPredParam1;
		IsIntra4x4or8x8 (MbLayer.IsIntra4x4 )--> ReadMbPredParam1;

		CheckMbTypeInter (LaunchSubMbPred )--> ReadSubMbPredParam;
		CheckMbTypeInter (LaunchMbPred    )--> ReadMbPredParam1;

		ReadMbPredParam1 (ReadMbPredParam1         )--> ReadMbPredParam1;
		ReadMbPredParam1 (ReadMbPredParam1Finished )--> ReadMbPredParam2;

		ReadMbPredParam2 (ReadMbPredParam2         )--> ReadMbPredParam2;
		ReadMbPredParam2 (ReadMbPredParam2Finished )--> ReadMbLayer;

		ReadSubMbPredParam (ReadSubMbPredParam         )--> ReadSubMbPredParam;
		ReadSubMbPredParam (ReadSubMbPredParamFinished )--> ReadMbLayer;

	end

	priority
		MbLayerSkipped     > MbLayer;
		LaunchSubMbPred    > LaunchMbPred;
		ReadMbPredParam1   > ReadMbPredParam1Finished;
		ReadMbPredParam2   > ReadMbPredParam2Finished;
		ReadSubMbPredParam > ReadSubMbPredParamFinished;
		ReadMbPredParam1.MbIntra > ReadMbPredParam1.MbInter;
	end
end
