/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/


actor Algo_DecodeResidualBlock_Cavlc()
	int (size=32) ValVLD,
	int (size=8)  nC,
	uint(size=5)  MaxNumCoeff,
	uint(size=5)  StartIdx,
	uint(size=5)  EndIdx
		==>
	uint(size=3)  TypeOfVLD,
	int (size=32) VLD_Param,
	bool          SkipNal,
	uint(size=5)  Total_Coeff
		:


	uint(size=4) READ_BITS             = 0;
	uint(size=4) CAVLC_COEFF_TOKEN     = 5;
	uint(size=4) CAVLC_LEVEL_PREFIX    = 6;
	uint(size=4) CAVLC_TOTAL_ZEROS     = 7;
	uint(size=4) CAVLC_RUN_BEFORE      = 8;

	int (size=8)  nC_Val;
	uint(size=8)  TotalCoeff   := 0;
	uint(size=8)  TrailingOnes := 0;
	uint(size=5)  suffixLength := 0;
	uint(size=32) level_prefix := 0;
	uint(size=32) level_suffix := 0;
	uint(size=32) levelCode    := 0;
	uint(size=5)  iLoop        := 0;
	uint(size=4)  zerosLeft    := 0;
	uint(size=5)  maxNumCoeff  := 0;
	uint(size=5)  startIdx     := 0;
	uint(size=5)  endIdx       := 0;

	List(type: uint(size=8) , size=16) CoeffLevel;
	List(type: int (size=16), size=16) level        := [ 0 : for int i in 1 .. 16];
	List(type: int (size=4) , size=16) run          := [ 0 : for int i in 1 .. 16];

	function Abs(int(size=32) x)
				-->
			uint(size=32)
		:
			if(x > 0)then
				x
			else
				-x
			end
		end

	ReadCoeffToken.Asked: action
			nC          :[ValnC],
			MaxNumCoeff :[ValMaxNumCoeff],
			StartIdx    :[ValStartIdx],
			EndIdx      :[ValEndIdx]
				==>
			//        mb_field_decoding_flag
			SkipNal   :[       false       ],//Keep synchro
			TypeOfVLD :[ CAVLC_COEFF_TOKEN ],
			VLD_Param :[       ValnC       ]
		do
			nC_Val := ValnC;
			foreach int i in 0 .. 15
			do
				CoeffLevel[i] := 0;
			end
			startIdx    := ValStartIdx;
			endIdx      := ValEndIdx;
			maxNumCoeff := ValMaxNumCoeff;
			println("******************** New Block Cavlc***************************");
	println("nC : "+nC_Val);
	println("startIdx"+startIdx);
	println("endIdx"+endIdx);
			zerosLeft := 0;
		end

	ReadCoeffToken.Done: action
			ValVLD :[ValueOfVLD]
				==>
			Total_Coeff:[TotalCoeff]
		do
			TotalCoeff   := bitand(ValueOfVLD,0xFF);
			TrailingOnes := rshift(ValueOfVLD,8);
			println("Trailing Ones : "+rshift(ValueOfVLD,8));
			println("TotalCoeff : "+bitand(ValueOfVLD,0xFF));
			//if(i==TrailingOnes and TrailingOnes < 3) then
			//  levelCode := levelCode + 2;
			//end
			if(TrailingOnes < 3) then
				levelCode := 2;
			else
				levelCode := 0;
			end
		end

	CheckTotalCoeff.IsGreaterThan0: action ==>
		guard
			TotalCoeff > 0
		do
			if((TotalCoeff > 10) and (TrailingOnes < 3)) then
				suffixLength := 1;
			else
				suffixLength := 0;
			end
			iLoop     := 0;
		end

	ReadTrailingOnesSign.Asked: action
				==>
			//     trailing_ones_sign_flag
			SkipNal   :[   false   ],//Keep synchro
			TypeOfVLD :[ READ_BITS ],
			VLD_Param :[ TrailingOnes ]
		guard
			TrailingOnes > 0
		end

	ReadTrailingOnesSign.Done: action
			ValVLD :[ValueOfVLD]
				==>
		var
			uint(size=1) trailing_ones_sign_flag
		do
			foreach int i in 0 .. TrailingOnes - 1
			do
				trailing_ones_sign_flag := bitand(rshift(ValueOfVLD,TrailingOnes - 1 - i) ,1);
				level[iLoop] := 1 - 2 * trailing_ones_sign_flag;
				println("levelT1 : "+level[iLoop]);
				iLoop        := iLoop + 1;
			end
		end

	ReadLevelPrefix.Asked: action
				==>
			//              level_prefix
			SkipNal   :[       false        ],//Keep synchro
			TypeOfVLD :[ CAVLC_LEVEL_PREFIX ]
		guard
			iLoop < TotalCoeff
		end

	ReadLevelPrefix.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			//println("\t\tlevel_prefix : "+ValueOfVLD);
			level_prefix := ValueOfVLD;
			level_suffix := 0;
		end

	ReadLevelSuffix.Asked: action
				==>
			//            level_suffix
			SkipNal   :[      false      ],//Keep synchro
			TypeOfVLD :[    READ_BITS    ],
			VLD_Param :[ levelSuffixSize ]
		guard
			   level_prefix >= 14
			or suffixLength  > 0
		var
			int levelSuffixSize
		do
			if((level_prefix = 14) and (suffixLength = 0) )then
				levelSuffixSize := 4;
			else
				if(level_prefix >= 15) then
					levelSuffixSize := level_prefix - 3;
				else
					levelSuffixSize := suffixLength;
				end
			end
		end

	ReadLevelSuffix.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			//println("\t\tlevel_suffix : "+ValueOfVLD);
			level_suffix := ValueOfVLD;
		end

	ComputeLevel: action ==>
		do
			levelCode :=
				if(level_prefix < 15) then
					levelCode + lshift(level_prefix, suffixLength)
				else
					levelCode + lshift(15, suffixLength)
				end;
			levelCode := levelCode + level_suffix;
			if((level_prefix >= 15) and (suffixLength = 0)) then
				levelCode := levelCode + 15;
			end
			if(level_prefix >= 16) then
				levelCode := levelCode + lshift(1, level_prefix - 3) - 4096;
			end
			if((levelCode mod 2) = 0) then
				level[iLoop] := rshift(levelCode + 2, 1);
			else
				level[iLoop] := rshift( -levelCode - 1, 1);
			end

			if(suffixLength = 0)then
				suffixLength := 1;
			end
			if( (Abs(level[iLoop]) > lshift(3, suffixLength - 1)) and (suffixLength < 6) ) then
				suffixLength := suffixLength + 1;
			end
			println("level : "+level[iLoop]);
			
			levelCode := 0;
			iLoop     := iLoop + 1;
		end

	ReadTotalZeros.Asked: action
				==>
			//               total_zeros
			SkipNal   :[       false       ],//Keep synchro
			TypeOfVLD :[ CAVLC_TOTAL_ZEROS ],
			VLD_Param :[ maxNumCoeff , TotalCoeff ]
		guard
			TotalCoeff < (endIdx - startIdx + 1)
		end

	ReaadTotalZeros.Done: action
			ValVLD :[total_zeros]
				==>
		do
			zerosLeft := total_zeros;
			println("total_zeros : "+total_zeros);
		end

	InitiLoop: action ==>
		do
			iLoop := 0;
		end

	ZerosLeft.GreaterThan0: action
				==>
			//            run_before
			SkipNal   :[      false      ],//Keep synchro
			TypeOfVLD :[ CAVLC_RUN_BEFORE ],
			VLD_Param :[ zerosLeft ]
		guard
			iLoop     < TotalCoeff - 1,
			zerosLeft > 0
		end

	ReadRunBefore: action
			ValVLD :[run_before]
				==>
		do
			run[iLoop] := run_before;
			println("run_before : "+run_before);
			zerosLeft  := zerosLeft - run_before;
			iLoop      := iLoop + 1;
		end

	ZerosLeft.IsEqualTo0: action ==>
		guard
			iLoop < TotalCoeff - 1
		do
			foreach int i in iLoop .. TotalCoeff - 2
			do
				run[i] := 0;
			end
		end

	SendEndResidualBlock: action
				==>
			SkipNal :[true]
		do
			run[TotalCoeff - 1] := zerosLeft;
			/*
				coeffNum = -1
				for( i = TotalCoeff( coeff_token ) - 1; i >= 0; i-- ) {
				   coeffNum += run[ i ] + 1
				   coeffLevel[ startIdx + coeffNum ] = level[ i ]
				}
			
			*/
		end

	schedule fsm ReadCoeffToken_Asked:
		ReadCoeffToken_Asked (ReadCoeffToken.Asked )--> ReadCoeffTokenDone;

		ReadCoeffTokenDone (ReadCoeffToken.Done )--> CheckTotalCoeff;

		CheckTotalCoeff (CheckTotalCoeff.IsGreaterThan0 )--> CheckiLoop;
		CheckTotalCoeff (SendEndResidualBlock )-->ReadCoeffToken_Asked;

		CheckiLoop (ReadTrailingOnesSign.Asked )--> ReadTrailingOnesSign;
		CheckiLoop (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop (InitiLoop )--> Loop4run;

		CheckiLoop2 (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop2 (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop2 (InitiLoop )--> Loop4run;

		ReadTrailingOnesSign (ReadTrailingOnesSign.Done )--> CheckiLoop2;

		ReadLevelPrefix (ReadLevelPrefix.Done )--> ReadLevelSuffixAsked;

		ReadLevelSuffixAsked (ReadLevelSuffix.Asked )--> ReadLevelSuffixDone;
		ReadLevelSuffixAsked (ComputeLevel )--> CheckiLoop2;

		ReadLevelSuffixDone (ReadLevelSuffix.Done )--> ComputeLevel;

		ComputeLevel (ComputeLevel )--> CheckiLoop2;

		ReadTotalZerosDone (ReaadTotalZeros.Done )--> InitiLoop;

		InitiLoop (InitiLoop )--> Loop4run;

		Loop4run (ZerosLeft.GreaterThan0 )--> ReadRunBefore;
		Loop4run (ZerosLeft.IsEqualTo0 )--> SendEndResidualBlock;
		Loop4run (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		ReadRunBefore (ReadRunBefore )--> Loop4run;

		SendEndResidualBlock (SendEndResidualBlock )--> ReadCoeffToken_Asked;
	end
	priority
		CheckTotalCoeff.IsGreaterThan0 > SendEndResidualBlock;
		ReadTrailingOnesSign.Asked > ReadLevelPrefix.Asked;
		ReadLevelSuffix.Asked  > ComputeLevel;
		ReadLevelPrefix.Asked  > ReadTotalZeros.Asked;
		ReadTotalZeros.Asked   > InitiLoop;
		ZerosLeft.GreaterThan0 > ZerosLeft.IsEqualTo0  > SendEndResidualBlock;
	end
end
