/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_DecodeSliceHeader()
	int (size=32) ValVLD,
	bool          IsAnIdrPic,
	uint(size=2)  NalRefIdc,
	
	uint(size=6)  Log2MaxFrameNum,
	bool          frame_mbs_only,
	uint(size=2)  poc_type,
	uint(size=6)  log2_max_poc_lsb,
	bool          delta_pic_order_always_zero,
	uint(size=8)  NumRefFramesInPocCycle,
	int (size=32) ExpectedDeltaPerPocCycle,
	int (size=32) OffsetForRefFrameAccumul,
	int (size=32) OffsetForNonRefPic,
	int (size=32) OffsetForTopToBottomField,
	bool          MbAdaptFrameField,

	bool          pic_order_present,
	bool          redundant_pic_cnt_present,
	bool          entropy_coding_mode,
	bool          deblocking_filter_control_present,
	uint(size=4)  NumSliceGroups,
	uint(size=3)  SliceGroupMapType,
	int (size=32) SizeSliceGroupChgCycle,
	int (size=8)  PicInitQP
		==>
	uint(size=31) FramNumCurrPic,

	int (size=6)  TypeOfVLD,
	int (size=32) VLDParam,
	bool          DecodeNextNal,

	uint(size=8)  GetPps,

	uint(size=4)  SliceType,

	uint(size=13) FirstMbInSlice,
	bool          MbaffFrame,

	uint(size=32) Poc,
	uint(size=2)  DisDeblockingFilterIdc,
	int (size=6)  SliceBetaOffset,
	int (size=6)  SliceAlphaC0Offset,
	int (size=8)  ValQp
		:


/*   
*
* Constants
*
*/


	int (size=6) LAUNCH_ACTOR = -1;
	uint(size=3) READ_BITS    =  0;
	uint(size=3) VLD_UE       =  1;
	uint(size=3) VLD_SE       =  2;
	uint(size=4) SKIP_NAL     = 10;

	uint(size=4) DEC_REF_PIC_MARKING  = 0;
	uint(size=4) REF_PIC_LIST         = 1;

//	uint(size=4) SLICE_TYPE_P  = 0;
//	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;

	bool DEBUG_FLAG_DECODED = true;
	bool DEBUG_OUTUPUT      = false;
/*
*
* State variables
*
*/

	//Parameters read
	List( type:int(size=32), size=2)   delta_pic_order_cnt          := [ 0 : for int i in 0 .. 1];
	//Sps Parameters
	List( type: int(size=32), size=32) offset_for_ref_frame_accumul := [ 0 : for int j in 0 .. 31 ];

	//Parameters read
	int (size=32) frame_num;
	bool          Idr_flag;
	uint(size=32) first_mb_in_slice;
	uint(size=4)  slice_type;
	bool          separate_colour_plane_flag    := false;
	bool          field_pic_flag;
	bool          bottom_field_flag;
	uint(size=16) idr_pic_id                    := 0;
	int (size=32) pic_order_cnt_lsb             := 0;
	int (size=32) delta_pic_order_cnt_bottom    := 0;
	uint(size=7)  redundant_pic_cnt             := 0;
	uint(size=2)  cabac_init_idc                := 0;
	//int (size=32) slice_qp_delta;
	bool          sp_for_switch_flag;
	uint(size=6)  slice_qs_delta;
	uint(size=2)  disable_deblocking_filter_idc := 0;
	int(size=6)   slice_alpha_c0_offset         := 0;
	int(size=6)   slice_beta_offset             := 0;
	uint(size=32) slice_group_change_cycle      := 0;
	//Sps Parameters
	uint(size=6)  log2_max_frame_num;
	bool          frame_mbs_only_flag;
	uint(size=2)  pic_order_cnt_type;
	uint(size=6)  SzMaxPocLsb;
	bool          delta_pic_order_always_zero_flag;
	uint(size=8)  num_ref_frames_in_pic_order_cnt_cycle := 0;
	int (size=32) expected_delta_per_poc_cycle          := 0;
	int (size=32) offset_for_non_ref_pic                := 0;
	int (size=32) offset_for_top_to_bottom_field        := 0;
	bool          mb_adaptive_frame_field_flag          := false;
	//PpsParameters
	bool          pic_order_present_flag;
	bool          redundant_pic_cnt_present_flag;
	bool          entropy_coding_mode_flag;
	bool          deblocking_filter_control_present_flag;
	uint(size=4)  num_slice_groups;
	uint(size=3)  slice_group_map_type;
	int (size=32) SzSliceGroupChgCycle;
	//Poc parameters
	int (size=32) prev_frame_num         := 0;
	int (size=32) frame_num_offset       := 0;
	int (size=32) PicOrderCntMsb         := 0;
	int (size=32) prevPicOrderCntLsb     := 0;
	uint(size=2)  nal_ref_idc            := 0;
	int (size=32) expectedpoc            := 0;
	//Slice Data Parameters
	bool          MbaffFrameFlag := false;

	int (size=32) LoopVal;

/*   
*
* Actions
*
*/

	ReadSliceType.Asked: action
			==>
			//              first_ , slice_ , pic_par
			TypeOfVLD    :[ VLD_UE , VLD_UE , VLD_UE ]
	do
		disable_deblocking_filter_idc := 0;
		slice_alpha_c0_offset         := 0;
		slice_beta_offset             := 0;
	end


	ReadSliceType.Done: action
			ValVLD     :[ValueOfVLD] repeat 3,
			IsAnIdrPic :[IdrPic],
			NalRefIdc  :[ValNalRefIdc]
				==>
			FirstMbInSlice :[ValueOfVLD[0]],
			GetPps         :[ValueOfVLD[2]],
			SliceType      :[slice_type]
		do
			Idr_flag          := IdrPic;
			nal_ref_idc       := ValNalRefIdc;
			first_mb_in_slice := ValueOfVLD[0];
			slice_type        :=
				if( ValueOfVLD[1] < 5) then
					ValueOfVLD[1]
				else
					ValueOfVLD[1] - 5
				end;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tfirst_mb_in_slice:"+first_mb_in_slice);
				println("\t\tslice_type:       "+ValueOfVLD[1]);
				println("\t\tpps_id:           "+ValueOfVLD[2]);
			end
			//pps_id            := ValueOfVLD[2]; ==> don't need
			//Ask sps_id
			//Ask and get separate_colour_plane_flag ==> not implemented in decodeSpsHeader yet !!
		end


	SeparateColourPlane.IsEqualToTrue: action
				==>
			//           colour_plane_id
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     2     ]
		guard
			separate_colour_plane_flag = true
		end


	ReadFrameNum.Asked: action
			Log2MaxFrameNum :[SzMaxFrameNum]
				==>
			//                frame_num
			TypeOfVLD :[   READ_BITS   ],
			VLDParam  :[ SzMaxFrameNum ]
		do
			log2_max_frame_num := SzMaxFrameNum;
		end


	ReadFrameNum.Done: action
			ValVLD                            :[ValueOfVLD],

			frame_mbs_only                    :[ValFrameMbsOnly],
			poc_type                          :[ValPocType],
			log2_max_poc_lsb                  :[ValSzMaxPocLsb],
			pic_order_present                 :[ValPicOrderPresent],
			delta_pic_order_always_zero       :[ValDeltaPic],
			redundant_pic_cnt_present         :[ValRedPicCnt],
			entropy_coding_mode               :[ValEntropyCodingMode],
			deblocking_filter_control_present :[ValDebFilContPres],
			NumSliceGroups                    :[ValNumSliceGroups],
			SliceGroupMapType                 :[ValSliceGroupMapType],
			SizeSliceGroupChgCycle            :[ValSzSliceGroupChgCycle],
			NumRefFramesInPocCycle            :[ValNumRefFramesInPocCycle],
			ExpectedDeltaPerPocCycle          :[ValExpectedDeltaPerPocCycle],
			OffsetForNonRefPic                :[ValOffsetForNonRefPic],
			OffsetForTopToBottomField         :[ValOffsetForTopToBottomField],
			MbAdaptFrameField                 :[ValMbAdaptFrameField]
				==>
			FramNumCurrPic                    :[ValueOfVLD]
		do
			prev_frame_num                         := frame_num;
			frame_num                              := ValueOfVLD;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tframe_num:        "+ValueOfVLD);
			end
			frame_mbs_only_flag                    := ValFrameMbsOnly;
			pic_order_cnt_type                     := ValPocType;
			SzMaxPocLsb                            := ValSzMaxPocLsb;
			pic_order_present_flag                 := ValPicOrderPresent;
			delta_pic_order_always_zero_flag       := ValDeltaPic;
			redundant_pic_cnt_present_flag         := ValRedPicCnt;
			entropy_coding_mode_flag               := ValEntropyCodingMode;
			deblocking_filter_control_present_flag := ValDebFilContPres;
			num_slice_groups                       := ValNumSliceGroups;
			slice_group_map_type                   := ValSliceGroupMapType;
			SzSliceGroupChgCycle                   := ValSzSliceGroupChgCycle;
			num_ref_frames_in_pic_order_cnt_cycle  := ValNumRefFramesInPocCycle;
			expected_delta_per_poc_cycle           := ValExpectedDeltaPerPocCycle;
			offset_for_non_ref_pic                 := ValOffsetForNonRefPic;
			offset_for_top_to_bottom_field         := ValOffsetForTopToBottomField;
			mb_adaptive_frame_field_flag           := ValMbAdaptFrameField;
			LoopVal := 0;
		end


	GetOff4RefFrameAcc.Launch: action
			OffsetForRefFrameAccumul:[ValOffAccumul]
				==>
		guard
			LoopVal < num_ref_frames_in_pic_order_cnt_cycle
		do
			offset_for_ref_frame_accumul[LoopVal] := ValOffAccumul;
			LoopVal := LoopVal + 1;
		end

	GetOff4RefFrameAcc.Done: action
			==>
		guard
			LoopVal >= num_ref_frames_in_pic_order_cnt_cycle
		end

	FrameMbsOnly.IsEqualToFalse: action
				==>
			//           field_pic_flag
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     1     ]
		guard
			frame_mbs_only_flag = false
		end


	ReadFieldPicFlag.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			field_pic_flag := 
				if(ValueOfVLD = 0) then
					false
				else
					true
				end;
			MbaffFrameFlag := (field_pic_flag and mb_adaptive_frame_field_flag);
			if(DEBUG_FLAG_DECODED)then
				println("\t\tfield_pic_flag:   "+field_pic_flag);
			end
		end


	FieldPicFlag.IsEqualToTrue: action
				==>
			//           bottom_field_flag
			TypeOfVLD :[ READ_BITS ],
			VLDParam  :[     1     ]
		guard
			field_pic_flag = true
		end


	ReadBottomField.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			bottom_field_flag :=
				if(ValueOfVLD = 0)then
					false
				else
					true
				end;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tbottom_field_flag: "+bottom_field_flag);
			end
		end


	IdrFlag.IsEqualToFalse: action ==>
		guard
			Idr_flag = false
		do
			if(frame_num < prev_frame_num) then
				frame_num_offset := frame_num_offset + lshift(1, log2_max_frame_num);
			end
		end


	IdrFlag.IsEqualToTrue: action
				==>
			//            idr_pic_id
			TypeOfVLD    :[ VLD_UE ]
		guard
			Idr_flag = true
		do
			frame_num_offset := 0;
			frame_num        := 0;
			prev_frame_num   := 0;
			PicOrderCntMsb         := 0;
			prevPicOrderCntLsb     := 0;
			expectedpoc            := 0;
			
		end


	ReadIdrPicId.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			idr_pic_id := ValueOfVLD;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tidr_pic_id:       "+idr_pic_id);
			end
		end


	PocType.IsEqualTo0: action
				==>
			//           pic_order_cnt_lsb
			TypeOfVLD :[  READ_BITS  ],
			VLDParam  :[ SzMaxPocLsb ]
		guard
			pic_order_cnt_type = 0
		end


	ReadPocLsb.Done: action
			ValVLD :[ValueOfVLD]
				==>
			Poc    :[POC_val]
		var
			int MaxPicOrderCntLsb,
			int POC_val
		do
			MaxPicOrderCntLsb := lshift(1,SzMaxPocLsb) / 2;
			if Idr_flag = true then
				PicOrderCntMsb := 0;
				prevPicOrderCntLsb := 0;
			else
				prevPicOrderCntLsb := pic_order_cnt_lsb;
			end
			pic_order_cnt_lsb := ValueOfVLD;
			if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= MaxPicOrderCntLsb) then
				PicOrderCntMsb     :=  PicOrderCntMsb + MaxPicOrderCntLsb;
				prevPicOrderCntLsb := 0;
			else 
				if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) > MaxPicOrderCntLsb) then 
					PicOrderCntMsb := PicOrderCntMsb - MaxPicOrderCntLsb;
				end
			end
			POC_val := PicOrderCntMsb + pic_order_cnt_lsb;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tpic_order_cnt_lsb: "+ValueOfVLD);
			end
			if(DEBUG_OUTUPUT)then
				println("PocVal: "+POC_val);
			end
		end


	Check_PicOrPres_FieldPic: action
				==>
			//     delta_pic_order_cnt_bottom
			//                or
			//      delta_pic_order_cnt[ 1 ]
			TypeOfVLD    :[ VLD_SE ]
		guard
			pic_order_present_flag = true,
			field_pic_flag         = false
		end


	ReadDeltaPicOrderCntBottom.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			delta_pic_order_cnt_bottom := ValueOfVLD;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tdelta_pic_order_cnt_bottom: "+delta_pic_order_cnt_bottom);
			end
		end


	PocType.IsEqualTo2: action
				==>
			Poc    :[POC_val]
		var
			int POC_val
		do
			POC_val :=
				if(Idr_flag = true) then
					0
				else
					if(nal_ref_idc > 0) then
						(frame_num_offset + frame_num) * 2
					else
						((frame_num_offset + frame_num) * 2) - 1
					end
				end;
			if(DEBUG_OUTUPUT)then
				println("PocVal: "+POC_val);
			end
		end


	PocType.IsEqualTo1: action
				==>
		guard
			pic_order_cnt_type = 1
		var
			int abs_frame_num,
			int idx
		do
				abs_frame_num :=
					if(num_ref_frames_in_pic_order_cnt_cycle != 0) then
						frame_num_offset + frame_num
					else
						0
					end ;
				if( (nal_ref_idc = 0) and (abs_frame_num > 0) ) then
					abs_frame_num := abs_frame_num -1;
				end
				if(abs_frame_num > 0) then
					expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle);
					idx         := (abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle;
					expectedpoc := expectedpoc + offset_for_ref_frame_accumul[idx];
				else
					expectedpoc :=0;
				end
			if(nal_ref_idc = 0) then
				expectedpoc := expectedpoc + offset_for_non_ref_pic;
			end

		end


	ReadDeltaPicOrCnt0.Asked: action
				==>
			//      delta_pic_order_cnt[ 0 ]
			TypeOfVLD    :[ VLD_SE ]
		guard
			pic_order_cnt_type               = 1,
			not delta_pic_order_always_zero_flag
		end


	ReadDeltaPicOrCnt0.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			delta_pic_order_cnt[0] := ValueOfVLD;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tdelta_pic_order_cnt[0]: "+delta_pic_order_cnt[0]);
			end
		end


	ReadDeltaPicOrCnt1.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			delta_pic_order_cnt[1] := ValueOfVLD;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tdelta_pic_order_cnt[1]: "+delta_pic_order_cnt[1]);
			end
		end


	CalcPOC4PocType1: action
			==>
		Poc :[POC_val]
	var 
/*		int TopFieldOrderCnt,
		int BottomFieldOrderCnt,*/
		int POC_val
	do
	//This code must be checked later and move into ReadDeltaPicOrCnt0.Done and ReadDeltaPicOrCnt1.Done !!!!

/*		TopFieldOrderCnt    := expectedpoc + delta_pic_order_cnt[0];
		BottomFieldOrderCnt := TopFieldOrderCnt + offset_for_top_to_bottom_field + delta_pic_order_cnt[1];// ==> WTF __
		if(field_pic_flag = true) then//                                                                             \/
			BottomFieldOrderCnt := BottomFieldOrderCnt +delta_pic_order_cnt[1];//                             ==> WTF !!!!!
		end
		POC_val :=
			if(TopFieldOrderCnt < BottomFieldOrderCnt) then
				TopFieldOrderCnt
			else
				BottomFieldOrderCnt
			end ;*/

		// TopField is always inferior !!!!!
		POC_val := expectedpoc + delta_pic_order_cnt[0];
		if(DEBUG_FLAG_DECODED)then
			println("PocVal: "+POC_val);
		end
	end


	RedundPicCntPres.IsEqualToTrue: action
				==>
			//         redundant_pic_cnt
			TypeOfVLD    :[ VLD_UE ]
		guard
			redundant_pic_cnt_present_flag = true
		end


	ReadRedunPicCnt.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			redundant_pic_cnt := ValueOfVLD;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tredundant_pic_cnt: "+redundant_pic_cnt);
			end
		end


	RefPicList.Launch: action
				==>
			TypeOfVLD :[LAUNCH_ACTOR],
			VLDParam  :[REF_PIC_LIST]
		end

	SendSliceDataParameters: action
				==>
			MbaffFrame :[MbaffFrameFlag]
		end


	DecRefPicMarking.Launch: action
				==>
			TypeOfVLD :[LAUNCH_ACTOR],
			VLDParam  :[DEC_REF_PIC_MARKING]
		end


	ReadCabacInitDc.Asked: action
				==>
			//           cabac_init_idc
			TypeOfVLD    :[ VLD_UE ]
		guard
			entropy_coding_mode_flag  = true,
			slice_type               != SLICE_TYPE_I,
			slice_type               != SLICE_TYPE_SI
		end


	ReadCabacInitDc.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			cabac_init_idc := VLDecoding;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tcabac_init_idc: "+cabac_init_idc);
			end
		end


	ReadSliceQpDelta.Asked: action
				==>
			//          slice_qp_delta
			TypeOfVLD    :[ VLD_SE ]
		end


	ReadSliceQpDelta.Done: action
			ValVLD    :[VLDecoding],
			PicInitQP :[ValInitQp]
				==>
			ValQp     :[ValueOfQp]
		var
			int(size=8) ValueOfQp
		do
			//slice_qp_delta := VLDecoding;
			ValueOfQp      := VLDecoding + ValInitQp;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tslice_qp_delta: "+VLDecoding);
			end
		end


	Slice_Type.IsEqualToSP: action
				==>
			//              sp_for_sw , slice_q
			TypeOfVLD :[ READ_BITS , VLD_SE ],
			VLDParam  :[     1              ]
		guard
			slice_type = SLICE_TYPE_SP
		end


	ReadSliceSpParameters.Done: action
			ValVLD :[VLDecoding] repeat 2
				==>
		do
			sp_for_switch_flag :=
				if(VLDecoding[0] = 0)then
					false
				else
					true
				end;
			slice_qs_delta := VLDecoding[1];
			if(DEBUG_FLAG_DECODED)then
				println("\t\tsp_for_switch_flag: "+sp_for_switch_flag);
				println("\t\tslice_qs_delta: "+slice_qs_delta);
			end
		end


	Slice_Type.IsEqualToSI: action
				==>
			//          slice_qs_delta
			TypeOfVLD    :[ VLD_SE ]
		guard
			slice_type = SLICE_TYPE_SP
		end


	ReadSliceSiParameters.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			slice_qs_delta := VLDecoding;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tslice_qs_delta: "+slice_qs_delta);
			end
		end


	DeblocFilterPresent: action
				==>
			//          slice_qs_delta
			TypeOfVLD    :[ VLD_UE ]
		guard
			deblocking_filter_control_present_flag = true
		end


	ReadDisDeblocFilterIdc.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			disable_deblocking_filter_idc := VLDecoding;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tdisable_deblocking_filter_idc: "+disable_deblocking_filter_idc);
			end
		end


	DisDeblocFilterIdc.IsNotEqualTo1: action
				==>
			//              slice_ , slice_
			TypeOfVLD    :[ VLD_SE , VLD_SE ]
		guard
			disable_deblocking_filter_idc != 1
		end


	ReadSliceAlphaAndBeta: action
			ValVLD :[VLDecoding] repeat 2
				==>
		do
			slice_alpha_c0_offset := VLDecoding[0] * 2;
			slice_beta_offset     := VLDecoding[1] * 2;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tslice_alpha_c0_offset_div2: "+VLDecoding[0]);
				println("\t\tslice_beta_offset_div2: "+VLDecoding[1]);
			end
		end


	ReadSlcGrpChgCycl.Asked: action
				==>
			//            slice_group_change_cycle
			TypeOfVLD :[       READ_BITS      ],
			VLDParam  :[ SzSliceGroupChgCycle ]
		guard
			num_slice_groups     >  1,
			slice_group_map_type >= 3,
			slice_group_map_type <= 5
		end


	ReadSlcGrpChgCycl.Done: action
			ValVLD             :[VLDecoding]
				==>
		do
			slice_group_change_cycle := VLDecoding;
			if(DEBUG_FLAG_DECODED)then
				println("\t\tslice_group_change_cycle: "+slice_group_change_cycle);
			end
		end


	SendEndSliceHeader: action
				==>
			DisDeblockingFilterIdc :[disable_deblocking_filter_idc],
			SliceBetaOffset        :[slice_beta_offset],
			SliceAlphaC0Offset     :[slice_alpha_c0_offset],
			TypeOfVLD              :[SKIP_NAL],
			DecodeNextNal          :[true]
		end

/*   
*
* Scheduler
*
*/	

	schedule fsm ReadSliceTypeAsked:
		ReadSliceTypeAsked             (ReadSliceType.Asked               )--> ReadSliceTypeDone;

		ReadSliceTypeDone              (ReadSliceType.Done                )--> CheckSeparateColourPlane;

		CheckSeparateColourPlane       (SeparateColourPlane.IsEqualToTrue )--> undefined; //Not implemented yet
		CheckSeparateColourPlane       (ReadFrameNum.Asked                )--> ReadFrameNumDone;

		ReadFrameNumDone               (ReadFrameNum.Done                 )--> GetOff4RefFrameAcc;

		GetOff4RefFrameAcc             (GetOff4RefFrameAcc.Launch         )--> GetOff4RefFrameAcc;
		GetOff4RefFrameAcc             (GetOff4RefFrameAcc.Done           )--> CheckFrameMbsOnly;

		CheckFrameMbsOnly              (FrameMbsOnly.IsEqualToFalse       )--> ReadFieldPicFlagDone;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;
	

		ReadFieldPicFlagDone           (ReadFieldPicFlag.Done             )-->CheckFieldPicFlag;

		CheckFieldPicFlag              (FieldPicFlag.IsEqualToTrue        )--> ReadBottomFieldDone;
		CheckFieldPicFlag              (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckFieldPicFlag              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;

		ReadBottomFieldDone            (ReadBottomField.Done              )-->CheckIdrFlag;

		CheckIdrFlag                   (IdrFlag.IsEqualToFalse            )--> CheckPocType;
		CheckIdrFlag                   (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;

		ReadIdrPicIdDone               (ReadIdrPicId.Done                 )--> CheckPocType;

		CheckPocType                   (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckPocType                   (PocType.IsEqualTo1                )--> CheckDeltaPicOrderFlag;
		CheckPocType                   (PocType.IsEqualTo2                )--> CheckRedundPicCntPres;

		ReadPocLsbDone                 (ReadPocLsb.Done                   )--> Check4DeltPicOrdCntBot;

		Check4DeltPicOrdCntBot         (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrderCntBottomDone;
		Check4DeltPicOrdCntBot         (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		Check4DeltPicOrdCntBot         (RefPicList.Launch                 )--> SendSliceDataParameters;

		ReadDeltaPicOrderCntBottomDone (ReadDeltaPicOrderCntBottom.Done   )--> CheckRedundPicCntPres;

		CheckDeltaPicOrderFlag         (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckDeltaPicOrderFlag         (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt0Done         (ReadDeltaPicOrCnt0.Done           )--> Check4DeltaPicOrCnt1;

		Check4DeltaPicOrCnt1           (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrCnt1Done;
		Check4DeltaPicOrCnt1           (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt1Done         (ReadDeltaPicOrCnt1.Done           )--> CalcPOC4PocType1;

		CalcPOC4PocType1               (CalcPOC4PocType1                  )--> CheckRedundPicCntPres;

		CheckRedundPicCntPres          (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckRedundPicCntPres          (RefPicList.Launch                 )--> SendSliceDataParameters;

		ReadRedunPicCntDone            (ReadRedunPicCnt.Done              )--> DecodeRefPicList;

		DecodeRefPicList               (RefPicList.Launch                 )--> SendSliceDataParameters;

		SendSliceDataParameters        (SendSliceDataParameters           )-->                             DecodeDecRefPicMarking;//DecodeWeightedPred;
		//DecodeWeightedPred           (LaunchWeightedPred                )--> ...;


		DecodeDecRefPicMarking         (DecRefPicMarking.Launch           )--> CheckEntropyCodingMode;

		CheckEntropyCodingMode         (ReadCabacInitDc.Asked             )--> ReadCabacInitIdc;
		CheckEntropyCodingMode         (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadCabacInitIdc               (ReadCabacInitDc.Done              )--> ReadSliceQpDeltaAsked;

		ReadSliceQpDeltaAsked          (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadSliceQpDeltaDone           (ReadSliceQpDelta.Done             )--> CheckSliceType;

		CheckSliceType                 (Slice_Type.IsEqualToSP            )--> ReadSliceSpParameters;
		CheckSliceType                 (Slice_Type.IsEqualToSI            )--> ReadSliceSiParameters;
		CheckSliceType                 (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckSliceType                 (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckSliceType                 (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadSliceSpParameters          (ReadSliceSpParameters.Done        )--> CheckDeblocFilterControl;

		ReadSliceSiParameters          (ReadSliceSiParameters.Done        )--> CheckDeblocFilterControl;

		CheckDeblocFilterControl       (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckDeblocFilterControl       (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDeblocFilterControl       (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadDisDeblocFilterIdc         (ReadDisDeblocFilterIdc.Done       )--> CheckDisDeblocFilterIdc;

		CheckDisDeblocFilterIdc        (DisDeblocFilterIdc.IsNotEqualTo1  )--> ReadSliceAlphaAndBeta;
		CheckDisDeblocFilterIdc        (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDisDeblocFilterIdc        (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadSliceAlphaAndBeta          (ReadSliceAlphaAndBeta             )--> CheckNumSliceGroups;

		CheckNumSliceGroups            (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckNumSliceGroups            (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadSlcGrpChgCycl              (ReadSlcGrpChgCycl.Done            )--> EndSliceHeader;

		EndSliceHeader                 (SendEndSliceHeader                )--> ReadSliceTypeAsked;
	end

	priority
		SeparateColourPlane              > ReadFrameNum;
		FrameMbsOnly.IsEqualToFalse      > IdrFlag.IsEqualToFalse;
		FieldPicFlag.IsEqualToTrue       > IdrFlag.IsEqualToFalse;
		IdrFlag.IsEqualToFalse           > IdrFlag.IsEqualToTrue;
		PocType.IsEqualTo0               > PocType.IsEqualTo1;
		PocType.IsEqualTo1               > PocType.IsEqualTo2;
		ReadDeltaPicOrCnt0.Asked         > CalcPOC4PocType1;
		Check_PicOrPres_FieldPic         > CalcPOC4PocType1;
		RedundPicCntPres.IsEqualToTrue   > RefPicList.Launch;
		ReadCabacInitDc.Asked            > ReadSliceQpDelta.Asked;
		Slice_Type.IsEqualToSP           > Slice_Type.IsEqualToSI         > DeblocFilterPresent;
		DeblocFilterPresent              > ReadSlcGrpChgCycl.Asked;
		DisDeblocFilterIdc.IsNotEqualTo1 > ReadSlcGrpChgCycl.Asked;
		ReadSlcGrpChgCycl.Asked          > SendEndSliceHeader;
	end
end
