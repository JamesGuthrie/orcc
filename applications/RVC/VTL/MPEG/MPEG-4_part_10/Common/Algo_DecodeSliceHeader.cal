/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_DecodeSliceHeader()
	int (size=32) ValVLD,
	bool          IsAnIdrPic,
	
	uint(size=6)  log2_max_frame_num,
	bool          frame_mbs_only,
	uint(size=2)  poc_type,
	uint(size=6)  log2_max_poc_lsb,
	bool          delta_pic_order_always_zero,

	bool          pic_order_present,
	bool          redundant_pic_cnt_present,
	bool          entropy_coding_mode,
	bool          deblocking_filter_control_present,
	uint(size=4)  NumSliceGroups,
	uint(size=3)  SliceGroupMapType,
	int (size=32) SizeSliceGroupChgCycle,

	uint(size=3)  RefPicListTypeOfVLD,
	uint(size=5)  RefPicListNbBitsToRead,
	bool          RefPicListSkipNal,

	uint(size=3)  DecRefPicMarkingTypeOfVLD,
	uint(size=5)  DecRefPicMarkingNbBitsToRead,
	bool          DecRefPicMarkingSkipNal
		==>
	uint(size=3)  TypeOfVLD,
	uint(size=5)  NbBitsToRead,
	bool          SkipNal,

	uint(size=8)  GetPps,

	uint(size=4)  SliceType,
	int (size=32) RefPicListValVLD,

	int (size=32) DecRefPicMarkingValVLD
		:


/*   
*
* Constants
*
*/

	uint(size=3) READ_BITS = 0;
	uint(size=3) VLD_UE    = 1;
	uint(size=3) VLD_SE    = 2;

//	uint(size=4) SLICE_TYPE_P  = 0;
//	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;


/*   
*
* State variables
*
*/

	List (type:int(size=32), size=2) delta_pic_order_cnt  := [ 0 : for int i in 0 .. 1];

	bool          Idr_flag;
	uint(size=32) first_mb_in_slice;
	uint(size=4)  slice_type;
	bool          separate_colour_plane_flag := false;
	bool          field_pic_flag;
	bool          bottom_field_flag;
	uint(size=16) idr_pic_id := 0;
	int (size=32) pic_order_cnt_lsb := 0;
	int (size=32) delta_pic_order_cnt_bottom := 0;
	uint(size=7)  redundant_pic_cnt := 0;
	uint(size=2)  cabac_init_idc := 0;
	int (size=32) slice_qp_delta;
	bool          sp_for_switch_flag;
	uint(size=6)  slice_qs_delta;
	uint(size=2)  disable_deblocking_filter_idc := 0;
	int(size=6)   slice_alpha_c0_offset;
	int(size=6)   slice_beta_offset := 0;
	uint(size=32) slice_group_change_cycle := 0;
	//Sps Parameters
	bool          frame_mbs_only_flag;
	uint(size=2)  pic_order_cnt_type;
	uint(size=6)  SzMaxPocLsb;
	bool          delta_pic_order_always_zero_flag;
	//PpsParameters
	bool          pic_order_present_flag;
	bool          redundant_pic_cnt_present_flag;
	bool          entropy_coding_mode_flag;
	bool          deblocking_filter_control_present_flag;
	uint(size=4)  num_slice_groups;
	uint(size=3)  slice_group_map_type;
	int (size=32) SzSliceGroupChgCycle;


/*   
*
* Actions
*
*/

	ReadSliceType.Asked: action
			==>
			//              first_ , slice_ , pic_par
			SkipNal      :[  false ,  false ,  false ],//Keep synchro
			TypeOfVLD    :[ VLD_UE , VLD_UE , VLD_UE ]
	end


	ReadSliceType.Done: action
			ValVLD     :[ValueOfVLD] repeat 3,
			IsAnIdrPic :[IdrPic]
				==>
			GetPps     :[ValueOfVLD[2]],
			SliceType  :[slice_type]
		do
			Idr_flag           := IdrPic;
			first_mb_in_slice := ValueOfVLD[0];
			slice_type        :=
				if( ValueOfVLD[1] < 5) then
					ValueOfVLD[1]
				else
					ValueOfVLD[1] - 5
				end;
			println("\t\tfirst_mb_in_slice:"+first_mb_in_slice);
			println("\t\tslice_type:       "+slice_type);
			println("\t\tpps_id:           "+ValueOfVLD[2]);
			//pps_id            := ValueOfVLD[2]; ==> don't need
			//Ask sps_id
			//Ask and get separate_colour_plane_flag ==> not implemented in decodeSpsHeader yet !!
		end


	SeparateColourPlane.IsEqualToTrue: action
				==>
			//           colour_plane_id
			SkipNal      :[   false   ],//Keep synchro
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     2     ]
		guard
			separate_colour_plane_flag = true
		end


	ReadFrameNum.Asked: action
			log2_max_frame_num :[SzMaxFrameNum]
				==>
			//                frame_num
			SkipNal      :[     false     ],//Keep synchro
			TypeOfVLD    :[   READ_BITS   ],
			NbBitsToRead :[ SzMaxFrameNum ]
		end


	ReadFrameNum.Done: action
			ValVLD                            :[ValueOfVLD],

			frame_mbs_only                    :[ValFrameMbsOnly],
			poc_type                          :[ValPocType],
			log2_max_poc_lsb                  :[ValSzMaxPocLsb],
			pic_order_present                 :[ValPicOrderPresent],
			delta_pic_order_always_zero       :[ValDeltaPic],
			redundant_pic_cnt_present         :[ValRedPicCnt],
			entropy_coding_mode               :[ValEntropyCodingMode],
			deblocking_filter_control_present :[ValDebFilContPres],
			NumSliceGroups                    :[ValNumSliceGroups],
			SliceGroupMapType                 :[ValSliceGroupMapType],
			SizeSliceGroupChgCycle            :[ValSzSliceGroupChgCycle]
				==>
		do
			println("\t\tframe_num:        "+ValueOfVLD);
			frame_mbs_only_flag                    := ValFrameMbsOnly;
			pic_order_cnt_type                     := ValPocType;
			SzMaxPocLsb                            := ValSzMaxPocLsb;
			pic_order_present_flag                 := ValPicOrderPresent;
			delta_pic_order_always_zero_flag       := ValDeltaPic;
			redundant_pic_cnt_present_flag         := ValRedPicCnt;
			entropy_coding_mode_flag               := ValEntropyCodingMode;
			deblocking_filter_control_present_flag := ValDebFilContPres;
			num_slice_groups                       := ValNumSliceGroups;
			slice_group_map_type                   := ValSliceGroupMapType;
			SzSliceGroupChgCycle                   := ValSzSliceGroupChgCycle;
		end


	FrameMbsOnly.IsEqualToFalse: action
				==>
			//           field_pic_flag
			SkipNal      :[   false   ],//Keep synchro
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     1     ]
		guard
			frame_mbs_only_flag = false
		end


	ReadFieldPicFlag.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			field_pic_flag := 
				if(ValueOfVLD = 0) then
					false
				else
					true
				end;
			println("\t\tfield_pic_flag:   "+field_pic_flag);
		end


	FieldPicFlag.IsEqualToTrue: action
				==>
			//           bottom_field_flag
			SkipNal      :[   false   ],//Keep synchro
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     1     ]
		guard
			field_pic_flag = true
		end


	ReadBottomField.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			bottom_field_flag :=
				if(ValueOfVLD = 0)then
					false
				else
					true
				end;
			println("\t\tbottom_field_flag: "+bottom_field_flag);
		end


	IdrFlag.IsEqualToTrue: action
				==>
			//            idr_pic_id
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_UE ]
		guard
			Idr_flag = true
		end


	ReadIdrPicId.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			idr_pic_id := ValueOfVLD;
			println("\t\tidr_pic_id:       "+idr_pic_id);
		end


	PocType.IsEqualTo0: action
				==>
			//           pic_order_cnt_lsb
			SkipNal      :[    false    ],//Keep synchro
			TypeOfVLD    :[  READ_BITS  ],
			NbBitsToRead :[ SzMaxPocLsb ]
		guard
			pic_order_cnt_type = 0
		end

	ReadPocLsb.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			pic_order_cnt_lsb := ValueOfVLD;
			println("\t\tpic_order_cnt_lsb: "+ValueOfVLD);
		end



	Check_PicOrPres_FieldPic: action
				==>
			//     delta_pic_order_cnt_bottom
			//                or
			//      delta_pic_order_cnt[ 1 ]
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_SE ]
		guard
			pic_order_present_flag = true,
			field_pic_flag         = false
		end


	ReadDeltaPicOrderCntBottom.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			delta_pic_order_cnt_bottom := ValueOfVLD;
			println("\t\tdelta_pic_order_cnt_bottom: "+delta_pic_order_cnt_bottom);
		end


	ReadDeltaPicOrCnt0.Asked: action
				==>
			//      delta_pic_order_cnt[ 0 ]
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_SE ]
		guard
			pic_order_cnt_type               = 1,
			delta_pic_order_always_zero_flag = false
		end

	ReadDeltaPicOrCnt0.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			delta_pic_order_cnt[0] := ValueOfVLD;
			println("\t\tdelta_pic_order_cnt[0]: "+delta_pic_order_cnt[0]);
		end


	ReadDeltaPicOrCnt1.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			delta_pic_order_cnt[1] := ValueOfVLD;
			println("\t\tdelta_pic_order_cnt[1]: "+delta_pic_order_cnt[1]);
		end

	CalcPOC: action
			==>
/*		POC        :[POC_val],
		SizeDPBMax :[MaxDPBSz[sps_id]]
	guard
		first_mb_in_slice=0
	var 
		int PicOrderCntMsb,
		int TopFieldOrderCnt,
		int BottomFieldOrderCnt,
		int POC_val,
		int MaxPicOrderCntLsb = lshift(1, log2_max_pic_order_cnt_lsb_minus4[sps_id]+4),
		int frame_num_offset, 
		int abs_frame_num, 
		int expected_delta_per_poc_cycle := 0, 
		int expectedpoc := 0
*/	do
		//println("CalcPOC");
/*		if nal_unit_type = 5 then 
			frame_num_offset := 0;
		else 
			if frame_num < prev_frame_num then
				frame_num_offset := prev_frame_num_offset + lshift(1, 4+log2_max_frame_num_minus4[sps_id]);
			else
				frame_num_offset := prev_frame_num_offset;
			end
		end
		if pic_order_cnt_type[sps_id] = 0 then 
			if nal_unit_type = 5 then
				prevPicOrderCntMsb := 0;
				prevPicOrderCntLsb := 0;
			end
			if  (pic_order_cnt_lsb < prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) >= rshift(MaxPicOrderCntLsb, 1)) then
				PicOrderCntMsb :=  prevPicOrderCntMsb + MaxPicOrderCntLsb;
				prevPicOrderCntMsb := PicOrderCntMsb;
				prevPicOrderCntLsb := 0;
			else 
				if (pic_order_cnt_lsb > prevPicOrderCntLsb) and ((prevPicOrderCntLsb - pic_order_cnt_lsb) > rshift(MaxPicOrderCntLsb, 1)) then 
					PicOrderCntMsb := prevPicOrderCntMsb - MaxPicOrderCntLsb;
					prevPicOrderCntMsb := PicOrderCntMsb;
				else
					PicOrderCntMsb :=  prevPicOrderCntMsb;
				end
			end
			BottomFieldOrderCnt := PicOrderCntMsb + pic_order_cnt_lsb;
			TopFieldOrderCnt := BottomFieldOrderCnt;
		else
			if pic_order_cnt_type[sps_id] = 1 then
				abs_frame_num := if num_ref_frames_in_pic_order_cnt_cycle[sps_id] != 0 then frame_num_offset + frame_num else 0 end ;
				if nal_ref_idc = 0 and abs_frame_num > 0 then abs_frame_num := abs_frame_num -1; end
				foreach int i in 0 .. num_ref_frames_in_pic_order_cnt_cycle[sps_id]-1 do
					expected_delta_per_poc_cycle := expected_delta_per_poc_cycle + offset_for_ref_frame[sps_id][ i ];
				end
				if abs_frame_num > 0 then
					expectedpoc := expected_delta_per_poc_cycle * ((abs_frame_num - 1) / num_ref_frames_in_pic_order_cnt_cycle[sps_id]);
					foreach int i in 0 .. ((abs_frame_num - 1) mod num_ref_frames_in_pic_order_cnt_cycle[sps_id]) do
						expectedpoc := expectedpoc + offset_for_ref_frame[sps_id][ i ];
					end
				else
					expectedpoc :=0;
				end
				if nal_ref_idc = 0 then expectedpoc := expectedpoc + offset_for_non_ref_pic[sps_id]; end
				TopFieldOrderCnt := expectedpoc + delta_pic_order_cnt[0];
				BottomFieldOrderCnt := TopFieldOrderCnt + offset_for_top_to_bottom_field[sps_id] + delta_pic_order_cnt[1];
				if field_pic_flag = 1 then BottomFieldOrderCnt := BottomFieldOrderCnt +delta_pic_order_cnt[1]; end
			else // pic_order_cnt_type[sps_id] = 2
				TopFieldOrderCnt := if nal_unit_type = 5 then 0 else if nal_ref_idc > 0 then lshift(frame_num_offset + frame_num, 1) else lshift(frame_num_offset + frame_num, 1) - 1 end end;
				BottomFieldOrderCnt := TopFieldOrderCnt; 
			end 
		end
		POC_val := if TopFieldOrderCnt < BottomFieldOrderCnt then TopFieldOrderCnt else BottomFieldOrderCnt end ;
		prev_frame_num_offset := frame_num_offset;
		prev_frame_num := frame_num;
		prevPicOrderCntLsb := pic_order_cnt_lsb;
*/	end


	RedundPicCntPres.IsEqualToTrue: action
				==>
			//         redundant_pic_cnt
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_UE ]
		guard
			redundant_pic_cnt_present_flag = true
		end

	ReadRedunPicCnt.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			redundant_pic_cnt := ValueOfVLD;
			println("\t\tredundant_pic_cnt: "+redundant_pic_cnt);
		end

	RefPicList.GetVLDVal: action
			ValVLD           :[VLDecoding]
				==>
			RefPicListValVLD :[VLDecoding]
		end


	RefPicList.AskVLD: action
			RefPicListTypeOfVLD :[ValTypeOfVLD],
			RefPicListSkipNal   :[EndOfDecoding]
				==>
			TypeOfVLD           :[ValTypeOfVLD],
			SkipNal             :[false]
		guard
			ValTypeOfVLD  != READ_BITS,
			EndOfDecoding  = false
		end


	RefPicList.AskReadBits: action
			RefPicListTypeOfVLD    :[ValTypeOfVLD],
			RefPicListNbBitsToRead :[NbBits],
			RefPicListSkipNal      :[EndOfDecoding]
				==>
			TypeOfVLD              :[READ_BITS],
			NbBitsToRead           :[NbBits],
			SkipNal                :[false]
		guard
			ValTypeOfVLD  = READ_BITS,
			EndOfDecoding = false
		end


	RefPicList.Done: action
			RefPicListSkipNal :[EndOfDecoding]
				==>
		guard
			EndOfDecoding = true
		end

	DecRefPicMarking.GetVLDVal: action
			ValVLD           :[VLDecoding]
				==>
			DecRefPicMarkingValVLD :[VLDecoding]
		end


	DecRefPicMarking.AskVLD: action
			DecRefPicMarkingTypeOfVLD :[ValTypeOfVLD],
			DecRefPicMarkingSkipNal   :[EndOfDecoding]
				==>
			TypeOfVLD           :[ValTypeOfVLD],
			SkipNal             :[false]
		guard
			ValTypeOfVLD  != READ_BITS,
			EndOfDecoding  = false
		end


	DecRefPicMarking.AskReadBits: action
			DecRefPicMarkingTypeOfVLD    :[ValTypeOfVLD],
			DecRefPicMarkingNbBitsToRead :[NbBits],
			DecRefPicMarkingSkipNal      :[EndOfDecoding]
				==>
			TypeOfVLD              :[READ_BITS],
			NbBitsToRead           :[NbBits],
			SkipNal                :[false]
		guard
			ValTypeOfVLD  = READ_BITS,
			EndOfDecoding = false
		end


	DecRefPicMarking.Done: action
			DecRefPicMarkingSkipNal :[EndOfDecoding]
				==>
		guard
			EndOfDecoding = true
		end

	ReadCabacInitDc.Asked: action
				==>
			//           cabac_init_idc
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_UE ]
		guard
			entropy_coding_mode_flag  = true,
			slice_type               != SLICE_TYPE_I,
			slice_type               != SLICE_TYPE_SI
		end

	ReadCabacInitDc.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			cabac_init_idc := VLDecoding;
			println("\t\tcabac_init_idc: "+cabac_init_idc);
		end

	ReadSliceQpDelta.Asked: action
				==>
			//          slice_qp_delta
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_SE ]
		end

	ReadSliceQpDelta.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			slice_qp_delta := VLDecoding;
			println("\t\tslice_qp_delta: "+slice_qp_delta);
		end

	Slice_Type.IsEqualToSP: action
				==>
			//              sp_for_sw , slice_q
			SkipNal      :[   false   ,  false ],//Keep synchro
			TypeOfVLD    :[ READ_BITS , VLD_SE ],
			NbBitsToRead :[     1              ]
		guard
			slice_type = SLICE_TYPE_SP
		end

	ReadSliceSpParameters.Done: action
			ValVLD :[VLDecoding] repeat 2
				==>
		do
			sp_for_switch_flag :=
				if(VLDecoding[0] = 0)then
					false
				else
					true
				end;
			slice_qs_delta := VLDecoding[1];
			println("\t\tsp_for_switch_flag: "+sp_for_switch_flag);
			println("\t\tslice_qs_delta: "+slice_qs_delta);
		end

	Slice_Type.IsEqualToSI: action
				==>
			//          slice_qs_delta
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_SE ]
		guard
			slice_type = SLICE_TYPE_SP
		end

	ReadSliceSiParameters.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			slice_qs_delta := VLDecoding;
			println("\t\tslice_qs_delta: "+slice_qs_delta);
		end

	DeblocFilterPresent: action
				==>
			//          slice_qs_delta
			SkipNal      :[  false ],//Keep synchro
			TypeOfVLD    :[ VLD_UE ]
		guard
			deblocking_filter_control_present_flag = true
		end

	ReadDisDeblocFilterIdc.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			disable_deblocking_filter_idc := VLDecoding;
			println("\t\tdisable_deblocking_filter_idc: "+disable_deblocking_filter_idc);
		end

	DisDeblocFilterIdc.IsNotEqualTo1: action
				==>
			//              slice_ , slice_
			SkipNal      :[  false ,  false ],//Keep synchro
			TypeOfVLD    :[ VLD_SE , VLD_SE ]
		guard
			disable_deblocking_filter_idc != 1
		end

	ReadSliceAlphaAndBeta: action
			ValVLD :[VLDecoding] repeat 2
				==>
		do
			slice_alpha_c0_offset := VLDecoding[0];
			slice_beta_offset     := VLDecoding[1];
			println("\t\tslice_alpha_c0_offset: "+slice_alpha_c0_offset);
			println("\t\tslice_beta_offset: "+slice_beta_offset);
		end

	ReadSlcGrpChgCycl.Asked: action
				==>
			//            slice_group_change_cycle
			SkipNal      :[         false        ],//Keep synchro
			TypeOfVLD    :[       READ_BITS      ],
			NbBitsToRead :[ SzSliceGroupChgCycle ]
		guard
			num_slice_groups     >  1,
			slice_group_map_type >= 3,
			slice_group_map_type <= 5
		end

	ReadSlcGrpChgCycl.Done: action
			ValVLD :[VLDecoding]
				==>
		do
			slice_group_change_cycle := VLDecoding;
			println("\t\tslice_group_change_cycle: "+slice_group_change_cycle);
		end


	SendEndSliceHeader: action
				==>
			SkipNal :[true]
		end

/*   
*
* Scheduler
*
*/	

	schedule fsm ReadSliceTypeAsked:
		ReadSliceTypeAsked             (ReadSliceType.Asked               )--> ReadSliceTypeDone;

		ReadSliceTypeDone              (ReadSliceType.Done                )--> CheckSeparateColourPlane;

		CheckSeparateColourPlane       (SeparateColourPlane.IsEqualToTrue )--> undefined; //Not implemented yet
		CheckSeparateColourPlane       (ReadFrameNum.Asked                )--> ReadFrameNumDone;

		ReadFrameNumDone               (ReadFrameNum.Done                 )--> CheckFrameMbsOnly;

		CheckFrameMbsOnly              (FrameMbsOnly.IsEqualToFalse       )--> ReadFieldPicFlagDone;
		CheckFrameMbsOnly              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;
		CheckFrameMbsOnly              (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckFrameMbsOnly              (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckFrameMbsOnly              (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckFrameMbsOnly              (RefPicList.AskVLD                 )--> DecodeRefPicList;
		CheckFrameMbsOnly              (RefPicList.AskReadBits            )--> DecodeRefPicList;
		CheckFrameMbsOnly              (RefPicList.Done                   )-->                        DecodeDecRefPicMarking;//DecodeWeightedPred;
	

		ReadFieldPicFlagDone           (ReadFieldPicFlag.Done             )-->CheckFieldPicFlag;

		CheckFieldPicFlag              (FieldPicFlag.IsEqualToTrue        )--> ReadBottomFieldDone;
		CheckFieldPicFlag              (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;
		CheckFieldPicFlag              (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckFieldPicFlag              (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckFieldPicFlag              (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckFieldPicFlag              (RefPicList.AskVLD                 )--> DecodeRefPicList;
		CheckFieldPicFlag              (RefPicList.AskReadBits            )--> DecodeRefPicList;
		CheckFieldPicFlag              (RefPicList.Done                   )-->                            DecodeDecRefPicMarking;//DecodeWeightedPred;

		ReadBottomFieldDone            (ReadBottomField.Done              )-->CheckIdrFlag;

		CheckIdrFlag                   (IdrFlag.IsEqualToTrue             )--> ReadIdrPicIdDone;
		CheckIdrFlag                   (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckIdrFlag                   (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckIdrFlag                   (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckIdrFlag                   (RefPicList.AskVLD                 )--> DecodeRefPicList;
		CheckIdrFlag                   (RefPicList.AskReadBits            )--> DecodeRefPicList;
		CheckIdrFlag                   (RefPicList.Done                   )-->                             DecodeDecRefPicMarking;//DecodeWeightedPred;

		ReadIdrPicIdDone               (ReadIdrPicId.Done                 )--> CheckPocType;

		CheckPocType                   (PocType.IsEqualTo0                )--> ReadPocLsbDone;
		CheckPocType                   (ReadDeltaPicOrCnt0.Asked          )--> ReadDeltaPicOrCnt0Done;
		CheckPocType                   (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckPocType                   (RefPicList.AskVLD                 )--> DecodeRefPicList;
		CheckPocType                   (RefPicList.AskReadBits            )--> DecodeRefPicList;
		CheckPocType                   (RefPicList.Done                   )-->                            DecodeDecRefPicMarking;//DecodeWeightedPred;

		ReadPocLsbDone                 (ReadPocLsb.Done                   )--> Check4DeltPicOrdCntBot;

		Check4DeltPicOrdCntBot         (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrderCntBottomDone;
		Check4DeltPicOrdCntBot         (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		Check4DeltPicOrdCntBot         (RefPicList.AskVLD                 )--> DecodeRefPicList;
		Check4DeltPicOrdCntBot         (RefPicList.AskReadBits            )--> DecodeRefPicList;
		Check4DeltPicOrdCntBot         (RefPicList.Done                   )-->                            DecodeDecRefPicMarking;//DecodeWeightedPred;

		ReadDeltaPicOrderCntBottomDone (ReadDeltaPicOrderCntBottom.Done   )--> CheckRedundPicCntPres;

		ReadDeltaPicOrCnt0Done         (ReadDeltaPicOrCnt0.Done           )--> Check4DeltaPicOrCnt1;

		Check4DeltaPicOrCnt1           (Check_PicOrPres_FieldPic          )--> ReadDeltaPicOrCnt1Done;
		Check4DeltaPicOrCnt1           (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		Check4DeltaPicOrCnt1           (RefPicList.AskVLD                 )--> DecodeRefPicList;
		Check4DeltaPicOrCnt1           (RefPicList.AskReadBits            )--> DecodeRefPicList;
		Check4DeltaPicOrCnt1           (RefPicList.Done                   )-->                            DecodeDecRefPicMarking;//DecodeWeightedPred;

		ReadDeltaPicOrCnt1Done         (ReadDeltaPicOrCnt1.Done           )--> CheckRedundPicCntPres;

		CheckRedundPicCntPres          (RedundPicCntPres.IsEqualToTrue    )--> ReadRedunPicCntDone;
		CheckRedundPicCntPres          (RefPicList.AskVLD                 )--> DecodeRefPicList;
		CheckRedundPicCntPres          (RefPicList.AskReadBits            )--> DecodeRefPicList;
		CheckRedundPicCntPres          (RefPicList.Done                   )-->                           DecodeDecRefPicMarking;//DecodeWeightedPred;

		ReadRedunPicCntDone            (ReadRedunPicCnt.Done              )--> DecodeRefPicList;

		DecodeRefPicList               (RefPicList.GetVLDVal              )--> DecodeRefPicList;
		DecodeRefPicList               (RefPicList.AskVLD                 )--> DecodeRefPicList;
		DecodeRefPicList               (RefPicList.AskReadBits            )--> DecodeRefPicList;
		DecodeRefPicList               (RefPicList.Done                   )-->                            DecodeDecRefPicMarking;//DecodeWeightedPred;


		//DecodeWeightedPred           (WeightedPred.GetVLDVal            )--> DecodeWeightedPred;
		//DecodeWeightedPred           (WeightedPred.AskVLD               )--> DecodeWeightedPred;
		//DecodeWeightedPred           (WeightedPred.AskReadBits          )--> DecodeWeightedPred;
		//DecodeWeightedPred           (WeightedPred.Done                 )--> DecodeDecRefPicMarking;


		DecodeDecRefPicMarking         (DecRefPicMarking.GetVLDVal        )--> DecodeDecRefPicMarking;
		DecodeDecRefPicMarking         (DecRefPicMarking.AskVLD           )--> DecodeDecRefPicMarking;
		DecodeDecRefPicMarking         (DecRefPicMarking.AskReadBits      )--> DecodeDecRefPicMarking;
		DecodeDecRefPicMarking         (DecRefPicMarking.Done             )--> CheckEntropyCodingMode;

		CheckEntropyCodingMode         (ReadCabacInitDc.Asked             )--> ReadCabacInitIdc;
		CheckEntropyCodingMode         (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadCabacInitIdc               (ReadCabacInitDc.Done              )--> ReadSliceQpDeltaAsked;

		ReadSliceQpDeltaAsked          (ReadSliceQpDelta.Asked            )--> ReadSliceQpDeltaDone;

		ReadSliceQpDeltaDone           (ReadSliceQpDelta.Done             )--> CheckSliceType;

		CheckSliceType                 (Slice_Type.IsEqualToSP            )--> ReadSliceSpParameters;
		CheckSliceType                 (Slice_Type.IsEqualToSI            )--> ReadSliceSiParameters;
		CheckSliceType                 (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckSliceType                 (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckSliceType                 (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadSliceSpParameters          (ReadSliceSpParameters.Done        )--> CheckDeblocFilterControl;

		ReadSliceSiParameters          (ReadSliceSiParameters.Done        )--> CheckDeblocFilterControl;

		CheckDeblocFilterControl       (DeblocFilterPresent               )--> ReadDisDeblocFilterIdc;
		CheckDeblocFilterControl       (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDeblocFilterControl       (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadDisDeblocFilterIdc         (ReadDisDeblocFilterIdc.Done       )--> CheckDisDeblocFilterIdc;

		CheckDisDeblocFilterIdc        (DisDeblocFilterIdc.IsNotEqualTo1  )--> ReadSliceAlphaAndBeta;
		CheckDisDeblocFilterIdc        (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckDisDeblocFilterIdc        (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadSliceAlphaAndBeta          (ReadSliceAlphaAndBeta             )--> CheckNumSliceGroups;

		CheckNumSliceGroups            (ReadSlcGrpChgCycl.Asked           )--> ReadSlcGrpChgCycl;
		CheckNumSliceGroups            (SendEndSliceHeader                )--> ReadSliceTypeAsked;

		ReadSlcGrpChgCycl              (ReadSlcGrpChgCycl.Done            )--> EndSliceHeader;

		EndSliceHeader                 (SendEndSliceHeader                )--> ReadSliceTypeAsked;
	end

	priority
		SeparateColourPlane              > ReadFrameNum;
		FrameMbsOnly.IsEqualToFalse      > IdrFlag.IsEqualToTrue;
		FieldPicFlag.IsEqualToTrue       > IdrFlag.IsEqualToTrue;
		IdrFlag.IsEqualToTrue            > PocType.IsEqualTo0;
		PocType.IsEqualTo0               > ReadDeltaPicOrCnt0.Asked;
		ReadDeltaPicOrCnt0.Asked         > RedundPicCntPres.IsEqualToTrue;
		Check_PicOrPres_FieldPic         > RedundPicCntPres.IsEqualToTrue;
		RedundPicCntPres.IsEqualToTrue   > RefPicList.AskVLD;
		RefPicList.GetVLDVal             > RefPicList.AskVLD              > RefPicList.AskReadBits       > RefPicList.Done;
		DecRefPicMarking.GetVLDVal       > DecRefPicMarking.AskVLD        > DecRefPicMarking.AskReadBits > DecRefPicMarking.Done;
		ReadCabacInitDc.Asked            > ReadSliceQpDelta.Asked;
		Slice_Type.IsEqualToSP           > Slice_Type.IsEqualToSI         > DeblocFilterPresent;
		DeblocFilterPresent              > ReadSlcGrpChgCycl.Asked;
		DisDeblocFilterIdc.IsNotEqualTo1 > ReadSlcGrpChgCycl.Asked;
		ReadSlcGrpChgCycl.Asked          > SendEndSliceHeader;
	end
end
