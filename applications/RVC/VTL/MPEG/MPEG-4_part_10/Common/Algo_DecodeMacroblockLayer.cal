/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_DecodeMacroblockLayer()
	int (size=32) ValVLD,
	uint(size=4)  SliceType,
	//Pps parameters
	bool          Transform8x8Mode,
	uint(size=5)  NumRefIdxLXActive,
	bool          EntropyCodingMode,
	int (size=5)  ChromaQpIdxOffset,
	//Sps parameters
	uint(size=4)  BitDepthLuma,
	uint(size=4)  BitDepthChroma,
	bool          Direct8x8Inference,
	uint(size=2)  Num_C8x8,

	uint(size=4) SubMbType,

	uint(size=2)  ChromaArrayType,
	bool          MbFieldDecoding,
	uint(size=5)  NATab,
	uint(size=5)  NBTab,
	bool          LeftMbExists,
	bool          AboveMbExists,
	int (size=8)  ValQp,

	uint(size=5)  Total_CoeffLuma,
	uint(size=5)  Total_CoeffChroma
		==>
	uint(size=3)  TypeOfVLD,
	int (size=32) NbBitsToRead,
	bool          SkipNal,
	uint(size=4)  LaunchActor,

	//MbPred parameters
	uint(size=4)  MbPredSliceType,
	uint(size=6)  MbPredMbType,
	bool          MbPredTransfSz8x8,
	uint(size=2)  MbPredChromaArrayType,
	uint(size=5)  MbPredNumRefIdxLXActive,
	bool          MbPredMbFieldDecoding,

	//SubMbPred parameters
	uint(size=4)  SubMbPredSliceType,
	uint(size=6)  SubMbPredMbType,
	uint(size=5)  SubMbPredNumRefIdxLXActive,
	bool          SubMbPredMbFieldDecoding,

	//Residual Parameters
	bool          ResEntropyCodingMode,
	uint(size=4)  ResSliceType,
	uint(size=6)  ResMbType,
	bool          ResTransfSz8x8,
	bool          ResBmFlag,
	uint(size=4)  ResStartIdx,
	uint(size=4)  ResEndIdx,
	uint(size=6)  ResCodBlkPatnLm,
	uint(size=6)  ResCodBlkPatnChm,
	uint(size=5)  ResNATab,
	uint(size=5)  ResNBTab,
	bool          ResLeftMbExists,
	bool          ResAboveMbExists,
	uint(size=2)  ResChromaArrayType,
	uint(size=2)  ResNumC8x8,

	uint(size=5)  SData_Total_CoeffLuma,
	uint(size=5)  SData_Total_CoeffChroma,

	uint(size=6) MbType,
	bool         MergeTransfSz8x8,
	int(size=9)  pix_I_PCM_Y,
	int(size=9)  pix_I_PCM_U,
	int(size=9)  pix_I_PCM_V,

	uint(size=5)  NbCoeffInMB,
	bool          SkipMacroBlk,
	bool          IsIPCM,
	uint(size=16) cbp_blk,
	int (size=8)  Qp_Y_Cb_Cr
		:


/*
*
* Constants
*
*/

	uint(size=3) READ_BITS             = 0;
	uint(size=3) VLD_UE                = 1;
	uint(size=3) VLD_SE                = 2;
	uint(size=3) BYTE_ALIGNED_REQUIRED = 3;
//	uint(size=3) MORE_RBSP_DATA        = 4;

	uint(size=4) MB_LAYER            = 4;
	uint(size=4) SUB_MB_PRED         = 5;
	uint(size=4) MB_PRED             = 6;
	uint(size=4) RESIDUAL            = 7;

	uint(size=4) SLICE_TYPE_P  = 0;
	uint(size=4) SLICE_TYPE_B  = 1;
	uint(size=4) SLICE_TYPE_I  = 2;
	uint(size=4) SLICE_TYPE_SP = 3;
	uint(size=4) SLICE_TYPE_SI = 4;


	uint(size=6) BLOCK_TYPE_I_8x8_or_4x4   = 0;
	uint(size=6) BLOCK_TYPE_INTRA_16x16_MIN = 1;
	uint(size=6) BLOCK_TYPE_INTRA_16x16_MAX = 24;
	uint(size=6) BLOCK_TYPE_I_PCM          = 25;

	List(type: uint(size=4), size=8) TabCodedBlockPatternChroma = [  0,  1,  2,  0,  1,  2,  0,  0];
	List(type: uint(size=4), size=8) TabCodedBlockPatternLuma   = [  0,  0,  0, 15, 15, 15,  0,  0];
	List(type: uint(size=4), size=16) InverseScan4x4Tab         = [ 0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15 ];

	List ( type: List ( type: List ( type: uint(size=6), size=2), size=48 ), size=4) VLD_ME_TABLE =
		[
			[[15, 0], [ 0, 1], [ 7, 2], [11, 4], [13, 8], [14, 3], [ 3, 5], [ 5,10], [10,12], [12,15],
			 [ 1, 7], [ 2,11], [ 4,13], [ 8,14], [ 6, 6], [ 9, 9]
			],
			[[47, 0], [31,16], [15, 1], [ 0, 2], [23, 4], [27, 8], [29,32], [30, 3], [ 7, 5], [11, 10],
			 [13,12], [14,15], [39,47], [43, 7], [45,11], [46,13], [16,14], [ 3, 6], [ 5, 9], [10,31],
			 [12,35], [19,37], [21,42], [26,44], [28,33], [35,34], [37,36], [42,40], [44,39], [ 1,43],
			 [ 2,45], [ 4,46], [ 8,17], [17,18], [18,20], [20,24], [24,19], [ 6,21], [ 9,26], [22,28],
			 [25,23], [32,27], [33,29], [34,30], [36,22], [40,25], [38,38], [41,41]
			],
			[[47, 0], [31,16], [15, 1], [ 0, 2], [23, 4], [27, 8], [29,32], [30, 3], [ 7, 5], [11, 10],
			 [13,12], [14,15], [39,47], [43, 7], [45,11], [46,13], [16,14], [ 3, 6], [ 5, 9], [10,31],
			 [12,35], [19,37], [21,42], [26,44], [28,33], [35,34], [37,36], [42,40], [44,39], [ 1,43],
			 [ 2,45], [ 4,46], [ 8,17], [17,18], [18,20], [20,24], [24,19], [ 6,21], [ 9,26], [22,28],
			 [25,23], [32,27], [33,29], [34,30], [36,22], [40,25], [38,38], [41,41]
			],
			[[15, 0], [ 0, 1], [ 7, 2], [11, 4], [13, 8], [14, 3], [ 3, 5], [ 5,10], [10,12], [12,15],
			 [ 1, 7], [ 2,11], [ 4,13], [ 8,14], [ 6, 6], [ 9, 9]
			]
		];

	List (type:uint(size=6),size=64) QP_TAB := 
		[
			 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
			10,11,12,13,14,15,16,17,18,19,
			20,21,22,23,24,25,26,27,28,29,
			29,30,31,32,32,33,34,34,35,35,
			36,36,37,37,37,38,38,38,39,39,
			39,39,39,39,39,39,39,39,42,42,
			42,42,42,42
		];

	bool DEBUG_FLAG_DECODED = false;


	uint(size=6)  mb_type                        := 0;
	bool          noSubMbPartSizeLessThan8x8Flag := true;
	bool          transform_size_8x8_flag        := true;
	uint(size=6)  coded_block_pattern            := 0;
	uint(size=6)  CodedBlockPatternLuma          := 0;
	uint(size=6)  CodedBlockPatternChroma        := 0;
	//int (size=32) mb_qp_delta                    := 0;
	bool          entropy_coding_mode_flag;
	//SliceData Parameters
	uint(size=4)  slice_type;
	uint(size=4)  bit_depth_luma;
	uint(size=4)  bit_depth_chroma;
	bool          direct_8x8_inference_flag;
	bool          transform_8x8_mode_flag;
	uint(size=2)  Chroma_Array_Type;
	uint(size=5)  num_ref_idx_l0_active;
	uint(size=5)  num_ref_idx_l1_active;
	bool          mb_field_decoding;
	List(type: uint(size=5), size=12) nATab;
	List(type: uint(size=5), size=12) nBTab;
	bool          LeftMb_Exists;
	bool          AboveMb_Exists;
	uint(size=2)  NumC8x8;
	int (size=8)  QpValue;
	int (size=8)  Qp_CbValue;
	int (size=8)  Qp_CrValue;
	int (size=5)  chroma_qp_index_offset;
	int (size=5)  second_chroma_qp_index_offset;


	function Is_Intra_16x16(uint MbType)
				-->
			bool
		:
			if((slice_type = SLICE_TYPE_SI) or (slice_type = SLICE_TYPE_I)) then
				if( (MbType >= BLOCK_TYPE_INTRA_16x16_MIN) and (MbType <= BLOCK_TYPE_INTRA_16x16_MAX)) then
					true
				else
					false
				end
			else
				if(slice_type != SLICE_TYPE_B) then
					if( ((MbType-5) >= BLOCK_TYPE_INTRA_16x16_MIN) and ((MbType-5) <= BLOCK_TYPE_INTRA_16x16_MAX)) then
						true
					else
						false
					end
				else
					if( ((MbType-5-23) >= BLOCK_TYPE_INTRA_16x16_MIN) and ((MbType-5-23) <= BLOCK_TYPE_INTRA_16x16_MAX)) then
						true
					else
						false
					end
				end
			end
		end

	function Is_Intra_8x8(uint MbType)
				-->
			bool
		:
			if((slice_type = SLICE_TYPE_SI) or (slice_type = SLICE_TYPE_I)) then
				if( (MbType = BLOCK_TYPE_I_8x8_or_4x4) and transform_size_8x8_flag ) then
					true
				else
					false
				end
			else
				if(slice_type != SLICE_TYPE_B) then
					if( ((MbType-5) = BLOCK_TYPE_I_8x8_or_4x4) and transform_size_8x8_flag ) then
						true
					else
						false
					end
				else
					if( ((MbType-5-23) = BLOCK_TYPE_I_8x8_or_4x4) and transform_size_8x8_flag ) then
						true
					else
						false
					end
				end
			end
		end

	function Is_Intra_4x4(uint MbType)
				-->
			bool
		:
			if((slice_type = SLICE_TYPE_SI) or (slice_type = SLICE_TYPE_I)) then
				if( (MbType = BLOCK_TYPE_I_8x8_or_4x4) and  (not transform_size_8x8_flag) ) then
					true
				else
					false
				end
			else
				if(slice_type != SLICE_TYPE_B) then
					if( ((MbType-5) = BLOCK_TYPE_I_8x8_or_4x4) and (not transform_size_8x8_flag) ) then
						true
					else
						false
					end
				else
					if( ((MbType-5-23) = BLOCK_TYPE_I_8x8_or_4x4) and (not transform_size_8x8_flag) ) then
						true
					else
						false
					end
				end
			end
		end

	ReadMbType.Asked: action
				==>
			//              mb_type
			SkipNal      :[   false  ],//Keep synchro
			TypeOfVLD    :[  VLD_UE  ],
			LaunchActor  :[ MB_LAYER ]
		end

	ReadMbType.Done: action
			ValVLD             :[ValueOfVLD],
			SliceType          :[ValSliceType],
			BitDepthLuma       :[ValBitDepthLuma],
			BitDepthChroma     :[ValBitDepthChroma],
			Direct8x8Inference :[ValDirect8x8Inference],
			Transform8x8Mode   :[ValTransform8x8Mode],
			ChromaArrayType    :[ValChromaArrayType],
			NumRefIdxLXActive  :[ValNumRefIdxLXActive] repeat 2,
			MbFieldDecoding    :[ValMbFieldDecoding],
			EntropyCodingMode  :[ValEntropyCodingMode],
			NATab              :[ValNATab] repeat 12,
			NBTab              :[ValNBTab] repeat 12,
			LeftMbExists       :[ValLeftMbExists],
			AboveMbExists      :[ValAboveMbExists],
			Num_C8x8           :[ValNum_C8x8],
			ValQp              :[Val_Qp],
			ChromaQpIdxOffset  :[ ValChrmQpIdxOff , Val2ndChrmQpIdxOff ]
				==>
			MbType             :[ValMbType],
			MergeTransfSz8x8   :[ValTransform8x8Mode]
		var
			uint         Idx,
			uint(size=6) ValMbType
		do
			mb_type                       := ValueOfVLD;
			slice_type                    := ValSliceType;
			bit_depth_luma                := ValBitDepthLuma;
			bit_depth_chroma              := ValBitDepthChroma;
			direct_8x8_inference_flag     := ValDirect8x8Inference;
			transform_8x8_mode_flag       := ValTransform8x8Mode;
			Chroma_Array_Type             := ValChromaArrayType;
			num_ref_idx_l0_active         := ValNumRefIdxLXActive[0];
			num_ref_idx_l1_active         := ValNumRefIdxLXActive[1];
			mb_field_decoding             := ValMbFieldDecoding;
			entropy_coding_mode_flag      := ValEntropyCodingMode;
			LeftMb_Exists                 := ValLeftMbExists;
			AboveMb_Exists                := ValAboveMbExists;
			NumC8x8                       := ValNum_C8x8;
			QpValue                       := Val_Qp;
			chroma_qp_index_offset        := ValChrmQpIdxOff;
			second_chroma_qp_index_offset := Val2ndChrmQpIdxOff;
			Qp_CbValue                    := QP_TAB[(QpValue + chroma_qp_index_offset) & 0x3F];
			Qp_CrValue                    := QP_TAB[(QpValue + second_chroma_qp_index_offset) & 0x3F];
			foreach int i in 0 .. 11
			do
				nATab[i] := ValNATab[i];
				nBTab[i] := ValNBTab[i];
			end
			//mb_type should have the same value in order to simplify : if(slice_type=stuff)then if(mb_type > other_stuff)then ...
			ValMbType :=
				if(slice_type=SLICE_TYPE_I or slice_type = SLICE_TYPE_SI)then
					mb_type
				else
					if(slice_type != SLICE_TYPE_B)then
						if(mb_type > 4)then
							mb_type - 5
						else
							mb_type + 26
						end
					else
						if(mb_type <= 22)then
							mb_type + 26 + 5
						else
							if(mb_type <= (22+5))then
								mb_type - 23 + 26
							else
								mb_type - 23 - 5
							end
						end
					end
				end;

			transform_size_8x8_flag        := false;
			noSubMbPartSizeLessThan8x8Flag := true;
			if(DEBUG_FLAG_DECODED)then
				println("mb_type : "+ValueOfVLD);
			end
			Idx := 
				if(slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI)then
					(mb_type-1)/4
				else
					if(slice_type != SLICE_TYPE_B)then
						(mb_type-1-5)/4
					else
						(mb_type-1 - 5 - 23)/4
					end
				end;
			CodedBlockPatternLuma   := TabCodedBlockPatternLuma[Idx & 7];
			CodedBlockPatternChroma := TabCodedBlockPatternChroma[Idx & 7];
			coded_block_pattern     := CodedBlockPatternLuma + CodedBlockPatternChroma * 16;
		end

	CheckMbType.IsIPCM: action
				==>
			//    pcm_alignment_zero_bit , pcm_sample_luma[ i ]
			SkipNal      :[     FalseTab      ] repeat 257,//Keep synchro
			LaunchActor  :[     LaunchTab     ] repeat 257,
			TypeOfVLD    :[   ValTypeOfVLD    ] repeat 257,
			//Orcc doesn't support it yet :
			//TypeOfVLD    :[ [BYTE_ALIGNED_REQUIRED] +  [ValTypeOfVLDecod]repeat 256 ],
			NbBitsToRead :[ BitDepthChromaTab ] repeat 256,

			SData_Total_CoeffLuma  :[[16: for int s in 0 .. 15]] repeat 16,	
			SData_Total_CoeffChroma:[[16: for int s in 0 .. 31]] repeat 32,

			IsIPCM :[true]
		guard
			    (slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI)
			and (mb_type = BLOCK_TYPE_I_PCM)
		var
			List(type: bool        , size=257) FalseTab           = [false            : for int s in 0 .. 256],
			List(type: uint(size=4), size=257) LaunchTab          = [MB_LAYER         : for int s in 0 .. 256],
			List(type: uint(size=3), size=257) ValTypeOfVLD      := [READ_BITS        : for int s in 0 .. 256],
			//List(type: uint(size=3), size=256) ValTypeOfVLDecod   = [READ_BITS        : for int s in 0 .. 255],
			List(type: uint(size=5), size=256) BitDepthChromaTab  = [bit_depth_chroma : for int s in 0 .. 255]
		do
			if(DEBUG_FLAG_DECODED)then
				println("IsIPCM");
			end
			ValTypeOfVLD[0] := BYTE_ALIGNED_REQUIRED;
		end

	ReadPcmSampleLuma.Done: action
			ValVLD       :[ValueOfVLD] repeat 256
				==>
			pix_I_PCM_Y  :[ValueOfVLD] repeat 256
		do
			if(DEBUG_FLAG_DECODED)then
				println("");
				/* Forward to the output for the pcm decoding */
				foreach int a in 0 .. 255
				do
					println("\t\tpcm_sample_luma[" + a + "] : " + ValueOfVLD[a]);
				end
				println("");
			end
		end

	ReadPcmSampleLuma.Asked: action
				==>
			//            pcm_sample_chroma[ i ]
			SkipNal      :[     FalseTab      ] repeat 256,//Keep synchro
			LaunchActor  :[     LaunchTab     ] repeat 256,
			TypeOfVLD    :[    ReadBitsTab    ] repeat 256,
			NbBitsToRead :[ BitDepthChromaTab ] repeat 256
			// Size is not always 256. Should be corrected and the value should be compute in Pps or Sps actor
		var
			List(type: bool        , size=256) FalseTab          = [false            : for int s in 0 .. 255],
			List(type: uint(size=4), size=256) LaunchTab         = [MB_LAYER         : for int s in 0 .. 255],
			List(type: uint(size=3), size=256) ReadBitsTab       = [READ_BITS        : for int s in 0 .. 255],
			List(type: uint(size=5), size=256) BitDepthChromaTab = [bit_depth_chroma : for int s in 0 .. 255]
		end

	ReadPcmSampleChroma.UComponent: action
			ValVLD       :[ValueOfVLD] repeat 256
				==>
			pix_I_PCM_U  :[ValueOfVLD] repeat 256
		do
			if(DEBUG_FLAG_DECODED)then
				/* Forward to the output for the pcm decoding */
				foreach int a in 0 .. 255
				do
					println("\t\tpcm_sample_chroma1[" + a + "] : " + ValueOfVLD[a]);
				end
				println("");
			end
		end

	ReadPcmSampleChroma.VComponent: action
			ValVLD       :[ValueOfVLD] repeat 256
				==>
			pix_I_PCM_V  :[ValueOfVLD] repeat 256
		do
			if(DEBUG_FLAG_DECODED)then
				/* Forward to the output for the pcm decoding */
				foreach int a in 0 .. 255
				do
					println("\t\tpcm_sample_chroma2[" + a + "] : " + ValueOfVLD[a]);
				end
				println("");
			end
		end

	CheckMbType.IsNotIPCM: action
				==>
			NbCoeffInMB :[NbCoeff],
			IsIPCM      :[false]
		var
			uint(size=5) NbCoeff
		do
			NbCoeff := 16 + 1 + 1 + 4 + 4; // 16 Luma AC + 1 * 2 Chroma DC + 4 * 2 Chroma AC
			if(Is_Intra_16x16(mb_type))then
				NbCoeff := NbCoeff + 1;// 1 Luma DC
			end
		end

	LaunchSubMbPred: action
				==>
			SkipNal     :[   false   ],
			LaunchActor :[SUB_MB_PRED],

			SubMbPredSliceType         :[slice_type],
			SubMbPredMbType            :[mb_type],
			SubMbPredNumRefIdxLXActive :[num_ref_idx_l0_active , num_ref_idx_l1_active],
			SubMbPredMbFieldDecoding   :[mb_field_decoding]
		guard
			(slice_type = SLICE_TYPE_P or slice_type = SLICE_TYPE_SP) and (mb_type = 3 or mb_type = 4)
			// slice_type = SLICE_TYPE_B ...
		end

	CheckSubMbType: action
			SubMbType :[sub_mb_type] repeat 4
				==>
		do
			if(slice_type = SLICE_TYPE_B) then
				foreach int mbPartIdx in 0 .. 3
				do
					if(sub_mb_type[mbPartIdx] > 3)then
						noSubMbPartSizeLessThan8x8Flag := false;
					else
						if((sub_mb_type[mbPartIdx] = 0) and (not direct_8x8_inference_flag))then
							noSubMbPartSizeLessThan8x8Flag := false;
						end
					end
				end
			else
				if((slice_type = SLICE_TYPE_P) or (slice_type = SLICE_TYPE_SP))then
					foreach int mbPartIdx in 0 .. 3
					do
						if(sub_mb_type[mbPartIdx] != 0)then
							noSubMbPartSizeLessThan8x8Flag := false;
						end
					end
				end
			end
		end

	ReadTransformSize.Asked: action
			==>
			//        transform_size_8x8_flag
			SkipNal      :[   false   ],//Keep synchro
			LaunchActor  :[ MB_LAYER  ],
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     1     ]
		guard
			transform_8x8_mode_flag = true,
			(slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI) and mb_type = 0
		do
			println("ReadTransformSize.Asked not implemented yet");
		end

	LaunchMbPred: action
				==>
			SkipNal                 :[  false  ],
			LaunchActor             :[ MB_PRED ],

			MbPredSliceType         :[slice_type],
			MbPredMbType            :[mb_type],
			MbPredTransfSz8x8       :[transform_size_8x8_flag],
			MbPredChromaArrayType   :[Chroma_Array_Type],
			MbPredNumRefIdxLXActive :[num_ref_idx_l0_active , num_ref_idx_l1_active],
			MbPredMbFieldDecoding   :[mb_field_decoding]
		end

	ReadCodedBlockPattern.Asked: action
				==>
			//        coded_block_pattern
			SkipNal      :[  false   ],//Keep synchro
			LaunchActor  :[ MB_LAYER ],
			TypeOfVLD    :[  VLD_UE  ] //VLD_ME
		guard
			not(Is_Intra_16x16(mb_type))
		end

	ReadCodedBlockPattern.Done: action
			ValVLD :[CodeNum]
				==>
		do
			coded_block_pattern :=
				if( Is_Intra_4x4(mb_type) or Is_Intra_8x8(mb_type) )then
					VLD_ME_TABLE[Chroma_Array_Type][CodeNum][0]
				else
					VLD_ME_TABLE[Chroma_Array_Type][CodeNum][1]
				end;
			CodedBlockPatternLuma   := coded_block_pattern mod 16;
			CodedBlockPatternChroma := coded_block_pattern  /  16;
			if(DEBUG_FLAG_DECODED)then
				println("coded_block_pattern : "+coded_block_pattern);
			end
		end

	ReadTransformSize8x8.Asked: action
				==>
			//        transform_size_8x8_flag
			SkipNal      :[   false   ],//Keep synchro
			LaunchActor  :[ MB_LAYER  ],
			TypeOfVLD    :[ READ_BITS ],
			NbBitsToRead :[     1     ]
		guard
			CodedBlockPatternLuma > 0,
			transform_8x8_mode_flag = true,
			not( (slice_type = SLICE_TYPE_I or slice_type = SLICE_TYPE_SI) and mb_type = 0 ),
			noSubMbPartSizeLessThan8x8Flag = true,
			not( (slice_type = SLICE_TYPE_B) and (mb_type = 0) ) or (direct_8x8_inference_flag = true)
		end

	ReadTransformSize8x8.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			transform_size_8x8_flag :=
				if(ValueOfVLD = 0) then
					false
				else
					true
				end;
		end

	ReadMbQpDelta.Asked: action
				==>
			//            mb_qp_delta
			SkipNal      :[  false   ],//Keep synchro
			LaunchActor  :[ MB_LAYER ],
			TypeOfVLD    :[  VLD_SE  ]
		guard
			   (CodedBlockPatternLuma   > 0)
			or (CodedBlockPatternChroma > 0)
			or Is_Intra_16x16(mb_type)
		end

	ReadMbQpDelta.Done: action
			ValVLD :[ValueOfVLD]
				==>
			Qp_Y_Cb_Cr :[QpValue , Qp_CbValue , Qp_CrValue]
		do
			if(DEBUG_FLAG_DECODED)then
				println("mb_qp_delta : "+ValueOfVLD);
			end
			//mb_qp_delta := ValueOfVLD;
			QpValue    := (QpValue + ValueOfVLD + 52) mod 52;
			Qp_CbValue := QP_TAB[(QpValue + chroma_qp_index_offset) & 0x3F];
			Qp_CrValue := QP_TAB[(QpValue + second_chroma_qp_index_offset) & 0x3F];
		end

	LaunchResidual: action
				==>
			SkipNal              :[  false   ],
			LaunchActor          :[ RESIDUAL ],

			ResEntropyCodingMode :[entropy_coding_mode_flag],
			ResSliceType         :[slice_type],
			ResMbType            :[mb_type],
			ResTransfSz8x8       :[transform_size_8x8_flag],
			ResBmFlag            :[false],
			ResStartIdx          :[0],
			ResEndIdx            :[15],
			ResCodBlkPatnLm      :[CodedBlockPatternLuma],
			ResCodBlkPatnChm     :[CodedBlockPatternChroma],
			ResNATab             :[nATab] repeat 12,
			ResNBTab             :[nBTab] repeat 12,
			ResLeftMbExists      :[LeftMb_Exists],
			ResAboveMbExists     :[AboveMb_Exists],
			ResChromaArrayType   :[Chroma_Array_Type],
			ResNumC8x8           :[NumC8x8],

			SkipMacroBlk         :[false]
		end

	GetResidualCoeffToken: action
			Total_CoeffLuma  :[CoLu]    repeat 16,
			Total_CoeffChroma:[CoLuChe] repeat 32//It's the story of a guy, a normal guy ...
				==>
			SData_Total_CoeffLuma  :[CoLu]    repeat 16,
			SData_Total_CoeffChroma:[CoLuChe] repeat 32,

			cbp_blk :[CbpBlk]
		var
			uint(size=16) CbpBlk := 0
		do
			foreach int i in 0 .. 15
			do
				CbpBlk := CbpBlk << 1;
				if(CoLu[InverseScan4x4Tab[15 - i]] > 0)then
					CbpBlk := CbpBlk + 1;
				end
			end
		end

	NoResidual: action
				==>
			SData_Total_CoeffLuma   :[[0: for int s in 0 .. 15]] repeat 16,
			SData_Total_CoeffChroma :[[0: for int s in 0 .. 31]] repeat 32,
			SkipMacroBlk            :[true],
			Qp_Y_Cb_Cr              :[QpValue , Qp_CbValue , Qp_CrValue]
		end

	SendEndSliceHeader: action
				==>
			SkipNal :[true]
		end

	schedule fsm ReadMbType_Asked:
		ReadMbType_Asked          (ReadMbType.Asked               )--> ReadMbType;

		ReadMbType                (ReadMbType.Done                )--> CheckMbType;

		CheckMbType               (CheckMbType.IsIPCM             )--> ReadPcmSampleLuma;
		CheckMbType               (CheckMbType.IsNotIPCM          )--> CheckMbPred;

		CheckMbPred               (LaunchSubMbPred                )--> CheckSubMbType;
		CheckMbPred               (ReadTransformSize.Asked        )--> ReadTransformSize8x8_1;
		CheckMbPred               (LaunchMbPred                   )--> Check4CodedBlockPattern;

		/* PCM Macroblock */
		ReadPcmSampleLuma         (ReadPcmSampleLuma.Done         )--> ReadPcmSampleChroma1Asked;

		ReadPcmSampleChroma1Asked (ReadPcmSampleLuma.Asked        )--> ReadPcmSampleChroma1;

		ReadPcmSampleChroma1      (ReadPcmSampleChroma.UComponent )--> ReadPcmSampleChroma2Asked;

		ReadPcmSampleChroma2Asked (ReadPcmSampleLuma.Asked        )--> ReadPcmSampleChroma2;

		ReadPcmSampleChroma2      (ReadPcmSampleChroma.VComponent )--> SendEndSliceHeader;

		/* Other Macroblock */
		CheckSubMbType            (CheckSubMbType                 )--> Check4CodedBlockPattern;

		ReadTransformSize8x8_1    (ReadTransformSize8x8.Done      )--> LaunchMbPred;

		LaunchMbPred              (LaunchMbPred                   )--> Check4CodedBlockPattern;

		Check4CodedBlockPattern   (ReadCodedBlockPattern.Asked    )--> ReadCodedBlockPattern;
		Check4CodedBlockPattern   (ReadMbQpDelta.Asked            )--> ReadMbQpDelta;
		Check4CodedBlockPattern   (NoResidual                     )--> SendEndSliceHeader;
	
		ReadCodedBlockPattern     (ReadCodedBlockPattern.Done     )--> Check4TransformSize8x8;

		Check4TransformSize8x8    (ReadTransformSize8x8.Asked     )--> ReadTransformSize8x8_2;
		Check4TransformSize8x8    (ReadMbQpDelta.Asked            )--> ReadMbQpDelta;
		Check4TransformSize8x8    (NoResidual                     )--> SendEndSliceHeader;

		ReadTransformSize8x8_2    (ReadTransformSize8x8.Done      )--> Check4MbQpDelta;

		Check4MbQpDelta           (ReadMbQpDelta.Asked            )--> ReadMbQpDelta;
		Check4MbQpDelta           (NoResidual                     )--> SendEndSliceHeader;

		ReadMbQpDelta             (ReadMbQpDelta.Done             )--> LaunchResidual;

		LaunchResidual            (LaunchResidual                 )--> GetResidualCoeffToken;

		GetResidualCoeffToken     (GetResidualCoeffToken          )--> SendEndSliceHeader;

		SendEndSliceHeader        (SendEndSliceHeader             )--> ReadMbType_Asked;
	end

	priority
		CheckMbType.IsIPCM          > CheckMbType.IsNotIPCM;
		LaunchSubMbPred             > ReadTransformSize.Asked > LaunchMbPred;
		ReadCodedBlockPattern.Asked > ReadMbQpDelta.Asked;
		ReadTransformSize8x8.Asked  > ReadMbQpDelta.Asked;
		ReadMbQpDelta.Asked         > NoResidual;
	end
end