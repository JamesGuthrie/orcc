/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
actor Algo_DecodeSubMbPred()
	int (size=32) ValVLD,

	uint(size=6)  Parameters
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) VldParam,

	uint(size=4) SubMbType,

	uint(size=4) RefIdxL0,
	uint(size=4) RefIdxL1,
	int(size=16) MvResl0,
	uint(size=5) MbPartHeight,
	uint(size=5) MbPartWidth,
	uint(size=3) MbPartIdx,
	bool         EndRefIdxL0
		:

	bool DEBUG_MV = false;

	uint(size=3) READ_BITS = 0;
	uint(size=3) VLD_UE    = 1;
	uint(size=3) VLD_SE    = 2;
	uint(size=4) VLD_TE    = 9;
	uint(size=4) SKIP_NAL  = 10;

	uint(size=6) BLOCK_TYPE_P_MIN           = 26;
	uint(size=6) BLOCK_TYPE_P_8x8ref0       = 30;
	uint(size=6) BLOCK_TYPE_P_MAX           = 30;

	uint(size=6) BLOCK_TYPE_B_MIN           = 31;
	uint(size=6) BLOCK_TYPE_B_MAX           = 53;

	uint(size=2) B_DIRECT_8x8  = 0;

	uint(size=3) PRED_L0 = 0;
	uint(size=3) PRED_L1 = 1;
	uint(size=3) BIPRED  = 2;
	uint(size=3) DIRECT  = 3;
	uint(size=3) NA      = 4;

	List(type: uint(size=2), size=16) SubMbPredMode_B
		=	[  DIRECT , PRED_L0 , PRED_L1 , BIPRED , PRED_L0 , PRED_L0 , PRED_L1 , PRED_L1 , BIPRED , BIPRED 
			, PRED_L0 , PRED_L1 , BIPRED  ,   NA   ,   NA    ,   NA    ];

	List(type: uint(size=3), size=4)  NumSubMbPart_P = [1,2,2,4];

	List(type: uint(size=3), size=11)  NumSubMbPart_B = [4,1,1,1,2,2,2,2,2,2,4];

	List ( type: List ( type: uint(size=5), size=4), size=4 ) P_tab_sub = //[sub_mb_type[mbPartIdx]][NumSubMbPart / MbPartWidth / MbPartHeight / SubMbPredMode]
		[ [1,8,8,0], [2,8,4,0], [2,4,8,0], [4,4,4,0] ];

	List ( type: List ( type: uint(size=5), size=4), size=13 ) B_tab_sub = //[sub_mb_type[mbPartIdx]][NumSubMbPart / MbPartWidth / MbPartHeight / SubMbPredMode]
		[ [4,4,4,3], [1,8,8,0], [1,8,8,1], [1,8,8,2], [2,8,4,0], [2,4,8,0], [2,8,4,1], [2,4,8,1], [2,8,4,2], [2,4,8,2], [4,4,4,0], [4,4,4,1], [4,4,4,2] ];


	uint(size=5)  num_ref_idx_l0_active;
	uint(size=5)  num_ref_idx_l1_active;
	bool          mb_field_decoding_flag;
	uint(size=6)  mb_type;

	uint(size=2) mbPartIdx;
	uint(size=3) subMbPartIdx;
	uint(size=3) subMbPartIdxMax;

	List(type: uint(size=4), size=4) sub_mb_type;
	List (type:int,size=4) ref_idx_l0 := [ 0 : for int i in 0 .. 3];
	List (type:int,size=4) ref_idx_l1 := [ 0 : for int i in 0 .. 3];

	function SubMbPredMode( uint(size=4) ValSubMbType) --> uint(size=2) :
			if(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX)then
				if(ValSubMbType >12) then
					DIRECT
				else
					SubMbPredMode_B[ValSubMbType]
				end
			else
				if(ValSubMbType < 4)then
					PRED_L0
				else
					DIRECT
				end
			end
		end

	function SubMbPartWidthHeight(uint(size=1) x)
				-->
			uint(size=5)
		:
			if(mb_type >= BLOCK_TYPE_P_MIN and mb_type <= BLOCK_TYPE_P_MAX)then
				P_tab_sub[sub_mb_type[mbPartIdx - 1]][1+x]
			else
				B_tab_sub[sub_mb_type[mbPartIdx - 1]][1+x]
			end
		end

	function GetFlag(int(size=32) Val, uint(size=5) Idx)
				-->
			bool
		:
			(Val & (1 << Idx)) != 0
		end


	ReadSubMbType.Asked: action
				==>
			TypeOfVLD :[ VLD_UE , VLD_UE , VLD_UE , VLD_UE ]
		end

	ReadSubMbType.Done: action
			ValVLD           :[ValueOfVLD] repeat 4
				==>
			SubMbType :[ValueOfVLD] repeat 4
		do
			foreach int i in 0 .. 3
			do
				sub_mb_type[i] := ValueOfVLD[i];
				if(DEBUG_MV)then
					println("sub_mb_type[ "+i+" ] : "+ValueOfVLD[i]);
				end
			end
		end

	ReadParameters: action
			Parameters :[MacroBType,NumRefIdxL0Act,NumRefIdxL1Act,Flag]
				==>
		do
			num_ref_idx_l0_active  := NumRefIdxL0Act;
			num_ref_idx_l1_active  := NumRefIdxL1Act;
			mb_type                := MacroBType;
			mb_field_decoding_flag := GetFlag(Flag,0);

			mbPartIdx    := 0;
		end

/*
for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
   if( ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) &&
       mb_type != P_8x8ref0 &&
       sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
       SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
       	ref_idx_l0[ mbPartIdx ] = te(v)
*/
	AskRefIdxL0.Launch: action
				==>
			TypeOfVLD :[ VLD_TE ],
			VldParam  :[ num_ref_idx_l0_active - 1 ]
		guard
			/* ( num_ref_idx_l0_active_minus1 > 0 || mb_field_decoding_flag ) */
			num_ref_idx_l0_active > 1 or mb_field_decoding_flag,
			/* mb_type != P_8x8ref0 */
			   mb_type != BLOCK_TYPE_P_8x8ref0,
			/* sub_mb_type[ mbPartIdx ] != B_Direct_8x8 */
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx] != B_DIRECT_8x8),
			/* SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )*/
			SubMbPredMode(sub_mb_type[mbPartIdx]) != PRED_L1,

			mbPartIdx < 4
		do
			mbPartIdx := mbPartIdx + 1;
		end

	AskRefIdxLX.Skip: action
				==>
			TypeOfVLD :[ READ_BITS ],
			VldParam  :[ 0 ]
		guard
			mbPartIdx < 4
		do
			mbPartIdx := mbPartIdx + 1;
		end

	SendOrReadDone: action
				==>
		guard
			mbPartIdx = 4
		do
			mbPartIdx := 0;
		end

/*
for( mbPartIdx = 0; mbPartIdx < 4; mbPartIdx++ )
   if( (num_ref_idx_l1_active_minus1 > 0 | | mb_field_decoding_flag ) &&
        sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
        SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
           ref_idx_l1[ mbPartIdx ] := te(v);
*/
	AskRefIdxL1.Launch: action
				==>
			TypeOfVLD :[ VLD_TE ],
			VldParam  :[ num_ref_idx_l0_active - 1 ]
		guard
			/* ( num_ref_idx_l1_active_minus1 > 0 | | mb_field_decoding_flag ) */
			num_ref_idx_l1_active > 1 or mb_field_decoding_flag,
			/* sub_mb_type[ mbPartIdx ] != B_Direct_8x8 */
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx] != B_DIRECT_8x8),
			/* SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )*/
			SubMbPredMode(sub_mb_type[mbPartIdx]) != PRED_L0,

			mbPartIdx < 4
		do
			mbPartIdx := mbPartIdx + 1;
		end


	CheckmbPartIdx: action
				==>
		guard
			mbPartIdx < 4
		do
			subMbPartIdx := 0;
			if( (mb_type >= BLOCK_TYPE_P_MIN and mb_type <= BLOCK_TYPE_P_MAX) )then
				subMbPartIdxMax := NumSubMbPart_P[ (sub_mb_type[mbPartIdx]) & 0x03 ];
			else
				if(sub_mb_type[mbPartIdx] > 10) then
					subMbPartIdxMax := 4;
				else
					subMbPartIdxMax :=  NumSubMbPart_B[ sub_mb_type[mbPartIdx] ];
				end
			end
			mbPartIdx    := mbPartIdx + 1;
		end

/*
if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
    SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L1 )
*/
	ReadMvdl0Asked.Launch: action
				==>
			//             mvd_l0
			TypeOfVLD    :[  VLD_SE ,  VLD_SE  ]
		guard
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8),
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L1,
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadMvdl0Asked.Skip: action
				==>
			//             mvd_l0
			TypeOfVLD :[  READ_BITS ,  READ_BITS  ],
			VldParam  :[      0     ,      0      ]
		guard
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

/*
if( sub_mb_type[ mbPartIdx ] != B_Direct_8x8 &&
    SubMbPredMode( sub_mb_type[ mbPartIdx ] ) != Pred_L0 )
*/
	ReadMvdl1Asked.Launch: action
				==>
			//             mvd_l0
			TypeOfVLD    :[  VLD_SE ,  VLD_SE  ]
		guard
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8),
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L0,
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadMvdl1Asked.Skip: action
				==>
			//             mvd_l0
			TypeOfVLD :[  READ_BITS ,  READ_BITS  ],
			VldParam  :[      0     ,      0      ]
		guard
			subMbPartIdx < subMbPartIdxMax
		do
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadRefIdxLX: action
			ValVLD :[ValueOfVLD] repeat 8
				==>
		do
			foreach int i in 0 .. 3
			do
				ref_idx_l0[i] := ValueOfVLD[i];
				ref_idx_l1[i] := ValueOfVLD[i+4];
				if(DEBUG_MV)then
						println("refidxl1["+i+"] :"+ValueOfVLD[i+4]);
						println("refidxl0["+i+"] :"+ValueOfVLD[i]);
				end
			end
		end

	ReadMvdl0Done.Launch: action
			ValVLD   :[ValueOfVLD] repeat 2
				==>
			RefIdxL0     :[ref_idx_l0[mbPartIdx-1]],
			MvResl0      :[ValueOfVLD] repeat 2,
			MbPartHeight :[SubMbPartWidthHeight(1)],
			MbPartWidth  :[SubMbPartWidthHeight(0)],
			MbPartIdx    :[subMbPartIdx - 1],
			EndRefIdxL0  :[false]
		guard
			not(mb_type >= BLOCK_TYPE_B_MIN and mb_type <= BLOCK_TYPE_B_MAX) or (sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8),
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L1,
			subMbPartIdx < subMbPartIdxMax
		do
			if(DEBUG_MV)then
				println("sub_mb_pred mvld0["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][0]:"+ValueOfVLD[0]);
				println("sub_mb_pred mvld0["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][1]:"+ValueOfVLD[1]);
			end
			subMbPartIdx := subMbPartIdx +1;
		end
//Delete me!! e carefull with B_DIRECT_8x8
	ReadMvdl0Done.Skip: action
			ValVLD   :[ValueOfVLD] repeat 2
				==>
			MvResl0      :[ValueOfVLD] repeat 2,
			MbPartHeight :[SubMbPartWidthHeight(1)],
			MbPartWidth  :[SubMbPartWidthHeight(0)],
			MbPartIdx    :[subMbPartIdx - 1],
			EndRefIdxL0  :[false]
		guard
			subMbPartIdx < subMbPartIdxMax
		do
			if(DEBUG_MV)then
				println("sub_mb_pred mvld0["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][0]:"+ValueOfVLD[0]);
				println("sub_mb_pred mvld0["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][1]:"+ValueOfVLD[1]);
			end
			subMbPartIdx := subMbPartIdx +1;
		end

	ReadMvdl1Done.Launch: action
			ValVLD :[ValueOfVLD] repeat 2
				==>
			RefIdxL1 :[ref_idx_l1[mbPartIdx-1]]
		guard
			mb_type >= BLOCK_TYPE_B_MIN,
			mb_type <= BLOCK_TYPE_B_MAX,
			sub_mb_type[mbPartIdx - 1] != B_DIRECT_8x8,
			SubMbPredMode(sub_mb_type[mbPartIdx - 1]) != PRED_L0,
			subMbPartIdx < subMbPartIdxMax
		do
			if(DEBUG_MV)then
				println("mvld1["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][0]:"+ValueOfVLD[0]);
				println("mvld1["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][1]:"+ValueOfVLD[1]);
			end
			subMbPartIdx := subMbPartIdx +1;
		end
//Delete me!!
	ReadMvdl1Done.Skip: action
			ValVLD :[ValueOfVLD] repeat 2
				==>
		guard
			subMbPartIdx < subMbPartIdxMax
		do
			if(DEBUG_MV)then
				println("mvld1["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][0]:"+ValueOfVLD[0]);
				println("mvld1["+ (mbPartIdx - 1) +"]["+subMbPartIdx+"][1]:"+ValueOfVLD[1]);
			end
			subMbPartIdx := subMbPartIdx +1;
		end

	SendEndSubMbPred: action
				==>
			TypeOfVLD   :[ SKIP_NAL ],
			EndRefIdxL0 :[   true   ]
		end

	schedule fsm ReadSubMbTypeAsked:
		ReadSubMbTypeAsked (ReadSubMbType.Asked )--> ReadSubMbTypeDone;

		ReadSubMbTypeDone  (ReadSubMbType.Done  )--> ReadParameters;

		ReadParameters     (ReadParameters      )--> AskRefIdxL0;

		AskRefIdxL0        (AskRefIdxL0.Launch  )--> AskRefIdxL0;
		AskRefIdxL0        (AskRefIdxLX.Skip    )--> AskRefIdxL0;
		AskRefIdxL0        (SendOrReadDone      )--> AskRefIdxL1;

		AskRefIdxL1        (AskRefIdxL1.Launch  )--> AskRefIdxL1;
		AskRefIdxL1        (AskRefIdxLX.Skip    )--> AskRefIdxL1;
		AskRefIdxL1        (SendOrReadDone      )--> CheckmbPartIdx0;

		CheckmbPartIdx0    (CheckmbPartIdx      )--> ReadMvdl0Asked;

		ReadMvdl0Asked     (ReadMvdl0Asked      )--> ReadMvdl0Asked;
		ReadMvdl0Asked     (CheckmbPartIdx      )--> ReadMvdl0Asked;
		ReadMvdl0Asked     (SendOrReadDone      )--> CheckmbPartIdx1;

		CheckmbPartIdx1    (CheckmbPartIdx      )--> ReadMvdl1Asked;

		ReadMvdl1Asked     (ReadMvdl1Asked      )--> ReadMvdl1Asked;
		ReadMvdl1Asked     (CheckmbPartIdx      )--> ReadMvdl1Asked;
		ReadMvdl1Asked     (SendOrReadDone      )--> ReadRefIdxLX;

		ReadRefIdxLX       (ReadRefIdxLX        )--> CheckmbPartIdx2;

		CheckmbPartIdx2    (CheckmbPartIdx      )--> ReadMvdl0Done;

		ReadMvdl0Done      (ReadMvdl0Done       )--> ReadMvdl0Done;
		ReadMvdl0Done      (CheckmbPartIdx      )--> ReadMvdl0Done;
		ReadMvdl0Done      (SendOrReadDone      )--> CheckmbPartIdx3;

		CheckmbPartIdx3    (CheckmbPartIdx      )--> ReadMvdl1Done;

		ReadMvdl1Done      (ReadMvdl1Done       )--> ReadMvdl1Done;
		ReadMvdl1Done      (CheckmbPartIdx      )--> ReadMvdl1Done;
		ReadMvdl1Done      (SendOrReadDone      )--> SendEndSubMbPred;

		SendEndSubMbPred   (SendEndSubMbPred    )--> ReadSubMbTypeAsked;
	end
	priority
		AskRefIdxL0.Launch   > AskRefIdxLX.Skip;
		AskRefIdxLX.Skip     > SendOrReadDone;
		AskRefIdxL1.Launch   > AskRefIdxLX.Skip;
		CheckmbPartIdx       > SendOrReadDone;
		ReadMvdl0Asked       > CheckmbPartIdx;
		ReadMvdl1Asked       > CheckmbPartIdx;
		ReadMvdl0Done        > CheckmbPartIdx;
		ReadMvdl1Done        > CheckmbPartIdx;
		ReadMvdl1Done.Launch > ReadMvdl1Done.Skip;
		ReadMvdl0Done.Launch > ReadMvdl0Done.Skip;
	end
end
