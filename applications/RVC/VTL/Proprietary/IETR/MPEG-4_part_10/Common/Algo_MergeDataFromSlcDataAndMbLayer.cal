/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference
 purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or 
modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software 
module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the 
MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the 
<standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use 
in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module 
or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure 
the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third 
parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
import VTL.Proprietary.IETR.MPEG_4_part_10.Common.Imp_MacroBlockInfo.*;

actor Algo_MergeDataFromSlcDataAndMbLayer()
	bool          SkipMbLayer,
	bool          IsB_Skip,
	bool          TransfSz8x8Flag,
	uint(size=6)  MbType,
	uint(size=4)  RemIntraYxYPredMode,

	int (size=8)  SDataQp_Y_Cb_Cr,

	int (size=8)  MbLayerQp_Y_Cb_Cr

		==>
	uint(size=1)  MbIntraFlag,
	uint(size=4)  IntraPredMode,
	int (size=8)  ScalingList,
	int (size=8)  Qp,
	int (size=8)  Qp_Cb,
	int (size=8)  Qp_Cr,
	uint(size=6)  MacroBlockType,
	uint(size=6)  MBType4Pred,
	bool          TransformSize8x8
		:

	uint(size=6) mb_type;


	MbLayerSkipped: action
			SkipMbLayer     :[skip],
			IsB_Skip        :[is_B_Skip],
			SDataQp_Y_Cb_Cr :[ ValQp , ValQpCb , ValQpCr ]
				==>
			MbIntraFlag     :[0],
			ScalingList     :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp              :[ValQp],
			Qp_Cb           :[ValQpCb],
			Qp_Cr           :[ValQpCr],
			MacroBlockType  :[mb_type],
			MBType4Pred     :[mb_type]
		guard
			skip = true
		var
			uint(size=6) mb_type
		do
			mb_type :=
				if(is_B_Skip)then
					BLOCK_TYPE_B_SKIP
				else
					BLOCK_TYPE_P_SKIP
				end;
		end

	MbLayer.IsIntra4x4or8x8: action
			SkipMbLayer       :[skip],
			MbType            :[mb_type],
			MbLayerQp_Y_Cb_Cr :[ValQp , ValQpCb , ValQpCr]
				==>
			MbIntraFlag      :[1],
			ScalingList    :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp             :[ValQp],
			Qp_Cb          :[ValQpCb],
			Qp_Cr          :[ValQpCr],
			MacroBlockType :[mb_type]
		guard
			skip    =  false,
			mb_type = BLOCK_TYPE_I_NxN
		end

	MbLayer.IsIntra4x4: action
			TransfSz8x8Flag     :[Is8x8],
			RemIntraYxYPredMode :[rem_intra_4x4_pred_mode] repeat 16
				==>
			TransformSize8x8 :[Is8x8],
			IntraPredMode    :[intra_pred_mode] repeat 17
		guard
			Is8x8   = false
		var
			List(type: uint(size=4), size=17) intra_pred_mode
		do
			intra_pred_mode[0] := 1;
			foreach int i in 0 .. 15
			do
				intra_pred_mode[i+1] := rem_intra_4x4_pred_mode[i];
			end
		end

	MbLayer.IsIntra8x8: action
			TransfSz8x8Flag     :[Is8x8],
			RemIntraYxYPredMode :[rem_intra_8x8_pred_mode] repeat 4
				==>
			TransformSize8x8 :[Is8x8],
			IntraPredMode    :[intra_pred_mode] repeat 5
		guard
			Is8x8   = true
		var
			List(type: uint(size=4), size=5) intra_pred_mode
		do
			intra_pred_mode[0] := 2;
			foreach int i in 0 .. 3
			do
				intra_pred_mode[i+1] := rem_intra_8x8_pred_mode[i];
			end
		end

	MbLayer.IsIntra16x16: action
			SkipMbLayer       :[skip],
			MbType            :[mb_type],
			TransfSz8x8Flag   :[Is8x8],
			MbLayerQp_Y_Cb_Cr :[ValQp , ValQpCb , ValQpCr]
				==>
			MbIntraFlag    :[1],
			IntraPredMode  :[ 3 , (mb_type - 1) & 3],
			ScalingList    :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp             :[ValQp],
			Qp_Cb          :[ValQpCb],
			Qp_Cr          :[ValQpCr],
			MacroBlockType :[mb_type]
		guard
			skip     =  false,
			mb_type >= BLOCK_TYPE_INTRA_16x16_MIN,
			mb_type <= BLOCK_TYPE_INTRA_16x16_MAX
		end

	MbLayer.IsIntraPCM: action
			SkipMbLayer     :[skip],
			MbType          :[mb_type],
			TransfSz8x8Flag :[Is8x8]
				==>
			MbIntraFlag    :[1],
			IntraPredMode  :[4],
			MacroBlockType :[mb_type]
		guard
			skip    =  false,
			mb_type = BLOCK_TYPE_I_PCM
		end

	MbLayer.IsNotIntra: action
			SkipMbLayer     :[skip],
			MbType          :[Mb_type],
			TransfSz8x8Flag :[Is8x8],
			MbLayerQp_Y_Cb_Cr :[ValQp , ValQpCb , ValQpCr]
				==>
			MbIntraFlag    :[0],
			ScalingList    :[[16 : for int i in 0 .. 15]] repeat 16,
			Qp             :[ValQp],
			Qp_Cb          :[ValQpCb],
			Qp_Cr          :[ValQpCr],
			MacroBlockType :[mb_type],
			MBType4Pred    :[mb_type]
		guard
			skip    = false,
			Mb_type > BLOCK_TYPE_INTRA_MAX
		do
			mb_type := Mb_type;
		end

	schedule fsm ReadMbLayer:
		ReadMbLayer (MbLayerSkipped          )--> ReadMbLayer;
		ReadMbLayer (MbLayer.IsIntra4x4or8x8 )--> IsIntra4x4or8x8;
		ReadMbLayer (MbLayer.IsIntra16x16    )--> ReadMbLayer;
		ReadMbLayer (MbLayer.IsIntraPCM      )--> ReadMbLayer;
		ReadMbLayer (MbLayer.IsNotIntra      )--> ReadMbLayer;

		IsIntra4x4or8x8 (MbLayer.IsIntra8x8 )--> ReadMbLayer;
		IsIntra4x4or8x8 (MbLayer.IsIntra4x4 )--> ReadMbLayer;
	end

	priority
		MbLayerSkipped     > MbLayer;
	end
end
