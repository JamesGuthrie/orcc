
// Mgnt_FBAddr_Luma_MxN.cal

//

// Author: He-Yuan Lin

//

// Luma frame buffer generator for AVC inter prediction

//Modified by Florian DECOLOGNE (IETR) : 15/09/08 : 

//Mgnt_FBAddr_Luma_MxN --> Mgnt_Interp_FBAddr_Luma_MxN

//Modified by Endri Bezati <endri.bezati@insa-rennes.fr>

//Modified the "size" correctly to work with orcc

//Modified by Damien de Saint Jorre (IETR/Insa of Rennes)
import VTL.Proprietary.IETR.MPEG_4_part_10.Common.Imp_MacroBlockInfo.* ;

actor Mgnt_InterPred()
	uint(size=13) CurrMbAddr,
	uint(size=3)  MbPartIdx,
	uint(size=6)  Mb_Type,
	uint(size=13) PicSizeInMb,
	int (size=16) MV,
	uint(size=11) Location,
	uint(size=32) Poc2Read,
	uint(size=6)  PartSZ
		==>
	int (size=12) ReadAddr_l,
	int (size=12) ReadAddr_c,
	uint(size=32) PocToRead :

	bool DEBUG_INPUT = false;

	int(size=32) x_index;
	int(size=32) y_index;
	int(size=32) x;
	int(size=32) y;
	int width;
	int height;
	int count := 0;
	int currMB := 0;
	int pic_size := 0;
	uint(size=32) poc_to_read;

	//Mb_Type_NOK : Consume the token, nothing else to do 
	Mb_Type_NOK_and_IPCM: action
			Mb_Type:[ mb_type ],
			PicSizeInMb:[ c ],
			CurrMbAddr:[ valCurrMbAddr ]
				==>
		guard
			mb_type = BLOCK_TYPE_I_PCM
		do
			currMB := valCurrMbAddr;
			pic_size := c;
		end

	//Mb_Type_NOK : Consume the token, nothing else to do 
	Mb_Type_NOK: action
			Mb_Type     :[ mb_type ],
			PicSizeInMb :[ c ],
			CurrMbAddr  :[ valCurrMbAddr ]
				==>
		guard
			mb_type >= BLOCK_TYPE_INTRA_MIN,
			mb_type <= BLOCK_TYPE_INTRA_MAX,
			mb_type != BLOCK_TYPE_I_PCM
		do
			currMB := valCurrMbAddr;
			pic_size := c;
	end

	//Mb_Type_OK : Enable the prediction 
	Mb_Type_OK: action
			Mb_Type      :[ mb_type ],
			PicSizeInMb  :[ c ],
			CurrMbAddr   :[ valCurrMbAddr ]
				==>
		guard
			not(mb_type >= BLOCK_TYPE_INTRA_MIN and mb_type <= BLOCK_TYPE_INTRA_MAX)
		do
			currMB := valCurrMbAddr;
			pic_size := c;
		end

	get_pos: action
			MbPartIdx :[ idx ],
			Location  :[ a, b ],
			PartSZ    :[ c, d ],
			Poc2Read  :[ ValPocToRead ]
				==>
		do
			if (DEBUG_INPUT) then
				println("Input InterpFBAddrLuma MbPartIdx:" + idx);
				println("Input InterpFBAddrLuma Location:" + a + " ; " + b);
				println("Input InterpFBAddrLuma PartSZ:" + c + " ; " + d);
			end
			x      := a;
			y      := b;
			width  := c;
			height := d;
			count  :=
				if width = 16 and height = 16 then
					count + rshift(width, 2) * rshift(height, 2)
				else
					if height = 16 and width = 8 then
					//mode16x8
						if idx = 0 then
							4
						else
							16
						end
					else
						if height = 8 and width = 16 then
						//mode 8x16
							count + rshift(width, 2) * rshift(height, 2)
						else
							if height = 8 and width = 8 then
							// mode8x8
								count + rshift(width, 2) * rshift(height, 2)
							else
								if height = 8 and width = 4 then
								//mode 8x4
									count + 1 + lshift(idx, 1)
								else
									if height = 4 and width = 8 then
									//mode 4x8
										count + rshift(width, 2) * rshift(height, 2)
									else
									// if mbpart_h = 4 and mbpart_w = 4 then mode4x4 
										count + rshift(width, 2) * rshift(height, 2)
									end
								end
							end
						end
					end
				end;
			poc_to_read := ValPocToRead;
		end

	get_mv: action
			MV:[ mx, my ]
				==>
			PocToRead  :[ poc_to_read ],
			ReadAddr_l :[ x + rshift(mx, 2) - 2     , y + rshift(my, 2) - 2     , width + 5     , height + 5 ],
			ReadAddr_c :[ x/2 + rshift(mx, 3) , y/2 + rshift(my, 3) , width / 2 + 1 , height / 2 + 1 ]
		do
			x_index := rshift(mx, 2);
			y_index := rshift(my, 2);
		end

	MB_done: action ==>
		guard
			count = 16
		do
			count := 0;
		end

	MB_Ndone: action ==>
		end

	PIC_done: action ==>
		guard
			currMB = pic_size - 1
		end

	PIC_Ndone: action ==>
		guard
			currMB < pic_size - 1
		end

	schedule fsm get_MB :
		get_MB       (Mb_Type_NOK_and_IPCM )--> get_pic_done;
		get_MB       (Mb_Type_NOK          )--> get_pic_done;
		get_MB       (Mb_Type_OK           )--> get_pos;

		get_pic_done (PIC_done             )--> get_MB;
		get_pic_done (PIC_Ndone            )--> get_MB;

		MB_done      (MB_done              )--> get_pic_done;
		MB_done      (MB_Ndone             )--> get_pos;

		get_pos      (get_pos              )--> get_mv;

		get_mv       (get_mv               )--> MB_done;
	end

	priority
		PIC_done      > MB_done > MB_Ndone;
		PIC_Ndone     > PIC_done;
	end

end