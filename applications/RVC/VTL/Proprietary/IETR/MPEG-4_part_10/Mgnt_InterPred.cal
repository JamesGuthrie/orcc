
// Mgnt_FBAddr_Luma_MxN.cal

//

// Author: He-Yuan Lin

//

// Luma frame buffer generator for AVC inter prediction

//Modified by Florian DECOLOGNE (IETR) : 15/09/08 : 

//Mgnt_FBAddr_Luma_MxN --> Mgnt_Interp_FBAddr_Luma_MxN

//Modified by Endri Bezati <endri.bezati@insa-rennes.fr>

//Modified the "size" correctly to work with orcc

//Modified by Damien de Saint Jorre (IETR/Insa of Rennes)
import VTL.Proprietary.IETR.MPEG_4_part_10.Common.Imp_MacroBlockInfo.* ;

actor Mgnt_InterPred()
	uint(size=3)  MbPartIdx,/* Should be replaced by Mb_Type + look_up table*/
	uint(size=6)  PartSZ,/* Should be replaced by Mb_Type + look_up table*/
	uint(size=6)  Mb_Type,
	int (size=16) MV,
	uint(size=11) Location,
	uint(size=32) Poc2Read
		==>
	int (size=12) ReadAddr_l,
	int (size=12) ReadAddr_c,
	uint(size=32) PocToRead :

	bool DEBUG_INPUT = false;

	int(size=32) x_index;
	int(size=32) y_index;
	int(size=32) x;
	int(size=32) y;
	int width;
	int height;
	int count := 0;
	uint(size=32) poc_to_read;

	get_MB: action
			Mb_Type      :[ mb_type ]
				==>
		end

	get_pos: action
			MbPartIdx :[ idx ],
			Location  :[ a, b ],
			PartSZ    :[ c, d ],
			Poc2Read  :[ ValPocToRead ]
				==>
		do
			if (DEBUG_INPUT) then
				println("Input InterpFBAddrLuma MbPartIdx:" + idx);
				println("Input InterpFBAddrLuma Location:" + a + " ; " + b);
				println("Input InterpFBAddrLuma PartSZ:" + c + " ; " + d);
			end
			x      := a;
			y      := b;
			width  := c;
			height := d;
			count  :=
				if width = 16 and height = 16 then
					count + rshift(width, 2) * rshift(height, 2)
				else
					if height = 16 and width = 8 then
					//mode16x8
						if idx = 0 then
							4
						else
							16
						end
					else
						if height = 8 and width = 16 then
						//mode 8x16
							count + rshift(width, 2) * rshift(height, 2)
						else
							if height = 8 and width = 8 then
							// mode8x8
								count + rshift(width, 2) * rshift(height, 2)
							else
								if height = 8 and width = 4 then
								//mode 8x4
									count + 1 + lshift(idx, 1)
								else
									if height = 4 and width = 8 then
									//mode 4x8
										count + rshift(width, 2) * rshift(height, 2)
									else
									// if mbpart_h = 4 and mbpart_w = 4 then mode4x4 
										count + rshift(width, 2) * rshift(height, 2)
									end
								end
							end
						end
					end
				end;
			poc_to_read := ValPocToRead;
		end

	get_mv: action
			MV:[ mx, my ]
				==>
			PocToRead  :[ poc_to_read ],
			ReadAddr_l :[ x + rshift(mx, 2) - 2     , y + rshift(my, 2) - 2     , width + 5     , height + 5 ],
			ReadAddr_c :[ x/2 + rshift(mx, 3) , y/2 + rshift(my, 3) , width / 2 + 1 , height / 2 + 1 ]
		do
			x_index := rshift(mx, 2);
			y_index := rshift(my, 2);
		end

	MB_done: action ==>
		guard
			count = 16
		do
			count := 0;
		end

	MB_Ndone: action ==>
		guard
			count < 16
		end

	schedule fsm get_MB :
		MB_done (MB_done    )--> get_MB;
		MB_done (MB_Ndone   )--> get_pos;

		get_MB  (get_MB     )--> get_pos;

		get_pos (get_pos    )--> get_mv;

		get_mv  (get_mv     )--> MB_done;
	end

	priority
		MB_Ndone > MB_done;
	end
end