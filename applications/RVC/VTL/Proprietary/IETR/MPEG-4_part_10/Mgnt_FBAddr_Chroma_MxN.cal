// A Mgnt_FBAddr_Chroma_MxN.cal
//
// Author: He-Yuan Lin
//
// Chroma frame buffer generator for AVC inter prediction
//Modified By Endri Bezati <endri.bezati@insa-rennes.fr>IETR/INSA
import orcc.Imp_MacroBlockInfo.*;




// BTYPE
// refID  MB position (x,y)
actor Mgnt_FBAddr_Chroma_MxN () 

   							 uint(size=6)         Mb_Type, 
   							 int (size=16)     MV, 
  							 uint(size=11)   Location , 
  							 uint(size=6) PartSZ, 
  							 uint(size=13)   PicSizeInMb, 
  							 uint(size=7)   PicWidthInMb,
  							 uint(size=3)         MbPartIdx,
  							 uint(size=13)        CurrMbAddr,
							 uint(size=32) PocToRead_i
  															   ==> 
   																  int (size=12) 	   RA, 
   																  uint(size=11)        RA_Width, 
   																  uint(size=11)        RA_Height,
							 									  uint(size=32) PocToRead_o :

	/* ***
		Global Variables
							*** */

  int x_index ;
  int y_index ;
  int x;
  int y;
  int o_x;
  int o_y;
  int addr_x;
  int addr_y;
  int width;
  int height;
  
  int Picheight_c := 1;
  int Picwidth_c  := 1;
  
  int count    := 0;
  int currMB   := 0;
  int pic_size := 0;
  uint(size=32) poc_to_read;

  
  //Mb_Type_NOK_and_IPCM : Consume the token, nothing else to do 
  Mb_Type_NOK_and_IPCM: action Mb_Type      :[mb_type],
  		              PicWidthInMb :[ b ], 
  		              PicSizeInMb  :[ c ],
  		              CurrMbAddr   :[ valCurrMbAddr ] ==> 
  guard
  	mb_type = BLOCK_TYPE_I_PCM
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end

  //Mb_Type_NOK : Consume the token, nothing else to do 
  Mb_Type_NOK: action Mb_Type      :[mb_type],
  		              PicWidthInMb :[ b ], 
  		              PicSizeInMb  :[ c ], 
 // 		              Coef_ACR     :[ d ] repeat 8*8,
  		              CurrMbAddr   :[ valCurrMbAddr ] ==> 
  guard
  	mb_type >= BLOCK_TYPE_INTRA_MIN,
  	mb_type <= BLOCK_TYPE_INTRA_MAX,
  	mb_type != BLOCK_TYPE_I_PCM
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end
  
  
  
  
  //Mb_Type_OK : Enable the prediction 
  Mb_Type_OK: action Mb_Type      :[mb_type],
  	                 PicWidthInMb :[ b ], 
  	                 PicSizeInMb  :[ c ],
  	                 CurrMbAddr   :[valCurrMbAddr]              ==>
  guard
  	not(mb_type >= BLOCK_TYPE_INTRA_MIN and mb_type <= BLOCK_TYPE_INTRA_MAX)
  do 
    Picwidth_c  := lshift(b,3);
    Picheight_c := lshift(c/b,3);
    currMB      := valCurrMbAddr;
  	pic_size    := c;
  end
  
  
  
  get_pos: action MbPartIdx   : [ idx  ], 
  			      Location    : [ a, b ], 
  			      PartSZ      : [ c, d ],
  			      PocToRead_i :[PocToRead]
  			      	==>  
  do
  	x      := a/2;
    y      := b/2;
    width  := c/2;
    height := d/2;
  
  	if ( ( width = 2 ) and ( height = 4 ) ) then
      count := count + 1 + lshift(idx,1);
    else 
      if ( ( width = 4 ) and  ( height = 8 ) )   then
         
        if ( idx = 0)  then 
        	count := 4;
       	else 
       		count := 16; 
       	end
      else
        
        count := count + rshift(width,1) * rshift(height,1);
      end
    
    end
    poc_to_read := PocToRead;
    
  end
   

  get_mv_send_frac: action MV : [ mx, my ] ==>
//  											   Frac : [ frac_x, frac_y ]
//  var
//  	uint frac_x, 
//    uint frac_y
  do
  	x_index := rshift (mx, 3);        
    y_index := rshift (my, 3);
    o_x     := x + x_index;
    o_y     := y + y_index;
//    frac_x  := ( mx - lshift (x_index, 3) );
//    frac_y  := ( my - lshift (y_index, 3) ); 		
  end
  
  
  done: action ==>
  guard
    o_y = ( y + y_index + height + 1 )
  end

  MB_done: action ==>
  guard
  	count = 16
  do
  	count := 0;
  end
  
  MB_Ndone: action ==>
  end
  
  PIC_done: action ==>
  guard
  	currMB = pic_size - 1
  end

  PIC_Ndone: action ==>
  guard 
  	currMB < ( pic_size - 1 )
  end

  // read_address
  read_address: action ==> RA        : [addr_x,addr_y ], 
  						   RA_Width  : [ 1 ], 
  						   RA_Height : [ 1 ],
  						   PocToRead_o :[poc_to_read]
  
  var int r_addr
  do
 
    addr_x := o_x;
    addr_y := o_y;
    
    if( o_x < 0) then
    	addr_x := 0 ;
    end   
   
   	if( o_x >= Picwidth_c - 1 ) then
   		addr_x := Picwidth_c-1 ;
   	end
   
   	if( o_y < 0) then
   		addr_y := 0 ;
   	end   
   
   	if( o_y >=Picheight_c-1) then
    	addr_y := Picheight_c-1 ;
   	end
    
   	r_addr := (addr_x + Picwidth_c * addr_y);
     
   	o_x := o_x + 1;

   	if o_x >=  (x + x_index+ width+ 1) then
      	o_x := x + x_index;
      	o_y := o_y + 1;
   	end
    
  end
 
  schedule fsm get_MB:
    get_MB      		( Mb_Type_NOK_and_IPCM       ) 	--> get_pic_done;
    get_MB      		( Mb_Type_NOK       ) 	--> get_pic_done;
    get_pic_done   		( PIC_done       	) 	--> get_MB;
    get_pic_done   		( PIC_Ndone       	) 	--> get_MB;
    get_MB      		( Mb_Type_OK        ) 	--> get_pos;
    get_pos        		( get_pos        	) 	--> get_mv_send_frac;
    get_mv_send_frac    ( get_mv_send_frac 	) 	--> address;
    address      		( read_address		) 	--> address;
    address      		( done         		) 	--> MB_done;
    MB_done      		( MB_done         	) 	--> get_pic_done;
    MB_done      		( MB_Ndone         	) 	--> get_pos;
   end

  priority
     PIC_done > MB_done       > MB_Ndone ;
     done     > read_address;
     PIC_done > PIC_Ndone;
  end

end