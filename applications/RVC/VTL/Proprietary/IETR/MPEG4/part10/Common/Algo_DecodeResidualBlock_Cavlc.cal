/***********************************************************************

This software module was originally developed by Damien de Saint Jorre IETR/INSA of Rennes (France), in the course of development of the <standard> for reference purposes and its performance may not have been optimized. This software module is an implementation of one or more tools as specified by the MPEG-C part 4.
ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works of this software module or modifications thereof for use in implementations of the <standard>  in products that satisfy conformance criteria (if any).
Those intending to use this software module in products are advised that its use may infringe existing patents. ISO/IEC have no liability for use of this software module or modifications thereof.
Copyright is not released for products that do not conform to audiovisual and image-coding related ITU Recommendations and/or ISO/IEC International Standards.
Assurance that the originally developed software module can be used (1) in the <standard> once the <standard> has been adopted; and (2) to develop the MPEG-C part 4:

IETR/INSA of Rennes (France) grants ISO/IEC all rights necessary to include the originally developed software module or modifications thereof in the <standard> and to permit ISO/IEC to offer You a royalty-free, worldwide, non-exclusive, copyright license to copy, distribute, and make derivative works for use in implementations of the MPEG-C part 4 in products that satisfy conformance criteria (if any), and to the extent that such originally developed software module or portions of it are included in the MPEG-C part 4.  To the extent that IETR/INSA of Rennes (France) owns patent rights that would be required to make, use, or sell the originally developed software module or portions thereof included in the MPEG-C part 4 in a conforming product,  IETR/INSA of Rennes (France) will assure the ISO/IEC that it is willing to negotiate licenses under reasonable and non-discriminatory terms and conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications thereof for the sole  purpose of developing the MPEG-C part 4

IETR/INSA of Rennes (France) retains full right to modify and use the code for its own purpose, assign or donate the code to a third party and to inhibit third parties from using the code for products that do not conform to MPEG-related ITU Recommendations and/or ISO/IEC International Standards.
This copyright notice must be included in all copies or derivative works. Copyright (c) ISO/IEC 2008.
***********************************************************************/
package Proprietary.IETR.MPEG4.part10.Common;

import Proprietary.IETR.MPEG4.part10.Common.Imp_DecodingFunctions.*;
import MPEG.Common.Imp_Math.*;

actor Algo_DecodeResidualBlock_Cavlc()
	int (size=32) ValVLD,
	int (size=8)  Parameters
		==>
	uint(size=5)  TypeOfVLD,
	int (size=32) VLD_Param,
	uint(size=5)  Total_Coeff,

	int (size=12) Value,
	uint(size=4)  Run,
	bool          Last
		:

	bool DEBUG_FLAG_DECODED = false;

	int (size=8)  nC_Val;
	uint(size=8)  TotalCoeff   := 0;
	uint(size=8)  TrailingOnes := 0;
	uint(size=5)  suffixLength := 0;
	uint(size=32) level_prefix := 0;
	uint(size=32) level_suffix := 0;
	uint(size=32) levelCode    := 0;
	uint(size=5)  iLoop        := 0;
	uint(size=4)  zerosLeft    := 0;
	uint(size=5)  maxNumCoeff  := 0;
	uint(size=5)  startIdx     := 0;
	uint(size=5)  endIdx       := 0;

	List(type: uint(size=8) , size=16) CoeffLevel;
	List(type: int (size=16), size=3)  level        := [ 0 : for int i in 1 .. 3];
	List(type: int (size=4) , size=16) run          := [ 0 : for int i in 1 .. 16];


	ReadCoeffToken.Asked: action
			Parameters  :[nC , MaxNumCoeff , StartIdx , EndIdx]
				==>
			//        mb_field_decoding_flag
			TypeOfVLD :[ CAVLC_COEFF_TOKEN ],
			VLD_Param :[       nC       ]
		do
			nC_Val := nC;
			foreach int i in 0 .. 15
			do
				CoeffLevel[i] := 0;
			end
			startIdx    := StartIdx;
			endIdx      := EndIdx;
			maxNumCoeff := MaxNumCoeff;
			if(DEBUG_FLAG_DECODED)then
				println("******************** New Block Cavlc***************************");
				println("nC : "+nC_Val);
			//	println("startIdx : "+startIdx);
			//	println("endIdx : "+endIdx);
			//	println("maxNumCoeff : "+ValMaxNumCoeff);
			end
			zerosLeft := 0;
		end

	ReadCoeffToken.Done: action
			ValVLD :[ValueOfVLD]
				==>
			Total_Coeff:[TotalCoeff]
		do
			TotalCoeff   := bitand(ValueOfVLD,0xFF);
			TrailingOnes := rshift(ValueOfVLD,8);
			if(DEBUG_FLAG_DECODED)then
				println("TotalCoeff : "+bitand(ValueOfVLD,0xFF));
				println("Trailing Ones : "+rshift(ValueOfVLD,8));
			end
			if(TrailingOnes < 3) then
				levelCode := 2;
			else
				levelCode := 0;
			end
		end

	CheckTotalCoeff.IsGreaterThan0: action ==>
		guard
			TotalCoeff > 0
		do
			if((TotalCoeff > 10) and (TrailingOnes < 3)) then
				suffixLength := 1;
			else
				suffixLength := 0;
			end
			iLoop     := 0;
		end

	ReadTrailingOnesSign.Asked: action
				==>
			//     trailing_ones_sign_flag
			TypeOfVLD :[ READ_BITS ],
			VLD_Param :[ TrailingOnes ]
		guard
			TrailingOnes > 0
		end

	ReadTrailingOnesSign.Done: action
			ValVLD :[ValueOfVLD]
				==>
		var
			uint(size=1) trailing_ones_sign_flag
		do
			foreach int i in 0 .. TrailingOnes - 1
			do
				trailing_ones_sign_flag := bitand(rshift(ValueOfVLD,TrailingOnes - 1 - i) ,1);
				level[iLoop] := 1 - 2 * trailing_ones_sign_flag;
				if(DEBUG_FLAG_DECODED)then
					println("levelT1 : "+level[iLoop]);
				end
				iLoop        := iLoop + 1;
			end
			iLoop := 0;
		end

	SendTrailingOnes: action
				==>
			Value :[level[iLoop-1]],
			Last  :[false]
		guard
			iLoop < TrailingOnes
		do
			iLoop := iLoop + 1;
		end

	ReadLevelPrefix.Asked: action
				==>
			//              level_prefix
			TypeOfVLD :[ CAVLC_LEVEL_PREFIX ]
		guard
			iLoop < TotalCoeff
		end

	ReadLevelPrefix.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			//println("\t\tlevel_prefix : "+ValueOfVLD);
			level_prefix := ValueOfVLD;
			level_suffix := 0;
		end

	ReadLevelSuffix.Asked: action
				==>
			//            level_suffix
			TypeOfVLD :[    READ_BITS    ],
			VLD_Param :[ levelSuffixSize ]
		guard
			   level_prefix >= 14
			or suffixLength  > 0
		var
			int levelSuffixSize
		do
			if((level_prefix = 14) and (suffixLength = 0) )then
				levelSuffixSize := 4;
			else
				if(level_prefix >= 15) then
					levelSuffixSize := level_prefix - 3;
				else
					levelSuffixSize := suffixLength;
				end
			end
		end

	ReadLevelSuffix.Done: action
			ValVLD :[ValueOfVLD]
				==>
		do
			//println("\t\tlevel_suffix : "+ValueOfVLD);
			level_suffix := ValueOfVLD;
		end

	ComputeLevel: action
			==>
			Value:[ValLevel],
			Last  :[false]
		var
			int(size=16) ValLevel
		do
			levelCode :=
				if(level_prefix < 15) then
					levelCode + lshift(level_prefix, suffixLength)
				else
					levelCode + lshift(15, suffixLength)
				end;
			levelCode := levelCode + level_suffix;
			if((level_prefix >= 15) and (suffixLength = 0)) then
				levelCode := levelCode + 15;
			end
			if(level_prefix >= 16) then
				levelCode := levelCode + lshift(1, level_prefix - 3) - 4096;
			end
			if((levelCode mod 2) = 0) then
				ValLevel     := rshift(levelCode + 2, 1);
			else
				ValLevel     := rshift( -levelCode - 1, 1);
			end

			if(suffixLength = 0)then
				suffixLength := 1;
			end
			if( (Abs(ValLevel) > lshift(3, suffixLength - 1)) and (suffixLength < 6) ) then
				suffixLength := suffixLength + 1;
			end
			if(DEBUG_FLAG_DECODED)then
				println("level : "+ValLevel);
			end
			
			levelCode := 0;
			iLoop     := iLoop + 1;
		end

	ReadTotalZeros.Asked: action
				==>
			//               total_zeros
			TypeOfVLD :[ CAVLC_TOTAL_ZEROS ],
			VLD_Param :[ maxNumCoeff , TotalCoeff ]
		guard
			TotalCoeff < (endIdx - startIdx + 1)
		end

	ReadTotalZeros.Done: action
			ValVLD :[total_zeros]
				==>
		do
			zerosLeft := total_zeros;
			if(DEBUG_FLAG_DECODED)then
				println("total_zeros : "+total_zeros);
			end
		end

	InitiLoop: action ==>
		do
			iLoop := 0;
		end

	ZerosLeft.GreaterThan0: action
				==>
			//            run_before
			TypeOfVLD :[ CAVLC_RUN_BEFORE ],
			VLD_Param :[ zerosLeft ]
		guard
			iLoop     < TotalCoeff - 1,
			zerosLeft > 0
		end

	ReadRunBefore: action
			ValVLD :[run_before]
				==>
			Run    :[run_before]
		do
			run[iLoop] := run_before;
			if(DEBUG_FLAG_DECODED)then
				println("run_before : "+run_before);
			end
			zerosLeft  := zerosLeft - run_before;
			iLoop      := iLoop + 1;
		end

	SendOthersRun: action
				==>
			Run :[ValRun]
		guard
			iLoop < TotalCoeff
		var
			int(size=16) ValRun
		do
			ValRun    := zerosLeft;
			zerosLeft := 0;
			if( (maxNumCoeff = 15) and (iLoop = TotalCoeff - 1) )then // The first coeffAC will be replaced by coeffDC
				ValRun := ValRun + 1;
			end
			iLoop     := iLoop + 1;
		end

	SendEndResidualBlock: action
				==>
			TypeOfVLD :[ SKIP_NAL ],
			Last      :[   true   ]
		do
			run[TotalCoeff - 1] := zerosLeft;
			/*
				coeffNum = -1
				for( i = TotalCoeff( coeff_token ) - 1; i >= 0; i-- ) {
				   coeffNum += run[ i ] + 1
				   coeffLevel[ startIdx + coeffNum ] = level[ i ]
				}
			
			*/
		end

	schedule fsm ReadCoeffToken_Asked:
		ReadCoeffToken_Asked (ReadCoeffToken.Asked )--> ReadCoeffTokenDone;

		ReadCoeffTokenDone (ReadCoeffToken.Done )--> CheckTotalCoeff;

		CheckTotalCoeff (CheckTotalCoeff.IsGreaterThan0 )--> CheckiLoop;
		CheckTotalCoeff (SendEndResidualBlock )-->ReadCoeffToken_Asked;

		CheckiLoop (ReadTrailingOnesSign.Asked )--> ReadTrailingOnesSign;
		CheckiLoop (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop (InitiLoop )--> Loop4run;

		ReadTrailingOnesSign (ReadTrailingOnesSign.Done )--> SendTrailingOnes;

		SendTrailingOnes (SendTrailingOnes )--> SendTrailingOnes;
		SendTrailingOnes (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		SendTrailingOnes (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		SendTrailingOnes (InitiLoop )--> Loop4run;

		CheckiLoop2 (ReadLevelPrefix.Asked )--> ReadLevelPrefix;
		CheckiLoop2 (ReadTotalZeros.Asked )--> ReadTotalZerosDone;
		CheckiLoop2 (InitiLoop )--> Loop4run;


		ReadLevelPrefix (ReadLevelPrefix.Done )--> ReadLevelSuffixAsked;

		ReadLevelSuffixAsked (ReadLevelSuffix.Asked )--> ReadLevelSuffixDone;
		ReadLevelSuffixAsked (ComputeLevel )--> CheckiLoop2;

		ReadLevelSuffixDone (ReadLevelSuffix.Done )--> ComputeLevel;

		ComputeLevel (ComputeLevel )--> CheckiLoop2;

		ReadTotalZerosDone (ReadTotalZeros.Done )--> InitiLoop;

		InitiLoop (InitiLoop )--> Loop4run;

		Loop4run (ZerosLeft.GreaterThan0 )--> ReadRunBefore;
		Loop4run (SendOthersRun )--> SendOthersRun;
		Loop4run (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		SendOthersRun (SendOthersRun )--> SendOthersRun;
		SendOthersRun (SendEndResidualBlock )--> ReadCoeffToken_Asked;

		ReadRunBefore (ReadRunBefore )--> Loop4run;

		SendEndResidualBlock (SendEndResidualBlock )--> ReadCoeffToken_Asked;
	end
	priority
		CheckTotalCoeff.IsGreaterThan0 > SendEndResidualBlock;
		ReadTrailingOnesSign.Asked > ReadLevelPrefix.Asked;
		ReadLevelSuffix.Asked  > ComputeLevel;
		SendTrailingOnes       > ReadLevelPrefix.Asked;
		ReadLevelPrefix.Asked  > ReadTotalZeros.Asked;
		ReadTotalZeros.Asked   > InitiLoop;
		ZerosLeft.GreaterThan0 > SendOthersRun  > SendEndResidualBlock;
	end
end
