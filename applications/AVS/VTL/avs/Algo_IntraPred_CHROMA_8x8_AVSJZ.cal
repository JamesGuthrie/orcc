/*******************************************************************************************************
* COPYRIGHT AND WARRANTY INFORMATION
*
* Copyright 2003, Advanced Audio Video Coding Standard, Part II
*
* DISCLAIMER OF WARRANTY
*
* The contents of this file are subject to the Mozilla Public License
* Version 1.1 (the "License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific language governing rights and limitations under
* the License.
*                     
* THIS IS NOT A GRANT OF PATENT RIGHTS - SEE THE AVS PATENT POLICY.
* The AVS Working Group doesn't represent or warrant that the programs
* furnished here under are free of infringement of any third-party patents.
* Commercial implementations of AVS, including shareware, may be
* subject to royalty fees to patent holders. Information regarding
* the AVS patent policy for standardization procedure is available at 
* AVS Web site http://www.avs.org.cn. Patent Licensing is outside
* of AVS Working Group.
*******************************************************************************************************/

// Author: Dandan Ding (dandan2036@163.com), Honggang Qi(hgqi@jdl.ac.cn), Lu Yu, and Wen Gao

// Algo_IntraPred_CHROMA_8x8_AVSJZ.cal
// Function: This module implements intra prediction for 8x8 chroma block of AVS JiZhun Profile.

package avs;

actor Algo_IntraPred_CHROMA_8x8_AVSJZ (
  /*int PIX_SZ*/
)

  
  //int(size=PIX_SZ) C_LEFT,     // List
  //int(size=PIX_SZ) C_UP,       // List
  //int(size=PIX_SZ) C_UP_LEFT,  // point
  int(size=PIX_SZ) Intra_TOP_LEFT_Data,
  int(size=1) AVAIL,              // up, left, up_left, up_right availability List

  int(size=3) IntraChromaPredMode

  ==> int(size=PIX_SZ) IntraPred_UV:
  
  int PIX_SZ = 9;
  
  uint(size=1) left_avail;
  uint(size=1) up_avail;
  uint(size=1) up_left_avail;
  
  /*
  function initList( int v, int v_size ) --> int:
    [ v : for int i in Integers(1,v_size) ]
  end
*/
  List(type:int(size=PIX_SZ),size=9) c_left := [ 0 : for int i in 1 .. 9 ];//initList(0,8);
  List(type:int(size=PIX_SZ),size=9) c_up := [ 0 : for int i in 1 .. 9 ];//initList(0,8);
  List(type:int(size=PIX_SZ),size=1) c_up_left := [ 0 ];//initList(0,1);

  List(type:int(size=PIX_SZ),size=9) f_c_left := [ 0 : for int i in 1 .. 9 ];//initList(0,8);
  List(type:int(size=PIX_SZ),size=9) f_c_up := [ 0 : for int i in 1 .. 9 ];//initList(0,8);
  List(type:int(size=PIX_SZ),size=1) f_c_up_left := [ 0 ];
  
  /*
  function sum (int li) --> int:
    selectf( lambda (int a, int li1) : a+ sum (li1) end,
            li ,0 )
  end
  */
  function clip(int x)  --> int:
    if x > 255 then 255 else if x < 0 then 0 else x end end
  end
  
  List(type:int(size=PIX_SZ),size=19) PredPixBuffer_pass := [ 0 : for int i in 1 .. 19 ];//initList(0,17);
  
  read_avail: action AVAIL:[avail] repeat 3 ==>
  do
    left_avail    := avail[0];
    up_avail      := avail[1];
    up_left_avail := avail[2];
    //println("Algo_IntraPred_CHROMA : read.avail");
    //println("left_avail="+left_avail);
    //println("up_avail="+up_avail);
    //println("up_left_avail="+up_left_avail);
  end
  
  read_chroma_case_0: action ==> 
  guard
      left_avail=0,
      up_avail=0,
      up_left_avail=0
  end
  
  read_chroma_case_1: action Intra_TOP_LEFT_Data:[x] repeat 10 ==>
  guard
      left_avail=1,
      up_avail=0,
      up_left_avail=1
  do
      c_left := [x[i]: for int i in 0 .. 8];
      c_up_left := [x[9]];
  end
  read_chroma_case_2: action Intra_TOP_LEFT_Data:[x] repeat 10 ==>
  guard
      left_avail=0,
      up_avail=1,
      up_left_avail=1
  do
      c_up := [x[i]: for int i in 0 .. 8];
      c_up_left := [x[9]];
  end
  read_chroma_case_3: action Intra_TOP_LEFT_Data:[x] repeat 19 ==>
  guard
      left_avail=1,
      up_avail=1,
      up_left_avail=1
  do
      c_left := [x[i]: for int i in 0 .. 8];
      c_up := [x[i]: for int i in 9 .. 17];
      c_up_left := [x[18]];
  end
  /*
  read_left_avail: action Intra_TOP_LEFT_Data:[x] repeat 8 ==>
  guard 
    left_avail = 1
  do
    c_left:=x;
    //println("Algo_IntraPred_CHROMA : readpix.l.av");
  end

  read_left_navail: action ==>
  guard 
    left_avail = 0
  //do
    //println("Algo_IntraPred_CHROMA : readpix.l.nav");
  end

  read_top_avail: action Intra_TOP_LEFT_Data:[x] repeat 8 ==>
  guard 
    up_avail = 1
  do
    c_up:=x;
    //println("Algo_IntraPred_CHROMA : readpix.u.av");
  end

  read_top_navail: action ==>
  guard 
    up_avail = 0
  //do
    //println("Algo_IntraPred_CHROMA : readpix.u.nav");
  end

  read_top_left_avail: action Intra_TOP_LEFT_Data:[x] repeat 1 ==>
  guard 
    up_left_avail = 1
  do
    c_up_left:=x;
    //println("Algo_IntraPred_CHROMA : readpix.ul.av");
    //println("c_up_left="+c_up_left);
  end

  read_top_left_navail: action ==>
  guard 
    up_left_avail = 0
  //do
    //println("Algo_IntraPred_CHROMA : readpix.ul.nav");
    //println("c_up_left="+c_up_left);
  end
  */

  write: action IntraChromaPredMode:[mode] ==>
    IntraPred_UV:[[predpels[8*j+i]: for int i in 0 .. 7, for int j in 0 .. 7]] repeat 8*8
  var
    int H, int V,
    int a, int b, int c,
    List(type:int(size=PIX_SZ),size=19) PredPixBuffer,
    List(type:int(size=PIX_SZ),size=64) predpels := [ 0 : for int k in 1 .. 64 ]//initList(0,64)
    
  do
  
    //PredPixBuffer := [c_left[7-x]: for x in Integers(0,7)] + c_up_left + c_up;
    /*PredPixBuffer_pass:=[ rshift(3*PredPixBuffer[0] + PredPixBuffer[1] + 2, 2)] +
                  [ rshift(PredPixBuffer[x-1] + 2*PredPixBuffer[x] + PredPixBuffer[x+1] + 2, 2): for int x in  Integers(1,15)]
		+ [ rshift(PredPixBuffer[15]  + 3*PredPixBuffer[16] + 2, 2)];		 
    */
    PredPixBuffer[0] := c_left[8];
    PredPixBuffer[1] := c_left[7];
    PredPixBuffer[2] := c_left[6];
    PredPixBuffer[3] := c_left[5];
    PredPixBuffer[4] := c_left[4];
    PredPixBuffer[5] := c_left[3];
    PredPixBuffer[6] := c_left[2];
    PredPixBuffer[7] := c_left[1];
    PredPixBuffer[8] := c_left[0];
    
    PredPixBuffer[9] := c_up_left[0];
    
    PredPixBuffer[10] := c_up[0];
    PredPixBuffer[11] := c_up[1];
    PredPixBuffer[12] := c_up[2];
    PredPixBuffer[13] := c_up[3];
    PredPixBuffer[14] := c_up[4];
    PredPixBuffer[15] := c_up[5];
    PredPixBuffer[16] := c_up[6];
    PredPixBuffer[17] := c_up[7];
    PredPixBuffer[18] := c_up[8];
    //PredPixBuffer_pass
    PredPixBuffer_pass[0]:=  (3*PredPixBuffer[0] + PredPixBuffer[1] + 2) >> 2;
    foreach int x in 1 .. 17
    do
      PredPixBuffer_pass[x]:=  (PredPixBuffer[x-1] + 2*PredPixBuffer[x] + PredPixBuffer[x+1] + 2) >> 2;
    end
    PredPixBuffer_pass[18]:= (PredPixBuffer[17]  + 3*PredPixBuffer[18] + 2) >> 2;
    
    if mode = 0 then // DC
      f_c_left := [PredPixBuffer_pass[8-x]: for int x in 0 .. 8];
      f_c_up_left := [PredPixBuffer_pass[9]];
      f_c_up := [PredPixBuffer_pass[x]: for int x in 10 .. 18];
      if( left_avail=1 and up_avail=1) then
        predpels := [((f_c_up[i] + f_c_left[j]) >> 1): for int i in 0 .. 7, for int j in 0 .. 7];
      else if left_avail=1 then
             predpels := [f_c_left[j]: for int i in 0 .. 7, for int j in 0 .. 7];
	   else if up_avail=1 then
	          predpels := [f_c_up[i]: for int i in 0 .. 7, for int j in 0 .. 7];
	        else
		  predpels := [128: for int i in 0 .. 7, for int j in 0 .. 7];
		end
           end
      end
      //println("IntraPred_C:mode="+mode);
      //println("predpels="+predpels);
    end
    
    if mode = 1 then // horizontal
      predpels := [c_left[j]: for int i in 0 .. 7, for int j in 0 .. 7];
     //println("IntraPred_C:mode="+mode);
      //println("predpels="+predpels);
    end

    if mode = 2 then // vertical
      predpels := [c_up[i]: for int i in  0 .. 7, for int j in 0 .. 7];
      //println("IntraPred_C:mode="+mode);
      //println("predpels="+predpels);
    end
    if mode = 3 then //plane
      H:= (c_up[4]-c_up[2]) + 2*(c_up[5]-c_up[1]) + 3*(c_up[6]-c_up[0]) + 4*(c_up[7]-c_up_left[0]);
      V:= (c_left[4]-c_left[2]) + 2*(c_left[5]-c_left[1]) + 3*(c_left[6]-c_left[0]) + 4*(c_left[7]-c_up_left[0]);
      a:= 16*(c_left[7] + c_up[7]);
      b:= (17*H + 16) >> 5;
      c:= (17*V + 16) >> 5;
      predpels := [clip((a + b*(i-3) + c*(j-3) + 16) >> 5): for int i in 0 .. 7, for int j in 0 .. 7];
      //println("IntraPred_C:mode="+mode);
      //println("predpels="+predpels);
     end 
    /*    
    else if mode = 3 then //plane
      H:= sum([i*(c_up[3+i] - c_up[3-i]  ):for i in Integers(1,5)]);
      V:= sum([j*(c_left[3+j]-c_left[3-j]):for j in Integers(1,5)]);
      a:= 16*(c_left[7] + c_up[7]);
      b:= rshift( 17*H + 16, 5);
      c:= rshift( 17*V + 16, 5);
      predpels := [clip( rshift(a + b*(i-3) + c*(j-3) + 16, 5) ): for i in  Integers(0,7), for j in Integers(0,7)];
     end 
   */  
   
   //println("PredPixBuffer="+PredPixBuffer);
   //println("PredPixBuffer_pass="+PredPixBuffer_pass);
   //println("Algo_IntraPred_CHROMA : write");
  end


  schedule fsm start:
    /*
    start    ( read_avail           )   --> readpix0;
                          
    readpix0 ( read_left_avail      )   --> readpix1;
    readpix0 ( read_left_navail     )   --> readpix1;

    readpix1 ( read_top_avail       )   --> readpix2;
    readpix1 ( read_top_navail      )   --> readpix2;

    readpix2 ( read_top_left_avail  )   --> pixdone;
    readpix2 ( read_top_left_navail )   --> pixdone;
    pixdone  ( write                )   --> start;
    */
    start    ( read_avail           )   --> readpix;
                          
    readpix ( read_chroma_case_0    )   --> write;
    readpix ( read_chroma_case_1    )   --> write;
    readpix ( read_chroma_case_2    )   --> write;
    readpix ( read_chroma_case_3    )   --> write;
    write   ( write                 )   --> start;
  end

end
