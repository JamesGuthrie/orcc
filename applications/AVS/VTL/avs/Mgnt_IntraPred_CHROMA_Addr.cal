/*******************************************************************************************************
* COPYRIGHT AND WARRANTY INFORMATION
*
* Copyright 2003, Advanced Audio Video Coding Standard, Part II
*
* DISCLAIMER OF WARRANTY
*
* The contents of this file are subject to the Mozilla Public License
* Version 1.1 (the "License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific language governing rights and limitations under
* the License.
*                     
* THIS IS NOT A GRANT OF PATENT RIGHTS - SEE THE AVS PATENT POLICY.
* The AVS Working Group doesn't represent or warrant that the programs
* furnished here under are free of infringement of any third-party patents.
* Commercial implementations of AVS, including shareware, may be
* subject to royalty fees to patent holders. Information regarding
* the AVS patent policy for standardization procedure is available at 
* AVS Web site http://www.avs.org.cn. Patent Licensing is outside
* of AVS Working Group.
*******************************************************************************************************/

// Author: Dandan Ding (dandan2036@163.com), Honggang Qi(hgqi@jdl.ac.cn), Lu Yu, and Wen Gao

// Mgnt_IntraPred_CHROMA_Addr.cal
// Function: This module is to calculate address in frame buffer for intra prediction for AVS Jizhun Profile.
// Note:

package avs;

actor Mgnt_IntraPred_CHROMA_Addr(
  /*
  int BTYPE_SZ,
  int NEWVOP,
  int INTER,
  int INTRA,
  int ADDR_SZ,
  int MB_COORD_SZ,
  int COEFF_CODED
  */
)
  int(size=BTYPE_SZ) BTYPE,
  int(size=1) REC_DONE
  ==>
  int(size=ADDR_SZ) RA_INTRA,
  int(size=1) AVAIL :
  
  int BTYPE_SZ = 12;
  int NEWVOP = 2048;
  int INTER = 512;
  int INTRA = 1024;
  int ADDR_SZ = 24;
  int MB_COORD_SZ = 8;
  int COEFF_CODED = 2;
  
  int(size=MB_COORD_SZ) mbx;
  int(size=MB_COORD_SZ) mby;
  int(size=MB_COORD_SZ) mb_width;
  int(size=MB_COORD_SZ) mb_height;
  int(size=MB_COORD_SZ+4) pic_width;
  int(size=MB_COORD_SZ+4) pic_height;
 
  bool top_edge;
  bool left_edge;
  
  bool left_avail;
  bool top_avail;
  bool top_left_avail;
  
  uint(size=4) left_addr_count;
  uint(size=4) top_addr_count;
  uint(size=1) top_left_addr_count;

  int(size=ADDR_SZ) left_addr;
  int(size=ADDR_SZ) top_left_addr;
  int(size=ADDR_SZ) top_addr;
  
  /* 
  int(size=ADDR_SZ) top_initial_addr := (lshift(mby,3)-1)*lshift(mb_width,3)+ lshift(mbx,3);
  int(size=ADDR_SZ) left_initial_addr := lshift(mby,3)*lshift(mb_width,3) + lshift(mbx,3) -1;
  int(size=ADDR_SZ) top_left_initial_addr := (lshift(mby,3)-1)*lshift(mb_width,3)+ lshift(mbx,3) - 1;
  */

  bool block_left_done;
  bool block_top_done;
  bool block_top_left_done;

  bool avail_left_done;
  bool avail_top_done;
  bool avail_top_left_done;

  uint(size=1) flag;
      
  get_new_vop: action BTYPE:[cmd] ==>
  guard
    bitand( NEWVOP, cmd) != 0
  do
    mbx := 0;
    mby := 0;

    top_edge := true;
    left_edge := true;

    left_avail := false;
    top_avail := false;
    top_left_avail := false;

    left_addr_count := 0;
    top_addr_count := 0;
    top_left_addr_count := 0;
    
    block_left_done := false;
    block_top_done := false;
    block_top_left_done := false;

    avail_left_done := false;
    avail_top_done := false;
    avail_top_left_done := false;

    flag := 1;
  end
  
  get_w: action BTYPE:[w] ==>
  do
    mb_width := w;
    pic_width := lshift(w,3);
  end
  
  get_h: action BTYPE:[h] ==>
  do
    mb_height := h;
    pic_height := lshift(h,3);
  end
  
  get_flag: action ==>
  guard
    flag = 1
  do
    flag := 0;
    //println("Mgnt_IntraPred_CHROMA_Addr:get_flag");
  end

  get_block_rec_done: action REC_DONE:[block_rec_done] ==>
  guard
    block_rec_done = 1
  //do
    //println("Mgnt_IntraPred_CHROMA_Addr:block_rec_done=1");
  end

  //current block is inter
  get_inter: action BTYPE:[btype] ==>
  guard
    bitand( btype, NEWVOP ) = 0,
    bitand( btype, INTER  ) != 0
  do
    block_left_done := false;
    block_top_done := false;
    block_top_left_done := false;
  end
  
  //current block is intra
  get_intra: action BTYPE:[btype] ==>
  guard
    bitand( btype, NEWVOP ) = 0,
    bitand( btype, INTRA ) != 0
  do
    block_left_done := false;
    block_top_done := false;
    block_top_left_done := false;
  end
  
  //output block_left available or not as well as the address of intra prediction.

  pred_left_navail: action ==> AVAIL:[0]
  guard
    not block_left_done,
    not block_top_done,
    not block_top_left_done,

    not avail_left_done,
    not avail_top_done,
    not avail_top_left_done,

    left_edge
  do
    left_avail := false;
    left_addr_count := 0;
    block_left_done := true;
    avail_left_done := true;
    //println("Mgnt_IntraPred_CHROMA_Addr:pred_left_navail");
  end

  pred_left_avail: action ==> AVAIL:[1]
  guard
    not block_left_done,
    not block_top_done,
    not block_top_left_done,

    not avail_left_done,
    not avail_top_done,
    not avail_top_left_done,

    not left_edge
  do
    left_avail := true;
    avail_left_done := true;
    //println("Mgnt_IntraPred_CHROMA_Addr:pred_left_avail");
  end

  pred_left_avail_addr: action ==> RA_INTRA:[left_addr]
  guard
    not block_left_done,
    not block_top_done,
    not block_top_left_done,

    avail_left_done,
    not avail_top_done,
    not avail_top_left_done,

    not left_edge
  var
    int(size=ADDR_SZ) left_initial_addr := lshift(mby,3)*pic_width + lshift(mbx,3) -1
  do
    left_avail := true;
    if(left_addr_count > 7) then
      left_addr := left_initial_addr + 7 * pic_width;
    else
      left_addr := left_initial_addr + left_addr_count * pic_width;
    end
    left_addr_count := left_addr_count + 1;
    if(left_addr_count = 9) then
      left_addr_count := 0;
      block_left_done := true;
    end
    //println("Mgnt_IntraPred_CHROMA_Addr:RA_INTRA left_addr : "+left_addr);
  end
  
  //output block_top available or not as well as the address of intra prediction.

  pred_top_navail: action ==> AVAIL:[0]
  guard
    block_left_done,
    not block_top_done,
    not block_top_left_done,
    
    avail_left_done,
    not avail_top_done,
    not avail_top_left_done,

    top_edge
  do
    top_avail := false;
    top_addr_count := 0;    
    block_top_done := true;
    avail_top_done := true;
    //println("Mgnt_IntraPred_CHROMA_Addr:pred_top_navail");
  end

  pred_top_avail: action ==> AVAIL:[1]
  guard
    block_left_done,
    not block_top_done,
    not block_top_left_done,

    avail_left_done,
    not avail_top_done,
    not avail_top_left_done,

    not top_edge
  do
    top_avail := true;
    avail_top_done := true;
    //println("Mgnt_IntraPred_CHROMA_Addr:pred_top_avail");
  end

  pred_top_avail_addr: action ==> RA_INTRA:[top_addr]
  guard
    block_left_done,
    not block_top_done,
    not block_top_left_done,
    
    avail_left_done,
    avail_top_done,
    not avail_top_left_done,
    
    not top_edge
  var
    int(size=ADDR_SZ) top_initial_addr := (lshift(mby,3)-1)*pic_width + lshift(mbx,3)
  do
    top_avail := true;
    
    if (mbx=mb_width-1) and (top_addr_count > 7) then
      top_addr := top_initial_addr + 7;
    else
      top_addr := top_initial_addr + top_addr_count;
    end
    top_addr_count := top_addr_count + 1;
    if (top_addr_count = 9) then
      top_addr_count := 0;
      block_top_done := true;    
    end
    /*top_addr := top_initial_addr + top_addr_count;
    top_addr_count := top_addr_count + 1;
    if (top_addr_count = 9) then
      top_addr_count := 0;
      block_top_done := true;    
    end*/
    
    //println("Mgnt_IntraPred_CHROMA_Addr:RA_INTRA top_addr : "+top_addr);
  end
  
  //output block_top_left available or not as well as the address of intra prediction.
 
  pred_top_left_navail: action ==> AVAIL:[0]
  guard
    block_left_done,
    block_top_done,
    not block_top_left_done,

    avail_left_done,
    avail_top_done,
    not avail_top_left_done,

    top_edge and left_edge
  do
    top_left_avail := false;
    top_left_addr_count := 0;
    block_top_left_done := true;
    avail_top_left_done := true;
    //println("Mgnt_IntraPred_CHROMA_Addr:pred_top_left_navail");
  end

  pred_top_left_avail: action ==> AVAIL:[1]
  guard
    block_left_done,
    block_top_done,
    not block_top_left_done,

    avail_left_done,
    avail_top_done,
    not avail_top_left_done,

    not(top_edge and left_edge)
  do
    top_left_avail := true;
    avail_top_left_done := true;
    //println("Mgnt_IntraPred_CHROMA_Addr:pred_top_left_avail");
  end

  pred_top_left_avail_addr: action ==> RA_INTRA:[top_left_addr]
  guard
    block_left_done,
    block_top_done,
    not block_top_left_done,
    
    avail_left_done,
    avail_top_done,
    avail_top_left_done,

    not (top_edge and left_edge)
  var
    int(size=ADDR_SZ) top_initial_addr := (lshift(mby,3)-1)*pic_width + lshift(mbx,3),
    int(size=ADDR_SZ) left_initial_addr := lshift(mby,3)*pic_width + lshift(mbx,3) -1,
    int(size=ADDR_SZ) top_left_initial_addr := (lshift(mby,3)-1)*pic_width + lshift(mbx,3) - 1
  do
    if left_edge then
      top_left_avail := true;
      top_left_addr := top_initial_addr;
    else if top_edge then
      top_left_avail := true;
      top_left_addr := left_initial_addr;
      else
      top_left_avail := true;               
      top_left_addr := top_left_initial_addr;   
      end
    end
    top_left_addr_count := top_left_addr_count + 1;
    if (top_left_addr_count=1) then
      top_left_addr_count := 0;
      block_top_left_done := true;
    end
    //println("Mgnt_IntraPred_CHROMA_Addr:RA_INTRA top_left_addr : "+top_left_addr);
  end

  // top_left prediction finish
  pred_done: action ==>
  guard
    block_left_done,
    block_top_done,
    block_top_left_done,
    avail_left_done,
    avail_top_done,
    avail_top_left_done
  do
    block_left_done := false;
    block_top_done := false;
    block_top_left_done := false;

    avail_left_done := false;
    avail_top_done := false;
    avail_top_left_done := false;
    
    mbx := mbx + 1;
    left_edge := false;
    if(mbx = mb_width) then
      mbx := 0;
      mby := mby + 1;
      left_edge := true;
      top_edge := false;
    end
  end
  
  schedule fsm read:
   
    read                     ( get_new_vop          )  -->  get_w;
    get_w                    ( get_w                )  -->  get_h;
    get_h                    ( get_h                )  -->  read;
    read                     ( get_inter            )  -->  read_other;
    read                     ( get_intra            )  -->  read_other;

    read_other               ( get_flag             )  -->  pred;
    read_other               ( get_block_rec_done   )  -->  pred;

    pred                     ( pred_left_navail     )  -->  pred;
    pred                     ( pred_left_avail      )  -->  pred_left_avail_addr_next;
    pred_left_avail_addr_next( pred_left_avail_addr )  -->  pred_left_avail_addr_next;
    pred_left_avail_addr_next( pred_top_navail      )  -->  pred;
    pred_left_avail_addr_next( pred_top_avail       )  -->  pred_top_avail_addr_next;
    /*
    pred_left_avail_addr     ( pred_left_avail_addr )  -->  pred_left_avail_addr;
    pred_left_avail_addr     ( pred_left_avail_addr )  -->  pred;
    */

    pred                     ( pred_top_navail      )  -->  pred;
    pred                     ( pred_top_avail       )  -->  pred_top_avail_addr_next;
    pred_top_avail_addr_next ( pred_top_avail_addr  )  -->  pred_top_avail_addr_next;
    pred_top_avail_addr_next ( pred_top_left_navail )  -->  pred_done;
    pred_top_avail_addr_next ( pred_top_left_avail  )  -->  pred_top_left_avail_addr;
    
    pred                     ( pred_top_left_navail     )  -->  pred_done;
    pred                     ( pred_top_left_avail      )  -->  pred_top_left_avail_addr;
    
    pred_top_left_avail_addr ( pred_top_left_avail_addr )  -->  pred_done;

    pred_done                 ( pred_done               )  -->  read;
  end
  
  priority
    get_new_vop > get_inter > get_intra;
    get_flag > get_block_rec_done;
    pred_left_navail > pred_left_avail > pred_top_navail > pred_top_avail > pred_top_left_navail > pred_top_left_avail;
    pred_left_avail_addr > pred_top_navail > pred_top_avail;
    pred_top_avail_addr > pred_top_left_navail > pred_top_left_avail;
  end

end