/*******************************************************************************************************
* COPYRIGHT AND WARRANTY INFORMATION
*
* Copyright 2003, Advanced Audio Video Coding Standard, Part II
*
* DISCLAIMER OF WARRANTY
*
* The contents of this file are subject to the Mozilla Public License
* Version 1.1 (the "License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific language governing rights and limitations under
* the License.
*                     
* THIS IS NOT A GRANT OF PATENT RIGHTS - SEE THE AVS PATENT POLICY.
* The AVS Working Group doesn't represent or warrant that the programs
* furnished here under are free of infringement of any third-party patents.
* Commercial implementations of AVS, including shareware, may be
* subject to royalty fees to patent holders. Information regarding
* the AVS patent policy for standardization procedure is available at 
* AVS Web site http://www.avs.org.cn. Patent Licensing is outside
* of AVS Working Group.
*******************************************************************************************************/

// Author: Dandan Ding (dandan2036@163.com), Honggang Qi(hgqi@jdl.ac.cn), Lu Yu, and Wen Gao

// Algo_ADD.cal
// Function: This module is to reconstruct picture: combine resduals and preds for AVS Jizhun Profile.
// Note:

package avs;

actor Algo_Add_avs(
 )
  int(size=PIX_SZ) res,
  int(size=PIX_SZ) Pred,
  int(size=BTYPE_SZ) BTYPE 
  ==> 
  int(size=PIX_SZ) RecData :
  
  int PIX_SZ = 9;
  int BTYPE_SZ = 12;
  int NEWVOP = 2048;
  int INTRA = 1024;
  int INTER = 512;
  int COEFF_CODED = 2;
  
  
  //uint(size=7) count;
  /*function clip(int out) --> int:
    if out > 255 then 255 else if out < -256 then -256 else out end end
  end
  */
  
   List(type:int(size=PIX_SZ),size=64) tex_buffer := [0: for int i in 0 .. 63];
   List(type:int(size=PIX_SZ),size=64) res_buffer := [0: for int i in 0 .. 63];
   
  // Ignore new VOP command
  get_new_vop: action BTYPE:[ cmd ] ==>
  guard
    (cmd & NEWVOP) != 0
  //do
    //count := 0;
    //println("Algo_Add:get_new_vop cmd="+cmd);
  end
  
  // skip width and height command
  skip_wh: action BTYPE:[ cmd ] repeat 2==>
  //do
    //println("Algo_Add:skip_wh:cmd="+cmd[0]);
    //println("Algo_Add:skip_wh:cmd="+cmd[1]);
  end

  // get intra, if coefficients are all zero, skip add.
  get_intra_uncoded: action BTYPE:[ cmd ] ==>
  guard
    (cmd & NEWVOP) = 0,
    (cmd & INTRA) != 0,
    (cmd & COEFF_CODED) = 0
  //do
    //println("Algo_Add:get_intra_uncoded");
  end

  // get intra, if coefficients are not all zero, add RES and Pred.
  get_intra_coded: action BTYPE:[ cmd ] ==>
  guard
    (cmd & NEWVOP) = 0,
    (cmd & INTRA) != 0,
    (cmd & COEFF_CODED) != 0
  //do
    //println("Algo_Add:get_intra_coded cmd="+cmd);
  end
  
  // get intra, if coefficients are all zero, skip add.
  get_inter_uncoded: action BTYPE:[ cmd ] ==>
  guard
    (cmd & NEWVOP) = 0,
    (cmd & INTER) != 0,
    (cmd & COEFF_CODED) = 0
  end

  // get intra, if coefficients are not all zero, add RES and Pred.
  get_inter_coded: action BTYPE:[ cmd ] ==>
  guard
    (cmd & NEWVOP) = 0,
    (cmd & INTER) != 0,
    (cmd & COEFF_CODED) != 0
  end
  
  //if coefficients are all zero, skip add.
  add_uncoded: action Pred:[pred] repeat 64 ==> RecData:[ [ if pred[i] < -256 then
			-256
		else
			if pred[i] > 255 then
				255
			else
				pred[i]
			end
		end : for int i in 0 .. 63 ] ] repeat 64
  //do
    //println("Algo_Add:add_uncoded");
    //count := count + 1;
    //println("Algo_Add:Rec="+pred);
  end
  
  get_tex: action Pred:[tex] repeat 64 ==>
  /*var
      int(size=PIX_SZ) b
  */
  do
      //println("Algo_Add:get_tex");
      tex_buffer := [tex[i]: for int i in 0 .. 63];
      /*
      println("get_tex:tex[0]="+tex_buffer[0]);
      println("get_tex:tex[1]="+tex_buffer[1]);
      println("get_tex:tex[2]="+tex_buffer[2]);
      println("get_tex:tex[3]="+tex_buffer[3]);
      println("get_tex:tex[4]="+tex_buffer[4]);
      println("get_tex:tex[5]="+tex_buffer[5]);
      println("get_tex:tex[6]="+tex_buffer[6]);
      println("get_tex:tex[7]="+tex_buffer[7]);
      println("get_tex:tex[10]="+tex_buffer[10]);
      println("get_tex:tex[11]="+tex_buffer[11]);
      println("get_tex:tex[12]="+tex_buffer[12]);
      println("get_tex:tex[13]="+tex_buffer[13]);
      println("get_tex:tex[14]="+tex_buffer[14]);
      println("get_tex:tex[15]="+tex_buffer[15]);
      println("get_tex:tex[16]="+tex_buffer[16]);
      println("get_tex:tex[17]="+tex_buffer[17]);
      println(""); */
  end
  
  
  get_res: action res:[mot] repeat 64 ==> 
  do
      res_buffer := [mot[i]: for int i in 0 .. 63];
      /*println("get_res:res[0]="+res_buffer[0]);      
      println("get_res:res[1]="+res_buffer[1]);      
      println("get_res:res[2]="+res_buffer[2]);      
      println("get_res:res[3]="+res_buffer[3]);      
      println("get_res:res[4]="+res_buffer[4]);      
      println("get_res:res[5]="+res_buffer[5]);      
      println("get_res:res[6]="+res_buffer[6]);      
      println("get_res:res[7]="+res_buffer[7]);     
      
      println("get_res:res[10]="+res_buffer[10]);      
      println("get_res:res[11]="+res_buffer[11]);      
      println("get_res:res[12]="+res_buffer[12]);      
      println("get_res:res[13]="+res_buffer[13]);      
      println("get_res:res[14]="+res_buffer[14]);     
      println("get_res:res[15]="+res_buffer[15]);      
      println("get_res:res[16]="+res_buffer[16]);      
      println("get_res:res[17]="+res_buffer[17]);
      println("");*/ 
  end
  
  //if coefficients are not all zero, add RES and Pred.
  add_coded: action ==> RecData:[ [ if tex_buffer[i] + res_buffer[i] < -256 then -256
		else if tex_buffer[i] + res_buffer[i] > 255 then 255
			else tex_buffer[i] + res_buffer[i] end
		end : for int i in 0 .. 63 ] ] repeat 64
  do
    
  /*
      println("add_coded:tex[0]="+tex[0]);
      println("add_coded:tex[1]="+tex[1]);
      println("add_coded:tex[2]="+tex[2]);
      println("add_coded:tex[3]="+tex[3]);
      println("add_coded:tex[4]="+tex[4]);
      println("add_coded:tex[5]="+tex[5]);
      println("add_coded:tex[6]="+tex[6]);
      println("add_coded:tex[7]="+tex[7]);
      println("add_coded:tex[10]="+tex[10]);
      println("add_coded:tex[11]="+tex[11]);
      println("add_coded:tex[12]="+tex[12]);
      println("add_coded:tex[13]="+tex[13]);
      println("add_coded:tex[14]="+tex[14]);
      println("add_coded:tex[15]="+tex[15]);
      println("add_coded:tex[16]="+tex[16]);
      println("add_coded:tex[17]="+tex[17]);
      */
      /*
      println("add_coded:rres[0]="+mot[0]);      
      println("add_coded:rres[1]="+mot[1]);      
      println("add_coded:rres[2]="+mot[2]);      
      println("add_coded:rres[3]="+mot[3]);      
      println("add_coded:rres[4]="+mot[4]);      
      println("add_coded:rres[5]="+mot[5]);      
      println("add_coded:rres[6]="+mot[6]);      
      println("add_coded:rres[7]="+mot[7]);     
      
      println("add_coded:rres[10]="+mot[10]);      
      println("add_coded:rres[11]="+mot[11]);      
      println("add_coded:rres[12]="+mot[12]);      
      println("add_coded:rres[13]="+mot[13]);      
      println("add_coded:rres[14]="+mot[14]);     
      println("add_coded:rres[15]="+mot[15]);      
      println("add_coded:rres[16]="+mot[16]);      
      println("add_coded:rres[17]="+mot[17]);  
      */
  end
  
  schedule fsm read:
    read          ( get_new_vop       ) --> skip_wh;
    skip_wh       ( skip_wh           ) --> read;
    read          ( get_intra_uncoded ) --> add_uncoded;
    read          ( get_intra_coded   ) --> get_res;
    read          ( get_inter_uncoded ) --> add_uncoded;
    read          ( get_inter_coded   ) --> get_res;

    add_uncoded   ( add_uncoded        ) --> read;
     
    get_tex       ( get_tex            ) --> add_coded;
    get_res       ( get_res            ) --> get_tex;      
    add_coded     ( add_coded          ) --> read;
  end

  priority
    get_new_vop > get_intra_uncoded > get_intra_coded > get_inter_uncoded > get_inter_coded;
  end

end