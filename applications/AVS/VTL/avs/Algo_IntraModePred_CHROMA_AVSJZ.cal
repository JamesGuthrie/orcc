/*******************************************************************************************************
* COPYRIGHT AND WARRANTY INFORMATION
*
* Copyright 2003, Advanced Audio Video Coding Standard, Part II
*
* DISCLAIMER OF WARRANTY
*
* The contents of this file are subject to the Mozilla Public License
* Version 1.1 (the "License"); you may not use this file except in
* compliance with the License. You may obtain a copy of the License at
* http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an "AS IS"
* basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
* License for the specific language governing rights and limitations under
* the License.
*                     
* THIS IS NOT A GRANT OF PATENT RIGHTS - SEE THE AVS PATENT POLICY.
* The AVS Working Group doesn't represent or warrant that the programs
* furnished here under are free of infringement of any third-party patents.
* Commercial implementations of AVS, including shareware, may be
* subject to royalty fees to patent holders. Information regarding
* the AVS patent policy for standardization procedure is available at 
* AVS Web site http://www.avs.org.cn. Patent Licensing is outside
* of AVS Working Group.
*******************************************************************************************************/

// Author: Dandan Ding (dandan2036@163.com), Honggang Qi(hgqi@jdl.ac.cn), Lu Yu, and Wen Gao

// Algo_IntraModePred_CHROMA_AVSJZ.cal
// Function: This module predict the intra mode of chroma block.  

/*************************************************************************************************************************************
 Input Ports:
 ============
 *int(size=BTYPE_SZ) BTYPE
 This input token specifies the coding mode of the current 8x8 block. When executing, 
 the first 3 BTYPE tokens of a VOP relate to global parameters of the VOP. The first BTYPE 
 token indicates a new VOP, and the subsequent two BTYPE tokens indicate the width and the 
 height of the VOP in macroblocks respectively. All subsequent BTYPE tokens for the VOP 
 specify the coding mode of the current 8x8 block. For details on the structure of the
 BTYPE token, refer to ParseHeaders.cal

 *int(size=SAMPLE_SZ) INTRA_INFO
 The related parameters decoded from bitstream. INTRA_INFO includes 4bits[3:0],[0]:pred_mode_flag,[3:1] intra_chroma_pred_mode
 
 Output Ports:
 =============
 *int(size=3) IntraChromaPredMode:
 0 --> Intra_Chroma_DC
 1 --> Intra_Chroma_Horizontal
 2 --> Intra_Chroma_Vertical
 3 --> Intra_Chroma_Plane
************************************************************************************************************************************8***/

package avs;

actor Algo_IntraModePred_CHROMA_AVSJZ (
 /*int MB_COORD_SZ,
 int BTYPE_SZ,
 int SAMPLE_SZ,
 int NEWVOP,
 int INTRA_INFO_SZ*/
)

 int(size=BTYPE_SZ) BTYPE, 
 int(size=INTRA_INFO_SZ) INTRA_INFO 
 ==>
 int(size=3) IntraChromaPredMode:
 
 int MB_COORD_SZ = 8;
 int BTYPE_SZ = 12;
 int SAMPLE_SZ = 13;
 int NEWVOP = 2048;
 int INTRA_INFO_SZ = 3; 
  
  int(size=MB_COORD_SZ) mbx := 0;           // Current macroblock x position
  int(size=MB_COORD_SZ) mb_width := 0;           // Macroblock width of current vop
   
  //int BUF_SIZE = (MAXW_IN_MB + 2);      // Have 1 8x8 u or v block per MB(4:2:0 format)
  //int ptr := 1;                         // Pointer to current 8x8 block on current row
                                        // using circular buffer addressing. Start at 1.                                        
  bool top_edge  := true;               // Top edge macroblock flag
  bool left_edge := true;                       // Left edge macroblock flag  
                                      
  uint(size=2) intra_chroma_pred_mode;
  // Initialize to the dummy values needed for uncoded blocks (always mapped to index 0)
  //List( type:int(size=SAMPLE_SZ), size=BUF_SIZE ) intra_para_buf := [ VAL : for k in Integers(1,BUF_SIZE) ];


  // Function to return absolute value
  function abs( int x ) --> int:
    if x < 0 then (-x) else x end
  end
  
  // Function to get the minimum
  function min(int a,int b) --> int:
    if a<b then a else b end
  end

  // Check for NEWVOP flag
  start: action BTYPE:[ cmd ] ==>
  guard
    bitand( cmd, NEWVOP ) != 0
  do
    mbx := 0;
    top_edge := true;
    left_edge := true;
    //ptr   := 1; 
  end
  
  getw: action BTYPE: [w] ==>
  do
    mb_width := w;
  end
  
  // Used to skip BTYPE tokens where necessary
  geth: action BTYPE:[ cmd ] ==>
  end

  // skip other BTYPE signal where necessary
  skip: action BTYPE:[ cmd ] ==>
  guard
    bitand( cmd, NEWVOP ) = 0
  end

  // read INTRA_INFO to predict the intra mode
  get_intra_chroma_pred_mode: action INTRA_INFO:[ intra_info ] ==>
  do
    intra_chroma_pred_mode := rshift(intra_info,1);
  end

  get_intra_chroma_mode: action ==> IntraChromaPredMode:[mode]
  var
    uint(size=2) mode
  do
    mode := intra_chroma_pred_mode;
    //println("intra_chroma_pred_mode="+mode);
  end

  advance: action ==>
  do
    mbx := mbx + 1;
    left_edge := false;
    if mbx = mb_width then
      mbx := 0;
      top_edge := false;
      left_edge := true;
    end 
  end

  schedule fsm read :
    read                       ( start                      ) --> getw;
    getw                       ( getw                       ) --> geth;
    geth                       ( geth                       ) --> read;
    read                       ( skip                       ) --> get_intra_chroma_pred_mode;
                       
    get_intra_chroma_pred_mode ( get_intra_chroma_pred_mode ) --> get_intra_chroma_mode;
    get_intra_chroma_mode      ( get_intra_chroma_mode      ) --> advance;
    advance                    ( advance                    ) --> read;
  end

  priority
    start > skip;
  end
end